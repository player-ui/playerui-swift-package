{"version":3,"sources":["../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/ts-nested-error@1.2.1/node_modules/ts-nested-error/src/nested-error.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/timm@1.7.1/node_modules/timm/lib/timm.js","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/p-defer@3.0.0/node_modules/p-defer/index.js","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/queue-microtask@1.2.3/node_modules/queue-microtask/index.js","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/sorted-array@2.0.4/node_modules/sorted-array/sorted-array.js","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/index.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/tapable-ts@0.2.4/node_modules/tapable-ts/src/utils.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/tapable-ts@0.2.4/node_modules/tapable-ts/src/index.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/index.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding-grammar/ast.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding-grammar/custom/index.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/utils.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/binding.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/resolver.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/dependency-tracker.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/noop-model.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/model.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dlv@1.1.3/node_modules/dlv/index.js","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/local-model.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/evaluator.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/types.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/parser.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/evaluator-functions.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/utils.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/logger/types.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/logger/consoleLogger.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/logger/noopLogger.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/logger/tapableLogger.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/logger/proxyLogger.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/schema/schema.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/string-resolver/index.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/validator/validation-middleware.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/validator/binding-map-splice.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/validator/registry.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/resolver/index.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dequal@2.0.3/node_modules/dequal/dist/index.mjs","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/parser/index.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/parser/types.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/parser/utils.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/resolver/utils.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/view.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/builder/index.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/template-plugin.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/string-resolver.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/applicability.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/switch.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/player.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/flow/flow.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/flow/controller.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/validation/controller.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/utils/replaceParams.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/validation/binding-tracker.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/view/store.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/view/asset-transform.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/view/controller.ts","../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/partial-match-registry/src/index.ts","../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/partial-match-registry/src/deep-partial-matcher.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/data/utils.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/data/controller.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/constants/utils.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/constants/index.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/plugins/flow-exp-plugin.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/plugins/default-exp-plugin.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/types.ts","../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/plugins/default-view-plugin.ts"],"names":["NestedError","clone","addLast","removeAt","set","setIn","omit","deferred","SortedArray","parse","t","import_ts_nested_error","normalized","obj","key","def","p","undef","split","length","import_timm","NodeType","children","value","update","import_p_defer","defer","queueMicrotask"],"mappings":"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","sourcesContent":["/**\n * Subclass of standard `Error` that eagerly collects the callstack of the error\n * that caused it. This way you can investigate the core problem that happened\n * by looking at the callstack from up to bottom (from higher level errors to\n * lower level).\n */\nexport class NestedError extends Error {\n    /**\n     * Combined callstack of this error and the errors that it wraps.\n     * If the JavaScript runtime doesn't support `Error::stack` property\n     * this will contain only the concatenated messages.\n     */\n    readonly stack: string;\n\n    /**\n     * The list of lower-level errors wrapped by this error.\n     */\n    readonly innerErrors: Error[];\n\n    /**\n     * Provides the first `Error` of the `innerErrors` (if it exists);\n     * otherwise, `null`.\n     *\n     * @deprecated Please shift to using the `innerErrors` (with an 's') property.\n     */\n    get innerError(): Error | null {\n        return this.innerErrors.length === 0\n            ? null\n            : this.innerErrors[0];\n    }\n\n    private static readonly getErrorReport = typeof new Error().stack === 'string'\n        ? (err: Error) => err.stack!\n        : (err: Error) => `${err.name}: ${err.message}`;\n\n    /**\n     * Returns the function that accepts any value that was thrown as the first argument and\n     * throws it wrapped into `NestedError` or class derived from `NestedError` (provided\n     * this method was called directly in the context of that dervied class constructor)\n     * with the given `message`.\n     * Returned function will pass accepted `Error` object directly to `NestedError`\n     * as `innerErrors` by invoking `toError(err)` on it.\n     *\n     * You'll most likely want to use this method with promises:\n     *\n     * ```ts\n     * userService.getPage().then(\n     *     data => console.log(`Hooray! data: ${data}`),\n     *     NestedError.rethrow('failed to fetch users page')\n     * );\n     * ```\n     *\n     * @param message Message to attach `NestedError` created by the returned function.\n     */\n    static rethrow(message: string) {\n        return (...errs: unknown[]) => { throw new this(message, ...errs); };\n    }\n\n    /**\n     * Allocates an instance of `NestedError` with the given error `message` and\n     * optional `innerError` (which will be automatically coerced using `toError()`).\n     *\n     * @param message     Laconic error message to attach to the created `NestedError`.\n     * @param innerErrors Optional errors that will be wrapped by this higher level\n     *                    error. This value will be automatically coerced using `toError()`.\n     */\n    constructor(message?: string, ...innerErrors: unknown[]) {\n        super(message);\n        const thisErrorReport = NestedError.getErrorReport(this);\n        if (innerErrors.length === 1) {\n            const innerError = toError(innerErrors[0]);\n            this.innerErrors = [innerError];\n            const errReport = NestedError.getErrorReport(innerError);\n            this.stack = `${thisErrorReport}\\n\\n======= INNER ERROR =======\\n\\n${errReport}`;\n            return;\n        }\n        this.innerErrors = innerErrors.map(err => toError(err));\n        const innerErrorReports = this.innerErrors\n            .map((error, idx) => {\n                const errReport = NestedError.getErrorReport(error);\n                return `======= INNER ERROR (${idx + 1} of ${innerErrors.length}) =======\\n\\n${errReport}`;\n            })\n            .join(\"\\n\\n\");\n        this.stack = `${thisErrorReport}\\n\\n${innerErrorReports}`;\n    }\n}\n\nNestedError.prototype.name = nameof(NestedError);\n\n/**\n * @deprecated You should not call this function on an object of statically assumed `Error` type,\n *             because it is intended to be used in a dynamic context where the type of thrown value\n *             is not known ahead of time (during the compile time).\n */\nexport function toError(err: Error): Error;\n\n/**\n * Returns `err` itself if `err instanceof Error === true`, otherwise attemts to\n * stringify it and wrap into `Error` object to be returned.\n *\n * **This function is guaranteed never to throw.**\n *\n * @param err Possbile `instanceof Error` to return or value of any type that will\n *            be wrapped into a fully-fledged `Error` object.\n */\nexport function toError(err: unknown): Error;\n\nexport function toError(err: unknown) {\n    try {\n        return err instanceof Error\n            ? err\n            : new Error(`Value that is not an instance of Error was thrown: ${err}`);\n    } catch {\n        return new Error(\n            \"Failed to stringify non-instance of Error that was thrown.\" +\n            \"This is possibly due to the fact that toString() method of the value\" +\n            \"doesn't return a primitive value.\"\n        );\n    }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clone = clone;\nexports.addLast = addLast;\nexports.addFirst = addFirst;\nexports.removeLast = removeLast;\nexports.removeFirst = removeFirst;\nexports.insert = insert;\nexports.removeAt = removeAt;\nexports.replaceAt = replaceAt;\nexports.getIn = getIn;\nexports.set = set;\nexports.setIn = setIn;\nexports.update = update;\nexports.updateIn = updateIn;\nexports.merge = merge;\nexports.mergeDeep = mergeDeep;\nexports.mergeIn = mergeIn;\nexports.omit = omit;\nexports.addDefaults = addDefaults;\nexports.default = void 0;\n\n/* eslint-disable @typescript-eslint/ban-types */\n\n/*!\n * Timm\n *\n * Immutability helpers with fast reads and acceptable writes.\n *\n * @copyright Guillermo Grau Panea 2016\n * @license MIT\n */\nconst INVALID_ARGS = 'INVALID_ARGS';\nconst IS_DEV = process.env.NODE_ENV !== 'production';\n\n// ===============================================\n// ### Helpers\n// ===============================================\nfunction throwStr(msg) {\n  throw new Error(msg);\n}\n\nfunction getKeysAndSymbols(obj) {\n  const keys = Object.keys(obj);\n\n  if (Object.getOwnPropertySymbols) {\n    // @ts-ignore\n    return keys.concat(Object.getOwnPropertySymbols(obj));\n  }\n\n  return keys;\n}\n\nconst hasOwnProperty = {}.hasOwnProperty;\n\nfunction clone(obj0) {\n  // As array\n  if (Array.isArray(obj0)) return obj0.slice(); // As object\n\n  const obj = obj0;\n  const keys = getKeysAndSymbols(obj);\n  const out = {};\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    out[key] = obj[key];\n  } // @ts-ignore (see type tests)\n\n\n  return out;\n} // Custom guard\n\n\nfunction isObject(o) {\n  return o != null && typeof o === 'object';\n} // _deepFreeze = (obj) ->\n//   Object.freeze obj\n//   for key in Object.getOwnPropertyNames obj\n//     val = obj[key]\n//     if isObject(val) and not Object.isFrozen val\n//       _deepFreeze val\n//   obj\n// ===============================================\n// -- ### Arrays\n// ===============================================\n// -- #### addLast()\n// -- Returns a new array with an appended item or items.\n// --\n// -- Usage: `addLast(array, val)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = addLast(arr, 'c')\n// -- // ['a', 'b', 'c']\n// -- arr2 === arr\n// -- // false\n// -- arr3 = addLast(arr, ['c', 'd'])\n// -- // ['a', 'b', 'c', 'd']\n// -- ```\n// `array.concat(val)` also handles the scalar case,\n// but is apparently very slow\n\n\nfunction addLast(array, val) {\n  if (Array.isArray(val)) return array.concat(val);\n  return array.concat([val]);\n} // -- #### addFirst()\n// -- Returns a new array with a prepended item or items.\n// --\n// -- Usage: `addFirst(array, val)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = addFirst(arr, 'c')\n// -- // ['c', 'a', 'b']\n// -- arr2 === arr\n// -- // false\n// -- arr3 = addFirst(arr, ['c', 'd'])\n// -- // ['c', 'd', 'a', 'b']\n// -- ```\n\n\nfunction addFirst(array, val) {\n  if (Array.isArray(val)) return val.concat(array);\n  return [val].concat(array);\n} // -- #### removeLast()\n// -- Returns a new array removing the last item.\n// --\n// -- Usage: `removeLast(array)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = removeLast(arr)\n// -- // ['a']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- arr3 = []\n// -- removeLast(arr3) === arr3\n// -- // true\n// -- ```\n\n\nfunction removeLast(array) {\n  if (!array.length) return array;\n  return array.slice(0, array.length - 1);\n} // -- #### removeFirst()\n// -- Returns a new array removing the first item.\n// --\n// -- Usage: `removeFirst(array)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = removeFirst(arr)\n// -- // ['b']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- arr3 = []\n// -- removeFirst(arr3) === arr3\n// -- // true\n// -- ```\n\n\nfunction removeFirst(array) {\n  if (!array.length) return array;\n  return array.slice(1);\n} // -- #### insert()\n// -- Returns a new array obtained by inserting an item or items\n// -- at a specified index.\n// --\n// -- Usage: `insert(array, idx, val)`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = insert(arr, 1, 'd')\n// -- // ['a', 'd', 'b', 'c']\n// -- arr2 === arr\n// -- // false\n// -- insert(arr, 1, ['d', 'e'])\n// -- // ['a', 'd', 'e', 'b', 'c']\n// -- ```\n\n\nfunction insert(array, idx, val) {\n  return array.slice(0, idx).concat(Array.isArray(val) ? val : [val]).concat(array.slice(idx));\n} // -- #### removeAt()\n// -- Returns a new array obtained by removing an item at\n// -- a specified index.\n// --\n// -- Usage: `removeAt(array, idx)`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = removeAt(arr, 1)\n// -- // ['a', 'c']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- removeAt(arr, 4) === arr\n// -- // true\n// -- ```\n\n\nfunction removeAt(array, idx) {\n  if (idx >= array.length || idx < 0) return array;\n  return array.slice(0, idx).concat(array.slice(idx + 1));\n} // -- #### replaceAt()\n// -- Returns a new array obtained by replacing an item at\n// -- a specified index. If the provided item is the same as\n// -- (*referentially equal to*) the previous item at that position,\n// -- the original array is returned.\n// --\n// -- Usage: `replaceAt(array, idx, newItem)`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = replaceAt(arr, 1, 'd')\n// -- // ['a', 'd', 'c']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- replaceAt(arr, 1, 'b') === arr\n// -- // true\n// -- ```\n\n\nfunction replaceAt(array, idx, newItem) {\n  if (array[idx] === newItem) return array;\n  const len = array.length;\n  const result = Array(len);\n\n  for (let i = 0; i < len; i++) {\n    result[i] = array[i];\n  }\n\n  result[idx] = newItem;\n  return result;\n} // ===============================================\n// -- ### Collections (objects and arrays)\n// ===============================================\n// -- #### getIn()\n// -- Returns a value from an object at a given path. Works with\n// -- nested arrays and objects. If the path does not exist, it returns\n// -- `undefined`.\n// --\n// -- Usage: `getIn(obj, path)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: ['a', 'b', 'c'] }\n// -- getIn(obj, ['d', 'd1'])\n// -- // 3\n// -- getIn(obj, ['e', 1])\n// -- // 'b'\n// -- ```\n\n\nfunction getIn(obj, path) {\n  if (!Array.isArray(path)) {\n    throwStr(IS_DEV ? 'A path array should be provided when calling getIn()' : INVALID_ARGS);\n  }\n\n  if (obj == null) return undefined;\n  let ptr = obj;\n\n  for (let i = 0; i < path.length; i++) {\n    const key = path[i];\n    ptr = ptr != null ? ptr[key] : undefined;\n    if (ptr === undefined) return ptr;\n  }\n\n  return ptr;\n} // -- #### set()\n// -- Returns a new object with a modified attribute.\n// -- If the provided value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `set(obj, key, val)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3 }\n// -- obj2 = set(obj, 'b', 5)\n// -- // { a: 1, b: 5, c: 3 }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- set(obj, 'b', 2) === obj\n// -- // true\n// -- ```\n// When called with an undefined/null `obj`, `set()` returns either\n// a single-element array, or a single-key object\n\n\n// Implementation\nfunction set(obj0, key, val) {\n  let obj = obj0;\n  if (obj == null) obj = typeof key === 'number' ? [] : {};\n  if (obj[key] === val) return obj;\n  const obj2 = clone(obj);\n  obj2[key] = val;\n  return obj2;\n} // -- #### setIn()\n// -- Returns a new object with a modified **nested** attribute.\n// --\n// -- Notes:\n// --\n// -- * If the provided value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// -- * If the path does not exist, it will be created before setting\n// -- the new value.\n// --\n// -- Usage: `setIn(obj, path, val)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj2 = setIn(obj, ['d', 'd1'], 4)\n// -- // { a: 1, b: 2, d: { d1: 4, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj2 === obj\n// -- // false\n// -- obj2.d === obj.d\n// -- // false\n// -- obj2.e === obj.e\n// -- // true\n// --\n// -- // The same object is returned if there are no changes:\n// -- obj3 = setIn(obj, ['d', 'd1'], 3)\n// -- // { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj3 === obj\n// -- // true\n// -- obj3.d === obj.d\n// -- // true\n// -- obj3.e === obj.e\n// -- // true\n// --\n// -- // ... unknown paths create intermediate keys. Numeric segments are treated as array indices:\n// -- setIn({ a: 3 }, ['unknown', 0, 'path'], 4)\n// -- // { a: 3, unknown: [{ path: 4 }] }\n// -- ```\n\n\nfunction setIn(obj, path, val) {\n  if (!path.length) return val;\n  return doSetIn(obj, path, val, 0);\n}\n\nfunction doSetIn(obj, path, val, idx) {\n  let newValue;\n  const key = path[idx];\n\n  if (idx === path.length - 1) {\n    newValue = val;\n  } else {\n    const nestedObj = isObject(obj) && isObject(obj[key]) ? obj[key] : typeof path[idx + 1] === 'number' ? [] : {};\n    newValue = doSetIn(nestedObj, path, val, idx + 1);\n  }\n\n  return set(obj, key, newValue);\n} // -- #### update()\n// -- Returns a new object with a modified attribute,\n// -- calculated via a user-provided callback based on the current value.\n// -- If the calculated value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `update(obj, key, fnUpdate)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3 }\n// -- obj2 = update(obj, 'b', (val) => val + 1)\n// -- // { a: 1, b: 3, c: 3 }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- update(obj, 'b', (val) => val) === obj\n// -- // true\n// -- ```\n\n\nfunction update(obj, key, fnUpdate) {\n  const prevVal = obj == null ? undefined : obj[key];\n  const nextVal = fnUpdate(prevVal);\n  return set(obj, key, nextVal);\n} // -- #### updateIn()\n// -- Returns a new object with a modified **nested** attribute,\n// -- calculated via a user-provided callback based on the current value.\n// -- If the calculated value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `updateIn<T: ArrayOrObject>(obj: T, path: Array<Key>,\n// -- fnUpdate: (prevValue: any) => any): T`\n// --\n// -- ```js\n// -- obj = { a: 1, d: { d1: 3, d2: 4 } }\n// -- obj2 = updateIn(obj, ['d', 'd1'], (val) => val + 1)\n// -- // { a: 1, d: { d1: 4, d2: 4 } }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- obj3 = updateIn(obj, ['d', 'd1'], (val) => val)\n// -- // { a: 1, d: { d1: 3, d2: 4 } }\n// -- obj3 === obj\n// -- // true\n// -- ```\n\n\nfunction updateIn(obj, path, fnUpdate) {\n  const prevVal = getIn(obj, path);\n  const nextVal = fnUpdate(prevVal);\n  return setIn(obj, path, nextVal);\n} // -- #### merge()\n// -- Returns a new object built as follows: the overlapping keys from the\n// -- second one overwrite the corresponding entries from the first one.\n// -- Similar to `Object.assign()`, but immutable.\n// --\n// -- Usage:\n// --\n// -- * `merge(obj1, obj2)`\n// -- * `merge(obj1, ...objects)`\n// --\n// -- The unmodified `obj1` is returned if `obj2` does not *provide something\n// -- new to* `obj1`, i.e. if either of the following\n// -- conditions are true:\n// --\n// -- * `obj2` is `null` or `undefined`\n// -- * `obj2` is an object, but it is empty\n// -- * All attributes of `obj2` are `undefined`\n// -- * All attributes of `obj2` are referentially equal to the\n// --   corresponding attributes of `obj1`\n// --\n// -- Note that `undefined` attributes in `obj2` do not modify the\n// -- corresponding attributes in `obj1`.\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: 3 }\n// -- obj2 = { c: 4, d: 5 }\n// -- obj3 = merge(obj1, obj2)\n// -- // { a: 1, b: 2, c: 4, d: 5 }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- merge(obj1, { c: 3 }) === obj1\n// -- // true\n// -- ```\n// Signatures:\n// - 1 arg\n\n\n// Implementation\nfunction merge(a, b, c, d, e, f, ...rest) {\n  return rest.length ? doMerge.call(null, false, false, a, b, c, d, e, f, ...rest) : doMerge(false, false, a, b, c, d, e, f);\n} // -- #### mergeDeep()\n// -- Returns a new object built as follows: the overlapping keys from the\n// -- second one overwrite the corresponding entries from the first one.\n// -- If both the first and second entries are objects they are merged recursively.\n// -- Similar to `Object.assign()`, but immutable, and deeply merging.\n// --\n// -- Usage:\n// --\n// -- * `mergeDeep(obj1, obj2)`\n// -- * `mergeDeep(obj1, ...objects)`\n// --\n// -- The unmodified `obj1` is returned if `obj2` does not *provide something\n// -- new to* `obj1`, i.e. if either of the following\n// -- conditions are true:\n// --\n// -- * `obj2` is `null` or `undefined`\n// -- * `obj2` is an object, but it is empty\n// -- * All attributes of `obj2` are `undefined`\n// -- * All attributes of `obj2` are referentially equal to the\n// --   corresponding attributes of `obj1`\n// --\n// -- Note that `undefined` attributes in `obj2` do not modify the\n// -- corresponding attributes in `obj1`.\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: { a: 1 } }\n// -- obj2 = { b: 3, c: { b: 2 } }\n// -- obj3 = mergeDeep(obj1, obj2)\n// -- // { a: 1, b: 3, c: { a: 1, b: 2 }  }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- mergeDeep(obj1, { c: { a: 1 } }) === obj1\n// -- // true\n// -- ```\n\n\nfunction mergeDeep(a, b, c, d, e, f, ...rest) {\n  return rest.length ? doMerge.call(null, false, true, a, b, c, d, e, f, ...rest) : doMerge(false, true, a, b, c, d, e, f);\n} // -- #### mergeIn()\n// -- Similar to `merge()`, but merging the value at a given nested path.\n// --\n// -- Usage examples:\n// --\n// -- * `mergeIn(obj1, path, obj2)`\n// -- * `mergeIn(obj1, path, ...objects)`\n// --\n// -- ```js\n// -- obj1 = { a: 1, d: { b: { d1: 3, d2: 4 } } }\n// -- obj2 = { d3: 5 }\n// -- obj3 = mergeIn(obj1, ['d', 'b'], obj2)\n// -- // { a: 1, d: { b: { d1: 3, d2: 4, d3: 5 } } }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- mergeIn(obj1, ['d', 'b'], { d2: 4 }) === obj1\n// -- // true\n// -- ```\n\n\nfunction mergeIn(a, path, b, c, d, e, f, ...rest) {\n  let prevVal = getIn(a, path);\n  if (prevVal == null) prevVal = {};\n  let nextVal;\n\n  if (rest.length) {\n    nextVal = doMerge.call(null, false, false, prevVal, b, c, d, e, f, ...rest);\n  } else {\n    nextVal = doMerge(false, false, prevVal, b, c, d, e, f);\n  }\n\n  return setIn(a, path, nextVal);\n} // -- #### omit()\n// -- Returns an object excluding one or several attributes.\n// --\n// -- Usage: `omit(obj, attrs)`\n//\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3, d: 4 }\n// -- omit(obj, 'a')\n// -- // { b: 2, c: 3, d: 4 }\n// -- omit(obj, ['b', 'c'])\n// -- // { a: 1, d: 4 }\n// --\n// -- // The same object is returned if there are no changes:\n// -- omit(obj, 'z') === obj1\n// -- // true\n// -- ```\n\n\nfunction omit(obj, attrs) {\n  const omitList = Array.isArray(attrs) ? attrs : [attrs];\n  let fDoSomething = false;\n\n  for (let i = 0; i < omitList.length; i++) {\n    if (hasOwnProperty.call(obj, omitList[i])) {\n      fDoSomething = true;\n      break;\n    }\n  }\n\n  if (!fDoSomething) return obj;\n  const out = {};\n  const keys = getKeysAndSymbols(obj);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (omitList.indexOf(key) >= 0) continue;\n    out[key] = obj[key];\n  }\n\n  return out;\n} // -- #### addDefaults()\n// -- Returns a new object built as follows: `undefined` keys in the first one\n// -- are filled in with the corresponding values from the second one\n// -- (even if they are `null`).\n// --\n// -- Usage:\n// --\n// -- * `addDefaults(obj, defaults)`\n// -- * `addDefaults(obj, ...defaultObjects)`\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: 3 }\n// -- obj2 = { c: 4, d: 5, e: null }\n// -- obj3 = addDefaults(obj1, obj2)\n// -- // { a: 1, b: 2, c: 3, d: 5, e: null }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- addDefaults(obj1, { c: 4 }) === obj1\n// -- // true\n// -- ```\n// Signatures:\n// - 2 args\n\n\n// Implementation and catch-all\nfunction addDefaults(a, b, c, d, e, f, ...rest) {\n  return rest.length ? doMerge.call(null, true, false, a, b, c, d, e, f, ...rest) : doMerge(true, false, a, b, c, d, e, f);\n}\n\nfunction doMerge(fAddDefaults, fDeep, first, ...rest) {\n  let out = first;\n\n  if (!(out != null)) {\n    throwStr(IS_DEV ? 'At least one object should be provided to merge()' : INVALID_ARGS);\n  }\n\n  let fChanged = false;\n\n  for (let idx = 0; idx < rest.length; idx++) {\n    const obj = rest[idx];\n    if (obj == null) continue;\n    const keys = getKeysAndSymbols(obj);\n    if (!keys.length) continue;\n\n    for (let j = 0; j <= keys.length; j++) {\n      const key = keys[j];\n      if (fAddDefaults && out[key] !== undefined) continue;\n      let nextVal = obj[key];\n\n      if (fDeep && isObject(out[key]) && isObject(nextVal)) {\n        nextVal = doMerge(fAddDefaults, fDeep, out[key], nextVal);\n      }\n\n      if (nextVal === undefined || nextVal === out[key]) continue;\n\n      if (!fChanged) {\n        fChanged = true;\n        out = clone(out);\n      }\n\n      out[key] = nextVal;\n    }\n  }\n\n  return out;\n} // ===============================================\n// ### Public API\n// ===============================================\n\n\nconst timm = {\n  clone,\n  addLast,\n  addFirst,\n  removeLast,\n  removeFirst,\n  insert,\n  removeAt,\n  replaceAt,\n  getIn,\n  set,\n  setIn,\n  update,\n  updateIn,\n  merge,\n  mergeDeep,\n  mergeIn,\n  omit,\n  addDefaults\n};\nvar _default = timm;\nexports.default = _default;","'use strict';\n\nconst pDefer = () => {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n};\n\nmodule.exports = pDefer;\n","/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n","var SortedArray = (function () {\n    var SortedArray = defclass({\n\n        constructor: function (array, compare) {\n            this.array   = [];\n            this.compare = compare || compareDefault;\n            var length   = array.length,\n                index    = 0;\n            while (index < length) this.insert(array[index++]);\n        },\n        insert: function (element) {\n            var array   = this.array,\n                compare = this.compare,\n                high    = array.length-1,\n                low     = 0,\n                pos = -1,\n                index,\n                ordering;\n\n            // The array is sorted. You must find the position of new element in O(log(n)), not O(n).\n            while (high >= low) {\n                index    = (high + low) / 2 >>> 0;\n                ordering = compare(array[index], element);                \n                if (ordering < 0) low  = index + 1;\n                else if (ordering > 0) high = index - 1;\n                else {\n                    pos = index;\n                    break;\n                };\n            }\n\n            if (pos === -1) {\n                // if element was not found, high < low.\n                pos = high;\n            }\n            // This assures that equal elements inserted after will be in a higher position in array.\n            // They can be equal for comparison purposes, but different objects with different data.\n            // Respecting the chronological order can be important for many applications.\n            pos++;\n            high = array.length-1;\n            while ((pos < high) && (compare(element, array[pos]) === 0)){\n                pos++;\n            }\n            index = array.length;\n            // Just to increase array size.\n            array.push(element);            \n            // Much faster. No need to elements swap.\n            while (index > pos) {\n                array[index] = array[--index];\n            }\n            // Set the new element on its correct position.\n            array[pos] = element;\n\n            return this;\n        },\n        search: function (element) {\n            var array   = this.array,\n                compare = this.compare,\n                high    = array.length-1,\n                low     = 0,\n                // In most languages, inner variable declaration makes the code slower.\n                index,\n                ordering;\n\n            while (high >= low) {\n                index    = (high + low) / 2 >>> 0;\n                ordering = compare(array[index], element);\n\n                     if (ordering < 0) low  = index + 1;\n                else if (ordering > 0) high = index - 1;\n                else return index;\n            }\n\n            return -1;\n        },\n        remove: function (element) {\n            var index = this.search(element);\n            if (index >= 0) this.array.splice(index, 1);\n            return this;\n        }\n    });\n\n    SortedArray.comparing = function (property, array) {\n        return new SortedArray(array, function (a, b) {\n            // This should be faster than calling functions.\n            // Besides, this way it is not needed to create useless function to return property value.\n            return compareDefault(a[property], b[property]);\n        });\n    };\n\n    return SortedArray;\n\n    function defclass(prototype) {\n        var constructor = prototype.constructor;\n        constructor.prototype = prototype;\n        return constructor;\n    }\n\n    function compareDefault(a, b) {\n        // Equality has a very low chance to happen. It should be the last option.\n        if (a < b)\n            return -1;\n        else if (a > b)\n            return 1;\n        else\n            return 0;\n    }\n}());\n\nif (typeof module === \"object\") module.exports = SortedArray;\nif (typeof define === \"function\" && define.amd)\n    define(function () { return SortedArray; });\n","// Add the types export first so it's naming takes precedence\nexport * from \"@player-ui/types\";\nexport * from \"./binding/index\";\nexport * from \"./data/index\";\nexport * from \"./expressions/index\";\nexport * from \"./logger/index\";\nexport * from \"./schema/index\";\nexport * from \"./string-resolver/index\";\nexport * from \"./validator/index\";\nexport * from \"./view/index\";\n\nexport * from \"./player\";\nexport * from \"./controllers/index\";\nexport * from \"./types\";\nexport * from \"./plugins/flow-exp-plugin\";\n","/**\n * Checks if `value` is equal to `check` if `check` is a string or in `check` if check is an Array\n *\n * @param value - the value being searched for\n * @param check - the values to check against\n * @returns `boolean`\n */\nexport function equalToOrIn(value: string, check: string | Array<string>) {\n  if (Array.isArray(check)) {\n    return check.includes(value);\n  }\n\n  return check === value;\n}\n","import { equalToOrIn } from \"./utils\";\n\nexport type Interceptor<Args extends any[], ReturnType, ContextType> = {\n  /** An optional name for the interceptor */\n  name?: string;\n  /** Callback for each loop when used by the hook */\n  loop?: (...args: Args) => void;\n  /** Callback when an error occurs during the hook's call */\n  error?: (err: Error) => void;\n  /** Callback when a result is found for a hook's invocation */\n  result?: (\n    r: ReturnType extends Promise<infer AwaitedValue>\n      ? AwaitedValue\n      : ReturnType\n  ) => void;\n  /** Callback when a hook's call is complete */\n  done?: () => void;\n  /** Callback when a hook is tapped */\n  tap?: (tap: Tap<Args, ReturnType, ContextType>) => void;\n} & (\n  | {\n      /** If context should be omitted from the 'call'. This is the default */\n      context?: false;\n      /** Callback when the hook is tapped without context */\n      call?: (...args: Args) => void;\n    }\n  | {\n      /** If context should be included in the 'call' */\n      context: true;\n      /** Callback when the hook is tapped with context */\n      call?: (context: ContextType, ...args: Args) => void;\n    }\n);\n\nexport type Tap<Args extends any[], ReturnType, ContextType = unknown> = {\n  key: symbol;\n  name: string;\n  before?: string | Array<string>;\n} & (\n  | {\n      context: false;\n      callback: (...args: Args) => ReturnType;\n    }\n  | {\n      context: true;\n      callback: (context: ContextType, ...args: Args) => ReturnType;\n    }\n);\n\ntype BasicTap<Args extends any[], ReturnType, ContextType> = (\n  name: string,\n  callback: (...args: Args) => ReturnType,\n  before?: string | Array<string>\n) => Tap<Args, ReturnType, ContextType>;\n\ntype TapWithContext<Args extends any[], ReturnType, ContextType> =\n  | ((\n      options: {\n        name: string;\n        context?: false;\n        before?: string | Array<string>;\n      },\n      callback: (...args: Args) => ReturnType\n    ) => Tap<Args, ReturnType>)\n  | ((\n      options: {\n        name: string;\n        context: true;\n        before?: string | Array<string>;\n      },\n      callback: (context: ContextType, ...args: Args) => ReturnType\n    ) => Tap<Args, ReturnType>);\n\ninterface SyncBaseHookType<Args extends any[], ReturnType, ContextType> {\n  tap:\n    | BasicTap<Args, ReturnType, ContextType>\n    | TapWithContext<Args, ReturnType, ContextType>;\n  call(...args: Args): void;\n  untap(key: Tap<Args, ReturnType>): void;\n  isUsed(): boolean;\n  intercept(int: Interceptor<Args, ReturnType, ContextType>): void;\n}\n\nfunction callTap<Args extends any[], ReturnType, ContextType>(\n  tap: Tap<Args, ReturnType, ContextType>,\n  args: Args,\n  ctx: ContextType\n) {\n  if (tap.context) {\n    return tap.callback(ctx, ...args);\n  }\n\n  return tap.callback(...args);\n}\n\n/** A manager for all intercepts inside of a tap */\nclass InterceptionManager<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> {\n  protected interceptions: Array<Interceptor<Args, ReturnType, ContextType>>;\n  private interceptionKeySet: Set<\n    keyof Interceptor<Args, ReturnType, ContextType>\n  >;\n\n  constructor() {\n    this.interceptions = [];\n    this.interceptionKeySet = new Set();\n  }\n\n  isUsed() {\n    return this.interceptions.length > 0;\n  }\n\n  intercept(int: Interceptor<Args, ReturnType, ContextType>): void {\n    this.interceptions.push(int);\n    Object.keys(int).forEach((s) => {\n      this.interceptionKeySet.add(s as any);\n    });\n  }\n\n  tap(tap: Tap<Args, ReturnType, ContextType>): void {\n    if (this.interceptionKeySet.has(\"tap\")) {\n      this.interceptions.forEach((i) => {\n        i.tap?.(tap);\n      });\n    }\n  }\n\n  call(ctx: ContextType, ...args: Args): void {\n    if (this.interceptionKeySet.has(\"call\")) {\n      this.interceptions.forEach((i) => {\n        if (i.context) {\n          i.call?.(ctx, ...args);\n        } else {\n          i.call?.(...args);\n        }\n      });\n    }\n  }\n\n  loop(...args: Args): void {\n    if (this.interceptionKeySet.has(\"loop\")) {\n      this.interceptions.forEach((i) => {\n        i.loop?.(...args);\n      });\n    }\n  }\n\n  error(err: unknown): void {\n    if (this.interceptionKeySet.has(\"error\")) {\n      if (err instanceof Error) {\n        const asError: Error = err;\n        this.interceptions.forEach((i) => {\n          i.error?.(asError);\n        });\n      }\n    }\n  }\n\n  result(\n    r: ReturnType extends Promise<infer AwaitedValue>\n      ? AwaitedValue\n      : ReturnType\n  ): void {\n    if (this.interceptionKeySet.has(\"result\")) {\n      this.interceptions.forEach((i) => {\n        i.result?.(r);\n      });\n    }\n  }\n\n  done(): void {\n    if (this.interceptionKeySet.has(\"done\")) {\n      this.interceptions.forEach((i) => {\n        i.done?.();\n      });\n    }\n  }\n}\n\nabstract class Hook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> implements SyncBaseHookType<Args, ReturnType, ContextType>\n{\n  protected taps: Array<Tap<Args, ReturnType, ContextType>>;\n  protected interceptions: InterceptionManager<Args, ReturnType, ContextType>;\n\n  constructor() {\n    this.taps = [];\n    this.interceptions = new InterceptionManager<\n      Args,\n      ReturnType,\n      ContextType\n    >();\n  }\n\n  public tap(\n    options: { name: string; context?: false; before?: string | Array<string> },\n    callback: (...args: Args) => ReturnType\n  ): Tap<Args, ReturnType, ContextType>;\n\n  public tap(\n    options: { name: string; context: true; before?: string | Array<string> },\n    callback: (ctx: ContextType, ...args: Args) => ReturnType\n  ): Tap<Args, ReturnType, ContextType>;\n\n  public tap(\n    name: string,\n    callback: (...args: Args) => ReturnType\n  ): Tap<Args, ReturnType, ContextType>;\n\n  public tap(options: any, callback: any): Tap<Args, ReturnType, ContextType> {\n    const resolvedOptions =\n      typeof options === \"string\"\n        ? {\n            name: options,\n            context: false,\n          }\n        : {\n            context: false,\n            ...options,\n          };\n\n    const key = Symbol(resolvedOptions.name);\n    const tap: Tap<Args, ReturnType, ContextType> = {\n      key,\n      ...resolvedOptions,\n      callback,\n    };\n\n    if (tap.before) {\n      let insertionIndex = this.taps.length;\n      const beforeSet = new Set(\n        Array.isArray(tap.before) ? tap.before : [tap.before]\n      );\n      for (\n        insertionIndex;\n        insertionIndex > 0 && beforeSet.size > 0;\n        insertionIndex--\n      ) {\n        const t = this.taps[insertionIndex - 1];\n        if (beforeSet.has(t.name)) {\n          beforeSet.delete(t.name);\n        }\n\n        if (t.before && equalToOrIn(tap.name, t.before)) {\n          break;\n        }\n      }\n\n      this.taps.splice(insertionIndex, 0, tap);\n    } else {\n      this.taps.push(tap);\n    }\n\n    this.interceptions.tap(tap);\n\n    return tap;\n  }\n\n  abstract call(...args: Args): ReturnType;\n\n  public untap(tap: Tap<Args, ReturnType, ContextType>) {\n    this.taps = this.taps.filter((t) => t.key !== tap.key);\n  }\n\n  public isUsed() {\n    return this.taps.length > 0 || this.interceptions.isUsed();\n  }\n\n  public intercept(int: Interceptor<Args, ReturnType, ContextType>): void {\n    this.interceptions.intercept(int);\n  }\n}\n\nexport class SyncHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, void, ContextType> {\n  public call(...args: Args) {\n    if (!this.isUsed()) {\n      return;\n    }\n\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      this.taps.forEach((t) => {\n        callTap(t, args, ctx);\n      });\n    } catch (err: unknown) {\n      this.interceptions.error(err);\n\n      throw err;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class SyncBailHook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> extends Hook<Args, ReturnType | undefined | null, ContextType> {\n  public call(...args: Args): ReturnType | undefined | null {\n    if (!this.isUsed()) {\n      return;\n    }\n\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n      const rtn = callTap(this.taps[tapIndex], args, ctx);\n      if (rtn !== undefined) {\n        this.interceptions.result(rtn as any);\n        return rtn;\n      }\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class SyncWaterfallHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Args[0], ContextType> {\n  public call(...args: Args): Args[0] {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    // eslint-disable-next-line prefer-const\n    let [rtn, ...rest] = args;\n\n    for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n      const tapValue = callTap(this.taps[tapIndex], [rtn, ...rest] as any, ctx);\n      if (tapValue !== undefined) {\n        rtn = tapValue;\n      }\n    }\n\n    this.interceptions.result(rtn);\n\n    return rtn;\n  }\n}\n\nexport class SyncLoopHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, void, ContextType> {\n  public call(...args: Args) {\n    let finished = false;\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      while (finished !== true) {\n        finished = true;\n        this.interceptions.loop(...args);\n        for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n          const rtn = callTap(this.taps[tapIndex], args, ctx);\n\n          if (rtn !== undefined) {\n            finished = false;\n            break;\n          }\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncParallelHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<void>, ContextType> {\n  public async call(...args: Args): Promise<void> {\n    const ctx: ContextType = {} as any;\n    this.interceptions.call(ctx, ...args);\n\n    await Promise.allSettled(this.taps.map((tap) => callTap(tap, args, ctx)));\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncParallelBailHook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<ReturnType>, ContextType> {\n  public async call(...args: Args): Promise<ReturnType> {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      const rtn = await Promise.race(\n        this.taps.map((tap) => callTap(tap, args, ctx))\n      );\n\n      this.interceptions.result(rtn as any);\n      return rtn;\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n  }\n}\n\nexport class AsyncSeriesHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<void>, ContextType> {\n  public async call(...args: Args): Promise<void> {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        await callTap(this.taps[tapIndex], args, ctx);\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncSeriesBailHook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<ReturnType | undefined | null>, ContextType> {\n  public async call(...args: Args): Promise<ReturnType | undefined | null> {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        const rtn = await callTap(this.taps[tapIndex], args, ctx);\n        if (rtn !== undefined) {\n          this.interceptions.result(rtn);\n          return rtn;\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncSeriesWaterfallHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<Args[0]>, ContextType> {\n  public async call(...args: Args): Promise<Args[0]> {\n    // eslint-disable-next-line prefer-const\n    let [rtn, ...rest] = args;\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        const tapValue = await callTap(\n          this.taps[tapIndex],\n          [rtn, ...rest] as any,\n          ctx\n        );\n        if (tapValue !== undefined) {\n          rtn = tapValue;\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.result(rtn);\n\n    return rtn;\n  }\n}\n\nexport class AsyncSeriesLoopHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<void>, ContextType> {\n  public async call(...args: Args): Promise<void> {\n    let finished = false;\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      while (finished !== true) {\n        finished = true;\n        this.interceptions.loop(...args);\n        for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n          const rtn = await callTap(this.taps[tapIndex], args, ctx);\n\n          if (rtn !== undefined) {\n            finished = false;\n            break;\n          }\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n","import { SyncBailHook, SyncWaterfallHook } from \"tapable-ts\";\nimport { NestedError } from \"ts-nested-error\";\nimport type { ParserResult, AnyNode } from \"../binding-grammar/index\";\nimport {\n  // We can swap this with whichever parser we want to use\n  parseCustom as parseBinding,\n} from \"../binding-grammar\";\nimport type { BindingParserOptions, BindingLike } from \"./binding\";\nimport { BindingInstance } from \"./binding\";\nimport { isBinding } from \"./utils\";\nimport type { NormalizedResult, ResolveBindingASTOptions } from \"./resolver\";\nimport { resolveBindingAST } from \"./resolver\";\n\nexport * from \"./utils\";\nexport * from \"./binding\";\n\nexport const SIMPLE_BINDING_REGEX = /^[\\w\\-@]+(\\.[\\w\\-@]+)*$/;\nexport const BINDING_BRACKETS_REGEX = /[\\s()*=`{}'\"[\\]]/;\nconst LAZY_BINDING_REGEX = /^[^.]+(\\..+)*$/;\n\nconst DEFAULT_OPTIONS: BindingParserOptions = {\n  get: () => {\n    throw new Error(\"Not Implemented\");\n  },\n  set: () => {\n    throw new Error(\"Not Implemented\");\n  },\n  evaluate: () => {\n    throw new Error(\"Not Implemented\");\n  },\n};\n\ntype BeforeResolveNodeContext = Required<NormalizedResult> &\n  ResolveBindingASTOptions;\n\n/** A parser for creating bindings from a string */\nexport class BindingParser {\n  private cache: Record<string, BindingInstance>;\n  private parseCache: Record<string, ParserResult>;\n  private parserOptions: BindingParserOptions;\n\n  public hooks = {\n    skipOptimization: new SyncBailHook<[string], boolean>(),\n    beforeResolveNode: new SyncWaterfallHook<\n      [AnyNode, BeforeResolveNodeContext]\n    >(),\n  };\n\n  constructor(options?: Partial<BindingParserOptions>) {\n    this.parserOptions = { ...DEFAULT_OPTIONS, ...options };\n    this.cache = {};\n    this.parseCache = {};\n    this.parse = this.parse.bind(this);\n  }\n\n  /**\n   * Takes a binding path, parses it, and returns an equivalent, normalized\n   * representation of that path.\n   */\n  private normalizePath(\n    path: string,\n    resolveOptions: ResolveBindingASTOptions,\n  ) {\n    /**\n     * Ensure no binding characters exist in path and the characters remaining\n     * look like a binding format.\n     */\n    if (\n      !BINDING_BRACKETS_REGEX.test(path) &&\n      LAZY_BINDING_REGEX.test(path) &&\n      this.hooks.skipOptimization.call(path) !== true\n    ) {\n      return { path: path.split(\".\"), updates: undefined } as NormalizedResult;\n    }\n\n    const ast = this.parseCache[path] ?? parseBinding(path);\n    this.parseCache[path] = ast;\n\n    if (typeof ast !== \"object\" || !ast?.status) {\n      throw new TypeError(\n        `Cannot normalize path \"${path}\": ${ast?.error ?? \"Unknown Error.\"}`,\n      );\n    }\n\n    try {\n      return resolveBindingAST(ast.path, resolveOptions, this.hooks);\n    } catch (e: any) {\n      throw new NestedError(`Cannot resolve binding: ${path}`, e);\n    }\n  }\n\n  private getBindingForNormalizedResult(\n    normalized: NormalizedResult,\n  ): BindingInstance {\n    const normalizedStr = normalized.path.join(\".\");\n\n    if (this.cache[normalizedStr]) {\n      return this.cache[normalizedStr];\n    }\n\n    const created = new BindingInstance(\n      normalizedStr === \"\" ? [] : normalized.path,\n      this.parse,\n    );\n    this.cache[normalizedStr] = created;\n\n    return created;\n  }\n\n  public parse(\n    rawBinding: BindingLike,\n    overrides: Partial<BindingParserOptions> = {},\n  ): BindingInstance {\n    if (isBinding(rawBinding)) {\n      return rawBinding;\n    }\n\n    const options = {\n      ...this.parserOptions,\n      ...overrides,\n    };\n\n    let updates: Record<string, any> = {};\n\n    const joined = Array.isArray(rawBinding)\n      ? rawBinding.join(\".\")\n      : String(rawBinding);\n\n    const normalizeConfig: ResolveBindingASTOptions = {\n      getValue: (path: Array<string | number>) => {\n        const normalized = this.normalizePath(path.join(\".\"), normalizeConfig);\n\n        return options.get(this.getBindingForNormalizedResult(normalized));\n      },\n      evaluate: (exp) => {\n        return options.evaluate(exp);\n      },\n      convertToPath: (path: any) => {\n        if (path === undefined) {\n          throw new Error(\n            \"Attempted to convert undefined value to binding path\",\n          );\n        }\n\n        if (\n          typeof path !== \"string\" &&\n          typeof path !== \"number\" &&\n          typeof path !== \"boolean\"\n        ) {\n          throw new Error(\n            `Attempting to convert ${typeof path} to a binding path.`,\n          );\n        }\n\n        const normalized = this.normalizePath(String(path), normalizeConfig);\n\n        if (normalized.updates) {\n          updates = {\n            ...updates,\n            ...normalized.updates,\n          };\n        }\n\n        const joinedNormalizedPath = normalized.path.join(\".\");\n\n        if (joinedNormalizedPath === \"\") {\n          throw new Error(\"Nested path resolved to an empty path\");\n        }\n\n        return joinedNormalizedPath;\n      },\n    };\n\n    const normalized = this.normalizePath(joined, normalizeConfig);\n\n    if (normalized.updates) {\n      updates = {\n        ...updates,\n        ...normalized.updates,\n      };\n    }\n\n    const updateKeys = Object.keys(updates);\n\n    if (!options.readOnly && updateKeys.length > 0) {\n      const updateTransaction = updateKeys.map<[BindingInstance, any]>(\n        (updatedBinding) => [\n          this.parse(updatedBinding),\n          updates[updatedBinding],\n        ],\n      );\n\n      options.set(updateTransaction);\n    }\n\n    return this.getBindingForNormalizedResult(normalized);\n  }\n}\n","export interface Node<T extends string> {\n  /** The basic node type */\n  name: T;\n}\n\n/**\n * An AST node that represents a nested path in the model\n * foo.{{bar}}.baz (this is {{bar}})\n */\nexport interface PathNode extends Node<\"PathNode\"> {\n  /** The path in the model that this node represents */\n  path: Array<AnyNode>;\n}\n\n/**\n * A segment representing a query\n * [foo=bar]\n */\nexport interface QueryNode extends Node<\"Query\"> {\n  /** The key to query */\n  key: AnyNode;\n\n  /** The target value */\n  value?: AnyNode;\n}\n\n/** A simple segment */\nexport interface ValueNode extends Node<\"Value\"> {\n  /** The segment value */\n  value: string | number;\n}\n\n/** A nested expression */\nexport interface ExpressionNode extends Node<\"Expression\"> {\n  /** The expression */\n  value: string;\n}\n\n/** Helper to create a value node */\nexport const toValue = (value: string | number): ValueNode => ({\n  name: \"Value\",\n  value,\n});\n\n/** Helper to create an expression node */\nexport const toExpression = (value: string): ExpressionNode => ({\n  name: \"Expression\",\n  value,\n});\n\n/** Helper to create a nested path node */\nexport const toPath = (path: Array<AnyNode>): PathNode => ({\n  name: \"PathNode\",\n  path,\n});\n\n/** Helper to create a query node */\nexport const toQuery = (key: AnyNode, value?: AnyNode): QueryNode => ({\n  name: \"Query\",\n  key,\n  value,\n});\n\n/** Create a concat node */\nexport const toConcatenatedNode = (\n  values: Array<PathNode | ValueNode | ExpressionNode>,\n): PathNode | ValueNode | ConcatenatedNode | ExpressionNode => {\n  if (values.length === 1) {\n    return values[0];\n  }\n\n  return {\n    name: \"Concatenated\",\n    value: values,\n  };\n};\n\n/**\n * A binding segment that's multiple smaller ones\n * {{foo}}_bar_{{baz}}\n */\nexport interface ConcatenatedNode extends Node<\"Concatenated\"> {\n  /** A list of nested paths, or value nodes to concat together to form a segment */\n  value: Array<PathNode | ValueNode | ExpressionNode>;\n}\n\nexport type AnyNode =\n  | PathNode\n  | QueryNode\n  | ValueNode\n  | ConcatenatedNode\n  | ExpressionNode;\nexport type Path = Array<AnyNode>;\n\nexport interface ParserSuccessResult {\n  /** A successful parse result */\n  status: true;\n\n  /** The path the binding represents */\n  path: PathNode;\n}\n\nexport interface ParserFailureResult {\n  /** A failed parse result */\n  status: false;\n\n  /** The message representing the reason the parse result failed */\n  error: string;\n}\n\nexport type ParserResult = ParserSuccessResult | ParserFailureResult;\n\nexport type Parser = (raw: string) => ParserResult;\n","import type {\n  Parser,\n  AnyNode,\n  PathNode,\n  ConcatenatedNode,\n  ValueNode,\n  QueryNode,\n  ExpressionNode,\n} from \"../ast\";\nimport {\n  toValue,\n  toPath,\n  toConcatenatedNode,\n  toQuery,\n  toExpression,\n} from \"../ast\";\n\nconst SEGMENT_SEPARATOR = \".\";\nconst OPEN_CURL = \"{\";\nconst CLOSE_CURL = \"}\";\nconst OPEN_BRACKET = \"[\";\nconst CLOSE_BRACKET = \"]\";\nconst EQUALS = \"=\";\nconst SINGLE_QUOTE = \"'\";\nconst DOUBLE_QUOTE = '\"';\nconst BACK_TICK = \"`\";\n// const IDENTIFIER_REGEX = /[\\w\\-@]+/;\n\n/** A _faster_ way to match chars instead of a regex. */\nconst isIdentifierChar = (char?: string): boolean => {\n  if (!char) {\n    return false;\n  }\n\n  const charCode = char.charCodeAt(0);\n\n  const matches =\n    charCode === 32 || // ' '\n    charCode === 34 || // \"\n    charCode === 39 || // '\n    charCode === 40 || // (\n    charCode === 41 || // )\n    charCode === 42 || // *\n    charCode === 46 || // .\n    charCode === 61 || // =\n    charCode === 91 || // [\n    charCode === 93 || // ]\n    charCode === 96 || // `\n    charCode === 123 || // {\n    charCode === 125; // }\n\n  return !matches;\n};\n\n/** Parse out a binding AST from a path */\nexport const parse: Parser = (path) => {\n  let index = 1;\n  let ch = path.charAt(0);\n\n  /** get the next char in the string */\n  const next = (expected?: string) => {\n    if (expected && ch !== expected) {\n      throw new Error(`Expected char: ${expected} but got: ${ch}`);\n    }\n\n    ch = path.charAt(index);\n    index += 1;\n    return ch;\n  };\n\n  /** gobble all whitespace */\n  const whitespace = () => {\n    /* eslint-disable no-unmodified-loop-condition */\n    while (ch === \" \") {\n      next();\n    }\n  };\n\n  /** get an identifier if you can */\n  const identifier = (): ValueNode | undefined => {\n    if (!isIdentifierChar(ch)) {\n      return;\n    }\n\n    let value = ch;\n\n    while (next()) {\n      if (!isIdentifierChar(ch)) {\n        break;\n      }\n\n      value += ch;\n    }\n\n    if (value) {\n      return toValue(value);\n    }\n  };\n\n  /** get an expression node if you can */\n  const expression = (): ExpressionNode | undefined => {\n    if (ch === BACK_TICK) {\n      next(BACK_TICK);\n\n      let exp = ch;\n\n      while (next()) {\n        if (ch === BACK_TICK) {\n          break;\n        }\n\n        exp += ch;\n      }\n\n      next(BACK_TICK);\n\n      if (exp) {\n        return toExpression(exp);\n      }\n    }\n  };\n\n  /** Grab a value using a regex */\n  const regex = (match: RegExp): ValueNode | undefined => {\n    if (!ch?.match(match)) {\n      return;\n    }\n\n    let value = ch;\n\n    while (next()) {\n      if (!ch?.match(match)) {\n        break;\n      }\n\n      value += ch;\n    }\n\n    if (value) {\n      return toValue(value);\n    }\n  };\n\n  /** parse out a nestedPath if you can */\n  const nestedPath = (): PathNode | undefined => {\n    if (ch === OPEN_CURL) {\n      next(OPEN_CURL);\n      next(OPEN_CURL);\n\n      /* eslint-disable-next-line @typescript-eslint/no-use-before-define */\n      const modelRef = parsePath();\n      next(CLOSE_CURL);\n      next(CLOSE_CURL);\n      return modelRef;\n    }\n  };\n\n  /** get a simple segment node */\n  const simpleSegment = () => nestedPath() ?? expression() ?? identifier();\n\n  /** Parse a segment */\n  const segment = ():\n    | ConcatenatedNode\n    | PathNode\n    | ValueNode\n    | ExpressionNode\n    | undefined => {\n    // Either a string, modelRef, or concatenated version (both)\n    const segments: Array<ValueNode | PathNode | ExpressionNode> = [];\n    let nextSegment = simpleSegment();\n\n    while (nextSegment !== undefined) {\n      segments.push(nextSegment);\n      nextSegment = simpleSegment();\n    }\n\n    if (segments.length === 0) {\n      return undefined;\n    }\n\n    return toConcatenatedNode(segments);\n  };\n\n  /** get an optionally quoted block */\n  const optionallyQuotedSegment = ():\n    | ValueNode\n    | PathNode\n    | ExpressionNode\n    | undefined => {\n    whitespace();\n\n    // see if we have a quote\n\n    if (ch === SINGLE_QUOTE || ch === DOUBLE_QUOTE) {\n      const singleQuote = ch === SINGLE_QUOTE;\n      next(singleQuote ? SINGLE_QUOTE : DOUBLE_QUOTE);\n      const id = regex(/[^'\"]+/);\n      next(singleQuote ? SINGLE_QUOTE : DOUBLE_QUOTE);\n      return id;\n    }\n\n    return simpleSegment();\n  };\n\n  /** eat equals signs */\n  const equals = (): boolean => {\n    if (ch !== EQUALS) {\n      return false;\n    }\n\n    while (ch === EQUALS) {\n      next();\n    }\n\n    return true;\n  };\n\n  /** Parse out a bracket */\n  const parseBracket = ():\n    | ValueNode\n    | QueryNode\n    | PathNode\n    | ExpressionNode\n    | undefined => {\n    if (ch === OPEN_BRACKET) {\n      next(OPEN_BRACKET);\n      whitespace();\n      let value: ValueNode | QueryNode | PathNode | ExpressionNode | undefined =\n        optionallyQuotedSegment();\n      if (value) {\n        whitespace();\n        if (equals()) {\n          whitespace();\n          const second = optionallyQuotedSegment();\n          value = toQuery(value, second);\n          whitespace();\n        }\n      } else {\n        throw new Error(`Expected identifier`);\n      }\n\n      if (value) {\n        next(CLOSE_BRACKET);\n      }\n\n      return value;\n    }\n  };\n\n  /** Parse a segment and any number of brackets following it */\n  const parseSegmentAndBrackets = (): Array<AnyNode> => {\n    // try to parse a segment first\n\n    const parsed: Array<AnyNode> = [];\n\n    const firstSegment = segment();\n\n    if (firstSegment) {\n      parsed.push(firstSegment);\n\n      let bracketSegment = parseBracket();\n\n      while (bracketSegment !== undefined) {\n        parsed.push(bracketSegment);\n        bracketSegment = parseBracket();\n      }\n    }\n\n    return parsed;\n  };\n\n  /** Parse out a path segment */\n  const parsePath = (): PathNode => {\n    const parts: AnyNode[] = [];\n\n    let nextSegment = parseSegmentAndBrackets();\n\n    while (nextSegment !== undefined) {\n      parts.push(...nextSegment);\n\n      if (!ch || ch === CLOSE_CURL) {\n        break;\n      }\n\n      if (nextSegment.length === 0 && ch) {\n        throw new Error(`Unexpected character: ${ch}`);\n      }\n\n      next(SEGMENT_SEPARATOR);\n      nextSegment = parseSegmentAndBrackets();\n    }\n\n    return toPath(parts);\n  };\n\n  try {\n    const result = parsePath();\n\n    return {\n      status: true,\n      path: result,\n    };\n  } catch (e: any) {\n    return {\n      status: false,\n      error: e.message,\n    };\n  }\n};\n","import type { BindingLike, BindingInstance } from \"./binding\";\n\n/** Check if the parameter representing a binding is already of the Binding class */\nexport function isBinding(binding: BindingLike): binding is BindingInstance {\n  return !(typeof binding === \"string\" || Array.isArray(binding));\n}\n\n/** Convert the string to an int if you can, otherwise just return the original string */\nexport function maybeConvertToNum(i: string): string | number {\n  const asInt = parseInt(i, 10);\n\n  if (isNaN(asInt)) {\n    return i;\n  }\n\n  return asInt;\n}\n\n/**\n * utility to convert binding into binding segments.\n */\nexport function getBindingSegments(\n  binding: BindingLike,\n): Array<string | number> {\n  if (Array.isArray(binding)) {\n    return binding;\n  }\n\n  if (typeof binding === \"string\") {\n    return binding.split(\".\");\n  }\n\n  return binding.asArray();\n}\n\n/** Like _.findIndex, but ignores types */\nexport function findInArray<T extends Record<string | number, object>>(\n  array: Array<T>,\n  key: string | number,\n  value: T,\n): number | undefined {\n  return array.findIndex((obj) => {\n    if (obj && typeof obj === \"object\") {\n      // Intentional double-equals because we want '4' to be coerced to 4\n      // eslint-disable-next-line eqeqeq\n      return obj[key] == value;\n    }\n\n    return false;\n  });\n}\n","import { getBindingSegments } from \"./utils\";\n\nexport interface BindingParserOptions {\n  /** Get the value for a specific binding */\n  get: (binding: BindingInstance) => any;\n\n  /**\n   * Set the values for bindings.\n   * This is used when the query syntax needs to modify an object\n   */\n  set: (transaction: Array<[BindingInstance, any]>) => void;\n\n  /**\n   * Get the result of evaluating an expression\n   */\n  evaluate: (exp: string) => any;\n\n  /**\n   * Without readOnly, if a binding such as this is used: arr[key='does not exist'],\n   * then an object with that key will be created.\n   * This is done to make assignment such as arr[key='abc'].val = 'foo' work smoothly.\n   * Setting readOnly to true will prevent this behavior, avoiding unintended data changes.\n   */\n  readOnly?: boolean;\n}\n\nexport type Getter = (path: BindingInstance) => any;\n\nexport type RawBindingSegment = number | string;\nexport type RawBinding = string | RawBindingSegment[];\nexport type BindingLike = RawBinding | BindingInstance;\nexport type BindingFactory = (\n  raw: RawBinding,\n  options?: Partial<BindingParserOptions>,\n) => BindingInstance;\n\n/**\n * A path in the data model\n */\nexport class BindingInstance {\n  private split: RawBindingSegment[];\n  private joined: string;\n  private factory: BindingFactory;\n\n  constructor(\n    raw: RawBinding,\n    factory = (rawBinding: RawBinding) => new BindingInstance(rawBinding),\n  ) {\n    const split = Array.isArray(raw) ? raw : raw.split(\".\");\n    this.split = split.map((segment) => {\n      if (typeof segment === \"number\") {\n        return segment;\n      }\n\n      const tryNum = Number(segment);\n      return isNaN(tryNum) ? segment : tryNum;\n    });\n    Object.freeze(this.split);\n    this.joined = this.split.join(\".\");\n    this.factory = factory;\n  }\n\n  asArray(): RawBindingSegment[] {\n    return this.split;\n  }\n\n  asString(): string {\n    return this.joined;\n  }\n\n  /**\n   * Check to see if the given binding is a sub-path of the current one\n   */\n  contains(binding: BindingInstance): boolean {\n    // need to account for partial key matches\n    // [foo, bar] !== [foo, ba]\n    const bindingAsArray = binding.asArray();\n\n    if (bindingAsArray.length < this.split.length) {\n      return false;\n    }\n\n    // Check every overlapping index to make sure they're the same\n    // Intentionally use a for loop for speeeed\n    for (let i = 0; i < this.split.length; i++) {\n      if (this.split[i] !== bindingAsArray[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  relative(binding: BindingInstance): RawBindingSegment[] {\n    return this.asArray().slice(binding.asArray().length);\n  }\n\n  parent(): BindingInstance {\n    return this.factory(this.split.slice(0, -1));\n  }\n\n  key(): RawBindingSegment {\n    return this.split[this.split.length - 1];\n  }\n\n  /**\n   * This is a utility method to get a binding that is a descendent of this binding\n   *\n   * @param relative - The relative path to descend to\n   */\n  descendent(relative: BindingLike): BindingInstance {\n    const descendentSegments = getBindingSegments(relative);\n\n    return this.factory(this.split.concat(descendentSegments));\n  }\n}\n","import { NestedError } from \"ts-nested-error\";\nimport type { SyncWaterfallHook } from \"tapable-ts\";\nimport type { PathNode, AnyNode } from \"../binding-grammar\";\nimport { findInArray, maybeConvertToNum } from \"./utils\";\n\nexport interface NormalizedResult {\n  /** The normalized path */\n  path: Array<string | number>;\n\n  /** Any new updates that need to happen for this binding to be resolved */\n  updates?: Record<string, any>;\n}\n\nexport interface ResolveBindingASTOptions {\n  /** Get the value of the model at the given path */\n  getValue: (path: Array<string | number>) => any;\n\n  /** Convert the value into valid path segments */\n  convertToPath: (value: any) => string;\n\n  /** Convert the value into valid path segments */\n  evaluate: (exp: string) => any;\n}\n\nexport interface ResolveBindingASTHooks {\n  /** A hook for transforming a node before fully resolving it */\n  beforeResolveNode: SyncWaterfallHook<\n    [AnyNode, Required<NormalizedResult> & ResolveBindingASTOptions]\n  >;\n}\n\n/** Given a binding AST, resolve it */\nexport function resolveBindingAST(\n  bindingPathNode: PathNode,\n  options: ResolveBindingASTOptions,\n  hooks?: ResolveBindingASTHooks,\n): NormalizedResult {\n  const context: Required<NormalizedResult> = {\n    updates: {},\n    path: [],\n  };\n\n  // let updates: Record<string, any> = {};\n  // const path: Array<string | number> = [];\n\n  /** Get the value for any child node */\n  function getValueForNode(node: AnyNode): any {\n    if (node.name === \"Value\") {\n      return node.value;\n    }\n\n    if (node.name === \"PathNode\") {\n      const nestedResolvedValue = resolveBindingAST(node, options);\n\n      if (nestedResolvedValue.updates) {\n        context.updates = {\n          ...context.updates,\n          ...nestedResolvedValue.updates,\n        };\n      }\n\n      try {\n        return options.convertToPath(\n          options.getValue(nestedResolvedValue.path),\n        );\n      } catch (e: any) {\n        throw new NestedError(\n          `Unable to resolve path segment: ${nestedResolvedValue.path}`,\n          e,\n        );\n      }\n    }\n\n    if (node.name === \"Expression\") {\n      try {\n        const actualValue = options.evaluate(node.value);\n\n        return options.convertToPath(actualValue);\n      } catch (e: any) {\n        throw new NestedError(`Unable to resolve path: ${node.value}`, e);\n      }\n    }\n\n    throw new Error(`Unable to resolve value for node: ${node.name}`);\n  }\n\n  /** Handle when path segments are binding paths (foo.bar) or single segments (foo) */\n  function appendPathSegments(segment: string | number) {\n    if (typeof segment === \"string\" && segment.indexOf(\".\") > -1) {\n      segment.split(\".\").forEach((i) => {\n        context.path.push(maybeConvertToNum(i));\n      });\n    } else {\n      context.path.push(segment);\n    }\n  }\n\n  /** Compute the _actual_ binding val from the AST */\n  function resolveNode(_node: AnyNode) {\n    const resolvedNode =\n      hooks?.beforeResolveNode.call(_node, { ...context, ...options }) ?? _node;\n\n    switch (resolvedNode.name) {\n      case \"Expression\":\n      case \"PathNode\":\n        appendPathSegments(getValueForNode(resolvedNode));\n        break;\n\n      case \"Value\":\n        appendPathSegments(resolvedNode.value);\n        break;\n\n      case \"Query\": {\n        // Look for an object at the path with the given key/val criteria\n        const objToQuery: Record<string, any>[] =\n          options.getValue(context.path) ?? [];\n\n        const { key, value } = resolvedNode;\n\n        const resolvedKey = getValueForNode(key);\n        const resolvedValue = value && getValueForNode(value);\n\n        const index = findInArray(objToQuery, resolvedKey, resolvedValue);\n\n        if (index === undefined || index === -1) {\n          context.updates[\n            [...context.path, objToQuery.length, resolvedKey].join(\".\")\n          ] = resolvedValue;\n          context.path.push(objToQuery.length);\n        } else {\n          context.path.push(index);\n        }\n\n        break;\n      }\n\n      case \"Concatenated\":\n        context.path.push(resolvedNode.value.map(getValueForNode).join(\"\"));\n        break;\n\n      default:\n        throw new Error(`Unsupported node type: ${(resolvedNode as any).name}`);\n    }\n  }\n\n  bindingPathNode.path.forEach(resolveNode);\n\n  return {\n    path: context.path,\n    updates:\n      Object.keys(context.updates ?? {}).length > 0\n        ? context.updates\n        : undefined,\n  };\n}\n","import type { BindingInstance } from \"../binding\";\nimport type {\n  BatchSetTransaction,\n  DataModelImpl,\n  DataModelMiddleware,\n  DataModelOptions,\n  Updates,\n} from \"./model\";\n\nexport type DependencySets = \"core\" | \"children\";\n\n/** A class to track usage of read/writes to/from a data model */\nexport class DependencyTracker {\n  protected readDeps: Set<BindingInstance>;\n  protected writeDeps: Set<BindingInstance>;\n  protected namedSet: DependencySets;\n\n  private namedDependencySets: Partial<\n    Record<\n      DependencySets,\n      {\n        /** readDeps */\n        readDeps: Set<BindingInstance>;\n        /** writeDeps */\n        writeDeps: Set<BindingInstance>;\n      }\n    >\n  >;\n\n  constructor() {\n    this.readDeps = new Set();\n    this.writeDeps = new Set();\n    this.namedDependencySets = {};\n    this.namedSet = \"core\";\n\n    this.createSubset(\"core\");\n    this.createSubset(\"children\");\n  }\n\n  protected createSubset(name: DependencySets, force = false): void {\n    if (force || !this.namedDependencySets[name]) {\n      this.namedDependencySets[name] = {\n        readDeps: new Set(),\n        writeDeps: new Set(),\n      };\n    }\n  }\n\n  /** Grab all of the bindings that this depended on */\n  public getDependencies(name?: DependencySets): Set<BindingInstance> {\n    if (name !== undefined) {\n      return this.namedDependencySets?.[name]?.readDeps ?? new Set();\n    }\n\n    return this.readDeps;\n  }\n\n  public trackSubset(name: DependencySets) {\n    this.createSubset(name);\n    this.namedSet = name;\n  }\n\n  public trackDefault() {\n    this.namedSet = \"core\";\n  }\n\n  /** Grab all of the bindings this wrote to */\n  public getModified(name?: DependencySets): Set<BindingInstance> {\n    if (name !== undefined) {\n      return this.namedDependencySets?.[name]?.writeDeps ?? new Set();\n    }\n\n    return this.writeDeps;\n  }\n\n  /**\n   * Check to see if the dataModel has read the value at the given binding\n   *\n   * @param binding - The binding you want to check for\n   */\n  public readsBinding(binding: BindingInstance): boolean {\n    return this.readDeps.has(binding);\n  }\n\n  /**\n   * Check to see if the dataModel has written to the binding\n   */\n  public writesBinding(binding: BindingInstance): boolean {\n    return this.writeDeps.has(binding);\n  }\n\n  /** Reset all tracking of dependencies */\n  public reset() {\n    this.readDeps = new Set();\n    this.writeDeps = new Set();\n    this.namedDependencySets = {};\n    this.namedSet = \"core\";\n\n    this.createSubset(\"core\", true);\n    this.createSubset(\"children\", true);\n  }\n\n  protected addReadDep(\n    binding: BindingInstance,\n    namedSet = this.namedSet,\n  ): void {\n    if (namedSet) {\n      this.namedDependencySets?.[namedSet]?.readDeps.add(binding);\n    }\n\n    this.readDeps.add(binding);\n  }\n\n  protected addWriteDep(\n    binding: BindingInstance,\n    namedSet = this.namedSet,\n  ): void {\n    if (namedSet) {\n      this.namedDependencySets?.[namedSet]?.writeDeps.add(binding);\n    }\n\n    this.writeDeps.add(binding);\n  }\n\n  public addChildReadDep(binding: BindingInstance): void {\n    this.addReadDep(binding, \"children\");\n  }\n}\n\n/** Middleware that tracks dependencies of read/written data */\nexport class DependencyMiddleware\n  extends DependencyTracker\n  implements DataModelMiddleware\n{\n  constructor() {\n    super();\n    this.get = this.get.bind(this);\n    this.set = this.set.bind(this);\n  }\n\n  public set(\n    transaction: BatchSetTransaction,\n    options?: DataModelOptions,\n    next?: DataModelImpl | undefined,\n  ): Updates {\n    transaction.forEach(([binding]) => this.addWriteDep(binding));\n\n    return next?.set(transaction, options) ?? [];\n  }\n\n  public get(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl | undefined,\n  ) {\n    this.addReadDep(binding);\n\n    return next?.get(binding, options);\n  }\n\n  public delete(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl | undefined,\n  ) {\n    this.addWriteDep(binding);\n    return next?.delete(binding, options);\n  }\n}\n\n/** A data-model that tracks dependencies of read/written data */\nexport class DependencyModel<Options = DataModelOptions>\n  extends DependencyTracker\n  implements DataModelImpl<Options>\n{\n  private readonly rootModel: DataModelImpl<Options>;\n\n  constructor(rootModel: DataModelImpl<Options>) {\n    super();\n    this.rootModel = rootModel;\n    this.set = this.set.bind(this);\n    this.get = this.get.bind(this);\n  }\n\n  public set(transaction: BatchSetTransaction, options?: Options): Updates {\n    transaction.forEach(([binding]) => this.addWriteDep(binding));\n\n    return this.rootModel.set(transaction, options);\n  }\n\n  public get(binding: BindingInstance, options?: Options) {\n    this.addReadDep(binding);\n\n    return this.rootModel.get(binding, options);\n  }\n\n  public delete(binding: BindingInstance, options?: Options) {\n    this.addWriteDep(binding);\n    return this.rootModel.delete(binding, options);\n  }\n}\n","import type { DataModelImpl } from \"./model\";\n\n/**\n * A model that does nothing\n * Helpful for testing and other default DataModel applications\n */\nexport class NOOPDataModel implements DataModelImpl {\n  get() {\n    return undefined;\n  }\n\n  set() {\n    return [];\n  }\n\n  delete() {}\n}\n\n/** You only really need 1 instance of the NOOP model */\nexport const NOOP_MODEL = new NOOPDataModel();\n","import { SyncHook } from \"tapable-ts\";\nimport type { BindingLike, BindingFactory } from \"../binding\";\nimport { BindingInstance, isBinding } from \"../binding\";\nimport { NOOP_MODEL } from \"./noop-model\";\n\nexport const ROOT_BINDING = new BindingInstance([]);\nexport type BatchSetTransaction = [BindingInstance, any][];\n\nexport type Updates = Array<{\n  /** The updated binding */\n  binding: BindingInstance;\n\n  /** The old value */\n  oldValue: any;\n\n  /** The new value */\n  newValue: any;\n\n  /** Force the Update to be included even if no data changed */\n  force?: boolean;\n}>;\n\n/** Options to use when getting or setting data */\nexport interface DataModelOptions {\n  /**\n   * The data (either to set or get) should represent a formatted value\n   * For setting data, the data will be de-formatted before continuing in the pipeline\n   * For getting data, the data will be formatted before returning\n   */\n  formatted?: boolean;\n\n  /**\n   * By default, fetching data will ignore any invalid data.\n   * You can choose to grab the queued invalid data if you'd like\n   * This is usually the case for user-inputs\n   */\n  includeInvalid?: boolean;\n\n  /**\n   * A flag to set to ignore any default value in the schema, and just use the raw value\n   */\n  ignoreDefaultValue?: boolean;\n\n  /**\n   * A flag to indicate that this update should happen silently\n   */\n  silent?: boolean;\n\n  /** Other context associated with this request */\n  context?: {\n    /** The data model to use when getting other data from the context of this request */\n    model: DataModelWithParser;\n  };\n}\n\nexport interface DataModelWithParser<Options = DataModelOptions> {\n  get(binding: BindingLike, options?: Options): any;\n  set(transaction: [BindingLike, any][], options?: Options): Updates;\n  delete(binding: BindingLike, options?: Options): void;\n}\n\nexport interface DataModelImpl<Options = DataModelOptions> {\n  get(binding: BindingInstance, options?: Options): any;\n  set(transaction: BatchSetTransaction, options?: Options): Updates;\n  delete(binding: BindingInstance, options?: Options): void;\n}\n\nexport interface DataModelMiddleware {\n  /** The name of the middleware */\n  name?: string;\n\n  set(\n    transaction: BatchSetTransaction,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ): Updates;\n\n  get(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ): any;\n\n  delete?(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ): void;\n\n  reset?(): void;\n}\n\n/** Wrap the inputs of the DataModel with calls to parse raw binding inputs */\nexport function withParser<Options = unknown>(\n  model: DataModelImpl<Options>,\n  parseBinding: BindingFactory,\n): DataModelWithParser<Options> {\n  /** Parse something into a binding if it requires it */\n  function maybeParse(\n    binding: BindingLike,\n    readOnly: boolean,\n  ): BindingInstance {\n    const parsed = isBinding(binding)\n      ? binding\n      : parseBinding(binding, {\n          get: model.get,\n          set: model.set,\n          readOnly,\n        });\n\n    if (!parsed) {\n      throw new Error(\"Unable to parse binding\");\n    }\n\n    return parsed;\n  }\n\n  return {\n    get(binding, options?: Options) {\n      return model.get(maybeParse(binding, true), options);\n    },\n    set(transaction, options?: Options) {\n      return model.set(\n        transaction.map(([key, val]) => [maybeParse(key, false), val]),\n        options,\n      );\n    },\n    delete(binding, options?: Options) {\n      return model.delete(maybeParse(binding, false), options);\n    },\n  };\n}\n\n/** Wrap a middleware instance in a DataModel compliant API */\nexport function toModel(\n  middleware: DataModelMiddleware,\n  defaultOptions?: DataModelOptions,\n  next?: DataModelImpl,\n): DataModelImpl {\n  if (!next) {\n    return middleware as DataModelImpl;\n  }\n\n  return {\n    get: (binding: BindingInstance, options?: DataModelOptions) => {\n      const resolvedOptions = options ?? defaultOptions;\n\n      if (middleware.get) {\n        return middleware.get(binding, resolvedOptions, next);\n      }\n\n      return next?.get(binding, resolvedOptions);\n    },\n    set: (transaction: BatchSetTransaction, options?: DataModelOptions) => {\n      const resolvedOptions = options ?? defaultOptions;\n\n      if (middleware.set) {\n        return middleware.set(transaction, resolvedOptions, next);\n      }\n\n      return next?.set(transaction, resolvedOptions);\n    },\n    delete: (binding: BindingInstance, options?: DataModelOptions) => {\n      const resolvedOptions = options ?? defaultOptions;\n\n      if (middleware.delete) {\n        return middleware.delete(binding, resolvedOptions, next);\n      }\n\n      return next?.delete(binding, resolvedOptions);\n    },\n  };\n}\n\nexport type DataPipeline = Array<DataModelMiddleware | DataModelImpl>;\n\n/**\n * Given a set of steps in a pipeline, create the effective data-model\n */\nexport function constructModelForPipeline(\n  pipeline: DataPipeline,\n): DataModelImpl {\n  if (pipeline.length === 0) {\n    return NOOP_MODEL;\n  }\n\n  if (pipeline.length === 1) {\n    return toModel(pipeline[0]);\n  }\n\n  /** Default and propagate the options into the nested calls */\n  function createModelWithOptions(options?: DataModelOptions) {\n    const model: DataModelImpl =\n      pipeline.reduce<DataModelImpl | undefined>(\n        (nextModel, middleware) => toModel(middleware, options, nextModel),\n        undefined,\n      ) ?? NOOP_MODEL;\n\n    return model;\n  }\n\n  return {\n    get: (binding: BindingInstance, options?: DataModelOptions) => {\n      return createModelWithOptions(options)?.get(binding, options);\n    },\n    set: (transaction, options) => {\n      return createModelWithOptions(options)?.set(transaction, options);\n    },\n    delete: (binding, options) => {\n      return createModelWithOptions(options)?.delete(binding, options);\n    },\n  };\n}\n\n/** A DataModel that manages middleware data handlers  */\nexport class PipelinedDataModel implements DataModelImpl {\n  private pipeline: DataPipeline;\n  private effectiveDataModel: DataModelImpl;\n\n  public readonly hooks = {\n    onSet: new SyncHook<[BatchSetTransaction]>(),\n  };\n\n  constructor(pipeline: DataPipeline = []) {\n    this.pipeline = pipeline;\n    this.effectiveDataModel = constructModelForPipeline(this.pipeline);\n  }\n\n  public setMiddleware(handlers: DataPipeline) {\n    this.pipeline = handlers;\n    this.effectiveDataModel = constructModelForPipeline(handlers);\n  }\n\n  public addMiddleware(handler: DataModelMiddleware) {\n    this.pipeline = [...this.pipeline, handler];\n    this.effectiveDataModel = constructModelForPipeline(this.pipeline);\n  }\n\n  public reset(model = {}) {\n    this.pipeline.forEach((middleware) => {\n      if (\"reset\" in middleware) {\n        middleware.reset?.();\n      }\n    });\n\n    this.set([[ROOT_BINDING, model]]);\n  }\n\n  public set(\n    transaction: BatchSetTransaction,\n    options?: DataModelOptions,\n  ): Updates {\n    const appliedTransaction = this.effectiveDataModel.set(\n      transaction,\n      options,\n    );\n    this.hooks.onSet.call(transaction);\n    return appliedTransaction;\n  }\n\n  public get(binding: BindingInstance, options?: DataModelOptions): any {\n    return this.effectiveDataModel.get(binding, options);\n  }\n\n  public delete(binding: BindingInstance, options?: DataModelOptions): void {\n    return this.effectiveDataModel.delete(binding, options);\n  }\n}\n","export default function dlv(obj, key, def, p, undef) {\n\tkey = key.split ? key.split('.') : key;\n\tfor (p = 0; p < key.length; p++) {\n\t\tobj = obj ? obj[key[p]] : undef;\n\t}\n\treturn obj === undef ? def : obj;\n}\n","import get from \"dlv\";\nimport { setIn, omit, removeAt } from \"timm\";\nimport type { BindingInstance } from \"../binding\";\nimport type { BatchSetTransaction, DataModelImpl, Updates } from \"./model\";\n\n/**\n * A data model that stores data in an in-memory JS object\n */\nexport class LocalModel implements DataModelImpl {\n  public model: {\n    [key: string]: any;\n  };\n\n  constructor(model = {}) {\n    this.model = model;\n    this.get = this.get.bind(this);\n    this.set = this.set.bind(this);\n  }\n\n  public reset(model = {}) {\n    this.model = model;\n  }\n\n  public get(binding?: BindingInstance) {\n    if (!binding || !binding.asString()) {\n      return this.model;\n    }\n\n    return get(this.model, binding.asArray() as string[]);\n  }\n\n  public set(transaction: BatchSetTransaction) {\n    const effectiveOperations: Updates = [];\n    transaction.forEach(([binding, value]) => {\n      const oldValue = this.get(binding);\n      this.model = setIn(this.model, binding.asArray(), value) as any;\n      effectiveOperations.push({ binding, oldValue, newValue: value });\n    });\n    return effectiveOperations;\n  }\n\n  public delete(binding: BindingInstance) {\n    const parentBinding = binding.parent();\n\n    if (parentBinding) {\n      const parentValue = this.get(parentBinding);\n\n      if (parentValue !== undefined) {\n        if (Array.isArray(parentValue)) {\n          this.model = setIn(\n            this.model,\n            parentBinding.asArray(),\n            removeAt(parentValue, binding.key() as number),\n          ) as any;\n        } else {\n          this.model = setIn(\n            this.model,\n            parentBinding.asArray(),\n            omit(parentValue, binding.key() as string),\n          ) as any;\n        }\n      }\n    }\n  }\n}\n","import { SyncWaterfallHook, SyncBailHook } from \"tapable-ts\";\nimport { NestedError } from \"ts-nested-error\";\nimport { parseExpression } from \"./parser\";\nimport * as DEFAULT_EXPRESSION_HANDLERS from \"./evaluator-functions\";\nimport { isExpressionNode } from \"./types\";\nimport { isObjectExpression } from \"./utils\";\nimport type {\n  ExpressionNode,\n  BinaryOperator,\n  UnaryOperator,\n  ExpressionType,\n  ExpressionContext,\n  ExpressionHandler,\n} from \"./types\";\n\n/** a && b -- but handles short cutting if the first value is false */\nconst andandOperator: BinaryOperator = (ctx, a, b) => {\n  return ctx.evaluate(a) && ctx.evaluate(b);\n};\n\nandandOperator.resolveParams = false;\n\n/** a || b -- but with short cutting if first value is true */\nconst ororOperator: BinaryOperator = (ctx, a, b) => {\n  return ctx.evaluate(a) || ctx.evaluate(b);\n};\n\nororOperator.resolveParams = false;\n\nconst DEFAULT_BINARY_OPERATORS: Record<string, BinaryOperator> = {\n  // TODO: A lot of these functions used to do type coercion. Not sure if we want to keep that behavior or not.\n  \"+\": (a: any, b: any) => a + b,\n  \"-\": (a: any, b: any) => a - b,\n  \"*\": (a: any, b: any) => a * b,\n  \"/\": (a: any, b: any) => a / b,\n  \"%\": (a: any, b: any) => a % b,\n\n  // eslint-disable-next-line\n  \"==\": (a: any, b: any) => a == b,\n\n  // eslint-disable-next-line\n  \"!=\": (a: any, b: any) => a != b,\n  \">\": (a: any, b: any) => a > b,\n  \">=\": (a: any, b: any) => a >= b,\n  \"<\": (a: any, b: any) => a < b,\n  \"<=\": (a: any, b: any) => a <= b,\n  \"&&\": andandOperator,\n  \"||\": ororOperator,\n  \"!==\": (a: any, b: any) => a !== b,\n  \"===\": (a: any, b: any) => a === b,\n\n  // eslint-disable-next-line\n  \"|\": (a: any, b: any) => a | b,\n\n  // eslint-disable-next-line\n  \"&\": (a: any, b: any) => a & b,\n  \"+=\": (a: any, b: any) => a + b,\n  \"-=\": (a: any, b: any) => a - b,\n\n  // eslint-disable-next-line\n  \"&=\": (a: any, b: any) => a & b,\n\n  // eslint-disable-next-line\n  \"|=\": (a: any, b: any) => a | b,\n};\n\nconst DEFAULT_UNARY_OPERATORS: Record<string, UnaryOperator> = {\n  \"-\": (a: any) => -a,\n  \"+\": (a: any) => Number(a),\n  \"!\": (a: any) => !a,\n};\n\nexport interface HookOptions extends ExpressionContext {\n  /** Given an expression node  */\n  resolveNode: (node: ExpressionNode) => any;\n\n  /** Enabling this flag skips calling the onError hook, and just throws errors back to the caller.\n   * The caller is responsible for handling the error.\n   */\n  throwErrors?: boolean;\n\n  /** Whether expressions should be parsed strictly or not */\n  strict?: boolean;\n}\n\nexport type ExpressionEvaluatorOptions = Omit<\n  HookOptions,\n  \"resolveNode\" | \"evaluate\"\n>;\n\nexport type ExpressionEvaluatorFunction = (\n  exp: ExpressionType,\n  options?: ExpressionEvaluatorOptions,\n) => any;\n\n/**\n * The expression evaluator is responsible for parsing and executing anything in the custom expression language\n * */\nexport class ExpressionEvaluator {\n  private readonly vars: Record<string, any> = {};\n  public readonly hooks = {\n    /** Resolve an AST node for an expression to a value */\n    resolve: new SyncWaterfallHook<[any, ExpressionNode, HookOptions]>(),\n\n    /** Gets the options that will be passed in calls to the resolve hook */\n    resolveOptions: new SyncWaterfallHook<[HookOptions]>(),\n\n    /** Allows users to change the expression to be evaluated before processing */\n    beforeEvaluate: new SyncWaterfallHook<[ExpressionType, HookOptions]>(),\n\n    /**\n     * An optional means of handling an error in the expression execution\n     * Return true if handled, to stop propagation of the error\n     */\n    onError: new SyncBailHook<[Error], true>(),\n  };\n\n  private readonly expressionsCache: Map<string, ExpressionNode> = new Map();\n\n  private readonly defaultHookOptions: HookOptions;\n\n  public readonly operators = {\n    binary: new Map(Object.entries(DEFAULT_BINARY_OPERATORS)),\n    unary: new Map(Object.entries(DEFAULT_UNARY_OPERATORS)),\n    expressions: new Map<string, ExpressionHandler<any, any>>(\n      Object.entries(DEFAULT_EXPRESSION_HANDLERS),\n    ),\n  };\n\n  public reset(): void {\n    this.expressionsCache.clear();\n  }\n\n  constructor(defaultOptions: ExpressionEvaluatorOptions) {\n    this.defaultHookOptions = {\n      ...defaultOptions,\n      evaluate: (expr) => this.evaluate(expr, this.defaultHookOptions),\n      resolveNode: (node: ExpressionNode) =>\n        this._execAST(node, this.defaultHookOptions),\n    };\n\n    this.hooks.resolve.tap(\"ExpressionEvaluator\", this._resolveNode.bind(this));\n    this.evaluate = this.evaluate.bind(this);\n  }\n\n  public evaluate(\n    expr: ExpressionType,\n    options?: ExpressionEvaluatorOptions,\n  ): any {\n    const resolvedOpts = this.hooks.resolveOptions.call({\n      ...this.defaultHookOptions,\n      ...options,\n      resolveNode: (node: ExpressionNode) => this._execAST(node, resolvedOpts),\n    });\n\n    let expression = this.hooks.beforeEvaluate.call(expr, resolvedOpts) ?? expr;\n\n    // Unwrap any returned expression type\n    // Since this could also be an object type, we need to recurse through it until we find the end\n    while (isObjectExpression(expression)) {\n      expression = expression.value;\n    }\n\n    // Check for literals\n    if (\n      typeof expression === \"number\" ||\n      typeof expression === \"boolean\" ||\n      expression === undefined ||\n      expression === null\n    ) {\n      return expression;\n    }\n\n    // Skip doing anything with objects that are _actually_ just parsed expression nodes\n    if (isExpressionNode(expression)) {\n      return this._execAST(expression, resolvedOpts);\n    }\n\n    if (Array.isArray(expression)) {\n      return expression.reduce(\n        (_nothing, exp) => this.evaluate(exp, options),\n        null,\n      );\n    }\n\n    return this._execString(String(expression), resolvedOpts);\n  }\n\n  public addExpressionFunction<T extends readonly unknown[], R>(\n    name: string,\n    handler: ExpressionHandler<T, R>,\n  ): void {\n    this.operators.expressions.set(name, handler);\n  }\n\n  public addBinaryOperator(operator: string, handler: BinaryOperator) {\n    this.operators.binary.set(operator, handler);\n  }\n\n  public addUnaryOperator(operator: string, handler: UnaryOperator) {\n    this.operators.unary.set(operator, handler);\n  }\n\n  public setExpressionVariable(name: string, value: unknown) {\n    this.vars[name] = value;\n  }\n\n  public getExpressionVariable(name: string): unknown {\n    return this.vars[name];\n  }\n\n  private _execAST(node: ExpressionNode, options: HookOptions): any {\n    return this.hooks.resolve.call(undefined, node, options);\n  }\n\n  private _execString(exp: string, options: HookOptions) {\n    if (exp === \"\") {\n      return exp;\n    }\n\n    const matches = exp.match(/^@\\[(.*)\\]@$/);\n    let matchedExp = exp;\n\n    if (matches) {\n      [, matchedExp] = Array.from(matches); // In case the expression was surrounded by @[ ]@\n    }\n\n    let storedAST: ExpressionNode;\n\n    try {\n      storedAST =\n        this.expressionsCache.get(matchedExp) ??\n        parseExpression(matchedExp, { strict: options.strict });\n      this.expressionsCache.set(matchedExp, storedAST);\n    } catch (e: any) {\n      if (options.throwErrors || !this.hooks.onError.call(e)) {\n        // Only throw the error if it's not handled by the hook, or throwErrors is true\n        throw new NestedError(`Error parsing expression: ${exp}`, e);\n      }\n\n      return;\n    }\n\n    try {\n      return this._execAST(storedAST, options);\n    } catch (e: any) {\n      if (options.throwErrors || !this.hooks.onError.call(e)) {\n        // Only throw the error if it's not handled by the hook, or throwErrors is true\n        throw new NestedError(`Error evaluating expression: ${exp}`, e);\n      }\n    }\n  }\n\n  private _resolveNode(\n    _currentValue: any,\n    node: ExpressionNode,\n    options: HookOptions,\n  ) {\n    const { resolveNode, model } = options;\n\n    const expressionContext: ExpressionContext = {\n      ...options,\n      evaluate: (expr) => this.evaluate(expr, options),\n    };\n\n    if (node.type === \"Literal\") {\n      return node.value;\n    }\n\n    if (node.type === \"Identifier\") {\n      return this.vars[node.name];\n    }\n\n    if (node.type === \"Compound\" || node.type === \"ThisExpression\") {\n      throw new Error(`Expression type: ${node.type} is not supported`);\n    }\n\n    if (node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\") {\n      const operator = this.operators.binary.get(node.operator);\n\n      if (operator) {\n        if (\"resolveParams\" in operator) {\n          if (operator.resolveParams === false) {\n            return operator(expressionContext, node.left, node.right);\n          }\n\n          return operator(\n            expressionContext,\n            resolveNode(node.left),\n            resolveNode(node.right),\n          );\n        }\n\n        return operator(resolveNode(node.left), resolveNode(node.right));\n      }\n\n      return;\n    }\n\n    if (node.type === \"UnaryExpression\") {\n      const operator = this.operators.unary.get(node.operator);\n\n      if (operator) {\n        if (\"resolveParams\" in operator) {\n          return operator(\n            expressionContext,\n            operator.resolveParams === false\n              ? node.argument\n              : resolveNode(node.argument),\n          );\n        }\n\n        return operator(resolveNode(node.argument));\n      }\n\n      return;\n    }\n\n    if (node.type === \"Object\") {\n      const { attributes } = node;\n      const resolvedAttributes: any = {};\n\n      attributes.forEach((attr) => {\n        const key = resolveNode(attr.key);\n        const value = resolveNode(attr.value);\n        resolvedAttributes[key] = value;\n      });\n\n      return resolvedAttributes;\n    }\n\n    if (node.type === \"CallExpression\") {\n      const expressionName = node.callTarget.name;\n\n      const operator = this.operators.expressions.get(expressionName);\n\n      if (!operator) {\n        throw new Error(`Unknown expression function: ${expressionName}`);\n      }\n\n      if (\"resolveParams\" in operator && operator.resolveParams === false) {\n        return operator(expressionContext, ...node.args);\n      }\n\n      const args = node.args.map((n) => resolveNode(n));\n\n      return operator(expressionContext, ...args);\n    }\n\n    if (node.type === \"ModelRef\") {\n      return model.get(node.ref, { context: { model: options.model } });\n    }\n\n    if (node.type === \"MemberExpression\") {\n      const obj = resolveNode(node.object);\n      const prop = resolveNode(node.property);\n\n      return obj[prop];\n    }\n\n    if (node.type === \"Assignment\") {\n      if (node.left.type === \"ModelRef\") {\n        const value = resolveNode(node.right);\n        model.set([[node.left.ref, value]]);\n\n        return value;\n      }\n\n      if (node.left.type === \"Identifier\") {\n        const value = resolveNode(node.right);\n        this.vars[node.left.name] = value;\n        return value;\n      }\n\n      return;\n    }\n\n    if (node.type === \"ConditionalExpression\") {\n      const result = resolveNode(node.test) ? node.consequent : node.alternate;\n\n      return resolveNode(result);\n    }\n\n    if (node.type === \"ArrayExpression\") {\n      return node.elements.map((ele) => resolveNode(ele));\n    }\n\n    if (node.type === \"Modification\") {\n      const operation = this.operators.binary.get(node.operator);\n\n      if (operation) {\n        let newValue;\n\n        if (\"resolveParams\" in operation) {\n          if (operation.resolveParams === false) {\n            newValue = operation(expressionContext, node.left, node.right);\n          } else {\n            newValue = operation(\n              expressionContext,\n              resolveNode(node.left),\n              resolveNode(node.right),\n            );\n          }\n        } else {\n          newValue = operation(resolveNode(node.left), resolveNode(node.right));\n        }\n\n        if (node.left.type === \"ModelRef\") {\n          model.set([[node.left.ref, newValue]]);\n        } else if (node.left.type === \"Identifier\") {\n          this.vars[node.left.name] = newValue;\n        }\n\n        return newValue;\n      }\n\n      return resolveNode(node.left);\n    }\n  }\n}\n","import type { DataModelWithParser } from \"../data\";\nimport type { Logger } from \"../logger\";\n\nexport type ExpressionObjectType = {\n  /** The expression to eval */\n  value: BasicExpressionTypes;\n};\n\nexport type ExpressionLiteralType =\n  | string\n  | number\n  | boolean\n  | undefined\n  | null;\n\nexport type BasicExpressionTypes =\n  | ExpressionLiteralType\n  | ExpressionObjectType\n  | Array<ExpressionLiteralType | ExpressionObjectType>;\n\nexport type ExpressionType = BasicExpressionTypes | ExpressionNode;\n\nexport interface OperatorProcessingOptions {\n  /**\n   * When set to a falsy value, the arguments passed to the handler will be raw AST Nodes\n   * This enables lazy evaluation of arguments\n   */\n  resolveParams: boolean;\n}\n\nexport type BinaryOperatorBasic = (left: any, right: any) => unknown;\nexport type BinaryOperatorAdvanced = OperatorProcessingOptions &\n  ((ctx: ExpressionContext, left: any, right: any) => unknown);\n\nexport type BinaryOperator = BinaryOperatorAdvanced | BinaryOperatorBasic;\n\nexport type UnaryOperator =\n  | ((arg: any) => unknown)\n  | (((ctx: ExpressionContext, arg: any) => unknown) &\n      OperatorProcessingOptions);\n\nexport interface ExpressionContext {\n  /** A means of executing an expression */\n  evaluate: (expr: ExpressionType) => unknown;\n\n  /** The data model that expression handlers can use when fetching data */\n  model: DataModelWithParser;\n\n  /** A logger to use */\n  logger?: Logger;\n}\n\nexport type ExpressionHandler<\n  T extends readonly unknown[] = unknown[],\n  R = void,\n> = ((context: ExpressionContext, ...args: T) => R) &\n  Partial<OperatorProcessingOptions>;\n\nexport const ExpNodeOpaqueIdentifier = Symbol(\"Expression Node ID\");\n\n/** Checks if the input is an already processed Expression node */\nexport function isExpressionNode(x: any): x is ExpressionNode {\n  return (\n    typeof x === \"object\" &&\n    x !== null &&\n    !Array.isArray(x) &&\n    x.__id === ExpNodeOpaqueIdentifier\n  );\n}\n\nexport interface NodePosition {\n  /** The character location */\n  character: number;\n}\n\nexport interface NodeLocation {\n  // We only care about the character offset, not the line/column for now\n  // But making these objects allows us to add more (like line number) later\n\n  /** The start of the node */\n  start: NodePosition;\n\n  /** The end of the node */\n  end: NodePosition;\n}\n\nexport interface BaseNode<T> {\n  /** The thing to discriminate the AST type on */\n  type: T;\n\n  /** How to tell this apart from other objects */\n  __id: typeof ExpNodeOpaqueIdentifier;\n\n  /** The location of the node in the source expression string */\n  location?: NodeLocation;\n\n  /**\n   * The error that occurred while parsing this node\n   * This is only set if the parsing mode is set to non-strict\n   */\n  error?: Error;\n}\n\n/** A helper interface for nodes that container left and right children */\nexport interface DirectionalNode {\n  /** The left node. Often for the left hand side of an expression */\n  left: ExpressionNode;\n\n  /** The right child. Often for the right hand side of an expression */\n  right: ExpressionNode;\n}\n\nexport interface LiteralNode extends BaseNode<\"Literal\"> {\n  /** A node that holds a literal value */\n  value: string | number;\n\n  /** The unprocessed value */\n  raw?: any;\n}\n\nexport interface BinaryNode\n  extends BaseNode<\"BinaryExpression\">,\n    DirectionalNode {\n  /** The operation to perform on the nodes */\n  operator: string;\n}\n\nexport interface LogicalNode\n  extends BaseNode<\"LogicalExpression\">,\n    DirectionalNode {\n  /** The logical operation to perform on the nodes */\n  operator: string;\n}\n\nexport interface UnaryNode extends BaseNode<\"UnaryExpression\"> {\n  /** The operation to perform on the node */\n  operator: string;\n\n  /** The single argument that the operation should be performed on */\n  argument: ExpressionNode;\n}\n\nexport type ThisNode = BaseNode<\"ThisExpression\">;\n\nexport interface ModelRefNode extends BaseNode<\"ModelRef\"> {\n  /** The binding that the model reference points to */\n  ref: string;\n}\n\nexport interface ObjectNode extends BaseNode<\"Object\"> {\n  /**  */\n  attributes: Array<{\n    /** The property name of the object */\n    key: ExpressionNode;\n\n    /** the associated value */\n    value: ExpressionNode;\n  }>;\n}\n\nexport interface MemberExpressionNode extends BaseNode<\"MemberExpression\"> {\n  /** The object to be introspected */\n  object: ExpressionNode;\n\n  /** If the property uses . or open-bracket */\n  computed: boolean;\n\n  /** The property to access on the object */\n  property: ExpressionNode;\n}\n\nexport interface ConditionalExpressionNode\n  extends BaseNode<\"ConditionalExpression\"> {\n  /** The test for the ternary */\n  test: ExpressionNode;\n\n  /** The truthy case for the ternary */\n  consequent: ExpressionNode;\n\n  /** The falsy case for the ternary */\n  alternate: ExpressionNode;\n}\n\nexport interface CompoundNode extends BaseNode<\"Compound\"> {\n  /** The contents of the compound expression */\n  body: ExpressionNode[];\n}\n\nexport interface CallExpressionNode extends BaseNode<\"CallExpression\"> {\n  /** The arguments to the function */\n  args: ExpressionNode[];\n\n  /** The function name */\n  callTarget: IdentifierNode;\n}\n\nexport interface ArrayExpressionNode extends BaseNode<\"ArrayExpression\"> {\n  /** The items in an array */\n  elements: ExpressionNode[];\n}\n\nexport interface IdentifierNode extends BaseNode<\"Identifier\"> {\n  /** The variable name */\n  name: string;\n}\n\nexport type AssignmentNode = BaseNode<\"Assignment\"> & DirectionalNode;\n\nexport interface ModificationNode\n  extends BaseNode<\"Modification\">,\n    DirectionalNode {\n  /** The operator for the modification */\n  operator: string;\n}\n\nexport type ExpressionNode =\n  | LiteralNode\n  | BinaryNode\n  | LogicalNode\n  | UnaryNode\n  | ThisNode\n  | ModelRefNode\n  | MemberExpressionNode\n  | ConditionalExpressionNode\n  | CompoundNode\n  | CallExpressionNode\n  | ArrayExpressionNode\n  | IdentifierNode\n  | AssignmentNode\n  | ModificationNode\n  | ObjectNode;\n\nexport type ExpressionNodeType = ExpressionNode[\"type\"];\n\nexport interface ErrorWithLocation extends Error {\n  /** The place in the string where the error occurs */\n  index: number;\n\n  /** a helpful description */\n  description: string;\n}\n","/* eslint @typescript-eslint/no-use-before-define: 0 */\n/**\n * An expression to AST parser based on JSEP: http://jsep.from.so/\n */\nimport type {\n  ErrorWithLocation,\n  ExpressionNode,\n  ExpressionNodeType,\n  NodeLocation,\n} from \"./types\";\nimport { ExpNodeOpaqueIdentifier } from \"./types\";\n\nconst PERIOD_CODE = 46; // '.'\nconst COMMA_CODE = 44; // ','\nconst SQUOTE_CODE = 39; // Single quote\nconst DQUOTE_CODE = 34; // Double quotes\nconst OPAREN_CODE = 40; // (\nconst CPAREN_CODE = 41; // )\nconst OBRACK_CODE = 91; // [\nconst CBRACK_CODE = 93; // ]\nconst QUMARK_CODE = 63; // ?\nconst SEMCOL_CODE = 59; // ;\nconst COLON_CODE = 58; // :\nconst OCURL_CODE = 123; // {\nconst CCURL_CODE = 125; // }\n\n// Operations\n// ----------\n\n// Set `t` to `true` to save space (when minified, not gzipped)\nconst t = true;\n\n// Use a quickly-accessible map to store all of the unary operators\n// Values are set to `true` (it really doesn't matter)\nconst unaryOps = { \"-\": t, \"!\": t, \"~\": t, \"+\": t };\n\n// Also use a map for the binary operations but set their values to their\n// binary precedence for quick reference:\n// see [Operator precedence](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\nconst binaryOps: Record<string, number> = {\n  \"=\": 3,\n  \"+=\": 3,\n  \"-=\": 3,\n  \"&=\": 3,\n  \"|=\": 3,\n  // Conditional: 4,\n  \"||\": 5,\n  \"&&\": 6,\n  \"|\": 7,\n  \"^\": 8,\n  \"&\": 9,\n  \"==\": 10,\n  \"!=\": 10,\n  \"===\": 10,\n  \"!==\": 10,\n  \"<\": 11,\n  \">\": 11,\n  \"<=\": 11,\n  \">=\": 11,\n  \"<<\": 12,\n  \">>\": 12,\n  \">>>\": 12,\n  \"+\": 13,\n  \"-\": 13,\n  \"*\": 14,\n  \"/\": 14,\n  \"%\": 14,\n};\n\n/** Wrap the message and index in an error and throw it */\nfunction throwError(message: string, index: number): ErrorWithLocation {\n  const err = new Error(`${message} at character ${index}`);\n\n  (err as ErrorWithLocation).index = index;\n  (err as ErrorWithLocation).description = message;\n\n  throw err;\n}\n\n/** Create a new location marker that spans both nodes */\nfunction createSpanningLocation(start?: NodeLocation, end?: NodeLocation) {\n  if (!start || !end) {\n    return;\n  }\n\n  return {\n    start: start.start,\n    end: end.end,\n  };\n}\n\n/** Get return the longest key length of any object */\nfunction getMaxKeyLen(obj: object): number {\n  let maxLen = 0;\n\n  Object.keys(obj).forEach((key) => {\n    if (key.length > maxLen && Object.prototype.hasOwnProperty.call(obj, key)) {\n      maxLen = key.length;\n    }\n  });\n\n  return maxLen;\n}\n\nconst maxUnopLen = getMaxKeyLen(unaryOps);\nconst maxBinopLen = getMaxKeyLen(binaryOps);\n\n// Literals\n// ----------\n// Store the values to return for the various literals we may encounter\nconst literals = {\n  true: true,\n  false: false,\n  null: null,\n  undefined,\n} as const;\n\n// Except for `this`, which is special. This could be changed to something like `'self'` as well\nconst thisStr = \"this\";\n\n/** Returns the precedence of a binary operator or `0` if it isn't a binary operator */\nfunction binaryPrecedence(opVal: string): number {\n  return binaryOps[opVal] || 0;\n}\n\n/**\n * Utility function (gets called from multiple places)\n * Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions\n */\nfunction createBinaryExpression(\n  operator: string | boolean,\n  left: string,\n  right: string,\n  location?: NodeLocation,\n) {\n  let type: ExpressionNodeType;\n\n  if (operator === \"||\" || operator === \"&&\") {\n    type = \"LogicalExpression\";\n  } else if (operator === \"=\") {\n    type = \"Assignment\";\n  } else if (\n    operator === \"+=\" ||\n    operator === \"-=\" ||\n    operator === \"&=\" ||\n    operator === \"|=\"\n  ) {\n    type = \"Modification\";\n  } else {\n    type = \"BinaryExpression\";\n  }\n\n  return {\n    __id: ExpNodeOpaqueIdentifier,\n    type,\n    operator,\n    left,\n    right,\n    location,\n  };\n}\n\n/** `ch` is a character code in the next three functions */\nfunction isDecimalDigit(ch: number) {\n  return ch >= 48 && ch <= 57; // 0...9\n}\n\n/** Check if the char is the character code for the start of an identifier */\nfunction isIdentifierStart(ch: number) {\n  return (\n    ch === 36 ||\n    ch === 95 || // `$` and `_`\n    (ch >= 65 && ch <= 90) || // A...Z\n    (ch >= 97 && ch <= 122)\n  ); // A...z\n}\n\n/** Check if the char code is still a valid identifier portion */\nfunction isIdentifierPart(ch: number) {\n  return (\n    ch === 36 ||\n    ch === 95 || // `$` and `_`\n    (ch >= 65 && ch <= 90) || // A...Z\n    (ch >= 97 && ch <= 122) || // A...z\n    (ch >= 48 && ch <= 57)\n  ); // 0...9\n}\n\n/** Check if the 2 chars are the start of a model reference */\nfunction isModelRefStart(ch0: number, ch1: number) {\n  return ch0 === OCURL_CODE && ch1 === OCURL_CODE; // '{{'\n}\n\n/** Parse out an expression from the string */\nexport function parseExpression(\n  expr: string,\n  options?: {\n    /** If true (the default), will throw on invalid expressions */\n    strict?: boolean;\n  },\n): ExpressionNode {\n  const strictMode = options?.strict ?? true;\n\n  // `index` stores the character number we are currently at while `length` is a constant\n  // All of the gobbles below will modify `index` as we move along\n  const charAtFunc = expr.charAt;\n  const charCodeAtFunc = expr.charCodeAt;\n  const { length } = expr;\n\n  let index = 0;\n\n  /** Create a location object  */\n  const getLocation = (startChar: number) => {\n    return {\n      start: {\n        character: startChar,\n      },\n      end: {\n        character: index,\n      },\n    };\n  };\n\n  /** Grab the char at the index from the expression */\n  function exprI(i: number) {\n    return charAtFunc.call(expr, i);\n  }\n\n  /** Grab the unicode char at the index in the expression */\n  function exprICode(i: number) {\n    return charCodeAtFunc.call(expr, i);\n  }\n\n  /**\n   * Gobble an object and store the object in an attributes array\n   */\n  function gobbleObjects() {\n    const attributes: Array<{\n      /** The property name of the object */\n      key: any;\n\n      /** the associated value */\n      value: any;\n    }> = [];\n    let closed = false;\n\n    let shouldDefineKey = true;\n    let key;\n    let value;\n    let chCode;\n    const startCharIndex = index;\n\n    // get rid of OCURL_CODE\n    ++index;\n\n    while (index < length) {\n      gobbleSpaces();\n      chCode = exprICode(index);\n      // check for end\n      if (chCode === CCURL_CODE) {\n        // if we are at the end but a key was defined\n        if (key) {\n          throwError(\"A key was defined but a value was not\", index);\n        }\n\n        index++;\n        closed = true;\n        break;\n      } else if (shouldDefineKey) {\n        // check for key\n        if (chCode !== SQUOTE_CODE && chCode !== DQUOTE_CODE) {\n          throwError(\"An object must start wtih a key\", index);\n        }\n\n        // get key\n        key = gobbleStringLiteral();\n        // remove spaces\n        gobbleSpaces();\n        // remove colon\n        if (exprICode(index) === COLON_CODE) {\n          index++;\n          shouldDefineKey = false;\n        } else {\n          throwError(\"A colon must follow an object key\", index);\n        }\n      } else {\n        value = gobbleExpression();\n\n        attributes.push({ key, value });\n        gobbleSpaces();\n        chCode = exprICode(index);\n        if (chCode === COMMA_CODE) {\n          index++;\n        } else if (chCode !== CCURL_CODE) {\n          throwError(\"Please add a comma to add another key\", index);\n        }\n\n        shouldDefineKey = true;\n        key = undefined;\n        value = undefined;\n      }\n\n      chCode = exprICode(index);\n    }\n\n    // throw error if object is not closed\n    if (!closed) {\n      throwError(`Unclosed brace in object`, index);\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Object\",\n      attributes,\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  /**\n   * Push `index` up to the next non-space character\n   */\n  function gobbleSpaces() {\n    let ch = exprICode(index);\n    // Space or tab\n    while (ch === 32 || ch === 9) {\n      ch = exprICode(++index);\n    }\n  }\n\n  /**\n   * The main parsing function. Much of this code is dedicated to ternary expressions\n   */\n  function gobbleExpression(): ExpressionNode {\n    const test = gobbleBinaryExpression();\n    gobbleSpaces();\n    const startCharIndex = index;\n\n    if (index < length && exprICode(index) === QUMARK_CODE) {\n      // Ternary expression: test ? consequent : alternate\n      index++;\n      const consequent = gobbleExpression();\n\n      if (!consequent) {\n        throwError(\"Expected expression\", index);\n      }\n\n      gobbleSpaces();\n\n      if (exprICode(index) === COLON_CODE) {\n        index++;\n        const alternate = gobbleExpression();\n\n        if (!alternate) {\n          throwError(\"Expected expression\", index);\n        }\n\n        return {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"ConditionalExpression\",\n          test,\n          consequent,\n          alternate,\n          location: getLocation(startCharIndex),\n        };\n      }\n\n      throwError(\"Expected :\", index);\n    }\n\n    return test;\n  }\n\n  /**\n   * Search for the operation portion of the string (e.g. `+`, `===`)\n   * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n   * and move down from 3 to 2 to 1 character until a matching binary operation is found\n   * then, return that binary operation\n   */\n  function gobbleBinaryOp() {\n    gobbleSpaces();\n\n    let toCheck = expr.substr(index, maxBinopLen);\n    let tcLen = toCheck.length;\n\n    while (tcLen > 0) {\n      if (Object.prototype.hasOwnProperty.call(binaryOps, toCheck)) {\n        index += tcLen;\n        return toCheck;\n      }\n\n      toCheck = toCheck.substr(0, --tcLen);\n    }\n\n    return false;\n  }\n\n  /**\n   * This function is responsible for gobbling an individual expression,\n   * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n   */\n  function gobbleBinaryExpression() {\n    let node;\n    let prec;\n    let i;\n\n    // First, try to get the leftmost thing\n    // Then, check to see if there's a binary operator operating on that leftmost thing\n    let left = gobbleToken();\n    let biop = gobbleBinaryOp();\n\n    // If there wasn't a binary operator, just return the leftmost node\n    if (!biop) {\n      return left;\n    }\n\n    // Otherwise, we need to start a stack to properly place the binary operations in their\n    // precedence structure\n    let biopInfo = { value: biop, prec: binaryPrecedence(biop) };\n    let right = gobbleToken();\n\n    if (!right) {\n      throwError(`Expected expression after ${biop}`, index);\n    }\n\n    const stack = [left, biopInfo, right];\n\n    // Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n    biop = gobbleBinaryOp();\n    while (biop) {\n      prec = binaryPrecedence(biop);\n\n      if (prec === 0) {\n        break;\n      }\n\n      biopInfo = { value: biop, prec };\n\n      // Reduce: make a binary expression from the three topmost entries.\n      while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n        right = stack.pop();\n        biop = stack.pop().value;\n        left = stack.pop();\n        node = createBinaryExpression(\n          biop,\n          left,\n          right,\n          createSpanningLocation(left.location, right.location),\n        );\n        stack.push(node);\n      }\n\n      node = gobbleToken();\n\n      if (!node) {\n        throwError(`Expected expression after ${biop}`, index);\n      }\n\n      stack.push(biopInfo, node);\n      biop = gobbleBinaryOp();\n    }\n\n    i = stack.length - 1;\n    node = stack[i];\n\n    while (i > 1) {\n      node = createBinaryExpression(\n        stack[i - 1].value,\n        stack[i - 2],\n        node,\n        createSpanningLocation(stack[i - 2].location, node.location),\n      );\n      i -= 2;\n    }\n\n    return node;\n  }\n\n  /**\n   * An individual part of a binary expression:\n   * e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n   */\n  function gobbleToken(): any {\n    gobbleSpaces();\n    const ch = exprICode(index);\n    const startCharIndex = index;\n\n    if (isDecimalDigit(ch) || ch === PERIOD_CODE) {\n      // Char code 46 is a dot `.` which can start off a numeric literal\n      return gobbleNumericLiteral();\n    }\n\n    if (ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\n      // Single or double quotes\n      return gobbleStringLiteral();\n    }\n\n    if (isIdentifierStart(ch) || ch === OPAREN_CODE) {\n      // Open parenthesis\n      // `foo`, `bar.baz`\n      return gobbleVariable();\n    }\n\n    if (ch === OBRACK_CODE) {\n      return gobbleArray();\n    }\n\n    if (isModelRefStart(ch, exprICode(index + 1))) {\n      return gobbleModelRef();\n    }\n\n    // not a double bracket: {{}} but if its a single {}\n    if (ch === OCURL_CODE) {\n      return gobbleObjects();\n    }\n\n    let toCheck = expr.substr(index, maxUnopLen);\n    let tcLen = toCheck.length;\n\n    while (tcLen > 0) {\n      if (Object.prototype.hasOwnProperty.call(unaryOps, toCheck)) {\n        index += tcLen;\n        return {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"UnaryExpression\",\n          operator: toCheck,\n          argument: gobbleToken(),\n          prefix: true,\n          location: getLocation(startCharIndex),\n        };\n      }\n\n      toCheck = toCheck.substr(0, --tcLen);\n    }\n\n    return false;\n  }\n\n  /**\n   * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n   * keep track of everything in the numeric literal and then calling `parseFloat` on that string\n   */\n  function gobbleNumericLiteral() {\n    let num = \"\";\n    const startCharIndex = index;\n\n    while (isDecimalDigit(exprICode(index))) {\n      num += exprI(index++);\n    }\n\n    if (exprICode(index) === PERIOD_CODE) {\n      // Can start with a decimal marker\n      num += exprI(index++);\n\n      while (isDecimalDigit(exprICode(index))) {\n        num += exprI(index++);\n      }\n    }\n\n    let ch = exprI(index);\n    if (ch === \"e\" || ch === \"E\") {\n      // Exponent marker\n      num += exprI(index++);\n      ch = exprI(index);\n\n      if (ch === \"+\" || ch === \"-\") {\n        // Exponent sign\n        num += exprI(index++);\n      }\n\n      while (isDecimalDigit(exprICode(index))) {\n        // Exponent itself\n        num += exprI(index++);\n      }\n\n      if (!isDecimalDigit(exprICode(index - 1))) {\n        throwError(`Expected exponent (${num}${exprI(index)})`, index);\n      }\n    }\n\n    const chCode = exprICode(index);\n    // Check to make sure this isn't a variable name that start with a number (123abc)\n    if (isIdentifierStart(chCode)) {\n      throwError(\n        `Variable names cannot start with a number (${num}${exprI(index)})`,\n        index,\n      );\n    } else if (chCode === PERIOD_CODE) {\n      throwError(\"Unexpected period\", index);\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Literal\",\n      value: parseFloat(num),\n      raw: num,\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  /**\n   * Parses a string literal, staring with single or double quotes with basic support for escape codes\n   * e.g. `\"hello world\"`, `'this is\\nJSEP'`\n   */\n  function gobbleStringLiteral() {\n    const quote = exprI(index++);\n    let str = \"\";\n    let closed = false;\n    const startCharIndex = index;\n\n    while (index < length) {\n      let ch = exprI(index++);\n\n      if (ch === quote) {\n        closed = true;\n        break;\n      }\n\n      if (ch !== \"\\\\\") {\n        str += ch;\n        continue;\n      }\n\n      // Check for all of the common escape codes\n      ch = exprI(index++);\n\n      switch (ch) {\n        case \"n\":\n          str += \"\\n\";\n          break;\n        case \"r\":\n          str += \"\\r\";\n          break;\n        case \"t\":\n          str += \"\\t\";\n          break;\n        case \"b\":\n          str += \"\\b\";\n          break;\n        case \"f\":\n          str += \"\\f\";\n          break;\n        case \"v\":\n          str += \"\\u000B\";\n          break;\n        default:\n      }\n    }\n\n    if (!closed) {\n      throwError(`Unclosed quote after \"${str}\"`, index);\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Literal\",\n      value: str,\n      raw: `${quote}${str}${quote}`,\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  /**\n   * Model refs are bindings wrapped in 2 sets of double curlys\n   * e.g. {{foo.bar.ref}}\n   */\n  function gobbleModelRef() {\n    let str = \"\";\n    let closed = false;\n    let openBraceCount = 1;\n    const startCharIndex = index;\n\n    index += 2; // Skip the {{\n    while (index < length) {\n      const ch = exprI(index++);\n\n      if (ch === \"}\" && exprICode(index) === CCURL_CODE) {\n        index++;\n        openBraceCount--;\n\n        if (openBraceCount === 0) {\n          closed = true;\n          break;\n        }\n\n        str += \"}}\";\n      } else if (ch === \"{\" && exprICode(index) === OCURL_CODE) {\n        openBraceCount++;\n        str += \"{{\";\n        index++;\n      } else {\n        str += ch;\n      }\n    }\n\n    if (!closed) {\n      throwError(`Unclosed brace after \"${str}\"`, index);\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"ModelRef\",\n      ref: str,\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  /**\n   * Gobbles only identifiers\n   * e.g.: `foo`, `_value`, `$x1`\n   * Also, this function checks if that identifier is a literal:\n   * (e.g. `true`, `false`, `null`) or `this`\n   */\n  function gobbleIdentifier() {\n    const start = index;\n    let ch = exprICode(start);\n\n    if (isIdentifierStart(ch)) {\n      index++;\n    } else {\n      throwError(`Unexpected ${exprI(index)}`, index);\n    }\n\n    while (index < length) {\n      ch = exprICode(index);\n      if (isIdentifierPart(ch)) {\n        index++;\n      } else {\n        break;\n      }\n    }\n\n    const identifier = expr.slice(start, index);\n\n    if (Object.prototype.hasOwnProperty.call(literals, identifier)) {\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Literal\",\n        value: (literals as any)[identifier],\n        raw: identifier,\n        location: getLocation(start),\n      };\n    }\n\n    if (identifier === thisStr) {\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"ThisExpression\",\n        location: getLocation(start),\n      };\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Identifier\",\n      name: identifier,\n      location: getLocation(start),\n    };\n  }\n\n  /**\n   * Gobbles a list of arguments within the context of a function call\n   * or array literal. This function also assumes that the opening character\n   * `(` or `[` has already been gobbled, and gobbles expressions and commas\n   * until the terminator character `)` or `]` is encountered.\n   * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n   */\n  function gobbleArguments(termination: number) {\n    const args = [];\n    let charIndex;\n    let node;\n\n    while (index < length) {\n      gobbleSpaces();\n      charIndex = exprICode(index);\n\n      if (charIndex === termination) {\n        // Done parsing\n        index++;\n        break;\n      }\n\n      if (charIndex === COMMA_CODE) {\n        // Between expressions\n        index++;\n        continue;\n      }\n\n      node = gobbleExpression();\n\n      if (!node || node.type === \"Compound\") {\n        throwError(\"Expected comma\", index);\n      }\n\n      args.push(node);\n    }\n\n    if (strictMode && charIndex !== termination) {\n      throwError(`Expected ${String.fromCharCode(termination)}`, index);\n    }\n\n    return args;\n  }\n\n  /**\n   * Gobble a non-literal variable name. This variable name may include properties\n   * e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n   * It also gobbles function calls:\n   * e.g. `Math.acos(obj.angle)`\n   */\n  function gobbleVariable(): ExpressionNode {\n    let charIndex = exprICode(index);\n    let node: any =\n      charIndex === OPAREN_CODE ? gobbleGroup() : gobbleIdentifier();\n    const startCharIndex = index;\n    gobbleSpaces();\n    charIndex = exprICode(index);\n\n    while (\n      charIndex === PERIOD_CODE ||\n      charIndex === OBRACK_CODE ||\n      charIndex === OPAREN_CODE\n    ) {\n      index++;\n\n      if (charIndex === PERIOD_CODE) {\n        gobbleSpaces();\n\n        node = {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"MemberExpression\",\n          computed: false,\n          object: node,\n          property: gobbleIdentifier(),\n          location: getLocation(startCharIndex),\n        };\n      } else if (charIndex === OBRACK_CODE) {\n        node = {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"MemberExpression\",\n          computed: true,\n          object: node,\n          property: gobbleExpression(),\n          location: getLocation(startCharIndex),\n        };\n\n        gobbleSpaces();\n        charIndex = exprICode(index);\n\n        if (charIndex !== CBRACK_CODE) {\n          throwError(\"Unclosed [\", index);\n        }\n\n        index++;\n      } else if (charIndex === OPAREN_CODE) {\n        // A function call is being made; gobble all the arguments\n        node = {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"CallExpression\",\n          args: gobbleArguments(CPAREN_CODE),\n          callTarget: node,\n          location: getLocation(startCharIndex),\n        };\n      }\n\n      gobbleSpaces();\n      charIndex = exprICode(index);\n    }\n\n    return node;\n  }\n\n  /**\n   * Responsible for parsing a group of things within parentheses `()`\n   * This function assumes that it needs to gobble the opening parenthesis\n   * and then tries to gobble everything within that parenthesis, assuming\n   * that the next thing it should see is the close parenthesis. If not,\n   * then the expression probably doesn't have a `)`\n   */\n  function gobbleGroup() {\n    index++;\n    const node = gobbleExpression();\n    gobbleSpaces();\n\n    if (exprICode(index) === CPAREN_CODE) {\n      index++;\n      return node;\n    }\n\n    throwError(\"Unclosed (\", index);\n  }\n\n  /**\n   * Responsible for parsing Array literals `[1, 2, 3]`\n   * This function assumes that it needs to gobble the opening bracket\n   * and then tries to gobble the expressions as arguments.\n   */\n  function gobbleArray() {\n    const startCharIndex = index;\n    index++;\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"ArrayExpression\",\n      elements: gobbleArguments(CBRACK_CODE),\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  const nodes = [];\n\n  try {\n    while (index < length) {\n      const chIndex = exprICode(index);\n\n      // Expressions can be separated by semicolons, commas, or just inferred without any\n      // separators\n      if (chIndex === SEMCOL_CODE || chIndex === COMMA_CODE) {\n        index++; // ignore separators\n        continue;\n      }\n\n      const node = gobbleExpression();\n\n      // Try to gobble each expression individually\n      if (node) {\n        nodes.push(node);\n        // If we weren't able to find a binary expression and are out of room, then\n        // the expression passed in probably has too much\n      } else if (strictMode && index < length) {\n        throwError(`Unexpected \"${exprI(index)}\"`, index);\n      }\n    }\n\n    // If there's only one expression just try returning the expression\n    if (nodes.length === 1) {\n      return nodes[0];\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Compound\",\n      body: nodes,\n      location: getLocation(0),\n    };\n  } catch (e) {\n    if (strictMode || !(e instanceof Error)) {\n      throw e;\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Compound\",\n      body: nodes,\n      location: getLocation(0),\n      error: e,\n    };\n  }\n}\n","import type { Binding } from \"@player-ui/types\";\n\nimport type { BindingLike } from \"../binding\";\nimport type {\n  ExpressionHandler,\n  ExpressionContext,\n  ExpressionNode,\n} from \"./types\";\n\n/** Sets a value to the data-model */\nexport const setDataVal: ExpressionHandler<[Binding, any], any> = (\n  _context: ExpressionContext,\n  binding,\n  value,\n) => {\n  _context.model.set([[binding as BindingLike, value]]);\n};\n\n/** Fetches a valid from the data-model */\nexport const getDataVal: ExpressionHandler<[Binding], unknown> = (\n  _context: ExpressionContext,\n  binding,\n) => {\n  return _context.model.get(binding as BindingLike);\n};\n\n/** Deletes a value from the model */\nexport const deleteDataVal: ExpressionHandler<[Binding], void> = (\n  _context: ExpressionContext,\n  binding,\n) => {\n  return _context.model.delete(binding);\n};\n\n/** Conditional expression handler */\nexport const conditional: ExpressionHandler<\n  [ExpressionNode, ExpressionNode, ExpressionNode?]\n> = (ctx, condition, ifTrue, ifFalse) => {\n  const resolution = ctx.evaluate(condition);\n  if (resolution) {\n    return ctx.evaluate(ifTrue);\n  }\n\n  if (ifFalse) {\n    return ctx.evaluate(ifFalse);\n  }\n\n  return null;\n};\n\nconditional.resolveParams = false;\n","import { isExpressionNode } from \"./types\";\nimport type {\n  ErrorWithLocation,\n  ExpressionHandler,\n  ExpressionNode,\n  ExpressionObjectType,\n  ExpressionType,\n  NodeLocation,\n  NodePosition,\n} from \"./types\";\n\n/** Generates a function by removing the first context argument */\nexport function withoutContext<T extends unknown[], Return>(\n  fn: (...args: T) => Return,\n): ExpressionHandler<T, Return> {\n  return (_context, ...args) => fn(...args);\n}\n\n/** Checks if the location includes the target position  */\nfunction isInRange(position: NodePosition, location: NodeLocation) {\n  return (\n    position.character >= location.start.character &&\n    position.character <= location.end.character\n  );\n}\n\n/** Get the node in the expression that's closest to the desired position */\nexport function findClosestNodeAtPosition(\n  node: ExpressionNode,\n  position: NodePosition,\n): ExpressionNode | undefined {\n  // This is just mapping recursively over nodes in the tree\n\n  // eslint-disable-next-line default-case\n  switch (node.type) {\n    case \"Modification\":\n    case \"Assignment\":\n    case \"LogicalExpression\":\n    case \"BinaryExpression\": {\n      const check =\n        findClosestNodeAtPosition(node.left, position) ??\n        findClosestNodeAtPosition(node.right, position);\n      if (check) {\n        return check;\n      }\n\n      break;\n    }\n\n    case \"UnaryExpression\": {\n      const checkArg = findClosestNodeAtPosition(node.argument, position);\n      if (checkArg) {\n        return checkArg;\n      }\n\n      break;\n    }\n\n    case \"MemberExpression\": {\n      const checkObject =\n        findClosestNodeAtPosition(node.object, position) ??\n        findClosestNodeAtPosition(node.property, position);\n      if (checkObject) {\n        return checkObject;\n      }\n\n      break;\n    }\n\n    case \"ConditionalExpression\": {\n      const checkObject =\n        findClosestNodeAtPosition(node.test, position) ??\n        findClosestNodeAtPosition(node.consequent, position) ??\n        findClosestNodeAtPosition(node.alternate, position);\n      if (checkObject) {\n        return checkObject;\n      }\n\n      break;\n    }\n\n    case \"ArrayExpression\":\n    case \"Compound\": {\n      const elements =\n        node.type === \"ArrayExpression\" ? node.elements : node.body;\n\n      const anyElements = elements.find((e) =>\n        findClosestNodeAtPosition(e, position),\n      );\n\n      if (anyElements) {\n        return anyElements;\n      }\n\n      break;\n    }\n\n    case \"Object\": {\n      const checkObject = node.attributes.reduce<ExpressionNode | undefined>(\n        (found, next) => {\n          return (\n            found ??\n            findClosestNodeAtPosition(next.key, position) ??\n            findClosestNodeAtPosition(next.value, position)\n          );\n        },\n        undefined,\n      );\n\n      if (checkObject) {\n        return checkObject;\n      }\n\n      break;\n    }\n\n    case \"CallExpression\": {\n      const anyArgs =\n        node.args.find((arg) => {\n          return findClosestNodeAtPosition(arg, position);\n        }) ?? findClosestNodeAtPosition(node.callTarget, position);\n\n      if (anyArgs) {\n        return anyArgs;\n      }\n\n      break;\n    }\n  }\n\n  // Lastly check for yourself\n  if (node.location && isInRange(position, node.location)) {\n    return node;\n  }\n}\n\n/** Checks if the expression is a simple type */\nexport function isObjectExpression(\n  expr: ExpressionType,\n): expr is ExpressionObjectType {\n  if (isExpressionNode(expr)) {\n    return false;\n  }\n\n  return (\n    typeof expr === \"object\" &&\n    expr !== null &&\n    !Array.isArray(expr) &&\n    \"value\" in expr\n  );\n}\n\n/**\n * Type guard for ErrorWithLocation\n */\nexport function isErrorWithLocation(error: Error): error is ErrorWithLocation {\n  return (\n    (error as ErrorWithLocation).index !== undefined &&\n    (error as ErrorWithLocation).description !== undefined\n  );\n}\n","export type LogFn = (...args: Array<any>) => void;\n\nexport const severities = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"] as const;\nexport type Severity = (typeof severities)[number];\nexport type Logger = Record<Severity, LogFn>;\nexport type LoggerProvider = () => Logger | undefined;\n","import type { Logger, Severity } from \"./types\";\nimport { severities } from \"./types\";\n\nexport type ConsoleHandler = Pick<typeof console, \"log\" | \"warn\" | \"error\">;\n\n/** A Logger implementation that uses console */\nexport default class ConsoleLogger implements Logger {\n  private severity: Severity;\n  private _console: ConsoleHandler;\n\n  constructor(severity: Severity = \"warn\", _console: ConsoleHandler = console) {\n    this.severity = severity;\n    this._console = _console;\n  }\n\n  public setSeverity(severity: Severity) {\n    this.severity = severity;\n  }\n\n  private getConsoleFn(severity: Severity) {\n    switch (severities.indexOf(severity)) {\n      case 0:\n      case 1:\n      case 2:\n        return this._console.log;\n      case 3:\n        return this._console.warn;\n      default:\n        return this._console.error;\n    }\n  }\n\n  private createHandler(severity: Severity): (...args: any[]) => void {\n    return (...args: any[]) => {\n      const sevIndex = severities.indexOf(severity);\n      const sevConf = severities.indexOf(this.severity);\n\n      if (sevIndex >= sevConf) {\n        this.getConsoleFn(severity)(`player - ${severity} -`, ...args);\n      }\n    };\n  }\n\n  public readonly trace = this.createHandler(\"trace\");\n  public readonly debug = this.createHandler(\"debug\");\n  public readonly info = this.createHandler(\"info\");\n  public readonly warn = this.createHandler(\"warn\");\n  public readonly error = this.createHandler(\"error\");\n}\n","import type { Logger } from \"./types\";\n\n/** An empty function so the logger ignore everything */\nconst noop = () => {};\n\n/** A logger implementation that goes nowhere */\nexport default class NoopLogger implements Logger {\n  public readonly trace = noop;\n  public readonly debug = noop;\n  public readonly info = noop;\n  public readonly warn = noop;\n  public readonly error = noop;\n}\n","import { SyncHook } from \"tapable-ts\";\nimport type { Logger, Severity } from \"./types\";\n\n/** A logger that has a tapable subscriptions to callbacks */\nexport default class TapableLogger implements Logger {\n  public readonly hooks = {\n    trace: new SyncHook<[Array<any>]>(),\n    debug: new SyncHook<[Array<any>]>(),\n    info: new SyncHook<[Array<any>]>(),\n    warn: new SyncHook<[Array<any>]>(),\n    error: new SyncHook<[Array<any>]>(),\n    log: new SyncHook<[Severity, Array<any>]>(),\n  };\n\n  private logHandlers: Set<Logger> = new Set();\n\n  private createHandler(severity: Severity): (...args: any[]) => void {\n    return (...args: any[]) => {\n      this.hooks[severity].call(args);\n      this.hooks.log.call(severity, args);\n      this.logHandlers.forEach((logger) => logger[severity](...args));\n    };\n  }\n\n  public addHandler(logHandler: Logger) {\n    this.logHandlers.add(logHandler);\n  }\n\n  public removeHandler(logHandler: Logger) {\n    this.logHandlers.delete(logHandler);\n  }\n\n  public readonly trace = this.createHandler(\"trace\");\n  public readonly debug = this.createHandler(\"debug\");\n  public readonly info = this.createHandler(\"info\");\n  public readonly warn = this.createHandler(\"warn\");\n  public readonly error = this.createHandler(\"error\");\n}\n","import type { Logger, Severity, LoggerProvider } from \"./types\";\n\n/**\n * The ProxyLogger allows a user to log to another Logger instance that may not exist yet\n */\nexport default class ProxyLogger implements Logger {\n  private proxiedLoggerProvider: LoggerProvider;\n\n  constructor(loggerProvider: LoggerProvider) {\n    this.proxiedLoggerProvider = loggerProvider;\n  }\n\n  private createHandler(severity: Severity): (...args: any[]) => void {\n    return (...args: any[]) => {\n      const logger = this.proxiedLoggerProvider();\n      logger?.[severity](...args);\n    };\n  }\n\n  public readonly trace = this.createHandler(\"trace\");\n  public readonly debug = this.createHandler(\"debug\");\n  public readonly info = this.createHandler(\"info\");\n  public readonly warn = this.createHandler(\"warn\");\n  public readonly error = this.createHandler(\"error\");\n}\n","import { SyncWaterfallHook } from \"tapable-ts\";\nimport type { Schema as SchemaType, Formatting } from \"@player-ui/types\";\n\nimport type { BindingInstance } from \"../binding\";\nimport type { ValidationProvider, ValidationObject } from \"../validator\";\nimport type { FormatDefinition, FormatOptions, FormatType } from \"./types\";\n\n/** A function that returns itself */\nconst identify = (val: any) => val;\n\n/** Expand the authored schema into a set of paths -> DataTypes */\nexport function parse(\n  schema: SchemaType.Schema,\n): Map<string, SchemaType.DataTypes> {\n  const expandedPaths = new Map<string, SchemaType.DataTypes>();\n\n  if (!schema.ROOT) {\n    return expandedPaths;\n  }\n\n  const parseQueue: Array<{\n    /** The node to process */\n    node: SchemaType.Node;\n\n    /** The path in the data-model this node represents */\n    path: Array<string>;\n\n    /** A set of visited DataTypes to prevent loops */\n    visited: Set<string>;\n  }> = [{ node: schema.ROOT, path: [], visited: new Set() }];\n\n  while (parseQueue.length > 0) {\n    const next = parseQueue.shift();\n\n    if (!next) {\n      break;\n    }\n\n    const { node, path, visited } = next;\n\n    Object.entries(node).forEach(([prop, type]) => {\n      const nestedPath = [...path, prop];\n\n      const nestedPathStr = nestedPath.join(\".\");\n\n      if (expandedPaths.has(nestedPathStr)) {\n        // We've gone in a loop. Panic\n        throw new Error(\n          \"Path has already been processed. There's either a loop somewhere or a bug\",\n        );\n      }\n\n      if (visited.has(type.type)) {\n        throw new Error(\n          `Path already contained type: ${type.type}. This likely indicates a loop in the schema`,\n        );\n      }\n\n      expandedPaths.set(nestedPathStr, type);\n\n      if (type.isArray) {\n        nestedPath.push(\"[]\");\n      }\n\n      if (type.isRecord) {\n        nestedPath.push(\"{}\");\n      }\n\n      if (type.type && schema[type.type]) {\n        parseQueue.push({\n          path: nestedPath,\n          node: schema[type.type],\n          visited: new Set([...visited, type.type]),\n        });\n      }\n    });\n  }\n\n  return expandedPaths;\n}\n\n/**\n * The Schema is the central hub for all data invariants, and metaData associated with the data-model itself\n * Outside of the types defined in the JSON payload, it doesn't manage or keep any state.\n * It simply servers as an orchestrator for other modules to interface w/ the schema.\n */\nexport class SchemaController implements ValidationProvider {\n  private formatters: Map<string, FormatType<any, any, FormatOptions>> =\n    new Map();\n\n  private types: Map<string, SchemaType.DataType<any>> = new Map();\n  public readonly schema: Map<string, SchemaType.DataTypes> = new Map();\n\n  private bindingSchemaNormalizedCache: Map<BindingInstance, string> =\n    new Map();\n\n  public readonly hooks = {\n    resolveTypeForBinding: new SyncWaterfallHook<\n      [SchemaType.DataTypes | undefined, BindingInstance]\n    >(),\n  };\n\n  constructor(schema?: SchemaType.Schema) {\n    this.schema = schema ? parse(schema) : new Map();\n  }\n\n  public addFormatters(fns: Array<FormatType<any, any, FormatOptions>>) {\n    fns.forEach((def) => {\n      this.formatters.set(def.name, def);\n    });\n  }\n\n  public addDataTypes(types: Array<SchemaType.DataType<any>>) {\n    types.forEach((t) => {\n      this.types.set(t.type, t);\n    });\n  }\n\n  getValidationsForBinding(\n    binding: BindingInstance,\n  ): Array<ValidationObject> | undefined {\n    const typeDef = this.getApparentType(binding);\n\n    if (!typeDef?.validation?.length) {\n      return undefined;\n    }\n\n    // Set the defaults for schema-level validations\n    return typeDef.validation.map((vRef) => ({\n      severity: \"error\",\n      trigger: \"change\",\n      ...vRef,\n    }));\n  }\n\n  private normalizeBinding(binding: BindingInstance): string {\n    const cached = this.bindingSchemaNormalizedCache.get(binding);\n    if (cached) {\n      return cached;\n    }\n\n    let bindingArray = binding.asArray();\n    let normalized = bindingArray\n      .map((p) => (typeof p === \"number\" ? \"[]\" : p))\n      .join(\".\");\n\n    if (normalized) {\n      this.bindingSchemaNormalizedCache.set(binding, normalized);\n      bindingArray = normalized.split(\".\");\n    }\n\n    bindingArray.forEach((item) => {\n      const recordBinding = bindingArray\n        .map((p) => (p === item ? \"{}\" : p))\n        .join(\".\");\n\n      if (this.schema.get(recordBinding)) {\n        this.bindingSchemaNormalizedCache.set(binding, recordBinding);\n        bindingArray = recordBinding.split(\".\");\n        normalized = recordBinding;\n      }\n    });\n\n    return normalized;\n  }\n\n  public getType(binding: BindingInstance): SchemaType.DataTypes | undefined {\n    return this.hooks.resolveTypeForBinding.call(\n      this.schema.get(this.normalizeBinding(binding)),\n      binding,\n    );\n  }\n\n  public getApparentType(\n    binding: BindingInstance,\n  ): SchemaType.DataTypes | undefined {\n    const schemaType = this.getType(binding);\n\n    if (schemaType === undefined) {\n      return undefined;\n    }\n\n    const baseType = this.getTypeDefinition(schemaType?.type);\n\n    if (baseType === undefined) {\n      return schemaType;\n    }\n\n    return {\n      ...baseType,\n      ...schemaType,\n      validation: [\n        ...(schemaType.validation ?? []),\n        ...(baseType.validation ?? []),\n      ],\n    };\n  }\n\n  public getTypeDefinition(dataType: string) {\n    return this.types.get(dataType);\n  }\n\n  public getFormatterForType(\n    formatReference: Formatting.Reference,\n  ): FormatDefinition<unknown, unknown> | undefined {\n    const { type: formatType, ...options } = formatReference;\n\n    const formatter = this.formatters.get(formatType);\n\n    if (!formatter) {\n      return;\n    }\n\n    return {\n      format: formatter.format\n        ? (val) => formatter.format?.(val, options)\n        : identify,\n      deformat: formatter.deformat\n        ? (val) => formatter.deformat?.(val, options)\n        : identify,\n    };\n  }\n\n  /**\n   * Given a binding, fetch a function that's responsible for formatting, and/or de-formatting the data\n   * If no formatter is registered, it will return undefined\n   */\n  public getFormatter(\n    binding: BindingInstance,\n  ): FormatDefinition<unknown, unknown> | undefined {\n    const type = this.getApparentType(binding);\n\n    if (!type?.format) {\n      return undefined;\n    }\n\n    return this.getFormatterForType(type.format);\n  }\n}\n","import { setIn } from \"timm\";\nimport type { Expression } from \"@player-ui/types\";\nimport type { DataModelWithParser } from \"../data\";\n\nconst DOUBLE_OPEN_CURLY = \"{{\";\nconst DOUBLE_CLOSE_CURLY = \"}}\";\n\nexport interface Options {\n  /**\n   * The model to use when resolving refs\n   * Passing `false` will skip trying to resolve any direct model refs ({{foo}})\n   */\n  model: false | DataModelWithParser;\n\n  /**\n   * A function to evaluate an expression\n   * Passing `false` will skip trying to evaluate any expressions (@[ foo() ]@)\n   */\n  evaluate: false | ((exp: Expression) => any);\n\n  /**\n   * Optionaly resolve binding without formatting in case Type format applies\n   */\n  formatted?: boolean;\n}\n\n/** Search the given string for the coordinates of the next expression to resolve */\nexport function findNextExp(str: string) {\n  const expStart = str.indexOf(DOUBLE_OPEN_CURLY);\n\n  if (expStart === -1) {\n    return undefined;\n  }\n\n  let count = 1;\n  let offset = expStart + DOUBLE_OPEN_CURLY.length;\n  let workingString = str.substring(expStart + DOUBLE_OPEN_CURLY.length);\n\n  while (count > 0 && workingString.length > 0) {\n    // Find the next open or close curly\n    const nextCloseCurly = workingString.indexOf(DOUBLE_CLOSE_CURLY);\n\n    // We can't close anything, so there's no point in going on with life.\n    if (nextCloseCurly === -1) {\n      break;\n    }\n\n    const nextOpenCurly = workingString.indexOf(DOUBLE_OPEN_CURLY);\n\n    if (nextOpenCurly !== -1 && nextOpenCurly < nextCloseCurly) {\n      // We've hit another open bracket before closing out the one we want\n      // Move everything over and bump our close count by 1\n      count++;\n      workingString = workingString.substring(\n        nextOpenCurly + DOUBLE_OPEN_CURLY.length,\n      );\n      offset += nextOpenCurly + DOUBLE_OPEN_CURLY.length;\n    } else {\n      // We've hit another closing bracket\n      // Decrement our count and updates offsets\n      count--;\n      workingString = workingString.substring(\n        nextCloseCurly + DOUBLE_CLOSE_CURLY.length,\n      );\n      offset += nextCloseCurly + DOUBLE_CLOSE_CURLY.length;\n    }\n  }\n\n  if (count !== 0) {\n    throw new Error(`Unbalanced {{ and }} in exp: ${str}`);\n  }\n\n  return {\n    start: expStart,\n    end: offset,\n  };\n}\n\n/** Finds any subset of the string wrapped in @[]@ and evaluates it as an expression */\nexport function resolveExpressionsInString(\n  val: string,\n  { evaluate }: Options,\n): string {\n  if (!evaluate) {\n    return val;\n  }\n\n  const expMatch = /@\\[.*?\\]@/;\n  let newVal = val;\n  let match = newVal.match(expMatch);\n\n  while (match !== null) {\n    const expStrWithBrackets = match[0];\n    const matchStart = newVal.indexOf(expStrWithBrackets);\n\n    const expString = expStrWithBrackets.substr(\n      \"@[\".length,\n      expStrWithBrackets.length - \"@[\".length - \"]@\".length,\n    );\n    const expValue = evaluate(expString);\n\n    // The string is only the expression, return the raw value.\n    if (\n      matchStart === 0 &&\n      expStrWithBrackets === val &&\n      typeof expValue !== \"string\"\n    ) {\n      return expValue;\n    }\n\n    newVal =\n      newVal.substr(0, matchStart) +\n      expValue +\n      newVal.substr(matchStart + expStrWithBrackets.length);\n    // remove the surrounding @[]@ to get the expression\n    match = newVal.match(expMatch);\n  }\n\n  return newVal;\n}\n\n/** Return a string with all data model references resolved */\nexport function resolveDataRefsInString(val: string, options: Options): string {\n  const { model, formatted = true } = options;\n  let workingString = resolveExpressionsInString(val, options);\n\n  if (\n    !model ||\n    typeof workingString !== \"string\" ||\n    workingString.indexOf(DOUBLE_OPEN_CURLY) === -1\n  ) {\n    return workingString;\n  }\n\n  while (workingString.indexOf(DOUBLE_OPEN_CURLY) !== -1) {\n    const expLocation = findNextExp(workingString);\n\n    if (!expLocation) {\n      return workingString;\n    }\n\n    const { start, end } = expLocation;\n\n    // Strip out the wrapping curlies from {{binding}} before passing to the model\n    const binding = workingString\n      .substring(\n        start + DOUBLE_OPEN_CURLY.length,\n        end - DOUBLE_OPEN_CURLY.length,\n      )\n      .trim();\n\n    const evaledVal = model.get(binding, { formatted });\n\n    // Exit early if the string is _just_ a model lookup\n    // If the result is a string, we may need further processing for nested bindings\n    if (\n      start === 0 &&\n      end === workingString.length &&\n      typeof evaledVal !== \"string\"\n    ) {\n      return evaledVal;\n    }\n\n    workingString =\n      workingString.substr(0, start) + evaledVal + workingString.substr(end);\n  }\n\n  return workingString;\n}\n\n/** Traverse the thing and replace any model refs */\nfunction traverseObject<T>(val: T, options: Options): T {\n  switch (typeof val) {\n    case \"string\": {\n      return resolveDataRefsInString(val as string, options) as unknown as T;\n    }\n\n    case \"object\": {\n      if (!val) return val;\n      // TODO: Do we care refs in keys?\n      const keys = Object.keys(val);\n      let newVal = val;\n\n      if (keys.length > 0) {\n        keys.forEach((key) => {\n          newVal = setIn(\n            newVal as any,\n            [key],\n            traverseObject((val as any)[key], options),\n          ) as any;\n        });\n      }\n\n      return newVal;\n    }\n\n    default:\n      return val;\n  }\n}\n\n/** Recursively resolve all model refs in whatever you pass in */\nexport function resolveDataRefs<T>(val: T, options: Options): T {\n  return traverseObject(val, options);\n}\n","import { setIn } from \"timm\";\nimport type { BindingInstance } from \"../binding\";\nimport type {\n  BatchSetTransaction,\n  DataModelImpl,\n  DataModelOptions,\n  DataModelMiddleware,\n  Updates,\n} from \"../data\";\nimport { toModel } from \"../data\";\nimport type { Logger } from \"../logger\";\n\nimport type { ValidationResponse } from \"./types\";\nimport { removeBindingAndChildrenFromMap } from \"./binding-map-splice\";\n\n/**\n * A BindingInstance with an indicator of whether or not it's a strong binding\n */\nexport type StrongOrWeakBinding = {\n  /** BindingInstance in question */\n  binding: BindingInstance;\n  /** Boolean indicating whether the relevant BindingInstance is a strong binding */\n  isStrong: boolean;\n};\n\n/**\n * Returns a validation object if the data is invalid or an set of BindingsInstances if the binding itself is a weak ref of another invalid validation\n */\nexport type MiddlewareChecker = (\n  binding: BindingInstance,\n  model: DataModelImpl,\n) => ValidationResponse | Set<StrongOrWeakBinding> | undefined;\n\n/**\n * Middleware for the data-model that caches the results of invalid data\n */\nexport class ValidationMiddleware implements DataModelMiddleware {\n  public validator: MiddlewareChecker;\n  public shadowModelPaths: Map<BindingInstance, any>;\n  private logger?: Logger;\n  private shouldIncludeInvalid?: (options?: DataModelOptions) => boolean;\n\n  constructor(\n    validator: MiddlewareChecker,\n    options?: {\n      /** A logger instance */\n      logger?: Logger;\n      /** Optional function to include data staged in shadowModel */\n      shouldIncludeInvalid?: (options?: DataModelOptions) => boolean;\n    },\n  ) {\n    this.validator = validator;\n    this.shadowModelPaths = new Map();\n    this.logger = options?.logger;\n    this.shouldIncludeInvalid = options?.shouldIncludeInvalid;\n  }\n\n  public set(\n    transaction: BatchSetTransaction,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ): Updates {\n    const asModel = toModel(this, { ...options, includeInvalid: true }, next);\n    const nextTransaction: BatchSetTransaction = [];\n\n    const includedBindings = new Set<BindingInstance>();\n\n    transaction.forEach(([binding, value]) => {\n      this.shadowModelPaths.set(binding, value);\n      includedBindings.add(binding);\n    });\n\n    const invalidBindings: Array<BindingInstance> = [];\n\n    this.shadowModelPaths.forEach((value, binding) => {\n      const validations = this.validator(binding, asModel);\n\n      if (validations === undefined) {\n        nextTransaction.push([binding, value]);\n      } else if (validations instanceof Set) {\n        validations.forEach((validation) => {\n          invalidBindings.push(validation.binding);\n          if (\n            !validation.isStrong &&\n            validation.binding.asString() === binding.asString()\n          ) {\n            nextTransaction.push([validation.binding, value]);\n          }\n        });\n      } else if (includedBindings.has(binding)) {\n        invalidBindings.push(binding);\n        this.logger?.debug(\n          `Invalid value for path: ${binding.asString()} - ${\n            validations.severity\n          } - ${validations.message}`,\n        );\n      }\n    });\n\n    let validResults: Updates = [];\n\n    if (next && nextTransaction.length > 0) {\n      // defer clearing the shadow model to prevent validations that are run twice due to weak binding refs still needing the data\n      nextTransaction.forEach(([binding]) =>\n        this.shadowModelPaths.delete(binding),\n      );\n      const result = next.set(nextTransaction, options);\n      if (invalidBindings.length === 0) {\n        return result;\n      }\n\n      validResults = result;\n    }\n\n    const invalidResults = invalidBindings.map((binding) => {\n      return {\n        binding,\n        oldValue: asModel.get(binding),\n        newValue: asModel.get(binding),\n        force: true,\n      };\n    });\n\n    return [...validResults, ...invalidResults];\n  }\n\n  public get(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ) {\n    let val = next?.get(binding, options);\n\n    if (\n      this.shouldIncludeInvalid?.(options) ??\n      options?.includeInvalid === true\n    ) {\n      this.shadowModelPaths.forEach((shadowValue, shadowBinding) => {\n        if (shadowBinding === binding) {\n          val = shadowValue;\n\n          return;\n        }\n\n        if (binding.contains(shadowBinding)) {\n          val = setIn(val, shadowBinding.relative(binding), shadowValue);\n        }\n      });\n    }\n\n    return val;\n  }\n\n  public delete(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ) {\n    this.shadowModelPaths = removeBindingAndChildrenFromMap(\n      this.shadowModelPaths,\n      binding,\n    );\n\n    return next?.delete(binding, options);\n  }\n}\n","import type { BindingInstance } from \"../binding\";\n\n/**\n * Remove a binding, and any children from from the map\n * If the binding is an array-item, then it will be spliced from the array and the others will be shifted down\n *\n * @param sourceMap - A map of bindings to values\n * @param binding - The binding to remove from the map\n */\nexport function removeBindingAndChildrenFromMap<T>(\n  sourceMap: Map<BindingInstance, T>,\n  binding: BindingInstance,\n): Map<BindingInstance, T> {\n  const targetMap = new Map(sourceMap);\n\n  const parentBinding = binding.parent();\n  const property = binding.key();\n\n  // Clear out any that are sub-bindings of this binding\n\n  targetMap.forEach((_value, trackedBinding) => {\n    if (binding === trackedBinding || binding.contains(trackedBinding)) {\n      targetMap.delete(trackedBinding);\n    }\n  });\n\n  if (typeof property === \"number\") {\n    // Splice out this index from the rest\n\n    // Order matters here b/c we are shifting items in the array\n    // Start with the smallest index and work our way down\n    const bindingsToRewrite = Array.from(sourceMap.keys())\n      .filter((b) => {\n        if (parentBinding.contains(b)) {\n          const [childIndex] = b.relative(parentBinding);\n          return typeof childIndex === \"number\" && childIndex > property;\n        }\n\n        return false;\n      })\n      .sort();\n\n    bindingsToRewrite.forEach((trackedBinding) => {\n      // If the tracked binding is a sub-binding of the parent binding, then we need to\n      // update the path to reflect the new index\n\n      const [childIndex, ...childPath] = trackedBinding.relative(parentBinding);\n\n      if (typeof childIndex === \"number\") {\n        const newSegments = [childIndex - 1, ...childPath];\n        const newChildBinding = parentBinding.descendent(newSegments);\n        targetMap.set(newChildBinding, targetMap.get(trackedBinding) as T);\n        targetMap.delete(trackedBinding);\n      }\n    });\n  }\n\n  return targetMap;\n}\n","import type { ValidatorFunction } from \"./types\";\n\n/** A registry that tracks validators  */\nexport class ValidatorRegistry {\n  private registry: Map<string, ValidatorFunction<any>>;\n\n  constructor() {\n    this.registry = new Map();\n  }\n\n  /** Use the given validator name to fetch the handler */\n  public get(name: string): ValidatorFunction | undefined {\n    return this.registry.get(name);\n  }\n\n  /** Register a new validator */\n  public register<T>(name: string, handler: ValidatorFunction<T>) {\n    this.registry.set(name, handler);\n  }\n}\n","import { SyncWaterfallHook, SyncHook } from \"tapable-ts\";\nimport { setIn, addLast, clone } from \"timm\";\nimport dlv from \"dlv\";\nimport { dequal } from \"dequal\";\nimport type { BindingInstance, BindingLike } from \"../../binding\";\nimport type {\n  DataModelOptions,\n  DataModelWithParser,\n  Updates,\n} from \"../../data\";\nimport { DependencyModel, withParser } from \"../../data\";\nimport type { Logger } from \"../../logger\";\nimport type { Node } from \"../parser\";\nimport { NodeType } from \"../parser\";\nimport {\n  caresAboutDataChanges,\n  toNodeResolveOptions,\n  unpackAndPush,\n} from \"./utils\";\nimport type { Resolve } from \"./types\";\nimport { getNodeID } from \"../parser/utils\";\n\nexport * from \"./types\";\nexport * from \"./utils\";\n\ninterface NodeUpdate extends Resolve.ResolvedNode {\n  /** A flag to track if a node has changed since the last resolution */\n  updated: boolean;\n}\n\n/** Add model context to the data model */\nconst withContext = (model: DataModelWithParser): DataModelWithParser => {\n  return {\n    get: (binding: BindingLike, options?: DataModelOptions): any => {\n      return model.get(binding, {\n        context: { model },\n        ...options,\n      });\n    },\n\n    set: (\n      transaction: [BindingLike, any][],\n      options?: DataModelOptions,\n    ): Updates => {\n      return model.set(transaction, {\n        context: { model },\n        ...options,\n      });\n    },\n\n    delete: (binding: BindingLike, options?: DataModelOptions): void => {\n      return model.delete(binding, {\n        context: { model },\n        ...options,\n      });\n    },\n  };\n};\n\n/**\n * The Resolver is the way to take a parsed AST graph of a view and resolve it to a concrete representation of the current user state\n * It combines the ability to mutate ast nodes before resolving, as well as the mutating the resolved objects while parsing\n */\nexport class Resolver {\n  public readonly hooks = {\n    /** A hook to allow skipping of the resolution tree for a specific node */\n    skipResolve: new SyncWaterfallHook<\n      [boolean, Node.Node, Resolve.NodeResolveOptions]\n    >(),\n\n    /** An event emitted before calculating the next update */\n    beforeUpdate: new SyncHook<[Set<BindingInstance> | undefined]>(),\n\n    /** An event emitted after calculating the next update */\n    afterUpdate: new SyncHook<[any]>(),\n\n    /** The options passed to a node to resolve it to an object */\n    resolveOptions: new SyncWaterfallHook<\n      [Resolve.NodeResolveOptions, Node.Node]\n    >(),\n\n    /** A hook to transform the AST node into a new AST node before resolving it */\n    beforeResolve: new SyncWaterfallHook<\n      [Node.Node | null, Resolve.NodeResolveOptions]\n    >(),\n\n    /**\n     * A hook to transform an AST node into it's resolved value.\n     * This runs _before_ any children are resolved\n     */\n    resolve: new SyncWaterfallHook<\n      [any, Node.Node, Resolve.NodeResolveOptions]\n    >(),\n\n    /**\n     * A hook to transform the resolved value of an AST node.\n     * This runs _after_ all children nodes are resolved\n     */\n    afterResolve: new SyncWaterfallHook<\n      [any, Node.Node, Resolve.NodeResolveOptions]\n    >(),\n\n    /** Called at the very end of a node's tree being updated */\n    afterNodeUpdate: new SyncHook<\n      [Node.Node, Node.Node | undefined, NodeUpdate]\n    >(),\n  };\n\n  /**\n   * The AST tree after beforeResolve is ran mapped to the AST before beforeResolve is ran\n   */\n  private readonly ASTMap: Map<Node.Node, Node.Node>;\n  /**\n   * The root node in the AST tree we want to resolve\n   */\n  public readonly root: Node.Node;\n\n  /**\n   * The cache of the last resolved values when walking the tree.\n   * This gets recycled every update to avoid stale data if a node is unused in an update\n   */\n  private resolveCache: Map<Node.Node, Resolve.ResolvedNode>;\n\n  /**\n   * Cache of node IDs that have been processed to track if nodes have duplicate IDs\n   */\n  private idCache: Set<string>;\n\n  /**\n   * The parameters required to resolve AST nodes\n   */\n  private readonly options: Resolve.ResolverOptions;\n\n  /**\n   * Tapable logger for logging errors encountered during view resolution\n   */\n  private logger?: Logger;\n\n  constructor(root: Node.Node, options: Resolve.ResolverOptions) {\n    this.root = root;\n    this.options = options;\n    this.resolveCache = new Map();\n    this.ASTMap = new Map();\n    this.logger = options.logger;\n    this.idCache = new Set();\n  }\n\n  public getSourceNode(convertedAST: Node.Node) {\n    return this.ASTMap.get(convertedAST);\n  }\n\n  public update(changes?: Set<BindingInstance>): any {\n    this.hooks.beforeUpdate.call(changes);\n    const resolveCache = new Map<Node.Node, Resolve.ResolvedNode>();\n    this.idCache.clear();\n    const prevASTMap = new Map(this.ASTMap);\n    this.ASTMap.clear();\n\n    const updated = this.computeTree(\n      this.root,\n      undefined,\n      changes,\n      resolveCache,\n      toNodeResolveOptions(this.options),\n      undefined,\n      prevASTMap,\n    );\n    this.resolveCache = resolveCache;\n    this.hooks.afterUpdate.call(updated.value);\n\n    return updated.value;\n  }\n\n  public getResolveCache() {\n    return new Map(this.resolveCache);\n  }\n\n  private getPreviousResult(node: Node.Node): Resolve.ResolvedNode | undefined {\n    if (!node) {\n      return;\n    }\n\n    const isFirstUpdate = this.resolveCache.size === 0;\n    const id = getNodeID(node);\n\n    if (id) {\n      if (this.idCache.has(id)) {\n        // Only log this conflict once to cut down on noise\n        // May want to swap this to logging when we first see the id -- which may not be the first render\n        if (isFirstUpdate) {\n          if (node.type === NodeType.Asset || node.type === NodeType.View) {\n            this.logger?.error(\n              `Cache conflict: Found Asset/View nodes that have conflicting ids: ${id}, may cause cache issues.`,\n            );\n          } else if (node.type === NodeType.Value) {\n            this.logger?.info(\n              `Cache conflict: Found Value nodes that have conflicting ids: ${id}, may cause cache issues. To improve performance make value node IDs globally unique.`,\n            );\n          }\n        }\n\n        // Don't use anything from a prev result if there's a duplicate id detected\n        return;\n      }\n\n      this.idCache.add(id);\n    }\n\n    return this.resolveCache.get(node);\n  }\n\n  private cloneNode(node: any) {\n    const clonedNode = clone(node);\n\n    Object.keys(clonedNode).forEach((key) => {\n      if (key === \"parent\") return;\n\n      const value = clonedNode[key];\n      if (typeof value === \"object\" && value !== null) {\n        clonedNode[key] = Array.isArray(value) ? [...value] : { ...value };\n      }\n    });\n\n    return clonedNode;\n  }\n\n  private computeTree(\n    node: Node.Node,\n    rawParent: Node.Node | undefined,\n    dataChanges: Set<BindingInstance> | undefined,\n    cacheUpdate: Map<Node.Node, Resolve.ResolvedNode>,\n    options: Resolve.NodeResolveOptions,\n    partiallyResolvedParent: Node.Node | undefined,\n    prevASTMap: Map<Node.Node, Node.Node>,\n  ): NodeUpdate {\n    const dependencyModel = new DependencyModel(options.data.model);\n\n    dependencyModel.trackSubset(\"core\");\n    const depModelWithParser = withContext(\n      withParser(dependencyModel, this.options.parseBinding),\n    );\n\n    const resolveOptions = this.hooks.resolveOptions.call(\n      {\n        ...options,\n        data: {\n          ...options.data,\n          model: depModelWithParser,\n        },\n        evaluate: (exp) =>\n          this.options.evaluator.evaluate(exp, { model: depModelWithParser }),\n        node,\n      },\n      node,\n    );\n\n    const previousResult = this.getPreviousResult(node);\n    const previousDeps = previousResult?.dependencies;\n\n    const dataChanged = caresAboutDataChanges(dataChanges, previousDeps);\n    const shouldUseLastValue = this.hooks.skipResolve.call(\n      !dataChanged,\n      node,\n      resolveOptions,\n    );\n\n    // Shallow clone the node so that changes to it during the resolve steps don't impact the original.\n    // We are trusting that this becomes a deep clone once the whole node tree has been traversed.\n    const clonedNode = {\n      ...this.cloneNode(node),\n      parent: partiallyResolvedParent,\n    };\n    const resolvedAST = this.hooks.beforeResolve.call(\n      clonedNode,\n      resolveOptions,\n    ) ?? {\n      type: NodeType.Empty,\n    };\n\n    const isNestedMultiNode =\n      resolvedAST.type === NodeType.MultiNode &&\n      partiallyResolvedParent?.parent?.type === NodeType.MultiNode &&\n      partiallyResolvedParent.type === NodeType.Value;\n\n    if (previousResult && shouldUseLastValue) {\n      const update = {\n        ...previousResult,\n        updated: false,\n      };\n\n      /** Recursively repopulate the AST map given some AST Node and it's resolved AST representation */\n      const repopulateASTMapFromCache = (\n        resolvedNode: Resolve.ResolvedNode,\n        AST: Node.Node,\n        ASTParent: Node.Node | undefined,\n      ) => {\n        const { node: resolvedASTLocal } = resolvedNode;\n        this.ASTMap.set(resolvedASTLocal, AST);\n        const resolvedUpdate = {\n          ...resolvedNode,\n          updated: false,\n        };\n        cacheUpdate.set(AST, resolvedUpdate);\n\n        /** Helper function for recursing over child node */\n        const handleChildNode = (childNode: Node.Node) => {\n          // In order to get the correct results, we need to use the node references from the last update.\n          const originalChildNode = prevASTMap.get(childNode) ?? childNode;\n          const previousChildResult = this.getPreviousResult(originalChildNode);\n          if (!previousChildResult) return;\n\n          repopulateASTMapFromCache(\n            previousChildResult,\n            originalChildNode,\n            AST,\n          );\n        };\n\n        if (\"children\" in resolvedASTLocal) {\n          resolvedASTLocal.children?.forEach(({ value: childAST }) =>\n            handleChildNode(childAST),\n          );\n        } else if (resolvedASTLocal.type === NodeType.MultiNode) {\n          resolvedASTLocal.values.forEach(handleChildNode);\n        }\n\n        this.hooks.afterNodeUpdate.call(AST, ASTParent, resolvedUpdate);\n      };\n\n      // Point the root of the cached node to the new resolved node.\n      previousResult.node.parent = partiallyResolvedParent;\n\n      repopulateASTMapFromCache(previousResult, node, rawParent);\n\n      return update;\n    }\n\n    resolvedAST.parent = partiallyResolvedParent;\n\n    resolveOptions.node = resolvedAST;\n\n    this.ASTMap.set(resolvedAST, node);\n\n    let resolved = this.hooks.resolve.call(\n      undefined,\n      resolvedAST,\n      resolveOptions,\n    );\n\n    let updated = !dequal(previousResult?.value, resolved);\n\n    if (previousResult && !updated) {\n      resolved = previousResult?.value;\n    }\n\n    const childDependencies = new Set<BindingInstance>();\n    dependencyModel.trackSubset(\"children\");\n\n    if (\"children\" in resolvedAST) {\n      const newChildren = resolvedAST.children?.map((child) => {\n        const computedChildTree = this.computeTree(\n          child.value,\n          node,\n          dataChanges,\n          cacheUpdate,\n          resolveOptions,\n          resolvedAST,\n          prevASTMap,\n        );\n        const {\n          dependencies: childTreeDeps,\n          node: childNode,\n          updated: childUpdated,\n          value: childValue,\n        } = computedChildTree;\n\n        childTreeDeps.forEach((binding) => childDependencies.add(binding));\n\n        if (childValue) {\n          if (childNode.type === NodeType.MultiNode && !childNode.override) {\n            const arr = addLast(\n              dlv(resolved, child.path as any[], []),\n              childValue,\n            );\n            resolved = setIn(resolved, child.path, arr);\n          } else {\n            resolved = setIn(resolved, child.path, childValue);\n          }\n        }\n\n        updated = updated || childUpdated;\n\n        return { ...child, value: childNode };\n      });\n\n      resolvedAST.children = newChildren;\n    } else if (resolvedAST.type === NodeType.MultiNode) {\n      const childValue: any = [];\n      const rawParentToPassIn = isNestedMultiNode\n        ? partiallyResolvedParent?.parent\n        : node;\n\n      const newValues = resolvedAST.values.map((mValue) => {\n        const mTree = this.computeTree(\n          mValue,\n          rawParentToPassIn,\n          dataChanges,\n          cacheUpdate,\n          resolveOptions,\n          resolvedAST,\n          prevASTMap,\n        );\n\n        if (mTree.value !== undefined && mTree.value !== null) {\n          if (\n            mTree.node.parent?.type === NodeType.MultiNode &&\n            Array.isArray(mTree.value)\n          ) {\n            mTree.value.forEach((v: any) => {\n              unpackAndPush(v, childValue);\n            });\n          } else {\n            childValue.push(mTree.value);\n          }\n        }\n\n        mTree.dependencies.forEach((bindingDep) =>\n          childDependencies.add(bindingDep),\n        );\n\n        updated = updated || mTree.updated;\n\n        return mTree.node;\n      });\n\n      resolvedAST.values = newValues;\n      resolved = childValue;\n    }\n\n    childDependencies.forEach((bindingDep) =>\n      dependencyModel.addChildReadDep(bindingDep),\n    );\n\n    dependencyModel.trackSubset(\"core\");\n    if (previousResult && !updated) {\n      resolved = previousResult?.value;\n    }\n\n    resolved = this.hooks.afterResolve.call(resolved, resolvedAST, {\n      ...resolveOptions,\n      getDependencies: (scope?: \"core\" | \"children\") =>\n        dependencyModel.getDependencies(scope),\n    });\n\n    const update: NodeUpdate = {\n      node: resolvedAST,\n      updated,\n      value: resolved,\n      dependencies: new Set([\n        ...dependencyModel.getDependencies(),\n        ...childDependencies,\n      ]),\n    };\n\n    this.hooks.afterNodeUpdate.call(\n      node,\n      isNestedMultiNode ? partiallyResolvedParent?.parent : rawParent,\n      update,\n    );\n    cacheUpdate.set(node, update);\n\n    return update;\n  }\n}\n","var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import { omit, setIn } from \"timm\";\nimport { SyncBailHook, SyncWaterfallHook } from \"tapable-ts\";\nimport type { Template } from \"@player-ui/types\";\nimport type { AnyAssetType, Node } from \"./types\";\nimport { NodeType } from \"./types\";\nimport { getNodeID, hasAsync } from \"./utils\";\n\nexport * from \"./types\";\nexport * from \"./utils\";\n\nexport const EMPTY_NODE: Node.Empty = {\n  type: NodeType.Empty,\n};\n\nexport interface ParseObjectOptions {\n  /** how nested the templated is */\n  templateDepth?: number;\n}\n\ninterface NestedObj {\n  /** The values of a nested local object */\n  children: Node.Child[];\n\n  value: any;\n}\n/**\n * The Parser is the way to take an incoming view from the user and parse it into an AST.\n * It provides a few ways to interact with the parsing, including mutating an object before and after creation of an AST node\n */\nexport class Parser {\n  public readonly hooks = {\n    /**\n     * A hook to interact with an object _before_ parsing it into an AST\n     *\n     * @param value - The object we're are about to parse\n     * @returns - A new value to parse.\n     *  If undefined, the original value is used.\n     *  If null, we stop parsing this node.\n     */\n    onParseObject: new SyncWaterfallHook<[object, NodeType]>(),\n\n    /**\n     * A callback to interact with an AST _after_ we parse it into the AST\n     *\n     * @param value - The object we parsed\n     * @param node - The AST node we generated\n     * @returns - A new AST node to use\n     *   If undefined, the original value is used.\n     *   If null, we ignore this node all together\n     */\n    onCreateASTNode: new SyncWaterfallHook<\n      [Node.Node | undefined | null, object]\n    >(),\n\n    determineNodeType: new SyncBailHook<[object | string], NodeType>(),\n\n    parseNode: new SyncBailHook<\n      [\n        obj: object,\n        nodeType: Node.ChildrenTypes,\n        parseOptions: ParseObjectOptions,\n        determinedNodeType: NodeType | null,\n      ],\n      Node.Node\n    >(),\n  };\n\n  public parseView(value: AnyAssetType): Node.View {\n    const viewNode = this.parseObject(value, NodeType.View);\n\n    if (!viewNode) {\n      throw new Error(\"Unable to parse object into a view\");\n    }\n\n    return viewNode as Node.View;\n  }\n\n  private parseAsync(\n    obj: object,\n    type: Node.ChildrenTypes,\n    options: ParseObjectOptions,\n  ): Node.Node | null {\n    const parsedAsync = this.parseObject(omit(obj, \"async\"), type, options);\n    const parsedNodeId = getNodeID(parsedAsync);\n    if (parsedAsync !== null && parsedNodeId) {\n      return this.createASTNode(\n        {\n          id: parsedNodeId,\n          type: NodeType.Async,\n          value: parsedAsync,\n        },\n        obj,\n      );\n    }\n\n    return null;\n  }\n\n  public createASTNode(node: Node.Node | null, value: any): Node.Node | null {\n    const tapped = this.hooks.onCreateASTNode.call(node, value);\n\n    if (tapped === undefined) {\n      return node;\n    }\n\n    return tapped;\n  }\n\n  /**\n   * Checks if there are templated values in the object\n   *\n   * @param obj - The Parsed Object to check to see if we have a template array type for\n   * @param localKey - The key being checked\n   */\n  private hasTemplateValues(obj: any, localKey: string) {\n    return (\n      Object.hasOwnProperty.call(obj, \"template\") &&\n      Array.isArray(obj?.template) &&\n      obj.template.length &&\n      obj.template.find((tmpl: any) => tmpl.output === localKey)\n    );\n  }\n\n  private hasSwitchKey(localKey: string) {\n    return localKey === (\"staticSwitch\" || \"dynamicSwitch\");\n  }\n\n  public parseObject(\n    obj: object,\n    type: Node.ChildrenTypes = NodeType.Value,\n    options: ParseObjectOptions = { templateDepth: 0 },\n  ): Node.Node | null {\n    const nodeType = this.hooks.determineNodeType.call(obj);\n\n    if (nodeType !== undefined) {\n      const parsedNode = this.hooks.parseNode.call(\n        obj,\n        type,\n        options,\n        nodeType,\n      );\n      if (parsedNode) {\n        return parsedNode;\n      }\n    }\n\n    /**\n     *\n     */\n    const parseLocalObject = (\n      currentValue: any,\n      objToParse: unknown,\n      path: string[] = [],\n    ): NestedObj => {\n      if (typeof objToParse !== \"object\" || objToParse === null) {\n        return { value: objToParse, children: [] };\n      }\n\n      const localObj = this.hooks.onParseObject.call(objToParse, type);\n\n      if (!localObj) {\n        return currentValue;\n      }\n\n      const objEntries = Array.isArray(localObj)\n        ? localObj.map((v, i) => [i, v])\n        : [\n            ...Object.entries(localObj),\n            ...Object.getOwnPropertySymbols(localObj).map((s) => [\n              s,\n              (localObj as any)[s],\n            ]),\n          ];\n\n      const defaultValue: NestedObj = {\n        children: [],\n        value: currentValue,\n      };\n\n      const newValue = objEntries.reduce((accumulation, current): NestedObj => {\n        const { children, ...rest } = accumulation;\n        const [localKey, localValue] = current;\n        if (localKey === \"asset\" && typeof localValue === \"object\") {\n          const assetAST = this.parseObject(\n            localValue,\n            NodeType.Asset,\n            options,\n          );\n\n          if (assetAST) {\n            return {\n              ...rest,\n              children: [\n                ...children,\n                {\n                  path: [...path, \"asset\"],\n                  value: assetAST,\n                },\n              ],\n            };\n          }\n        } else if (\n          this.hooks.determineNodeType.call(localKey) === NodeType.Template &&\n          Array.isArray(localValue)\n        ) {\n          const templateChildren = localValue\n            .map((template: Template) => {\n              const templateAST = this.hooks.onCreateASTNode.call(\n                {\n                  type: NodeType.Template,\n                  depth: options.templateDepth ?? 0,\n                  data: template.data,\n                  template: template.value,\n                  dynamic: template.dynamic ?? false,\n                },\n                template,\n              );\n\n              if (templateAST?.type === NodeType.MultiNode) {\n                templateAST.values.forEach((v) => {\n                  // eslint-disable-next-line no-param-reassign\n                  v.parent = templateAST;\n                });\n              }\n\n              if (templateAST) {\n                return {\n                  path: [...path, template.output],\n                  value: templateAST,\n                };\n              }\n\n              // eslint-disable-next-line no-useless-return\n              return;\n            })\n            .filter((element) => !!element);\n\n          return {\n            ...rest,\n            children: [...children, ...templateChildren],\n          } as NestedObj;\n        } else if (\n          (localValue &&\n            this.hooks.determineNodeType.call(localValue) ===\n              NodeType.Switch) ||\n          this.hasSwitchKey(localKey)\n        ) {\n          const localSwitch = this.hooks.parseNode.call(\n            this.hasSwitchKey(localKey)\n              ? { [localKey]: localValue }\n              : localValue,\n            NodeType.Value,\n            options,\n            NodeType.Switch,\n          );\n\n          if (\n            localSwitch &&\n            localSwitch.type === NodeType.Value &&\n            localSwitch.children?.length === 1 &&\n            localSwitch.value === undefined\n          ) {\n            const firstChild = localSwitch.children[0];\n\n            return {\n              ...rest,\n              children: [\n                ...children,\n                {\n                  path: [...path, localKey, ...firstChild.path],\n                  value: firstChild.value,\n                },\n              ],\n            };\n          }\n\n          if (localSwitch) {\n            return {\n              ...rest,\n              children: [\n                ...children,\n                {\n                  path: [...path, localKey],\n                  value: localSwitch,\n                },\n              ],\n            };\n          }\n        } else if (localValue && hasAsync(localValue)) {\n          const localAsync = this.parseAsync(\n            localValue,\n            NodeType.Value,\n            options,\n          );\n          if (localAsync) {\n            children.push({\n              path: [...path, localKey],\n              value: localAsync,\n            });\n          }\n        } else if (localValue && Array.isArray(localValue)) {\n          const childValues = localValue\n            .map((childVal) =>\n              this.parseObject(childVal, NodeType.Value, options),\n            )\n            .filter((child): child is Node.Node => !!child);\n\n          if (childValues.length > 0) {\n            const multiNode = this.hooks.onCreateASTNode.call(\n              {\n                type: NodeType.MultiNode,\n                override: !this.hasTemplateValues(localObj, localKey),\n                values: childValues,\n              },\n              localValue,\n            );\n\n            if (multiNode?.type === NodeType.MultiNode) {\n              multiNode.values.forEach((v) => {\n                // eslint-disable-next-line no-param-reassign\n                v.parent = multiNode;\n              });\n            }\n            if (multiNode) {\n              return {\n                ...rest,\n                children: [\n                  ...children,\n                  {\n                    path: [...path, localKey],\n                    value: multiNode,\n                  },\n                ],\n              };\n            }\n          }\n        } else if (localValue && typeof localValue === \"object\") {\n          const determineNodeType =\n            this.hooks.determineNodeType.call(localValue);\n\n          if (determineNodeType === NodeType.Applicability) {\n            const parsedNode = this.hooks.parseNode.call(\n              localValue,\n              NodeType.Value,\n              options,\n              determineNodeType,\n            );\n            if (parsedNode) {\n              return {\n                ...rest,\n                children: [\n                  ...children,\n                  {\n                    path: [...path, localKey],\n                    value: parsedNode,\n                  },\n                ],\n              };\n            }\n          } else {\n            const result = parseLocalObject(accumulation.value, localValue, [\n              ...path,\n              localKey,\n            ]);\n            return {\n              value: result.value,\n              children: [...children, ...result.children],\n            };\n          }\n        } else {\n          const value = setIn(\n            accumulation.value,\n            [...path, localKey],\n            localValue,\n          );\n\n          return {\n            children,\n            value,\n          };\n        }\n\n        return accumulation;\n      }, defaultValue);\n\n      return newValue;\n    };\n\n    const { value, children } = parseLocalObject(undefined, obj);\n\n    const baseAst =\n      value === undefined && children.length === 0\n        ? undefined\n        : {\n            type,\n            value,\n          };\n\n    if (baseAst !== undefined && children.length > 0) {\n      const parent = baseAst as Node.BaseWithChildren<any>;\n      parent.children = children;\n      children.forEach((child) => {\n        // eslint-disable-next-line no-param-reassign\n        child.value.parent = parent;\n      });\n    }\n\n    return this.hooks.onCreateASTNode.call(baseAst, obj) ?? null;\n  }\n}\n","import type { Asset as AssetType, Expression, Binding } from \"@player-ui/types\";\n\nexport type AnyAssetType = AssetType<string>;\nexport enum NodeType {\n  Asset = \"asset\",\n  View = \"view\",\n  Applicability = \"applicability\",\n  Template = \"template\",\n  Value = \"value\",\n  MultiNode = \"multi-node\",\n  Switch = \"switch\",\n  Async = \"async\",\n  Unknown = \"unknown\",\n  Empty = \"empty\",\n}\nexport declare namespace Node {\n  export type ChildrenTypes = NodeType.Asset | NodeType.Value | NodeType.View;\n\n  export interface Base<T extends NodeType> {\n    /** Every node contains a type to distinguish it from other nodes */\n    type: T;\n\n    /** Every node (outside of the root) contains a reference to it's parent */\n    parent?: Node;\n  }\n\n  export type PathSegment = string | number;\n\n  export interface Child {\n    /** The path of the child relative to the parent */\n    path: PathSegment[];\n\n    /** If true, the path points to an array, and the value will be appended to it result */\n    array?: boolean;\n\n    /** The child node */\n    value: Node;\n  }\n\n  export interface BaseWithChildren<T extends NodeType> extends Base<T> {\n    /** Any node that contains a list of children underneath it */\n    children?: Child[];\n  }\n\n  export interface Asset<T extends AnyAssetType = AnyAssetType>\n    extends BaseWithChildren<NodeType.Asset>,\n      PluginOptions {\n    /** Any asset nested within a view */\n    value: T;\n  }\n\n  export interface View<T extends AnyAssetType = AnyAssetType>\n    extends BaseWithChildren<NodeType.View>,\n      PluginOptions {\n    /** The root of the parsed view */\n    value: T;\n  }\n\n  export interface Applicability extends Base<NodeType.Applicability> {\n    /** The expression to execute that determines applicability of the target node */\n    expression: Expression;\n\n    /** The node to use if the expression is truthy */\n    value: Node;\n  }\n\n  export interface Template extends Base<NodeType.Template> {\n    /** The location of an array in the model */\n    data: Binding;\n\n    /** The template to use when mapping over the data */\n    template: unknown;\n\n    /** The number of nested templates so far */\n    depth: number;\n\n    /** should the template recomputed when data changes */\n    dynamic?: boolean;\n  }\n\n  export interface Value\n    extends BaseWithChildren<NodeType.Value>,\n      PluginOptions {\n    /** A simple node representing a value */\n    value: any;\n  }\n\n  export interface MultiNode extends Base<NodeType.MultiNode> {\n    /**\n     * Should this list override the target node if they overlap?\n     * If not amend the existing list\n     */\n    override?: boolean;\n\n    /** A list of values that comprise this node */\n    values: Array<Node>;\n  }\n\n  export interface Switch extends Base<NodeType.Switch> {\n    /** Should this list be re-computed when data changes */\n    dynamic?: boolean;\n\n    /** A list of cases to evaluate in order */\n    cases: SwitchCase[];\n  }\n\n  export interface SwitchCase {\n    /** The expression to evaluate for a single case statement */\n    case: Expression | true;\n    /** The value to use if this case is true */\n    value: Value;\n  }\n\n  export interface Async extends Base<NodeType.Async> {\n    /** The unique id of the node */\n    id: string;\n    /** The value representing the node */\n    value: Node;\n  }\n\n  export interface PluginOptions {\n    /** A list of plugins */\n    plugins?: {\n      /** StringResolverPlugin options */\n      stringResolver?: {\n        /**\n         * An optional array of node properties to skip during string resolution\n         * Specified in the AssetTransformPlugin\n         */\n        propertiesToSkip?: string[];\n      };\n    };\n  }\n\n  export type Unknown = Base<NodeType.Unknown>;\n  export type Empty = Base<NodeType.Empty>;\n  export type ViewOrAsset = View | Asset;\n\n  export type Node =\n    | Asset\n    | Applicability\n    | Template\n    | Value\n    | View\n    | MultiNode\n    | Switch\n    | Async\n    | Unknown\n    | Empty;\n}\n","import type { Node } from \"./types\";\n\n/** Check to see if the object contains async */\nexport function hasAsync(obj: object): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, \"async\");\n}\n\n/** Get the ID of the Node if there is one */\nexport function getNodeID(node?: Node.Node | null): string | undefined {\n  if (!node) {\n    return;\n  }\n\n  if (\n    \"value\" in node &&\n    typeof node.value === \"object\" &&\n    typeof node.value?.id === \"string\"\n  ) {\n    return node.value.id;\n  }\n}\n","import type { BindingInstance, BindingLike } from \"../../binding\";\nimport { isBinding } from \"../../binding\";\nimport type { ExpressionType } from \"../../expressions\";\nimport type { Resolve } from \"./types\";\n\n/** Check to see if and of the data-changes affect the given dependencies  */\nexport function caresAboutDataChanges(\n  dataChanges?: Set<BindingInstance>,\n  dependencies?: Set<BindingInstance>,\n) {\n  if (!dataChanges || !dependencies) {\n    return true;\n  }\n\n  const depArray = Array.from(dependencies.values());\n  const dataChangeArray = Array.from(dataChanges.values());\n\n  return (\n    depArray.find(\n      (dep) =>\n        !!dataChangeArray.find(\n          (change) =>\n            change === dep || change.contains(dep) || dep.contains(change),\n        ),\n    ) !== undefined\n  );\n}\n\n/** Convert the options object for a resolver to one for a node */\nexport function toNodeResolveOptions(\n  resolverOptions: Resolve.ResolverOptions,\n): Resolve.NodeResolveOptions {\n  return {\n    ...resolverOptions,\n    data: {\n      model: resolverOptions.model,\n      formatValue: (ref, value) => {\n        if (resolverOptions.formatValue) {\n          return resolverOptions.formatValue(ref, value);\n        }\n\n        return value;\n      },\n      format: (bindingLike: BindingLike, value: any) =>\n        resolverOptions.format\n          ? resolverOptions.format(\n              isBinding(bindingLike)\n                ? bindingLike\n                : resolverOptions.parseBinding(bindingLike),\n              value,\n            )\n          : value,\n    },\n    evaluate: (exp: ExpressionType) =>\n      resolverOptions.evaluator.evaluate(exp, resolverOptions),\n  };\n}\n\n/**\n * helper function to flatten a potential nested array and combine with initial array\n */\nexport function unpackAndPush(item: any | any[], initial: any[]) {\n  if (Array.isArray(item)) {\n    item.forEach((i) => {\n      unpackAndPush(i, initial);\n    });\n  } else {\n    initial.push(item);\n  }\n}\n","import { SyncHook } from \"tapable-ts\";\nimport type { View as ViewType } from \"@player-ui/types\";\nimport type { BindingInstance, BindingFactory } from \"../binding\";\nimport type { ValidationProvider, ValidationObject } from \"../validator\";\nimport type { Logger } from \"../logger\";\nimport type { Resolve } from \"./resolver\";\nimport { Resolver, toNodeResolveOptions } from \"./resolver\";\nimport type { Node } from \"./parser\";\nimport { Parser } from \"./parser\";\nimport {\n  TemplatePlugin,\n  StringResolverPlugin,\n  ApplicabilityPlugin,\n  SwitchPlugin,\n} from \"./plugins\";\n\n/**\n * Manages the view level validations\n */\nclass CrossfieldProvider implements ValidationProvider {\n  private allValidations = new Set<ValidationObject>();\n  private byBinding = new Map<BindingInstance, Array<ValidationObject>>();\n  private logger?: Logger;\n\n  constructor(initialView: ViewType, parser: BindingFactory, logger?: Logger) {\n    this.logger = logger;\n    this.parse(initialView, parser);\n  }\n\n  private parse(contentView: ViewType, parser: BindingFactory) {\n    const xfieldRefs = contentView.validation;\n\n    if (xfieldRefs === undefined) {\n      return;\n    }\n\n    if (!Array.isArray(xfieldRefs)) {\n      this.logger?.warn(\n        `Unable to register view validations for id: ${contentView.id}. 'validation' property must be an Array.`,\n      );\n\n      return;\n    }\n\n    // Grab the validations from the view (as authored) and parse out the ones that have a _ref_ (to a binding)\n    // Group them all by binding to make it easier to return than later\n\n    xfieldRefs.forEach((vRef) => {\n      // x-field validations by default are triggered by navigating away from the page\n      // the reference can also override that _or_ the severity\n      const withDefaults: ValidationObject = {\n        trigger: \"navigation\",\n        severity: \"error\",\n        ...vRef,\n      };\n\n      this.allValidations.add(withDefaults);\n\n      // The validation reference contains a _ref_ (a binding)\n      const { ref } = vRef;\n\n      if (ref) {\n        /** Group together validations by binding */\n        const parsed = parser(ref);\n\n        if (this.byBinding.has(parsed)) {\n          this.byBinding.get(parsed)?.push(withDefaults);\n        } else {\n          this.byBinding.set(parsed, [withDefaults]);\n        }\n      }\n    });\n  }\n\n  getValidationsForBinding(binding: BindingInstance) {\n    return this.byBinding.get(binding);\n  }\n}\n\n/** A stateful view instance from an content */\nexport class ViewInstance implements ValidationProvider {\n  public hooks = {\n    onUpdate: new SyncHook<[ViewType]>(),\n    parser: new SyncHook<[Parser]>(),\n    resolver: new SyncHook<[Resolver]>(),\n    onTemplatePluginCreated: new SyncHook<[TemplatePlugin]>(),\n    templatePlugin: new SyncHook<[TemplatePlugin]>(),\n  };\n\n  private resolver?: Resolver;\n  public readonly initialView: ViewType;\n  public readonly resolverOptions: Resolve.ResolverOptions;\n  private rootNode?: Node.Node;\n\n  private validationProvider?: CrossfieldProvider;\n\n  private templatePlugin: TemplatePlugin | undefined;\n\n  // TODO might want to add a version/timestamp to this to compare updates\n  public lastUpdate: Record<string, any> | undefined;\n\n  constructor(initialView: ViewType, resolverOptions: Resolve.ResolverOptions) {\n    this.initialView = initialView;\n    this.resolverOptions = resolverOptions;\n    this.hooks.onTemplatePluginCreated.tap(\"view\", (templatePlugin) => {\n      this.templatePlugin = templatePlugin;\n    });\n  }\n\n  public updateAsync() {\n    const update = this.resolver?.update();\n    this.lastUpdate = update;\n    this.hooks.onUpdate.call(update);\n  }\n\n  public update(changes?: Set<BindingInstance>) {\n    if (this.rootNode === undefined) {\n      /** On initialization of the view, also create a validation parser */\n      this.validationProvider = new CrossfieldProvider(\n        this.initialView,\n        this.resolverOptions.parseBinding,\n        this.resolverOptions.logger,\n      );\n\n      if (this.templatePlugin) {\n        this.hooks.templatePlugin.call(this.templatePlugin);\n      } else {\n        this.resolverOptions.logger?.warn(\n          \"templatePlugin not set for View, legacy templates may not work\",\n        );\n      }\n\n      const parser = new Parser();\n      this.hooks.parser.call(parser);\n      this.rootNode = parser.parseView(this.initialView);\n\n      this.resolver = new Resolver(this.rootNode, {\n        ...this.resolverOptions,\n        parseNode: parser.parseObject.bind(parser),\n      });\n      this.hooks.resolver.call(this.resolver);\n    }\n\n    const update = this.resolver?.update(changes);\n\n    if (this.lastUpdate === update) {\n      return this.lastUpdate;\n    }\n\n    this.lastUpdate = update;\n    this.hooks.onUpdate.call(update);\n\n    return update;\n  }\n\n  getValidationsForBinding(binding: BindingInstance) {\n    return this.validationProvider?.getValidationsForBinding(binding);\n  }\n}\n\n/** A plugin for a view */\nexport interface ViewPlugin {\n  /** Called with a view instance */\n  apply(view: ViewInstance): void;\n}\n","import type { Node, AnyAssetType } from \"../parser\";\nimport { NodeType } from \"../parser\";\n\n/**\n * Functions for building AST nodes (relatively) easily\n */\nexport class Builder {\n  /**\n   * Creates an asset node\n   *\n   * @param value - the value to put in the asset node\n   */\n  static asset<T extends AnyAssetType>(value: T): Node.Asset<T> {\n    return {\n      type: NodeType.Asset,\n      value,\n    };\n  }\n\n  /**\n   * Creates a value node\n   *\n   * @param v - The object to put in the value node\n   */\n  static value(v?: object): Node.Value {\n    return {\n      type: NodeType.Value,\n      value: v,\n    };\n  }\n\n  /**\n   * Creates a multiNode and associates the multiNode as the parent\n   * of all the value nodes\n   *\n   * @param values - the value or applicability nodes to put in the multinode\n   */\n  static multiNode(\n    ...values: (Node.Value | Node.Applicability)[]\n  ): Node.MultiNode {\n    const m: Node.MultiNode = {\n      type: NodeType.MultiNode,\n      override: true,\n      values,\n    };\n\n    values.forEach((v) => {\n      // eslint-disable-next-line no-param-reassign\n      v.parent = m;\n    });\n\n    return m;\n  }\n\n  /**\n   * Adds a child node to a node\n   *\n   * @param node - The node to add a child to\n   * @param path - The path at which to add the child\n   * @param child - The child node\n   */\n  static addChild<N extends Node.BaseWithChildren<NT>, NT extends NodeType>(\n    node: N,\n    path: Node.PathSegment | Node.PathSegment[],\n    child: Node.Node,\n  ) {\n    // eslint-disable-next-line no-param-reassign\n    child.parent = node as Node.Node;\n\n    const newChild: Node.Child = {\n      path: Array.isArray(path) ? path : [path],\n      value: child,\n    };\n\n    // eslint-disable-next-line no-param-reassign\n    node.children = node.children || [];\n    node.children.push(newChild);\n\n    return node;\n  }\n}\n","import { SyncWaterfallHook } from \"tapable-ts\";\nimport type { Node, ParseObjectOptions, Parser } from \"../parser\";\nimport { NodeType } from \"../parser\";\nimport type { Options } from \"./options\";\nimport type { Resolver } from \"../resolver\";\nimport { ViewInstance, ViewPlugin } from \"../view\";\n\nexport interface TemplateItemInfo {\n  /** The index of the data for the current iteration of the template */\n  index: number;\n  /** The data for the current iteration of the template */\n  data: any;\n  /** The depth of the template node */\n  depth: number;\n}\n\nexport interface TemplateSubstitution {\n  /** Regular expression to find and replace. The global flag will be always be added to this expression. */\n  expression: string | RegExp;\n  /** The value to replace matches with. */\n  value: string;\n}\n\nexport type TemplateSubstitutionsFunc = (\n  baseSubstitutions: TemplateSubstitution[],\n  templateItemInfo: TemplateItemInfo,\n) => TemplateSubstitution[];\n\n/** A view plugin to resolve/manage templates */\nexport default class TemplatePlugin implements ViewPlugin {\n  private readonly options: Options;\n\n  hooks = {\n    resolveTemplateSubstitutions: new SyncWaterfallHook<\n      [TemplateSubstitution[], TemplateItemInfo]\n    >(),\n  };\n\n  constructor(options: Options) {\n    this.options = options;\n  }\n\n  private parseTemplate(\n    parseObject: any,\n    node: Node.Template,\n    options: Options,\n  ): Node.Node | null {\n    const { template, depth } = node;\n    const data = options.data.model.get(node.data);\n\n    if (!data) {\n      return null;\n    }\n\n    if (!Array.isArray(data)) {\n      throw new Error(`Template using '${node.data}' but is not an array`);\n    }\n\n    const values: Array<Node.Node> = [];\n\n    data.forEach((dataItem, index) => {\n      const templateSubstitutions =\n        this.hooks.resolveTemplateSubstitutions.call(\n          [\n            {\n              expression: new RegExp(`_index${depth || \"\"}_`),\n              value: String(index),\n            },\n          ],\n          {\n            depth,\n            data: dataItem,\n            index,\n          },\n        );\n      let templateStr = JSON.stringify(template);\n\n      for (const { expression, value } of templateSubstitutions) {\n        let flags = \"g\";\n        if (typeof expression === \"object\") {\n          flags = `${expression.flags}${expression.global ? \"\" : \"g\"}`;\n        }\n\n        templateStr = templateStr.replace(new RegExp(expression, flags), value);\n      }\n\n      const parsed = parseObject(JSON.parse(templateStr), NodeType.Value, {\n        templateDepth: node.depth + 1,\n      });\n\n      if (parsed) {\n        values.push(parsed);\n      }\n    });\n\n    const result: Node.MultiNode = {\n      type: NodeType.MultiNode,\n      override: false,\n      values,\n    };\n\n    return result;\n  }\n\n  applyParser(parser: Parser) {\n    parser.hooks.onCreateASTNode.tap(\"template\", (node) => {\n      if (node && node.type === NodeType.Template && !node.dynamic) {\n        return this.parseTemplate(\n          parser.parseObject.bind(parser),\n          node,\n          this.options,\n        );\n      }\n\n      return node;\n    });\n\n    parser.hooks.determineNodeType.tap(\"template\", (obj: any) => {\n      if (obj === \"template\") {\n        return NodeType.Template;\n      }\n    });\n\n    parser.hooks.parseNode.tap(\n      \"template\",\n      (\n        obj: any,\n        _nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        determinedNodeType: null | NodeType,\n      ) => {\n        if (determinedNodeType === NodeType.Template) {\n          const templateNode = parser.createASTNode(\n            {\n              type: NodeType.Template,\n              depth: options.templateDepth ?? 0,\n              data: obj.data,\n              template: obj.value,\n              dynamic: obj.dynamic ?? false,\n            },\n            obj,\n          );\n\n          if (templateNode) {\n            return templateNode;\n          }\n        }\n      },\n    );\n  }\n\n  applyResolverHooks(resolver: Resolver) {\n    resolver.hooks.beforeResolve.tap(\"template\", (node, options) => {\n      if (node && node.type === NodeType.Template && node.dynamic) {\n        return this.parseTemplate(options.parseNode, node, options);\n      }\n\n      return node;\n    });\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.parser.tap(\"template\", this.applyParser.bind(this));\n    view.hooks.resolver.tap(\"template\", this.applyResolverHooks.bind(this));\n  }\n}\n","import { set } from \"timm\";\nimport { resolveDataRefs } from \"../../string-resolver\";\nimport type { Options } from \"./options\";\nimport type { Node } from \"../parser\";\nimport { NodeType } from \"../parser\";\nimport type { Resolver } from \"../resolver\";\nimport { ViewInstance, ViewPlugin } from \"../view\";\n\n/** Create a function that checks for a start/end sequence in a string */\nconst createPatternMatcher = (start: string, end: string) => {\n  return (testStr: string) => {\n    const startLocation = testStr.indexOf(start);\n\n    if (startLocation === -1) {\n      return false;\n    }\n\n    const endLocation = testStr.indexOf(end);\n\n    if (endLocation === -1) {\n      return false;\n    }\n\n    return startLocation < endLocation;\n  };\n};\n\nconst bindingResolveLookup = createPatternMatcher(\"{{\", \"}}\");\nconst expressionResolveLookup = createPatternMatcher(\"@[\", \"]@\");\n\n/** Check to see if a string contains a reference to dynamic content */\nfunction hasSomethingToResolve(str: string) {\n  return bindingResolveLookup(str) || expressionResolveLookup(str);\n}\n\n/** Resolve data refs in a string if necessary. */\nfunction resolveString(str: string, resolveOptions: Options) {\n  return hasSomethingToResolve(str)\n    ? resolveDataRefs(str, {\n        model: resolveOptions.data.model,\n        evaluate: resolveOptions.evaluate,\n      })\n    : str;\n}\n\n/** Recursively resolve all string references in an object or array */\nexport function resolveAllRefs(\n  node: any,\n  resolveOptions: Options,\n  propertiesToSkip: Set<string | number>,\n): any {\n  if (\n    node === null ||\n    node === undefined ||\n    (typeof node !== \"object\" && typeof node !== \"string\")\n  ) {\n    return node;\n  }\n\n  if (typeof node === \"string\") {\n    return resolveString(node, resolveOptions);\n  }\n\n  let newNode = node;\n\n  Object.keys(node).forEach((key: string | number) => {\n    if (propertiesToSkip.has(key)) {\n      return;\n    }\n\n    const val = node[key];\n\n    let newVal = val;\n\n    if (typeof val === \"object\") {\n      newVal = resolveAllRefs(val, resolveOptions, propertiesToSkip);\n    } else if (typeof val === \"string\") {\n      newVal = resolveString(val, resolveOptions);\n    }\n\n    if (newVal !== val) {\n      newNode = set(newNode, key as any, newVal);\n    }\n  });\n\n  return newNode;\n}\n\n/** Traverse up the node tree finding the first available 'path' */\nconst findBasePath = (\n  node: Node.Node,\n  resolver: Resolver,\n): Node.PathSegment[] => {\n  const parentNode = node.parent;\n  if (!parentNode) {\n    return [];\n  }\n\n  if (\"children\" in parentNode) {\n    const original = resolver.getSourceNode(node);\n    return (\n      parentNode.children?.find((child) => child.value === original)?.path ?? []\n    );\n  }\n\n  if (parentNode.type !== NodeType.MultiNode) {\n    return [];\n  }\n\n  return findBasePath(parentNode, resolver);\n};\n\n/** A plugin that resolves all string references for each node */\nexport default class StringResolverPlugin implements ViewPlugin {\n  private propertiesToSkipCache: Map<string, Set<string>>;\n\n  constructor() {\n    this.propertiesToSkipCache = new Map();\n  }\n\n  applyResolver(resolver: Resolver) {\n    resolver.hooks.resolve.tap(\"string-resolver\", (value, node, options) => {\n      if (node.type === NodeType.Empty || node.type === NodeType.Unknown) {\n        return null;\n      }\n\n      if (\n        node.type === NodeType.Value ||\n        node.type === NodeType.Asset ||\n        node.type === NodeType.View\n      ) {\n        /** Use specified properties to skip during string resolution, or default */\n        let propsToSkip: Set<string>;\n        if (node.type === NodeType.Asset || node.type === NodeType.View) {\n          propsToSkip = new Set(\n            node.plugins?.stringResolver?.propertiesToSkip ?? [\"exp\"],\n          );\n          if (node.value?.id) {\n            this.propertiesToSkipCache.set(node.value.id, propsToSkip);\n          }\n        } else if (\n          node.parent?.type === NodeType.MultiNode &&\n          (node.parent?.parent?.type === NodeType.Asset ||\n            node.parent?.parent?.type === NodeType.View) &&\n          node.parent.parent.value?.id &&\n          this.propertiesToSkipCache.has(node.parent.parent.value.id)\n        ) {\n          propsToSkip = this.propertiesToSkipCache.get(\n            node.parent.parent.value.id,\n          ) as Set<string>;\n        } else {\n          propsToSkip = new Set([\"exp\"]);\n        }\n\n        const nodePath = findBasePath(node, resolver);\n\n        /** If the path includes something that is supposed to be skipped, this node should be skipped too. */\n        if (\n          nodePath.length > 0 &&\n          nodePath.some((segment) => propsToSkip.has(segment.toString()))\n        ) {\n          return node.value;\n        }\n\n        return resolveAllRefs(node.value, options, propsToSkip);\n      }\n\n      return value;\n    });\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.resolver.tap(\"string-resolver\", this.applyResolver.bind(this));\n  }\n}\n","import { omit } from \"timm\";\nimport type { Options } from \"./options\";\nimport type { Resolver } from \"../resolver\";\nimport type { Node, ParseObjectOptions, Parser } from \"../parser\";\nimport { NodeType } from \"../parser\";\nimport { ViewInstance, ViewPlugin } from \"../view\";\n\n/** A view plugin to remove inapplicable assets from the tree */\nexport default class ApplicabilityPlugin implements ViewPlugin {\n  applyResolver(resolver: Resolver) {\n    resolver.hooks.beforeResolve.tap(\n      \"applicability\",\n      (node: Node.Node | null, options: Options) => {\n        let newNode = node;\n\n        if (node?.type === NodeType.Applicability) {\n          const isApplicable = options.evaluate(node.expression);\n\n          if (isApplicable === false) {\n            return null;\n          }\n\n          newNode = node.value;\n        }\n\n        return newNode;\n      },\n    );\n  }\n\n  applyParser(parser: Parser) {\n    /** Switches resolved during the parsing phase are static */\n    parser.hooks.determineNodeType.tap(\"applicability\", (obj: any) => {\n      if (Object.prototype.hasOwnProperty.call(obj, \"applicability\")) {\n        return NodeType.Applicability;\n      }\n    });\n\n    parser.hooks.parseNode.tap(\n      \"applicability\",\n      (\n        obj: any,\n        nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        determinedNodeType: null | NodeType,\n      ) => {\n        if (determinedNodeType === NodeType.Applicability) {\n          const parsedApplicability = parser.parseObject(\n            omit(obj, \"applicability\"),\n            nodeType,\n            options,\n          );\n          if (parsedApplicability !== null) {\n            const applicabilityNode = parser.createASTNode(\n              {\n                type: NodeType.Applicability,\n                expression: (obj as any).applicability,\n                value: parsedApplicability,\n              },\n              obj,\n            );\n\n            if (applicabilityNode?.type === NodeType.Applicability) {\n              applicabilityNode.value.parent = applicabilityNode;\n            }\n\n            return applicabilityNode;\n          }\n        }\n      },\n    );\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.resolver.tap(\"applicability\", this.applyResolver.bind(this));\n    view.hooks.parser.tap(\"applicability\", this.applyParser.bind(this));\n  }\n}\n","import type { Options } from \"./options\";\nimport type { Parser, Node, ParseObjectOptions } from \"../parser\";\nimport { EMPTY_NODE, NodeType } from \"../parser\";\nimport type { Resolver } from \"../resolver\";\nimport { ViewInstance, ViewPlugin } from \"../view\";\n\n/** A view plugin to resolve switches */\nexport default class SwitchPlugin implements ViewPlugin {\n  private readonly options: Options;\n\n  constructor(options: Options) {\n    this.options = options;\n  }\n\n  private resolveSwitch(node: Node.Switch, options: Options): Node.Node {\n    for (const switchCase of node.cases) {\n      const isApplicable = options.evaluate(switchCase.case);\n      if (isApplicable) {\n        return switchCase.value;\n      }\n    }\n\n    return EMPTY_NODE;\n  }\n\n  applyParser(parser: Parser) {\n    /** Switches resolved during the parsing phase are static */\n    parser.hooks.onCreateASTNode.tap(\"switch\", (node) => {\n      if (node && node.type === NodeType.Switch && !node.dynamic) {\n        return this.resolveSwitch(node, this.options);\n      }\n\n      return node;\n    });\n\n    parser.hooks.determineNodeType.tap(\"switch\", (obj) => {\n      if (\n        Object.prototype.hasOwnProperty.call(obj, \"dynamicSwitch\") ||\n        Object.prototype.hasOwnProperty.call(obj, \"staticSwitch\")\n      ) {\n        return NodeType.Switch;\n      }\n    });\n\n    parser.hooks.parseNode.tap(\n      \"switch\",\n      (\n        obj: any,\n        _nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        determinedNodeType: null | NodeType,\n      ) => {\n        if (determinedNodeType === NodeType.Switch) {\n          const dynamic = \"dynamicSwitch\" in obj;\n          const switchContent =\n            \"dynamicSwitch\" in obj ? obj.dynamicSwitch : obj.staticSwitch;\n\n          const cases: Node.SwitchCase[] = [];\n\n          switchContent.forEach(\n            (switchCase: {\n              [x: string]: any;\n              /**\n               *\n               */\n              case: any;\n            }) => {\n              const { case: switchCaseExpr, ...switchBody } = switchCase;\n              const value = parser.parseObject(\n                switchBody,\n                NodeType.Value,\n                options,\n              );\n\n              if (value) {\n                cases.push({\n                  case: switchCaseExpr,\n                  value: value as Node.Value,\n                });\n              }\n            },\n          );\n\n          const switchAST = parser.hooks.onCreateASTNode.call(\n            {\n              type: NodeType.Switch,\n              dynamic,\n              cases,\n            },\n            obj,\n          );\n\n          if (switchAST?.type === NodeType.Switch) {\n            switchAST.cases.forEach((sCase) => {\n              // eslint-disable-next-line no-param-reassign\n              sCase.value.parent = switchAST;\n            });\n          }\n\n          if (switchAST?.type === NodeType.Empty) {\n            return null;\n          }\n\n          return switchAST ?? null;\n        }\n      },\n    );\n  }\n\n  applyResolver(resolver: Resolver) {\n    /** Switches resolved during the parsing phase are dynamic */\n    resolver.hooks.beforeResolve.tap(\"switch\", (node, options) => {\n      if (node && node.type === NodeType.Switch && node.dynamic) {\n        return this.resolveSwitch(node, options);\n      }\n\n      return node;\n    });\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.parser.tap(\"switch\", this.applyParser.bind(this));\n    view.hooks.resolver.tap(\"switch\", this.applyResolver.bind(this));\n  }\n}\n","import { setIn } from \"timm\";\nimport deferred from \"p-defer\";\nimport type { Flow as FlowType, FlowResult } from \"@player-ui/types\";\n\nimport { SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport type { Logger } from \"./logger\";\nimport { TapableLogger } from \"./logger\";\nimport type { ExpressionType } from \"./expressions\";\nimport { ExpressionEvaluator } from \"./expressions\";\nimport { SchemaController } from \"./schema\";\nimport { BindingParser } from \"./binding\";\nimport type { ViewInstance } from \"./view\";\nimport { resolveDataRefs } from \"./string-resolver\";\nimport type { FlowInstance } from \"./controllers\";\nimport {\n  ConstantsController,\n  ViewController,\n  DataController,\n  ValidationController,\n  FlowController,\n} from \"./controllers\";\nimport { FlowExpPlugin } from \"./plugins/flow-exp-plugin\";\nimport { DefaultExpPlugin } from \"./plugins/default-exp-plugin\";\nimport type {\n  PlayerFlowState,\n  InProgressState,\n  CompletedState,\n  ErrorState,\n} from \"./types\";\nimport { NOT_STARTED_STATE } from \"./types\";\nimport { DefaultViewPlugin } from \"./plugins/default-view-plugin\";\n\n// Variables injected at build time\nconst PLAYER_VERSION = \"__VERSION__\";\nconst COMMIT = \"__GIT_COMMIT__\";\n\nexport interface PlayerPlugin {\n  /**\n   * Unique identifier of the plugin.\n   * Enables the plugin to be retrievable from Player.\n   */\n  symbol?: symbol;\n\n  /** The name of the plugin */\n  name: string;\n\n  /**\n   * Use this to tap into Player hooks\n   */\n  apply: (player: Player) => void;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ExtendedPlayerPlugin<\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  Assets = void,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  Views = void,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  Expressions = void,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  DataTypes = void,\n> {}\n\nexport interface PlayerConfigOptions {\n  /** A set of plugins to load  */\n  plugins?: PlayerPlugin[];\n\n  /** A logger to use */\n  logger?: Logger;\n}\n\nexport interface PlayerInfo {\n  /** Version of the running player */\n  version: string;\n\n  /** Hash of the HEAD commit used to build the current version */\n  commit: string;\n}\n\n/**\n * This is it.\n */\nexport class Player {\n  public static readonly info: PlayerInfo = {\n    version: PLAYER_VERSION,\n    commit: COMMIT,\n  };\n\n  public readonly logger = new TapableLogger();\n  public readonly constantsController = new ConstantsController();\n  private config: PlayerConfigOptions;\n  private state: PlayerFlowState = NOT_STARTED_STATE;\n\n  public readonly hooks = {\n    /** The hook that fires every time we create a new flowController (a new Content blob is passed in) */\n    flowController: new SyncHook<[FlowController]>(),\n\n    /** The hook that updates/handles views */\n    viewController: new SyncHook<[ViewController]>(),\n\n    /** A hook called every-time there's a new view. This is equivalent to the view hook on the view-controller */\n    view: new SyncHook<[ViewInstance]>(),\n\n    /** Called when an expression evaluator was created */\n    expressionEvaluator: new SyncHook<[ExpressionEvaluator]>(),\n\n    /** The hook that creates and manages data */\n    dataController: new SyncHook<[DataController]>(),\n\n    /** Called after the schema is created for a flow */\n    schema: new SyncHook<[SchemaController]>(),\n\n    /** Manages validations (schema and x-field ) */\n    validationController: new SyncHook<[ValidationController]>(),\n\n    /** Manages parsing binding */\n    bindingParser: new SyncHook<[BindingParser]>(),\n\n    /** A that's called for state changes in the flow execution */\n    state: new SyncHook<[PlayerFlowState]>(),\n\n    /** A hook to access the current flow */\n    onStart: new SyncHook<[FlowType]>(),\n\n    /** A hook for when the flow ends either in success or failure */\n    onEnd: new SyncHook<[]>(),\n    /** Mutate the Content flow before starting */\n    resolveFlowContent: new SyncWaterfallHook<[FlowType]>(),\n  };\n\n  constructor(config?: PlayerConfigOptions) {\n    if (config?.logger) {\n      this.logger.addHandler(config.logger);\n    }\n\n    this.config = config || {};\n    this.config.plugins = [\n      new DefaultExpPlugin(),\n      new DefaultViewPlugin(),\n      ...(this.config.plugins || []),\n      new FlowExpPlugin(),\n    ];\n    this.config.plugins?.forEach((plugin) => {\n      plugin.apply(this);\n    });\n  }\n\n  /**  Returns currently registered plugins */\n  public getPlugins(): PlayerPlugin[] {\n    return this.config.plugins ?? [];\n  }\n\n  /** Find instance of [Plugin] that has been registered to Player */\n  public findPlugin<Plugin extends PlayerPlugin>(\n    symbol: symbol,\n  ): Plugin | undefined {\n    return this.config.plugins?.find((el) => el.symbol === symbol) as Plugin;\n  }\n\n  /** Retrieve an instance of [Plugin] and conditionally invoke [apply] if it exists */\n  public applyTo<Plugin extends PlayerPlugin>(\n    symbol: symbol,\n    apply: (plugin: Plugin) => void,\n  ): void {\n    const plugin = this.findPlugin<Plugin>(symbol);\n\n    if (plugin) {\n      apply(plugin);\n    }\n  }\n\n  /** Register and apply [Plugin] if one with the same symbol is not already registered. */\n  public registerPlugin(plugin: PlayerPlugin) {\n    plugin.apply(this);\n    this.config.plugins?.push(plugin);\n  }\n\n  /** Returns the current version of the running player */\n  public getVersion(): string {\n    return Player.info.version;\n  }\n\n  /** Returns the git commit used to build Player version */\n  public getCommit(): string {\n    return Player.info.commit;\n  }\n\n  /**\n   * Fetch the current state of Player.\n   * It will return either `not-started`, `in-progress`, `completed`\n   * with some extra data in each\n   */\n  public getState(): PlayerFlowState {\n    return this.state;\n  }\n\n  /**\n   * A private means of setting the state of Player\n   * Calls the hooks for subscribers to listen for this event\n   */\n  private setState(state: PlayerFlowState) {\n    this.state = state;\n    this.hooks.state.call(state);\n  }\n\n  /** Start Player with the given flow */\n  private setupFlow(userContent: FlowType): {\n    /** a callback to _actually_ start the flow */\n    start: () => void;\n\n    /** the state object to kick if off */\n    state: Omit<InProgressState, \"ref\">;\n  } {\n    const userFlow = this.hooks.resolveFlowContent.call(userContent);\n\n    const flowController = new FlowController(userFlow.navigation, {\n      logger: this.logger,\n    });\n\n    this.hooks.onStart.call(userFlow);\n\n    this.hooks.flowController.call(flowController);\n\n    // eslint-disable-next-line prefer-const\n    let expressionEvaluator: ExpressionEvaluator;\n    // eslint-disable-next-line prefer-const\n    let dataController: DataController;\n\n    const pathResolver = new BindingParser({\n      get: (binding) => {\n        return dataController.get(binding);\n      },\n      set: (transaction) => {\n        return dataController.set(transaction);\n      },\n      evaluate: (expression) => {\n        return expressionEvaluator.evaluate(expression);\n      },\n    });\n\n    this.hooks.bindingParser.call(pathResolver);\n    const parseBinding = pathResolver.parse;\n    const flowResultDeferred = deferred<FlowResult>();\n\n    const schema = new SchemaController(userFlow.schema);\n    this.hooks.schema.call(schema);\n\n    const validationController = new ValidationController(schema);\n\n    this.hooks.validationController.call(validationController);\n\n    dataController = new DataController(userFlow.data, {\n      pathResolver,\n      middleware: validationController.getDataMiddleware(),\n      logger: this.logger,\n    });\n\n    dataController.hooks.format.tap(\"player\", (value, binding) => {\n      const formatter = schema.getFormatter(binding);\n\n      return formatter ? formatter.format(value) : value;\n    });\n\n    dataController.hooks.deformat.tap(\"player\", (value, binding) => {\n      const formatter = schema.getFormatter(binding);\n\n      return formatter ? formatter.deformat(value) : value;\n    });\n\n    dataController.hooks.resolveDefaultValue.tap(\n      \"player\",\n      (binding) => schema.getApparentType(binding)?.default,\n    );\n\n    // eslint-disable-next-line prefer-const\n    let viewController: ViewController;\n\n    expressionEvaluator = new ExpressionEvaluator({\n      model: dataController,\n      logger: this.logger,\n    });\n\n    this.hooks.expressionEvaluator.call(expressionEvaluator);\n\n    expressionEvaluator.hooks.onError.tap(\"player\", (e) => {\n      flowResultDeferred.reject(e);\n\n      return true;\n    });\n\n    /** Resolve any data references in a string */\n    function resolveStrings<T>(val: T, formatted?: boolean) {\n      return resolveDataRefs(val, {\n        model: dataController,\n        evaluate: expressionEvaluator.evaluate,\n        formatted,\n      });\n    }\n\n    flowController.hooks.flow.tap(\"player\", (flow: FlowInstance) => {\n      flow.hooks.beforeTransition.tap(\"player\", (state, transitionVal) => {\n        /** Checks to see if there are any transitions for a specific transition state (i.e. next, back). If not, it will default to * */\n        const computedTransitionVal = state.transitions[transitionVal]\n          ? transitionVal\n          : \"*\";\n        if (state.onEnd && state.transitions[computedTransitionVal]) {\n          if (typeof state.onEnd === \"object\" && \"exp\" in state.onEnd) {\n            expressionEvaluator?.evaluate(state.onEnd.exp);\n          } else {\n            expressionEvaluator?.evaluate(state.onEnd as ExpressionType);\n          }\n        }\n\n        /** If the transition does not exist, then do not resolve any expressions */\n        if (\n          !(\"transitions\" in state) ||\n          !state.transitions[computedTransitionVal]\n        ) {\n          return state;\n        }\n\n        /** resolves and sets the transition to the computed exp */\n        return setIn(\n          state,\n          [\"transitions\", computedTransitionVal],\n          resolveStrings(state.transitions[computedTransitionVal]),\n        ) as any;\n      });\n\n      flow.hooks.skipTransition.tap(\"validation\", (currentState) => {\n        if (currentState?.value.state_type === \"VIEW\") {\n          const { canTransition, validations } =\n            validationController.validateView(\"navigation\");\n\n          if (!canTransition && validations) {\n            const bindings = new Set(validations.keys());\n            viewController?.currentView?.update(bindings);\n\n            return true;\n          }\n        }\n\n        return undefined;\n      });\n\n      flow.hooks.resolveTransitionNode.tap(\"player\", (state) => {\n        let newState = state;\n\n        if (\"ref\" in state) {\n          newState = setIn(state, [\"ref\"], resolveStrings(state.ref)) as any;\n        }\n\n        if (\"param\" in state) {\n          newState = setIn(\n            state,\n            [\"param\"],\n            resolveStrings(state.param, false),\n          ) as any;\n        }\n\n        return newState;\n      });\n\n      flow.hooks.transition.tap(\"player\", (_oldState, newState) => {\n        if (newState.value.state_type !== \"VIEW\") {\n          validationController.reset();\n        }\n      });\n\n      flow.hooks.afterTransition.tap(\"player\", (flowInstance) => {\n        const value = flowInstance.currentState?.value;\n        if (value && value.state_type === \"ACTION\") {\n          const { exp } = value;\n          flowController?.transition(\n            String(expressionEvaluator?.evaluate(exp)),\n          );\n        }\n\n        expressionEvaluator.reset();\n      });\n    });\n\n    this.hooks.dataController.call(dataController);\n\n    validationController.setOptions({\n      parseBinding,\n      model: dataController,\n      logger: this.logger,\n      evaluate: expressionEvaluator.evaluate,\n      constants: this.constantsController,\n    });\n\n    viewController = new ViewController(userFlow.views || [], {\n      evaluator: expressionEvaluator,\n      parseBinding,\n      transition: flowController.transition,\n      model: dataController,\n      utils: {\n        findPlugin: <Plugin = unknown>(pluginSymbol: symbol) => {\n          return this.findPlugin(pluginSymbol) as unknown as Plugin;\n        },\n      },\n      logger: this.logger,\n      flowController,\n      schema,\n      format: (binding, value) => {\n        const formatter = schema.getFormatter(binding);\n\n        return formatter?.format ? formatter.format(value) : value;\n      },\n      formatValue: (ref, value) => {\n        const formatter = schema.getFormatterForType(ref);\n\n        return formatter?.format ? formatter.format(value) : value;\n      },\n      validation: {\n        ...validationController.forView(parseBinding),\n        type: (b) => schema.getType(parseBinding(b)),\n      },\n      constants: this.constantsController,\n    });\n    viewController.hooks.view.tap(\"player\", (view) => {\n      validationController.onView(view);\n      this.hooks.view.call(view);\n    });\n    this.hooks.viewController.call(viewController);\n\n    return {\n      start: () => {\n        flowController\n          .start()\n          .then((endState) => {\n            const flowResult: FlowResult = {\n              endState: resolveStrings(endState, false),\n              data: dataController.serialize(),\n            };\n\n            return flowResult;\n          })\n          .then(flowResultDeferred.resolve)\n          .catch((e) => {\n            this.logger.error(`Something went wrong: ${e.message}`);\n            throw e;\n          })\n          .catch(flowResultDeferred.reject)\n          .finally(() => this.hooks.onEnd.call());\n      },\n      state: {\n        status: \"in-progress\",\n        flowResult: flowResultDeferred.promise,\n        controllers: {\n          data: dataController,\n          view: viewController,\n          flow: flowController,\n          schema,\n          expression: expressionEvaluator,\n          binding: pathResolver,\n          validation: validationController,\n        },\n        fail: flowResultDeferred.reject,\n        flow: userFlow,\n        logger: this.logger,\n      },\n    };\n  }\n\n  public async start(payload: FlowType): Promise<CompletedState> {\n    const ref = Symbol(payload?.id ?? \"payload\");\n\n    /** A check to avoid updating the state for a flow that's not the current one */\n    const maybeUpdateState = <T extends PlayerFlowState>(newState: T) => {\n      if (this.state.ref !== ref) {\n        this.logger.warn(\n          `Received update for a flow that's not the current one`,\n        );\n\n        return newState;\n      }\n\n      this.setState(newState);\n\n      return newState;\n    };\n\n    this.setState({\n      status: \"not-started\",\n      ref,\n    });\n\n    try {\n      const { state, start } = this.setupFlow(payload);\n      this.setState({\n        ref,\n        ...state,\n      });\n\n      start();\n\n      // common data for the end state\n      // make sure to use the same ref as the starting one\n      const endProps = {\n        ref,\n        status: \"completed\",\n        flow: state.flow,\n        controllers: {\n          data: state.controllers.data.makeReadOnly(),\n        },\n      } as const;\n\n      return maybeUpdateState({\n        ...(await state.flowResult),\n        ...endProps,\n      });\n    } catch (error: any) {\n      const errorState: ErrorState = {\n        status: \"error\",\n        ref,\n        flow: payload,\n        error,\n      };\n\n      maybeUpdateState(errorState);\n\n      throw error;\n    }\n  }\n}\n","import { SyncBailHook, SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport type { DeferredPromise } from \"p-defer\";\nimport defer from \"p-defer\";\nimport type {\n  NavigationFlow,\n  NavigationFlowState,\n  NavigationFlowEndState,\n} from \"@player-ui/types\";\nimport type { Logger } from \"../../logger\";\n\nexport interface NamedState {\n  /** The name of the navigation node */\n  name: string;\n\n  /** The nav node */\n  value: NavigationFlowState;\n}\n\nexport interface TransitionOptions {\n  /** Ignore any validations or other signals preventing the transition from taking place  */\n  force?: boolean;\n}\nexport type TransitionFunction = (\n  name: string,\n  options?: TransitionOptions,\n) => void;\n\n/** The Content navigation state machine */\nexport class FlowInstance {\n  private flow: NavigationFlow;\n  private log?: Logger;\n  private history: string[];\n  private isTransitioning = false;\n  private flowPromise?: DeferredPromise<NavigationFlowEndState>;\n  public readonly id: string;\n  public currentState?: NamedState;\n  public readonly hooks = {\n    beforeStart: new SyncBailHook<[NavigationFlow], NavigationFlow>(),\n\n    /** A callback when the onStart node was present */\n    onStart: new SyncHook<[any]>(),\n\n    /** A callback when the onEnd node was present */\n    onEnd: new SyncHook<[any]>(),\n\n    /** A hook to intercept and block a transition */\n    skipTransition: new SyncBailHook<\n      [NamedState | undefined],\n      boolean | undefined\n    >(),\n\n    /** A chance to manipulate the flow-node used to calculate the given transition used  */\n    beforeTransition: new SyncWaterfallHook<\n      [Exclude<NavigationFlowState, NavigationFlowEndState>, string]\n    >(),\n\n    /** A chance to manipulate the flow-node calculated after a transition */\n    resolveTransitionNode: new SyncWaterfallHook<[NavigationFlowState]>(),\n\n    /** A callback when a transition from 1 state to another was made */\n    transition: new SyncHook<[NamedState | undefined, NamedState]>(),\n\n    /** A callback to run actions after a transition occurs */\n    afterTransition: new SyncHook<[FlowInstance]>(),\n  };\n\n  constructor(\n    id: string,\n    flow: NavigationFlow,\n    options?: {\n      /** Logger instance to use */\n      logger?: Logger;\n    },\n  ) {\n    this.id = id;\n    this.flow = flow;\n    this.log = options?.logger;\n    this.history = [];\n\n    this.hooks.transition.tap(\n      \"startPromise\",\n      async (_oldState, nextState: NamedState) => {\n        const newState = nextState.value;\n\n        if (this.flowPromise && newState.state_type === \"END\") {\n          this.flowPromise.resolve(newState);\n        }\n      },\n    );\n  }\n\n  /** Start the state machine */\n  public async start(): Promise<NavigationFlowEndState> {\n    if (this.flowPromise) {\n      this.log?.warn(\"Already called start for flow\");\n\n      return this.flowPromise.promise;\n    }\n\n    this.flow = this.hooks.beforeStart.call(this.flow) || this.flow;\n\n    if (this.flow.onStart) {\n      this.hooks.onStart.call(this.flow.onStart);\n    }\n\n    const initialState = this.flow.startState;\n\n    if (!initialState) {\n      return Promise.reject(new Error(\"No 'startState' defined for flow\"));\n    }\n\n    this.flowPromise = defer();\n    this.pushHistory(initialState);\n\n    return this.flowPromise.promise;\n  }\n\n  public transition(transitionValue: string, options?: TransitionOptions) {\n    if (this.isTransitioning) {\n      throw new Error(\n        `Transitioning while ongoing transition from ${this.currentState?.name} is in progress is not supported`,\n      );\n    }\n\n    if (this.currentState?.value.state_type === \"END\") {\n      this.log?.warn(\n        `Skipping transition using ${transitionValue}. Already at and END state`,\n      );\n\n      return;\n    }\n\n    if (this.currentState === undefined) {\n      throw new Error(\"Cannot transition when there's no current state\");\n    }\n\n    if (options?.force) {\n      this.log?.debug(`Forced transition. Skipping validation checks`);\n    } else {\n      const skipTransition = this.hooks.skipTransition.call(this.currentState);\n\n      if (skipTransition) {\n        this.log?.debug(\n          `Skipping transition from ${this.currentState.name} b/c hook told us to`,\n        );\n        return;\n      }\n    }\n\n    const state = this.hooks.beforeTransition.call(\n      this.currentState.value,\n      transitionValue,\n    );\n\n    if (!(\"transitions\" in state)) {\n      throw new Error(`No transitions defined for ${this.currentState.value}`);\n    }\n\n    const { transitions } = state;\n    const nextState = transitions[transitionValue] || transitions[\"*\"];\n\n    if (nextState === undefined) {\n      this.log?.warn(\n        `No transition from ${this.currentState.name} using ${transitionValue} or *`,\n      );\n\n      return;\n    }\n\n    this.log?.debug(\n      `Transitioning from ${this.currentState.name} to ${nextState} using ${transitionValue} `,\n    );\n\n    return this.pushHistory(nextState, options);\n  }\n\n  private pushHistory(stateName: string, options?: TransitionOptions) {\n    if (!Object.prototype.hasOwnProperty.call(this.flow, stateName)) {\n      throw new Error(`No flow definition for: ${stateName} was found.`);\n    }\n\n    let nextState = this.flow[stateName];\n\n    if (\n      !this.flow[stateName] ||\n      typeof nextState !== \"object\" ||\n      !(\"state_type\" in nextState)\n    ) {\n      this.log?.error(`Flow doesn't contain any states named: ${stateName}`);\n\n      return;\n    }\n\n    const prevState = this.currentState;\n\n    this.isTransitioning = true;\n    nextState = this.hooks.resolveTransitionNode.call(nextState);\n\n    const newCurrentState = {\n      name: stateName,\n      value: nextState,\n    } as NamedState;\n    this.currentState = newCurrentState;\n    this.history.push(stateName);\n\n    // If the new state is an END state call the `onEnd` if it exists\n\n    if (newCurrentState.value.state_type === \"END\" && this.flow.onEnd) {\n      this.hooks.onEnd.call(this.flow.onEnd);\n    }\n\n    this.hooks.transition.call(prevState, {\n      ...newCurrentState,\n    });\n\n    this.isTransitioning = false;\n\n    this.hooks.afterTransition.call(this);\n  }\n}\n","import { SyncHook } from \"tapable-ts\";\nimport type { Navigation, NavigationFlowEndState } from \"@player-ui/types\";\nimport type { Logger } from \"../../logger\";\nimport type { TransitionOptions } from \"./flow\";\nimport { FlowInstance } from \"./flow\";\n\n/** A manager for the navigation section of a Content blob */\nexport class FlowController {\n  public readonly hooks = {\n    flow: new SyncHook<[FlowInstance]>(),\n  };\n\n  private readonly log?: Logger;\n  private navigation: Navigation;\n  private navStack: FlowInstance[];\n  public current?: FlowInstance;\n\n  constructor(\n    navigation: Navigation,\n    options?: {\n      /** A logger instance to use */\n      logger?: Logger;\n    },\n  ) {\n    this.navigation = navigation;\n    this.navStack = [];\n    this.log = options?.logger;\n\n    this.start = this.start.bind(this);\n    this.run = this.run.bind(this);\n    this.transition = this.transition.bind(this);\n    this.addNewFlow = this.addNewFlow.bind(this);\n  }\n\n  /** Navigate to another state in the state-machine */\n  public transition(stateTransition: string, options?: TransitionOptions) {\n    if (this.current === undefined) {\n      throw new Error(\"Not currently in a flow. Cannot transition.\");\n    }\n\n    this.current.transition(stateTransition, options);\n  }\n\n  private addNewFlow(flow: FlowInstance) {\n    this.navStack.push(flow);\n    this.current = flow;\n    this.hooks.flow.call(flow);\n  }\n\n  private async run(startState: string): Promise<NavigationFlowEndState> {\n    if (!Object.prototype.hasOwnProperty.call(this.navigation, startState)) {\n      return Promise.reject(new Error(`No flow defined for: ${startState}`));\n    }\n\n    const startFlow = this.navigation[startState];\n\n    if (startFlow === null || typeof startFlow !== \"object\") {\n      return Promise.reject(\n        new Error(`Flow: ${startState} needs to be an object`),\n      );\n    }\n\n    this.log?.debug(`Starting flow: ${startState}`);\n\n    const flow = new FlowInstance(startState, startFlow, { logger: this.log });\n    this.addNewFlow(flow);\n\n    flow.hooks.afterTransition.tap(\"flow-controller\", (flowInstance) => {\n      if (flowInstance.currentState?.value.state_type === \"FLOW\") {\n        const subflowId = flowInstance.currentState?.value.ref;\n        this.log?.debug(`Loading subflow ${subflowId}`);\n        this.run(subflowId).then((subFlowEndState) => {\n          this.log?.debug(\n            `Subflow ended. Using outcome: ${subFlowEndState.outcome}`,\n          );\n          flowInstance.transition(subFlowEndState?.outcome);\n        });\n      }\n    });\n\n    const end = await flow.start();\n    this.navStack.pop();\n\n    if (this.navStack.length > 0) {\n      const firstItem = 0;\n      this.current = this.navStack[firstItem];\n    }\n\n    return end;\n  }\n\n  public async start(): Promise<NavigationFlowEndState> {\n    if (!this.navigation.BEGIN) {\n      return Promise.reject(new Error(\"Must supply a BEGIN state\"));\n    }\n\n    return this.run(this.navigation.BEGIN);\n  }\n}\n","import type { Validation } from \"@player-ui/types\";\nimport { SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport { setIn } from \"timm\";\n\nimport type { BindingInstance, BindingFactory } from \"../../binding\";\nimport { isBinding } from \"../../binding\";\nimport type { DataModelWithParser, DataModelMiddleware } from \"../../data\";\nimport type { SchemaController } from \"../../schema\";\nimport type {\n  ErrorValidationResponse,\n  ValidationObject,\n  ValidationObjectWithHandler,\n  ValidatorContext,\n  ValidationProvider,\n  ValidationResponse,\n  WarningValidationResponse,\n  StrongOrWeakBinding,\n} from \"../../validator\";\nimport {\n  ValidationMiddleware,\n  ValidatorRegistry,\n  removeBindingAndChildrenFromMap,\n} from \"../../validator\";\nimport type { Logger } from \"../../logger\";\nimport { ProxyLogger } from \"../../logger\";\nimport type { Resolve, ViewInstance } from \"../../view\";\nimport { caresAboutDataChanges } from \"../../view\";\nimport { replaceParams } from \"../../utils\";\nimport { resolveDataRefs } from \"../../string-resolver\";\nimport type {\n  ExpressionEvaluatorOptions,\n  ExpressionType,\n} from \"../../expressions\";\nimport type { BindingTracker } from \"./binding-tracker\";\nimport { ValidationBindingTrackerViewPlugin } from \"./binding-tracker\";\n\nexport const SCHEMA_VALIDATION_PROVIDER_NAME = \"schema\";\nexport const VIEW_VALIDATION_PROVIDER_NAME = \"view\";\n\nexport const VALIDATION_PROVIDER_NAME_SYMBOL: unique symbol = Symbol.for(\n  \"validation-provider-name\",\n);\n\nexport type ValidationObjectWithSource = ValidationObjectWithHandler & {\n  /** The name of the validation */\n  [VALIDATION_PROVIDER_NAME_SYMBOL]: string;\n};\n\ntype SimpleValidatorContext = Omit<\n  ValidatorContext,\n  \"validation\" | \"schemaType\"\n>;\n\ninterface BaseActiveValidation<T> {\n  /** The validation is being actively shown */\n  state: \"active\";\n\n  /** The validation response */\n  response: T;\n}\n\ntype ActiveWarning = BaseActiveValidation<WarningValidationResponse> & {\n  /** Warnings track if they can be dismissed automatically (by navigating) */\n  dismissable: boolean;\n};\ntype ActiveError = BaseActiveValidation<ErrorValidationResponse>;\n\n/**\n * warnings that keep track of their active state\n */\ntype StatefulWarning = {\n  /** A common key to differentiate between errors and warnings */\n  type: \"warning\";\n\n  /** The underlying validation this tracks */\n  value: ValidationObjectWithSource;\n\n  /** If this is currently preventing navigation from continuing */\n  isBlockingNavigation: boolean;\n} & (\n  | {\n      /** warnings start with no state, but can active or dismissed */\n      state: \"none\" | \"dismissed\";\n    }\n  | ActiveWarning\n);\n\n/** Errors that keep track of their state */\ntype StatefulError = {\n  /** A common key to differentiate between errors and warnings */\n  type: \"error\";\n\n  /** The underlying validation this tracks */\n  value: ValidationObjectWithSource;\n\n  /** If this is currently preventing navigation from continuing */\n  isBlockingNavigation: boolean;\n} & (\n  | {\n      /** Errors start with no state an can be activated */\n      state: \"none\";\n    }\n  | ActiveError\n);\n\nexport type StatefulValidationObject = StatefulWarning | StatefulError;\n\n/** Helper function to determin if the subset is within the containingSet */\nfunction isSubset<T>(subset: Set<T>, containingSet: Set<T>): boolean {\n  if (subset.size > containingSet.size) return false;\n  for (const entry of subset) if (!containingSet.has(entry)) return false;\n  return true;\n}\n\n/** Helper for initializing a validation object that tracks state */\nfunction createStatefulValidationObject(\n  obj: ValidationObjectWithSource,\n): StatefulValidationObject {\n  return {\n    value: obj,\n    type: obj.severity,\n    state: \"none\",\n    isBlockingNavigation: false,\n  };\n}\n\ntype ValidationRunner = (obj: ValidationObjectWithHandler) =>\n  | {\n      /** A validation message */\n      message: string;\n    }\n  | undefined;\n\n/** A class that manages validating bindings across phases */\nclass ValidatedBinding {\n  public currentPhase?: Validation.Trigger;\n  private applicableValidations: Array<StatefulValidationObject> = [];\n  private validationsByState: Record<\n    Validation.Trigger,\n    Array<StatefulValidationObject>\n  > = {\n    load: [],\n    change: [],\n    navigation: [],\n  };\n\n  public get allValidations(): Array<StatefulValidationObject> {\n    return Object.values(this.validationsByState).flat();\n  }\n\n  public weakBindings: Set<BindingInstance>;\n\n  private onDismiss?: () => void;\n\n  constructor(\n    possibleValidations: Array<ValidationObjectWithSource>,\n    onDismiss?: () => void,\n    log?: Logger,\n    weakBindings?: Set<BindingInstance>,\n  ) {\n    this.onDismiss = onDismiss;\n    possibleValidations.forEach((vObj) => {\n      const { trigger } = vObj;\n\n      if (this.validationsByState[trigger]) {\n        const statefulValidationObject = createStatefulValidationObject(vObj);\n        this.validationsByState[trigger].push(statefulValidationObject);\n      } else {\n        log?.warn(`Unknown validation trigger: ${trigger}`);\n      }\n    });\n    this.weakBindings = weakBindings ?? new Set();\n  }\n\n  private checkIfBlocking(statefulObj: StatefulValidationObject) {\n    if (statefulObj.state === \"active\") {\n      const { isBlockingNavigation } = statefulObj;\n      return isBlockingNavigation;\n    }\n\n    return false;\n  }\n\n  public getAll(): Array<ValidationResponse> {\n    return this.applicableValidations.reduce((all, statefulObj) => {\n      if (statefulObj.state === \"active\" && statefulObj.response) {\n        all.push({\n          ...statefulObj.response,\n          blocking: this.checkIfBlocking(statefulObj),\n        });\n      }\n\n      return all;\n    }, [] as Array<ValidationResponse>);\n  }\n\n  public get(): ValidationResponse | undefined {\n    const firstInvalid = this.applicableValidations.find((statefulObj) => {\n      return statefulObj.state === \"active\" && statefulObj.response;\n    });\n\n    if (firstInvalid?.state === \"active\") {\n      return {\n        ...firstInvalid.response,\n        blocking: this.checkIfBlocking(firstInvalid),\n      };\n    }\n  }\n\n  private runApplicableValidations(\n    runner: ValidationRunner,\n    canDismiss: boolean,\n    phase: Validation.Trigger,\n  ) {\n    // If the currentState is not load, skip those\n    this.applicableValidations = this.applicableValidations.map(\n      (originalValue) => {\n        if (originalValue.state === \"dismissed\") {\n          // Don't rerun any dismissed warnings\n          return originalValue;\n        }\n\n        // treat all warnings the same and block it once (unless blocking is true)\n        const blocking =\n          originalValue.value.blocking ??\n          ((originalValue.value.severity === \"warning\" && \"once\") || true);\n\n        const obj = setIn(\n          originalValue,\n          [\"value\", \"blocking\"],\n          blocking,\n        ) as StatefulValidationObject;\n\n        const isBlockingNavigation =\n          blocking === true || (blocking === \"once\" && !canDismiss);\n\n        if (\n          phase === \"navigation\" &&\n          obj.state === \"active\" &&\n          obj.value.blocking !== true\n        ) {\n          if (obj.value.severity === \"warning\") {\n            const warn = obj as ActiveWarning;\n            if (\n              warn.dismissable &&\n              warn.response.dismiss &&\n              (warn.response.blocking !== \"once\" || !warn.response.blocking)\n            ) {\n              warn.response.dismiss();\n            } else {\n              if (warn?.response.blocking === \"once\") {\n                warn.response.blocking = false;\n              }\n\n              warn.dismissable = true;\n            }\n\n            return warn as StatefulValidationObject;\n          }\n        }\n\n        const response = runner(obj.value);\n\n        const newState = {\n          type: obj.type,\n          value: obj.value,\n          state: response ? \"active\" : \"none\",\n          isBlockingNavigation,\n          dismissable:\n            obj.value.severity === \"warning\" && phase === \"navigation\",\n          response: response\n            ? {\n                ...obj.value,\n                message: response.message ?? \"Something is broken\",\n                severity: obj.value.severity,\n                displayTarget: obj.value.displayTarget ?? \"field\",\n              }\n            : undefined,\n        } as StatefulValidationObject;\n\n        if (newState.state === \"active\" && obj.value.severity === \"warning\") {\n          (newState.response as WarningValidationResponse).dismiss = () => {\n            (newState as StatefulWarning).state = \"dismissed\";\n            this.onDismiss?.();\n          };\n        }\n\n        return newState;\n      },\n    );\n  }\n\n  public update(\n    phase: Validation.Trigger,\n    canDismiss: boolean,\n    runner: ValidationRunner,\n  ) {\n    const newApplicableValidations: StatefulValidationObject[] = [];\n\n    if (phase === \"load\" && this.currentPhase !== undefined) {\n      // Tried to run the 'load' phase twice. Aborting\n      return;\n    }\n\n    if (this.currentPhase === \"navigation\" || phase === this.currentPhase) {\n      // Already added all the types. No need to continue adding new validations\n      this.runApplicableValidations(runner, canDismiss, phase);\n      return;\n    }\n\n    if (phase === \"load\") {\n      this.currentPhase = \"load\";\n      this.applicableValidations = [...this.validationsByState.load];\n    } else if (phase === \"change\" && this.currentPhase === \"load\") {\n      this.currentPhase = \"change\";\n      // The transition to the 'change' type can only come from a 'load' type\n      this.applicableValidations = [\n        ...this.applicableValidations,\n        ...this.validationsByState.change,\n      ];\n    } else if (\n      phase === \"navigation\" &&\n      (this.currentPhase === \"load\" || this.currentPhase === \"change\")\n    ) {\n      // Can transition to a nav state from a change or load\n\n      // if there is an non-blocking error that is active then remove the error from applicable validations so it can no longer be shown\n      // which is needed if there are additional warnings to become active for that binding after the error is shown\n      this.applicableValidations.forEach((element) => {\n        if (\n          !(\n            element.type === \"error\" &&\n            element.state === \"active\" &&\n            element.isBlockingNavigation === false\n          )\n        ) {\n          newApplicableValidations.push(element);\n        }\n      });\n\n      this.applicableValidations = [\n        ...newApplicableValidations,\n        ...this.validationsByState.navigation,\n        ...(this.currentPhase === \"load\" ? this.validationsByState.change : []),\n      ];\n      this.currentPhase = \"navigation\";\n    }\n\n    this.runApplicableValidations(runner, canDismiss, phase);\n  }\n}\n\n/**\n * A controller for orchestrating validation within a running player\n *\n * The current validation flow is as follows:\n *\n *   - When a binding is first seen, gather all of the possible validations for it from the providers\n *     - Schema and Crossfield (view) are both providers of possible validations\n *     - Run all of the applicable validations for that binding for the `load` trigger\n *\n *   - When a change occurs, set the phase of the binding to `change`.\n *     - Run all of the `change` triggered validations for that binding.\n *\n *   - When a navigation event occurs, set the phase of the binding to `navigate`.\n *     - Run all `change` and `navigate` validations for each tracked binding.\n *     - For any warnings, also keep a state of `shown` or `dismissed`.\n *       - Set all non-dismissed warnings to `shown`.\n *       - Set all `shown` warnings to `dismissed`.\n *     - Allow navigation forward if there are no non-dismissed warnings and no valid errors.\n */\nexport class ValidationController implements BindingTracker {\n  public readonly hooks = {\n    /** A hook called to tap into the validator registry for adding more validators */\n    createValidatorRegistry: new SyncHook<[ValidatorRegistry]>(),\n\n    /** A callback/event when a new validation is added to the view */\n    onAddValidation: new SyncWaterfallHook<\n      [ValidationResponse, BindingInstance]\n    >(),\n\n    /** The inverse of onAddValidation, this is called when a validation is removed from the list */\n    onRemoveValidation: new SyncWaterfallHook<\n      [ValidationResponse, BindingInstance]\n    >(),\n\n    resolveValidationProviders: new SyncWaterfallHook<\n      [\n        Array<{\n          /** The name of the provider */\n          source: string;\n          /** The provider itself */\n          provider: ValidationProvider;\n        }>,\n      ],\n      {\n        /** The view this is triggered for  */\n        view?: ViewInstance;\n      }\n    >(),\n\n    /** A hook called when a binding is added to the tracker */\n    onTrackBinding: new SyncHook<[BindingInstance]>(),\n  };\n\n  private tracker: BindingTracker | undefined;\n  private validations = new Map<BindingInstance, ValidatedBinding>();\n  private validatorRegistry?: ValidatorRegistry;\n  private schema: SchemaController;\n\n  private providers:\n    | Array<{\n        /** The name of the provider */\n        source: string;\n        /** The provider itself */\n        provider: ValidationProvider;\n      }>\n    | undefined;\n\n  private viewValidationProvider?: ValidationProvider;\n  private options?: SimpleValidatorContext;\n  private weakBindingTracker = new Set<BindingInstance>();\n\n  constructor(schema: SchemaController, options?: SimpleValidatorContext) {\n    this.schema = schema;\n    this.options = options;\n    this.reset();\n  }\n\n  setOptions(options: SimpleValidatorContext) {\n    this.options = options;\n  }\n\n  /** Return the middleware for the data-model to stop propagation of invalid data */\n  public getDataMiddleware(): Array<DataModelMiddleware> {\n    return [\n      {\n        set: (transaction, options, next) => {\n          return next?.set(transaction, options) ?? [];\n        },\n        get: (binding, options, next) => {\n          return next?.get(binding, options);\n        },\n        delete: (binding, options, next) => {\n          this.validations = removeBindingAndChildrenFromMap(\n            this.validations,\n            binding,\n          );\n\n          return next?.delete(binding, options);\n        },\n      },\n      new ValidationMiddleware(\n        (binding) => {\n          if (!this.options) {\n            return;\n          }\n\n          this.updateValidationsForBinding(binding, \"change\", this.options);\n          const strongValidation = this.getValidationForBinding(binding);\n\n          // return validation issues directly on bindings first\n          if (strongValidation?.get()?.severity === \"error\") {\n            return strongValidation.get();\n          }\n\n          // if none, check to see any validations this binding may be a weak ref of and return\n          const newInvalidBindings: Set<StrongOrWeakBinding> = new Set();\n          this.validations.forEach((weakValidation, strongBinding) => {\n            if (\n              caresAboutDataChanges(\n                new Set([binding]),\n                weakValidation.weakBindings,\n              ) &&\n              weakValidation?.get()?.severity === \"error\"\n            ) {\n              weakValidation?.weakBindings.forEach((weakBinding) => {\n                if (weakBinding === strongBinding) {\n                  newInvalidBindings.add({\n                    binding: weakBinding,\n                    isStrong: true,\n                  });\n                } else {\n                  newInvalidBindings.add({\n                    binding: weakBinding,\n                    isStrong: false,\n                  });\n                }\n              });\n            }\n          });\n\n          if (newInvalidBindings.size > 0) {\n            return newInvalidBindings;\n          }\n        },\n        { logger: new ProxyLogger(() => this.options?.logger) },\n      ),\n    ];\n  }\n\n  private getValidationProviders() {\n    if (this.providers) {\n      return this.providers;\n    }\n\n    this.providers = this.hooks.resolveValidationProviders.call([\n      {\n        source: SCHEMA_VALIDATION_PROVIDER_NAME,\n        provider: this.schema,\n      },\n      {\n        source: VIEW_VALIDATION_PROVIDER_NAME,\n        provider: {\n          getValidationsForBinding: (\n            binding: BindingInstance,\n          ): Array<ValidationObject> | undefined => {\n            return this.viewValidationProvider?.getValidationsForBinding?.(\n              binding,\n            );\n          },\n\n          getValidationsForView: (): Array<ValidationObject> | undefined => {\n            return this.viewValidationProvider?.getValidationsForView?.();\n          },\n        },\n      },\n    ]);\n\n    return this.providers;\n  }\n\n  public reset() {\n    this.validations.clear();\n    this.tracker = undefined;\n  }\n\n  public onView(view: ViewInstance): void {\n    this.validations.clear();\n    if (!this.options) {\n      return;\n    }\n\n    const bindingTrackerPlugin = new ValidationBindingTrackerViewPlugin({\n      ...this.options,\n      callbacks: {\n        onAdd: (binding) => {\n          if (\n            !this.options ||\n            this.getValidationForBinding(binding) !== undefined\n          ) {\n            return;\n          }\n\n          // Set the default value for the binding if we need to\n          const originalValue = this.options.model.get(binding);\n          const withoutDefault = this.options.model.get(binding, {\n            ignoreDefaultValue: true,\n          });\n\n          if (originalValue !== withoutDefault) {\n            // Don't trigger updates when setting the default value\n            this.options.model.set([[binding, originalValue]], {\n              silent: true,\n            });\n          }\n\n          this.updateValidationsForBinding(\n            binding,\n            \"load\",\n            this.options,\n            () => {\n              view.update(new Set([binding]));\n            },\n          );\n\n          this.hooks.onTrackBinding.call(binding);\n        },\n      },\n    });\n\n    this.tracker = bindingTrackerPlugin;\n    this.viewValidationProvider = view;\n\n    bindingTrackerPlugin.apply(view);\n  }\n\n  updateValidationsForBinding(\n    binding: BindingInstance,\n    trigger: Validation.Trigger,\n    validationContext?: SimpleValidatorContext,\n    onDismiss?: () => void,\n  ): void {\n    const context = validationContext ?? this.options;\n\n    if (!context) {\n      throw new Error(`Context is required for executing validations`);\n    }\n\n    if (trigger === \"load\") {\n      // Get all of the validations from each provider\n      const possibleValidations = this.getValidationProviders().reduce<\n        Array<ValidationObjectWithSource>\n      >((vals, provider) => {\n        vals.push(\n          ...(provider.provider\n            .getValidationsForBinding?.(binding)\n            ?.map((valObj) => ({\n              ...valObj,\n              [VALIDATION_PROVIDER_NAME_SYMBOL]: provider.source,\n            })) ?? []),\n        );\n\n        return vals;\n      }, []);\n\n      if (possibleValidations.length === 0) {\n        return;\n      }\n\n      this.validations.set(\n        binding,\n        new ValidatedBinding(\n          possibleValidations,\n          onDismiss,\n          this.options?.logger,\n        ),\n      );\n    }\n\n    const trackedValidations = this.validations.get(binding);\n    trackedValidations?.update(trigger, true, (validationObj) => {\n      const response = this.validationRunner(validationObj, binding, context);\n\n      if (this.weakBindingTracker.size > 0) {\n        const t = this.validations.get(binding) as ValidatedBinding;\n        this.weakBindingTracker.forEach((b) => t.weakBindings.add(b));\n      }\n\n      return response ? { message: response.message } : undefined;\n    });\n\n    // Also run any validations that binding or sub-binding is a weak binding of\n    if (trigger !== \"load\") {\n      this.validations.forEach((validation, vBinding) => {\n        if (\n          vBinding !== binding &&\n          caresAboutDataChanges(new Set([binding]), validation.weakBindings)\n        ) {\n          validation.update(trigger, true, (validationObj) => {\n            const response = this.validationRunner(\n              validationObj,\n              vBinding,\n              context,\n            );\n            return response ? { message: response.message } : undefined;\n          });\n        }\n      });\n    }\n  }\n\n  validationRunner(\n    validationObj: ValidationObjectWithHandler,\n    binding: BindingInstance,\n    context: SimpleValidatorContext | undefined = this.options,\n  ) {\n    if (!context) {\n      throw new Error(\"No context provided to validation runner\");\n    }\n\n    const handler =\n      validationObj.handler ?? this.getValidator(validationObj.type);\n\n    const weakBindings = new Set<BindingInstance>();\n\n    // For any data-gets in the validation runner, default to using the _invalid_ value (since that's what we're testing against)\n    const model: DataModelWithParser = {\n      get(b, options) {\n        weakBindings.add(isBinding(b) ? binding : context.parseBinding(b));\n        return context.model.get(b, { ...options, includeInvalid: true });\n      },\n      set: context.model.set,\n      delete: context.model.delete,\n    };\n\n    const result = handler?.(\n      {\n        ...context,\n        evaluate: (\n          exp: ExpressionType,\n          options: ExpressionEvaluatorOptions = { model },\n        ) => context.evaluate(exp, options),\n        model,\n        validation: validationObj,\n        schemaType: this.schema.getType(binding),\n      },\n      context.model.get(binding, {\n        includeInvalid: true,\n        formatted: validationObj.dataTarget === \"formatted\",\n      }),\n      validationObj,\n    );\n\n    this.weakBindingTracker = weakBindings;\n\n    if (result) {\n      let { message } = result;\n      const { parameters } = result;\n\n      if (validationObj.message) {\n        message = resolveDataRefs(validationObj.message, {\n          model,\n          evaluate: context.evaluate,\n        });\n        if (parameters) {\n          message = replaceParams(message, parameters);\n        }\n      }\n\n      return {\n        message,\n      };\n    }\n  }\n\n  private updateValidationsForView(trigger: Validation.Trigger): void {\n    const isNavigationTrigger = trigger === \"navigation\";\n    const lastActiveBindings = this.activeBindings;\n\n    /** Run validations for all bindings in view */\n    const updateValidations = (dismissValidations: boolean) => {\n      this.getBindings().forEach((binding) => {\n        this.validations\n          .get(binding)\n          ?.update(trigger, dismissValidations, (obj) => {\n            if (!this.options) {\n              return;\n            }\n\n            return this.validationRunner(obj, binding, this.options);\n          });\n      });\n    };\n\n    // Should dismiss for non-navigation triggers.\n    updateValidations(!isNavigationTrigger);\n\n    if (isNavigationTrigger) {\n      // If validations didn't change since last update, dismiss all dismissible validations.\n      const { activeBindings } = this;\n      if (isSubset(activeBindings, lastActiveBindings)) {\n        updateValidations(true);\n      }\n    }\n  }\n\n  private get activeBindings(): Set<BindingInstance> {\n    return new Set(\n      Array.from(this.getBindings()).filter(\n        (b) => this.validations.get(b)?.get() !== undefined,\n      ),\n    );\n  }\n\n  public getValidator(type: string) {\n    if (this.validatorRegistry) {\n      return this.validatorRegistry.get(type);\n    }\n\n    const registry = new ValidatorRegistry();\n    this.hooks.createValidatorRegistry.call(registry);\n    this.validatorRegistry = registry;\n\n    return registry.get(type);\n  }\n\n  getBindings(): Set<BindingInstance> {\n    return this.tracker?.getBindings() ?? new Set();\n  }\n\n  trackBinding(binding: BindingInstance): void {\n    this.tracker?.trackBinding(binding);\n  }\n\n  /** Executes all known validations for the tracked bindings using the given model */\n  validateView(trigger: Validation.Trigger = \"navigation\"): {\n    /** Indicating if the view can proceed without error */\n    canTransition: boolean;\n\n    /** the validations that are preventing the view from continuing */\n    validations?: Map<BindingInstance, ValidationResponse>;\n  } {\n    this.updateValidationsForView(trigger);\n\n    const validations = new Map<BindingInstance, ValidationResponse>();\n\n    let canTransition = true;\n\n    this.getBindings().forEach((b) => {\n      const allValidations = this.getValidationForBinding(b)?.getAll();\n\n      allValidations?.forEach((v) => {\n        if (trigger === \"navigation\" && v.blocking) {\n          this.options?.logger.debug(\n            `Validation on binding: ${b.asString()} is preventing navigation. ${JSON.stringify(\n              v,\n            )}`,\n          );\n\n          canTransition = false;\n        }\n\n        if (!validations.has(b)) {\n          validations.set(b, v);\n        }\n      });\n    });\n\n    return {\n      canTransition,\n      validations: validations.size ? validations : undefined,\n    };\n  }\n\n  /** Get the current tracked validation for the given binding */\n  public getValidationForBinding(\n    binding: BindingInstance,\n  ): ValidatedBinding | undefined {\n    return this.validations.get(binding);\n  }\n\n  forView(parser: BindingFactory): Resolve.Validation {\n    return {\n      _getValidationForBinding: (binding) => {\n        return this.getValidationForBinding(\n          isBinding(binding) ? binding : parser(binding),\n        );\n      },\n      getAll: () => {\n        const bindings = this.getBindings();\n        if (bindings.size === 0) {\n          return undefined;\n        }\n\n        const validationMapping = new Map<\n          BindingInstance,\n          ValidationResponse\n        >();\n\n        bindings.forEach((b) => {\n          const validation = this.getValidationForBinding(b)?.get();\n\n          if (validation) {\n            validationMapping.set(b, validation);\n          }\n        });\n\n        return validationMapping.size === 0 ? undefined : validationMapping;\n      },\n      get() {\n        throw new Error(\"Error Access be provided by the view plugin\");\n      },\n      getValidationsForBinding() {\n        throw new Error(\"Error rollup should be provided by the view plugin\");\n      },\n      getChildren() {\n        throw new Error(\"Error rollup should be provided by the view plugin\");\n      },\n      getValidationsForSection() {\n        throw new Error(\"Error rollup should be provided by the view plugin\");\n      },\n      track: () => {\n        throw new Error(\"Tracking should be provided by the view plugin\");\n      },\n      register: () => {\n        throw new Error(\n          \"Section functionality should be provided by the view plugin\",\n        );\n      },\n      type: (binding) =>\n        this.schema.getType(isBinding(binding) ? binding : parser(binding)),\n    };\n  }\n}\n","const ANY_CHAR_REGEX = /%([a-zA-Z]+)/g;\n\n/**\n * Replaces %num in message with the provided parameters in order.\n *\n * @param message - Parameterized string like \"This is a %1\"\n * @param params - Parameters to replace in message E.g. ['tax2021.amount']\n * @returns A message with the parameters replaced.\n */\nexport function replaceParams(\n  message: string,\n  params: Record<string, any>,\n): string {\n  return message\n    .slice()\n    .replace(ANY_CHAR_REGEX, (keyExpr) => params[keyExpr.slice(1)] || keyExpr);\n}\n","import type { Validation } from \"@player-ui/types\";\nimport type { ViewPlugin, Resolver, Node, ViewInstance } from \"../../view\";\nimport { NodeType } from \"../../view\";\nimport type {\n  BindingInstance,\n  BindingLike,\n  BindingFactory,\n} from \"../../binding\";\nimport { isBinding } from \"../../binding\";\nimport type { ValidationResponse } from \"../../validator\";\n\nconst CONTEXT = \"validation-binding-tracker\";\n\nexport interface BindingTracker {\n  /** Get the bindings currently being tracked for validation */\n  getBindings(): Set<BindingInstance>;\n\n  /** Add a binding to the tracked set */\n  trackBinding(binding: BindingInstance): void;\n}\ninterface Options {\n  /** Parse a binding from a view */\n  parseBinding: BindingFactory;\n\n  /** Callbacks when events happen */\n  callbacks?: {\n    /** Called when a binding is encountered for the first time in a view */\n    onAdd?: (binding: BindingInstance) => void;\n  };\n}\n\n/** A view plugin that manages bindings tracked across updates */\nexport class ValidationBindingTrackerViewPlugin\n  implements ViewPlugin, BindingTracker\n{\n  private options: Options;\n\n  private trackedBindings = new Set<BindingInstance>();\n\n  constructor(options: Options) {\n    this.options = options;\n  }\n\n  /** Fetch the tracked bindings in the current view */\n  getBindings(): Set<BindingInstance> {\n    return this.trackedBindings;\n  }\n\n  /** Add a binding to the tracked set */\n  trackBinding(binding: BindingInstance) {\n    if (this.trackedBindings.has(binding)) {\n      return;\n    }\n\n    this.trackedBindings.add(binding);\n    this.options.callbacks?.onAdd?.(binding);\n  }\n\n  /** Attach hooks to the given resolver */\n  applyResolver(resolver: Resolver) {\n    this.trackedBindings.clear();\n\n    /** Each node maps to a set of bindings that it directly tracks */\n    const tracked = new Map<Node.Node, Set<BindingInstance>>();\n\n    /** Each Node is a registered section or page that maps to a set of nodes in its section */\n    const sections = new Map<Node.Node, Set<Node.Node>>();\n\n    let lastViewUpdateChangeSet: Set<BindingInstance> | undefined;\n\n    /** Map of node to all bindings in children */\n    const lastComputedBindingTree = new Map<Node.Node, Set<BindingInstance>>();\n    let currentBindingTree = new Map<Node.Node, Set<BindingInstance>>();\n\n    /** Map of registered section nodes to bindings */\n    const lastSectionBindingTree = new Map<Node.Node, Set<BindingInstance>>();\n\n    /** Map of resolved nodes to their original nodes. */\n    const resolvedNodeMap: Map<Node.Node, Node.Node> = new Map();\n\n    resolver.hooks.beforeUpdate.tap(CONTEXT, (changes) => {\n      lastViewUpdateChangeSet = changes;\n    });\n\n    resolver.hooks.skipResolve.tap(CONTEXT, (shouldSkip, node) => {\n      const trackedBindingsForNode = lastComputedBindingTree.get(node);\n\n      if (!shouldSkip || !lastViewUpdateChangeSet || !trackedBindingsForNode) {\n        return shouldSkip;\n      }\n\n      const intersection = new Set(\n        [...lastViewUpdateChangeSet].filter((b) =>\n          trackedBindingsForNode.has(b),\n        ),\n      );\n\n      return intersection.size === 0;\n    });\n\n    resolver.hooks.resolveOptions.tap(CONTEXT, (options, node) => {\n      if (options.validation === undefined) {\n        return options;\n      }\n\n      // Clear out any old tracked bindings for this node since we're re-compiling it\n      tracked.delete(node);\n\n      /** Validation callback to track a binding */\n      const track = (binding: BindingLike) => {\n        const parsed = isBinding(binding)\n          ? binding\n          : this.options.parseBinding(binding);\n\n        if (tracked.has(node)) {\n          tracked.get(node)?.add(parsed);\n        } else {\n          tracked.set(node, new Set([parsed]));\n        }\n\n        /** find first parent registered as section and add self to its list */\n        let { parent } = node;\n\n        while (parent) {\n          if (sections.has(parent)) {\n            sections.get(parent)?.add(node);\n            break;\n          } else {\n            parent = parent.parent;\n          }\n        }\n\n        this.trackedBindings.add(parsed);\n        this.options.callbacks?.onAdd?.(parsed);\n      };\n\n      return {\n        ...options,\n        validation: {\n          ...options.validation,\n          get: (binding, getOptions) => {\n            if (getOptions?.track) {\n              track(binding);\n            }\n\n            const eows = options.validation\n              ?._getValidationForBinding(binding)\n              ?.getAll(getOptions);\n\n            const firstFieldEOW = eows?.find(\n              (eow) =>\n                eow.displayTarget === \"field\" ||\n                eow.displayTarget === undefined,\n            );\n\n            return firstFieldEOW;\n          },\n          getValidationsForBinding(binding, getOptions) {\n            if (getOptions?.track) {\n              track(binding);\n            }\n\n            return (\n              options.validation\n                ?._getValidationForBinding(binding)\n                ?.getAll(getOptions) ?? []\n            );\n          },\n          getChildren: (type?: Validation.DisplayTarget) => {\n            const validations = new Array<ValidationResponse>();\n            lastComputedBindingTree.get(node)?.forEach((binding) => {\n              const eow = options.validation\n                ?._getValidationForBinding(binding)\n                ?.get();\n\n              if (eow && (type === undefined || type === eow.displayTarget)) {\n                validations.push(eow);\n              }\n            });\n\n            return validations;\n          },\n          getValidationsForSection: () => {\n            const validations = new Array<ValidationResponse>();\n            lastSectionBindingTree.get(node)?.forEach((binding) => {\n              const eow = options.validation\n                ?._getValidationForBinding(binding)\n                ?.get();\n\n              if (eow && eow.displayTarget === \"section\") {\n                validations.push(eow);\n              }\n            });\n\n            return validations;\n          },\n          register: (registerOptions) => {\n            if (registerOptions?.type === \"section\") {\n              if (!sections.has(node)) {\n                sections.set(node, new Set());\n              }\n            }\n          },\n          track,\n        },\n      };\n    });\n\n    resolver.hooks.afterNodeUpdate.tap(\n      CONTEXT,\n      (originalNode, parent, update) => {\n        // Compute the new tree for this node\n        // If it's not-updated, use the last known value\n\n        const { updated, node: resolvedNode } = update;\n        resolvedNodeMap.set(resolvedNode, originalNode);\n\n        if (updated) {\n          const newlyComputed = new Set(tracked.get(originalNode));\n          if (resolvedNode.type === NodeType.MultiNode) {\n            resolvedNode.values.forEach((value) =>\n              currentBindingTree\n                .get(value)\n                ?.forEach((b) => newlyComputed.add(b)),\n            );\n          }\n\n          if (\"children\" in resolvedNode && resolvedNode.children) {\n            resolvedNode.children.forEach((child) => {\n              currentBindingTree\n                .get(child.value)\n                ?.forEach((b) => newlyComputed.add(b));\n            });\n          }\n\n          currentBindingTree.set(resolvedNode, newlyComputed);\n        } else {\n          currentBindingTree.set(\n            resolvedNode,\n            lastComputedBindingTree.get(originalNode) ?? new Set(),\n          );\n        }\n\n        if (originalNode === resolver.root) {\n          this.trackedBindings = new Set(currentBindingTree.get(resolvedNode));\n          lastComputedBindingTree.clear();\n          currentBindingTree.forEach((value, key) => {\n            const node = resolvedNodeMap.get(key);\n            if (node) {\n              lastComputedBindingTree.set(node, value);\n            }\n          });\n\n          lastSectionBindingTree.clear();\n          sections.forEach((nodeSet, sectionNode) => {\n            const temp = new Set<BindingInstance>();\n            nodeSet.forEach((n) => {\n              tracked.get(n)?.forEach(temp.add, temp);\n            });\n            lastSectionBindingTree.set(sectionNode, temp);\n          });\n\n          tracked.clear();\n          sections.clear();\n          currentBindingTree = new Map();\n        }\n      },\n    );\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.resolver.tap(CONTEXT, this.applyResolver.bind(this));\n  }\n}\n","export interface Store {\n  useLocalState<T>(initialState: T): readonly [T, (value: T) => void];\n  useSharedState<T>(\n    key: string | symbol,\n  ): (initialState: T) => readonly [T, (value: T) => void];\n}\n\ninterface SharedStore {\n  getLocalStateFunction<T>(\n    key: string | symbol,\n    countKey: symbol,\n  ): (initialState: T) => readonly [T, (value: T) => void];\n  useSharedState<T>(\n    key: string | symbol,\n  ): (initialState: T) => readonly [T, (value: T) => void];\n}\n\n/** A store that holds on to state for a transform */\nexport class LocalStateStore implements SharedStore {\n  private state: Map<string | symbol, any>;\n\n  private updateCallback?: () => void;\n\n  constructor(onUpdate?: () => void) {\n    this.updateCallback = onUpdate;\n\n    this.state = new Map();\n  }\n\n  public removeKey(key: symbol | string) {\n    this.state.delete(key);\n  }\n\n  public reset() {\n    this.state.clear();\n  }\n\n  useSharedState<T>(key: string | symbol) {\n    return (initialState: T) => {\n      if (!this.state.has(key)) {\n        this.state.set(key, initialState);\n      }\n\n      return [\n        this.state.get(key) as T,\n        (newState: T) => {\n          const current = this.state.get(key) as T;\n\n          this.state.set(key, newState);\n\n          if (current !== newState) {\n            this.updateCallback?.();\n          }\n        },\n      ] as const;\n    };\n  }\n\n  getLocalStateFunction<T>(key: symbol, countKey: symbol) {\n    return (initialState: T) => {\n      // initialize if not already created\n      if (!this.state.has(key)) {\n        this.state.set(key, []);\n      }\n\n      if (!this.state.has(countKey)) {\n        this.state.set(countKey, 0);\n      }\n\n      const localState = this.state.get(key);\n      const oldCount = this.state.get(countKey);\n\n      this.state.set(countKey, oldCount + 1);\n\n      if (localState.length <= oldCount) {\n        localState.push(initialState);\n      }\n\n      const value = localState[oldCount] as T;\n\n      return [\n        value,\n        (newState: T) => {\n          const oldValue = localState[oldCount] as T;\n          localState[oldCount] = newState;\n\n          if (oldValue !== newState) {\n            this.updateCallback?.();\n          }\n        },\n      ] as const;\n    };\n  }\n}\n","import type { Node } from \"../../view\";\nimport { NodeType } from \"../../view\";\nimport { LocalStateStore } from \"./store\";\nimport type { TransformRegistry } from \"./types\";\nimport type { ViewController } from \"./controller\";\n\n/** Traverse up the nodes until the target is found */\nfunction findUp(node: Node.Node, target: Node.Node): boolean {\n  if (node === target) {\n    return true;\n  }\n\n  if (node.parent) {\n    return findUp(node.parent, target);\n  }\n\n  return false;\n}\n\n/**\n * A plugin to register custom transforms on certain asset types\n * This allows users to embed stateful data into transforms.\n */\nexport class AssetTransformCorePlugin {\n  public readonly stateStore: Map<Node.Node, LocalStateStore>;\n  private readonly registry: TransformRegistry;\n  private beforeResolveSymbol: symbol;\n  private resolveSymbol: symbol;\n  private beforeResolveCountSymbol: symbol;\n  private resolveCountSymbol: symbol;\n\n  constructor(registry: TransformRegistry) {\n    this.registry = registry;\n    this.stateStore = new Map();\n    this.beforeResolveSymbol = Symbol(\"before resolve\");\n    this.resolveSymbol = Symbol(\"resolve\");\n    this.beforeResolveCountSymbol = Symbol(\"before resolve count\");\n    this.resolveCountSymbol = Symbol(\"resolve count\");\n  }\n\n  apply(viewController: ViewController) {\n    viewController.hooks.view.tap(\"asset-transform\", (view) => {\n      // Clear out everything when we create a new view\n      this.stateStore.clear();\n\n      view.hooks.resolver.tap(\"asset-transform\", (resolver) => {\n        let lastUpdatedNode: Node.Node | undefined;\n\n        /** A function to update the state and trigger a view re-compute */\n        const updateState = (node: Node.Node) => {\n          lastUpdatedNode = node;\n          view.update(new Set());\n        };\n\n        /** Given a node and a transform step, fetch a local store */\n        const getStore = (node: Node.Node, stepKey: symbol) => {\n          let store: LocalStateStore;\n          const countKey =\n            stepKey === this.resolveSymbol\n              ? this.resolveCountSymbol\n              : this.beforeResolveCountSymbol;\n\n          const storedState = this.stateStore.get(node);\n\n          if (storedState) {\n            store = storedState;\n            store.removeKey(countKey);\n          } else {\n            store = new LocalStateStore(() => {\n              updateState(node);\n            });\n            this.stateStore.set(node, store);\n          }\n\n          return {\n            useSharedState: (\n              key: string | symbol,\n            ): (<T>(initialState: T) => readonly [T, (value: T) => void]) => {\n              return store.useSharedState(key);\n            },\n            useLocalState: <T>(initialState: T) => {\n              return store.getLocalStateFunction<T>(\n                stepKey,\n                countKey,\n              )(initialState);\n            },\n          };\n        };\n\n        resolver.hooks.beforeResolve.tap(\"asset-transform\", (node, options) => {\n          if (node && (node.type === \"asset\" || node.type === \"view\")) {\n            const transform = this.registry.get(node.value);\n\n            if (transform?.beforeResolve) {\n              const store = getStore(\n                options.node ?? node,\n                this.beforeResolveSymbol,\n              );\n\n              return transform.beforeResolve(node, options, store);\n            }\n          }\n\n          return node;\n        });\n\n        resolver.hooks.afterUpdate.tap(\"asset-transform\", () => {\n          lastUpdatedNode = undefined;\n        });\n\n        resolver.hooks.skipResolve.tap(\"asset-transform\", (skip, node) => {\n          if (!skip || !lastUpdatedNode) {\n            return skip;\n          }\n\n          const isParentOfUpdated = findUp(lastUpdatedNode, node);\n          const isChildOfUpdated = findUp(node, lastUpdatedNode);\n\n          return !isParentOfUpdated && !isChildOfUpdated;\n        });\n\n        resolver.hooks.afterResolve.tap(\n          \"asset-transform\",\n          (value, node, options) => {\n            if (node.type !== NodeType.Asset && node.type !== NodeType.View) {\n              return value;\n            }\n\n            const originalNode = resolver.getSourceNode(node);\n\n            if (!originalNode) {\n              return value;\n            }\n\n            const transform = this.registry.get(value);\n\n            if (transform?.resolve) {\n              const store = getStore(originalNode, this.resolveSymbol);\n\n              return transform?.resolve(value, options, store);\n            }\n\n            return value;\n          },\n        );\n      });\n    });\n  }\n}\n","import { SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport queueMicrotask from \"queue-microtask\";\nimport { Registry } from \"@player-ui/partial-match-registry\";\nimport type { View, NavigationFlowViewState } from \"@player-ui/types\";\n\nimport { resolveDataRefsInString } from \"../../string-resolver\";\nimport type { Resolve } from \"../../view\";\nimport { ViewInstance } from \"../../view\";\nimport type { Logger } from \"../../logger\";\nimport type { FlowInstance, FlowController } from \"../flow\";\nimport type { DataController } from \"../data/controller\";\nimport { AssetTransformCorePlugin } from \"./asset-transform\";\nimport type { TransformRegistry } from \"./types\";\nimport type { BindingInstance } from \"../../binding\";\n\nexport interface ViewControllerOptions {\n  /** Where to get data from */\n  model: DataController;\n\n  /** Where to log data */\n  logger?: Logger;\n\n  /** A flow-controller instance to listen for view changes */\n  flowController: FlowController;\n}\n\n/** A controller to manage updating/switching views */\nexport class ViewController {\n  public readonly hooks = {\n    /** Do any processing before the `View` instance is created */\n    resolveView: new SyncWaterfallHook<\n      [View | undefined, string, NavigationFlowViewState]\n    >(),\n\n    // The hook right before the View starts resolving. Attach anything custom here\n    view: new SyncHook<[ViewInstance]>(),\n  };\n\n  private readonly viewMap: Record<string, View>;\n  private readonly viewOptions: Resolve.ResolverOptions & ViewControllerOptions;\n  private pendingUpdate?: {\n    /** pending data binding changes */\n    changedBindings?: Set<BindingInstance>;\n    /** Whether we have a microtask queued to handle this pending update */\n    scheduled?: boolean;\n  };\n\n  public currentView?: ViewInstance;\n  public transformRegistry: TransformRegistry = new Registry();\n  public optimizeUpdates = true;\n\n  constructor(\n    initialViews: View[],\n    options: Resolve.ResolverOptions & ViewControllerOptions,\n  ) {\n    this.viewOptions = options;\n    this.viewMap = initialViews.reduce<Record<string, View>>(\n      (viewMap, view) => {\n        // eslint-disable-next-line no-param-reassign\n        viewMap[view.id] = view;\n        return viewMap;\n      },\n      {},\n    );\n\n    new AssetTransformCorePlugin(this.transformRegistry).apply(this);\n\n    options.flowController.hooks.flow.tap(\n      \"viewController\",\n      (flow: FlowInstance) => {\n        flow.hooks.transition.tap(\"viewController\", (_oldState, newState) => {\n          if (newState.value.state_type === \"VIEW\") {\n            this.onView(newState.value);\n          } else {\n            this.currentView = undefined;\n          }\n        });\n      },\n    );\n\n    /** Trigger a view update */\n    const update = (updates: Set<BindingInstance>, silent = false) => {\n      if (this.currentView) {\n        if (this.optimizeUpdates) {\n          this.queueUpdate(updates, silent);\n        } else {\n          this.currentView.update();\n        }\n      }\n    };\n\n    options.model.hooks.onUpdate.tap(\n      \"viewController\",\n      (updates, updateOptions) => {\n        update(\n          new Set(updates.map((t) => t.binding)),\n          updateOptions?.silent ?? false,\n        );\n      },\n    );\n\n    options.model.hooks.onDelete.tap(\"viewController\", (binding) => {\n      const parentBinding = binding.parent();\n      const property = binding.key();\n\n      // Deleting an array item will trigger an update for the entire array\n      if (typeof property === \"number\" && parentBinding) {\n        update(new Set([parentBinding]));\n      } else {\n        update(new Set([binding]));\n      }\n    });\n  }\n\n  private queueUpdate(bindings: Set<BindingInstance>, silent = false) {\n    if (this.pendingUpdate?.changedBindings) {\n      // If there's already a pending update, just add to it don't worry about silent updates here yet\n      this.pendingUpdate.changedBindings = new Set([\n        ...this.pendingUpdate.changedBindings,\n        ...bindings,\n      ]);\n    } else {\n      this.pendingUpdate = { changedBindings: bindings, scheduled: false };\n    }\n\n    // If there's no pending update, schedule one only if this one isn't silent\n    // otherwise if this is silent, we'll just wait for the next non-silent update and make sure our bindings are included\n    if (!this.pendingUpdate.scheduled && !silent) {\n      this.pendingUpdate.scheduled = true;\n      queueMicrotask(() => {\n        const updates = this.pendingUpdate?.changedBindings;\n        this.pendingUpdate = undefined;\n        this.currentView?.update(updates);\n      });\n    }\n  }\n\n  private getViewForRef(viewRef: string): View | undefined {\n    // First look for a 1:1 viewRef -> id mapping (this is most common)\n    if (this.viewMap[viewRef]) {\n      return this.viewMap[viewRef];\n    }\n\n    // The view ids saved may also contain model refs, resolve those and try again\n    const matchingViewId = Object.keys(this.viewMap).find(\n      (possibleViewIdMatch) =>\n        viewRef ===\n        resolveDataRefsInString(possibleViewIdMatch, {\n          model: this.viewOptions.model,\n          evaluate: this.viewOptions.evaluator.evaluate,\n        }),\n    );\n\n    if (matchingViewId && this.viewMap[matchingViewId]) {\n      return this.viewMap[matchingViewId];\n    }\n  }\n\n  public onView(state: NavigationFlowViewState) {\n    const viewId = state.ref;\n\n    const source = this.hooks.resolveView.call(\n      this.getViewForRef(viewId),\n      viewId,\n      state,\n    );\n\n    if (!source) {\n      throw new Error(`No view with id ${viewId}`);\n    }\n\n    const view = new ViewInstance(source, this.viewOptions);\n    this.currentView = view;\n\n    // Give people a chance to attach their\n    // own listeners to the view before we resolve it\n    this.hooks.view.call(view);\n    view.update();\n  }\n}\n","import SortedArray from \"sorted-array\";\nimport type { Matcher } from \"./deep-partial-matcher\";\nimport createObjectMatcher from \"./deep-partial-matcher\";\n\nexport { default as createObjectMatcher } from \"./deep-partial-matcher\";\n\n/** create a matcher function that matches exactly */\nfunction createBasicMatcher(seed: any): Matcher {\n  /** a simple matcher function that only matches itself */\n  const matcher = (match: any) => seed === match;\n  matcher.count = 1;\n\n  return matcher;\n}\n\ninterface RegistryIndex<V> {\n  /** The original object we wanted to match on  */\n  key: object;\n\n  /** The value to return */\n  value: V;\n\n  /** The matcher function for this entry */\n  matcher: Matcher;\n}\n\n/** create an empty sorted array using the matcher count */\nconst createSortedArray = <V>() =>\n  new SortedArray<RegistryIndex<V>>([], (c) => c.matcher.count);\n\n/**\n * A partial match registry is a map that uses an object to \"match\" against keys.\n * More specific matches take precedence over less specific ones.\n */\nexport class Registry<V> {\n  private store = createSortedArray<V>();\n\n  constructor(initialSet?: Array<[any, V]>) {\n    initialSet?.forEach(([match, value]) => {\n      this.set(match, value);\n    });\n  }\n\n  /** Add match -> value mapping to the registry */\n  set(match: any, value: V) {\n    const matcher =\n      typeof match === \"object\"\n        ? createObjectMatcher(match)\n        : createBasicMatcher(match);\n\n    this.store.insert({\n      key: match,\n      value,\n      matcher,\n    });\n  }\n\n  /** Fetch the best match in the registry */\n  get(query: any): V | undefined {\n    for (const entry of this.store.array) {\n      if (entry.matcher(query)) {\n        return entry.value;\n      }\n    }\n  }\n\n  /** Loop over all entries and run callback */\n  forEach(callbackfn: (value: RegistryIndex<V>) => void): void {\n    for (const entry of this.store.array) {\n      callbackfn(entry);\n    }\n  }\n\n  /** Reset the items in the registry */\n  clear() {\n    this.store = createSortedArray<V>();\n  }\n}\n","import dlv from \"dlv\";\n\n/** A function that checks overlapping properties against a reference value */\nexport type Matcher = ((searchObj: object) => boolean) & {\n  /** The count represents the specificity of this matcher */\n  count: number;\n};\n\n/** Traverse an object and collect any key/value pairs including nested keys */\nfunction traverseObj(\n  object: Record<any, any>,\n  path: string[] = [],\n  pairs: Map<string[], any> = new Map(),\n): Map<string[], any> {\n  for (const key of Object.keys(object)) {\n    const val: any = object[key];\n    const nestedPath = [...path, key];\n    (\"\");\n\n    if (typeof val === \"object\") {\n      traverseObj(val, nestedPath, pairs);\n    } else {\n      pairs.set(nestedPath, val);\n    }\n  }\n\n  return pairs;\n}\n\n/** Given an object, create a function that compares any set key/value pairs in the given object against a new value */\nexport default function createMatcher(partialObj: object): Matcher {\n  // Convert the partial object into a list of [key, value] pairs;\n  const pairs = traverseObj(partialObj);\n\n  /** Generate a function to match against all of the properties we care about */\n  const matchFunction = (searchObj: object) => {\n    for (const entry of Array.from(pairs)) {\n      const [path, value] = entry;\n\n      if (dlv(searchObj, path) !== value) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  // Keep track of the specificity of the comparator\n  matchFunction.count = pairs.size;\n\n  return matchFunction;\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\nimport type { DataController } from \".\";\nimport type { Logger } from \"../../logger\";\nimport type { BindingLike } from \"../../binding\";\nimport type {\n  DataModelWithParser,\n  DataModelOptions,\n  Updates,\n} from \"../../data\";\n\n/** Wrapper for the Data Controller Class that prevents writes */\nexport class ReadOnlyDataController\n  implements DataModelWithParser<DataModelOptions>\n{\n  private controller: DataController;\n  private logger?: Logger;\n\n  constructor(controller: DataController, logger?: Logger) {\n    this.controller = controller;\n    this.logger = logger;\n  }\n\n  get(binding: BindingLike, options?: DataModelOptions | undefined) {\n    return this.controller.get(binding, options);\n  }\n\n  set(\n    transaction: [BindingLike, any][],\n    options?: DataModelOptions | undefined,\n  ): Updates {\n    this.logger?.error(\n      \"Error: Tried to set in a read only instance of the DataController\",\n    );\n    return [];\n  }\n\n  delete(binding: BindingLike, options?: DataModelOptions | undefined): void {\n    this.logger?.error(\n      \"Error: Tried to delete in a read only instance of the DataController\",\n    );\n  }\n}\n","import { SyncHook, SyncWaterfallHook, SyncBailHook } from \"tapable-ts\";\nimport { dequal } from \"dequal\";\nimport type { Logger } from \"../../logger\";\nimport type { BindingParser, BindingLike } from \"../../binding\";\nimport { BindingInstance } from \"../../binding\";\nimport type {\n  BatchSetTransaction,\n  Updates,\n  DataModelOptions,\n  DataModelWithParser,\n  DataPipeline,\n  DataModelMiddleware,\n} from \"../../data\";\nimport { PipelinedDataModel, LocalModel } from \"../../data\";\nimport type { RawSetTransaction } from \"../../types\";\nimport { ReadOnlyDataController } from \"./utils\";\n\n/** The orchestrator for player data */\nexport class DataController implements DataModelWithParser<DataModelOptions> {\n  public hooks = {\n    resolve: new SyncWaterfallHook(),\n    resolveDataStages: new SyncWaterfallHook<[DataPipeline]>(),\n\n    // On any set or get of an undefined value, redirect the value to be the default\n    resolveDefaultValue: new SyncBailHook<[BindingInstance], any>(),\n\n    onDelete: new SyncHook<[any]>(),\n\n    onSet: new SyncHook<[BatchSetTransaction]>(),\n\n    onGet: new SyncHook<[any, any]>(),\n\n    onUpdate: new SyncHook<[Updates, DataModelOptions | undefined]>(),\n\n    format: new SyncWaterfallHook<[any, BindingInstance]>(),\n\n    deformat: new SyncWaterfallHook<[any, BindingInstance]>(),\n\n    serialize: new SyncWaterfallHook<[any]>(),\n  };\n\n  private model?: PipelinedDataModel;\n  private trash: Set<BindingInstance>;\n  private pathResolver: BindingParser;\n  private baseMiddleware: Array<DataModelMiddleware>;\n  private logger?: Logger;\n\n  constructor(\n    model: Record<any, unknown> | undefined,\n    options: {\n      /** A means of parsing a raw binding to a Binding object */\n      pathResolver: BindingParser;\n\n      /** middleware to use. typically for validation */\n      middleware?: Array<DataModelMiddleware>;\n\n      /** A logger to use  */\n      logger?: Logger;\n    },\n  ) {\n    this.logger = options.logger;\n    const middleware = options.middleware || [];\n    this.baseMiddleware = [new LocalModel(model), ...middleware];\n\n    this.trash = new Set();\n    this.pathResolver = options.pathResolver;\n  }\n\n  public getModel(): PipelinedDataModel {\n    if (!this.model) {\n      const stages = this.hooks.resolveDataStages.call(this.baseMiddleware);\n      const model = new PipelinedDataModel();\n      model.setMiddleware(stages);\n      this.model = model;\n    }\n\n    return this.model;\n  }\n\n  private resolveDataValue(\n    binding: BindingInstance,\n    value: any,\n    deformat: boolean,\n  ) {\n    if (deformat) {\n      return this.hooks.deformat.call(value, binding);\n    }\n\n    return value;\n  }\n\n  public set(\n    transaction: RawSetTransaction,\n    options?: DataModelOptions,\n  ): Updates {\n    let normalizedTransaction: BatchSetTransaction = [];\n\n    if (Array.isArray(transaction)) {\n      normalizedTransaction = transaction.map(([binding, value]) => {\n        const parsed = this.pathResolver.parse(binding);\n\n        return [\n          parsed,\n          this.resolveDataValue(parsed, value, Boolean(options?.formatted)),\n        ];\n      }) as BatchSetTransaction;\n    } else {\n      normalizedTransaction = Object.keys(transaction).map(\n        (binding: string) => {\n          const parsed = this.pathResolver.parse(binding);\n          const val = transaction[binding];\n\n          return [\n            parsed,\n            this.resolveDataValue(parsed, val, Boolean(options?.formatted)),\n          ];\n        },\n      ) as BatchSetTransaction;\n    }\n\n    // Figure out what the base changes being applied are\n    const setUpdates = normalizedTransaction.reduce<Updates>(\n      (updates, [binding, newVal]) => {\n        const oldVal = this.get(binding, { includeInvalid: true });\n\n        const update = {\n          binding,\n          newValue: newVal,\n          oldValue: oldVal,\n        };\n\n        if (dequal(oldVal, newVal)) {\n          this.logger?.debug(\n            `Skipping update for path: ${binding.asString()}. Value was unchanged: ${oldVal}`,\n          );\n        } else {\n          updates.push(update);\n\n          this.logger?.debug(\n            `Setting path: ${binding.asString()} from: ${oldVal} to: ${newVal}`,\n          );\n        }\n\n        return updates;\n      },\n      [],\n    );\n\n    // Get the applied update\n    const result = this.getModel().set(normalizedTransaction, options);\n\n    // Add any extra bindings that were effected\n    const setUpdateBindings = new Set(setUpdates.map((su) => su.binding));\n    result.forEach((tr) => {\n      if (\n        !setUpdateBindings.has(tr.binding) &&\n        (tr.force === true || !dequal(tr.oldValue, tr.newValue))\n      ) {\n        this.logger?.debug(\n          `Path: ${tr.binding.asString()} was changed from: ${\n            tr.oldValue\n          } to: ${tr.newValue}`,\n        );\n        setUpdates.push(tr);\n      }\n    });\n\n    this.hooks.onSet.call(normalizedTransaction);\n\n    if (setUpdates.length > 0) {\n      this.hooks.onUpdate.call(setUpdates, options);\n    }\n\n    return result;\n  }\n\n  private resolve(binding: BindingLike, readOnly: boolean): BindingInstance {\n    return Array.isArray(binding) || typeof binding === \"string\"\n      ? this.pathResolver.parse(binding, { readOnly })\n      : binding;\n  }\n\n  public get(binding: BindingLike, options?: DataModelOptions) {\n    const resolved =\n      binding instanceof BindingInstance\n        ? binding\n        : this.resolve(binding, true);\n    let result = this.getModel().get(resolved, options);\n\n    if (result === undefined && !options?.ignoreDefaultValue) {\n      const defaultVal = this.hooks.resolveDefaultValue.call(resolved);\n\n      if (defaultVal !== result) {\n        result = defaultVal;\n      }\n    }\n\n    if (options?.formatted) {\n      result = this.hooks.format.call(result, resolved);\n    } else if (options?.formatted === false) {\n      result = this.hooks.deformat.call(result, resolved);\n    }\n\n    this.hooks.onGet.call(binding, result);\n\n    return result;\n  }\n\n  public delete(binding: BindingLike, options?: DataModelOptions) {\n    if (\n      typeof binding !== \"string\" &&\n      !Array.isArray(binding) &&\n      !(binding instanceof BindingInstance)\n    ) {\n      throw new Error(\"Invalid arguments: delete expects a data path (string)\");\n    }\n\n    const resolved =\n      binding instanceof BindingInstance\n        ? binding\n        : this.resolve(binding, false);\n\n    const parentBinding = resolved.parent();\n    const property = resolved.key();\n    const parentValue = this.get(parentBinding);\n\n    const existedBeforeDelete =\n      typeof parentValue === \"object\" &&\n      parentValue !== null &&\n      Object.prototype.hasOwnProperty.call(parentValue, property);\n\n    this.getModel().delete(resolved, options);\n\n    if (existedBeforeDelete && !this.get(resolved)) {\n      this.trash.add(resolved);\n    }\n\n    this.hooks.onDelete.call(resolved);\n  }\n\n  public serialize(): object {\n    return this.hooks.serialize.call(this.get(\"\"));\n  }\n\n  public makeReadOnly(): ReadOnlyDataController {\n    return new ReadOnlyDataController(this, this.logger);\n  }\n}\n","import { BindingInstance } from \"../../binding\";\n\n/** Recursively flattens a nested object to be an object of depth 1 with keys being the full path in the orginal object */\nexport function flatten(obj: any, roots: [string][] = [], sep = \".\"): any {\n  return (\n    Object\n      // find props of given object\n      .keys(obj)\n      // return an object by iterating props\n      .reduce(\n        (memo, prop) => ({\n          // create a new object\n\n          // include previously returned object\n          ...memo,\n          ...(Object.prototype.toString.call(obj[prop]) === \"[object Object]\"\n            ? // keep working if value is an object\n              flatten(obj[prop], roots.concat([prop]))\n            : // include current prop and value and prefix prop with the roots\n              { [roots.concat([prop]).join(sep)]: obj[prop] }),\n        }),\n        {},\n      )\n  );\n}\n\n/** Converts an object into a list of binding/value tuples to use with a LocalModel object */\nexport function objectToBatchSet(obj: any): [BindingInstance, any][] {\n  const flattenedObj = flatten(obj);\n  const batchTxn: [BindingInstance, any][] = [];\n\n  Object.keys(flattenedObj).forEach((key) => {\n    batchTxn.push([new BindingInstance(key), flattenedObj[key]]);\n  });\n\n  return batchTxn;\n}\n","import { LocalModel } from \"../../data\";\nimport { BindingInstance } from \"../../binding\";\nimport { objectToBatchSet } from \"./utils\";\n\nexport interface ConstantsProvider {\n  /**\n   * Function to add constants to the providers store\n   * - @param data values to add to the constants store\n   */\n  addConstants(data: Record<string, any>, namespace: string): void;\n\n  /**\n   * Function to retrieve constants from the providers store\n   *  - @param key Key used for the store access\n   *  - @param namespace namespace values were loaded under (defined in the plugin)\n   *  - @param fallback Optional - if key doesn't exist in namespace what to return (will return unknown if not provided)\n   */\n  getConstants(key: any, namespace: string, fallback?: any): any;\n\n  /**\n   * Function to set values to temporarily override certain keys in the perminant store\n   * - @param data values to override store with\n   * - @param namespace namespace to override\n   */\n  setTemporaryValues(data: any, namespace: string): void;\n\n  /**\n   * Clears any temporary values that were previously set\n   */\n  clearTemporaryValues(): void;\n}\n\n/**\n * Key/Value store for constants and context for Player\n */\nexport class ConstantsController implements ConstantsProvider {\n  /**\n   * Data store is basically a map of namespaces to DataModels to provide some data isolation\n   */\n  private store: Map<string, LocalModel>;\n\n  /**\n   * Separate store for temporary flow specific overrides.\n   * They are kept in a separate data model to make clearing it easier between flows\n   * and so there is no confusion on what is static and what is temporary\n   */\n  private tempStore: Map<string, LocalModel>;\n\n  constructor() {\n    this.store = new Map();\n    this.tempStore = new Map();\n  }\n\n  addConstants(data: any, namespace: string): void {\n    if (this.store.has(namespace)) {\n      this.store.get(namespace)?.set(objectToBatchSet(data));\n    } else {\n      this.store.set(namespace, new LocalModel(data));\n    }\n  }\n\n  getConstants(key: string, namespace: string, fallback?: any): any {\n    const path = new BindingInstance(key);\n\n    return (\n      this.tempStore.get(namespace)?.get(path) ??\n      this.store.get(namespace)?.get(path) ??\n      fallback\n    );\n  }\n\n  setTemporaryValues(data: any, namespace: string): void {\n    if (this.tempStore.has(namespace)) {\n      this.tempStore.get(namespace)?.set(objectToBatchSet(data));\n    } else {\n      this.tempStore.set(namespace, new LocalModel(data));\n    }\n  }\n\n  clearTemporaryValues(namespace?: string): void {\n    if (namespace) {\n      this.tempStore.get(namespace)?.reset();\n    } else {\n      this.tempStore.forEach((value: LocalModel) => {\n        value.reset();\n      });\n    }\n  }\n}\n","import type {\n  Expression,\n  ExpressionObject,\n  NavigationFlowState,\n} from \"@player-ui/types\";\nimport type { ExpressionEvaluator, ExpressionType } from \"../expressions\";\nimport type { FlowInstance } from \"../controllers\";\nimport type { Player, PlayerPlugin } from \"../player\";\n\n/**\n * A plugin that taps into the flow controller to evaluate available expressions\n * Expressions can be exposed via lifecycle \"hooks\" in flow/state nodes\n * e.g: onStart, onEnd\n */\nexport class FlowExpPlugin implements PlayerPlugin {\n  name = \"flow-exp-plugin\";\n\n  apply(player: Player) {\n    let expressionEvaluator: ExpressionEvaluator | undefined;\n\n    /**\n     * Eval Helper\n     *\n     * @param exp - an expression to be evaluated\n     */\n    const handleEval = (exp: Expression | ExpressionObject) => {\n      if (exp) {\n        if (typeof exp === \"object\" && \"exp\" in exp) {\n          expressionEvaluator?.evaluate(exp.exp);\n        } else {\n          expressionEvaluator?.evaluate(exp as ExpressionType);\n        }\n      }\n    };\n\n    player.hooks.expressionEvaluator.tap(this.name, (evaluator) => {\n      expressionEvaluator = evaluator;\n    });\n\n    player.hooks.flowController.tap(this.name, (fc) => {\n      fc.hooks.flow.tap(this.name, (flow: FlowInstance) => {\n        // Eval flow nodes\n        flow.hooks.onStart.tap(this.name, (exp) => handleEval(exp));\n\n        flow.hooks.onEnd.tap(this.name, (exp) => handleEval(exp));\n        // Eval state nodes\n        flow.hooks.resolveTransitionNode.intercept({\n          call: (nextState: NavigationFlowState) => {\n            if (nextState?.onStart) {\n              handleEval(nextState.onStart);\n            }\n          },\n        });\n      });\n    });\n  }\n}\n","import type { ExpressionHandler, ExpressionType } from \"../expressions\";\nimport type { SchemaController } from \"../schema\";\nimport type { Player, PlayerPlugin } from \"../player\";\n\n/** Gets formatter for given formatName and formats value if found, returns value otherwise */\nconst createFormatFunction = (schema: SchemaController) => {\n  /**\n   * The generated handler for the given schema\n   */\n  const handler: ExpressionHandler<[unknown, string], any> = (\n    ctx,\n    value,\n    formatName,\n  ) => {\n    return (\n      schema.getFormatterForType({ type: formatName })?.format(value) ?? value\n    );\n  };\n\n  return handler;\n};\n\n/**\n * A plugin that provides the out-of-the-box expressions for player\n */\nexport class DefaultExpPlugin implements PlayerPlugin {\n  name = \"flow-exp-plugin\";\n\n  apply(player: Player) {\n    let formatFunction: ExpressionHandler<[unknown, string]> | undefined;\n\n    player.hooks.schema.tap(this.name, (schemaController) => {\n      formatFunction = createFormatFunction(schemaController);\n    });\n\n    player.hooks.expressionEvaluator.tap(this.name, (expEvaluator) => {\n      if (formatFunction) {\n        expEvaluator.addExpressionFunction(\"format\", formatFunction);\n      }\n\n      expEvaluator.addExpressionFunction(\"log\", (ctx, ...args) => {\n        player.logger.info(...args);\n      });\n\n      expEvaluator.addExpressionFunction(\"debug\", (ctx, ...args) => {\n        player.logger.debug(...args);\n      });\n\n      expEvaluator.addExpressionFunction(\n        \"eval\",\n        (ctx, ...args: [ExpressionType]) => {\n          return ctx.evaluate(...args);\n        },\n      );\n    });\n  }\n}\n","import type { Flow, FlowResult } from \"@player-ui/types\";\nimport type { BindingParser, BindingLike } from \"./binding\";\nimport type { SchemaController } from \"./schema\";\nimport type { ExpressionEvaluator } from \"./expressions\";\nimport type { Logger } from \"./logger\";\nimport type {\n  ViewController,\n  DataController,\n  ValidationController,\n  FlowController,\n} from \"./controllers\";\nimport type { ReadOnlyDataController } from \"./controllers/data/utils\";\n\n/** The status for a flow's execution state */\nexport type PlayerFlowStatus =\n  | \"not-started\"\n  | \"in-progress\"\n  | \"completed\"\n  | \"error\";\n\n/** Common interface for the state of Player's flow execution */\nexport interface BaseFlowState<T extends PlayerFlowStatus> {\n  /** A unique reference for the life-cycle of a flow */\n  ref: symbol;\n\n  /** The status of the given flow */\n  status: T;\n}\n\n/** The beginning state of Player, before it's seen a flow  */\nexport type NotStartedState = BaseFlowState<\"not-started\">;\n\nexport const NOT_STARTED_STATE: NotStartedState = {\n  ref: Symbol(\"not-started\"),\n  status: \"not-started\",\n};\n\n/** Shared properties for a flow in any state of execution (in-progress, completed successfully, or errored out) */\nexport interface PlayerFlowExecutionData {\n  /** The currently executing flow */\n  flow: Flow;\n}\n\nexport interface ControllerState {\n  /** The manager for data for a flow */\n  data: DataController;\n\n  /** The view manager for a flow */\n  view: ViewController;\n\n  /** The schema manager for a flow */\n  schema: SchemaController;\n\n  /** The validation manager for a flow */\n  validation: ValidationController;\n\n  /** The expression evaluator for a flow */\n  expression: ExpressionEvaluator;\n\n  /** The manager for parsing and resolving bindings */\n  binding: BindingParser;\n\n  /** the manager for the flow state machine */\n  flow: FlowController;\n}\n\n/** A flow is currently executing */\nexport type InProgressState = BaseFlowState<\"in-progress\"> &\n  PlayerFlowExecutionData & {\n    /** A promise that resolves when the flow is completed */\n    flowResult: Promise<FlowResult>;\n\n    /** The underlying state controllers for the current flow */\n    controllers: ControllerState;\n\n    /** Allow other platforms to abort the current flow with an error  */\n    fail: (error: Error) => void;\n\n    /**\n     * The Logger for the current player instance\n     */\n    logger: Logger;\n  };\n\n/** The flow completed properly */\nexport type CompletedState = BaseFlowState<\"completed\"> &\n  PlayerFlowExecutionData &\n  FlowResult & {\n    /** Readonly Player controllers to provide Player functionality after the flow has ended */\n    controllers: {\n      /** A read only instance of the Data Controller */\n      data: ReadOnlyDataController;\n    };\n  };\n\n/** The flow finished but not successfully */\nexport type ErrorState = BaseFlowState<\"error\"> & {\n  /** The currently executing flow */\n  flow: Flow;\n\n  /** The error associated with the failed flow */\n  error: Error;\n};\n\n/** Any Player state  */\nexport type PlayerFlowState =\n  | NotStartedState\n  | InProgressState\n  | CompletedState\n  | ErrorState;\n\n// Model\n\nexport type RawSetType = [BindingLike, any];\nexport type RawSetTransaction = Record<string, any> | RawSetType[];\n","import type { Player, PlayerPlugin } from \"../player\";\nimport {\n  ApplicabilityPlugin,\n  StringResolverPlugin,\n  SwitchPlugin,\n  TemplatePlugin,\n  toNodeResolveOptions,\n} from \"../view\";\n\n/**\n * A plugin that provides the out-of-the-box expressions for player\n */\nexport class DefaultViewPlugin implements PlayerPlugin {\n  name = \"default-view-plugin\";\n\n  apply(player: Player) {\n    player.hooks.viewController.tap(this.name, (viewController) => {\n      viewController.hooks.view.tap(this.name, (view) => {\n        const pluginOptions = toNodeResolveOptions(view.resolverOptions);\n        new SwitchPlugin(pluginOptions).apply(view);\n        new ApplicabilityPlugin().apply(view);\n        new StringResolverPlugin().apply(view);\n        const templatePlugin = new TemplatePlugin(pluginOptions);\n        templatePlugin.apply(view);\n        view.hooks.onTemplatePluginCreated.call(templatePlugin);\n      });\n    });\n  }\n}\n"]}