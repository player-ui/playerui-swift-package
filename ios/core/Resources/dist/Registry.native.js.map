{"version":3,"sources":["../../../../../../../../../../../execroot/_main/bazel-out/darwin_arm64-fastbuild/bin/node_modules/.aspect_rules_js/sorted-array@2.0.4/node_modules/sorted-array/sorted-array.js","../../../../../../../../../../../execroot/_main/bazel-out/darwin_arm64-fastbuild/bin/core/partial-match-registry/src/index.ts","../../../../../../../../../../../execroot/_main/bazel-out/darwin_arm64-fastbuild/bin/node_modules/.aspect_rules_js/dlv@1.1.3/node_modules/dlv/index.js","../../../../../../../../../../../execroot/_main/bazel-out/darwin_arm64-fastbuild/bin/core/partial-match-registry/src/deep-partial-matcher.ts"],"sourcesContent":["var SortedArray = (function () {\n    var SortedArray = defclass({\n\n        constructor: function (array, compare) {\n            this.array   = [];\n            this.compare = compare || compareDefault;\n            var length   = array.length,\n                index    = 0;\n            while (index < length) this.insert(array[index++]);\n        },\n        insert: function (element) {\n            var array   = this.array,\n                compare = this.compare,\n                high    = array.length-1,\n                low     = 0,\n                pos = -1,\n                index,\n                ordering;\n\n            // The array is sorted. You must find the position of new element in O(log(n)), not O(n).\n            while (high >= low) {\n                index    = (high + low) / 2 >>> 0;\n                ordering = compare(array[index], element);                \n                if (ordering < 0) low  = index + 1;\n                else if (ordering > 0) high = index - 1;\n                else {\n                    pos = index;\n                    break;\n                };\n            }\n\n            if (pos === -1) {\n                // if element was not found, high < low.\n                pos = high;\n            }\n            // This assures that equal elements inserted after will be in a higher position in array.\n            // They can be equal for comparison purposes, but different objects with different data.\n            // Respecting the chronological order can be important for many applications.\n            pos++;\n            high = array.length-1;\n            while ((pos < high) && (compare(element, array[pos]) === 0)){\n                pos++;\n            }\n            index = array.length;\n            // Just to increase array size.\n            array.push(element);            \n            // Much faster. No need to elements swap.\n            while (index > pos) {\n                array[index] = array[--index];\n            }\n            // Set the new element on its correct position.\n            array[pos] = element;\n\n            return this;\n        },\n        search: function (element) {\n            var array   = this.array,\n                compare = this.compare,\n                high    = array.length-1,\n                low     = 0,\n                // In most languages, inner variable declaration makes the code slower.\n                index,\n                ordering;\n\n            while (high >= low) {\n                index    = (high + low) / 2 >>> 0;\n                ordering = compare(array[index], element);\n\n                     if (ordering < 0) low  = index + 1;\n                else if (ordering > 0) high = index - 1;\n                else return index;\n            }\n\n            return -1;\n        },\n        remove: function (element) {\n            var index = this.search(element);\n            if (index >= 0) this.array.splice(index, 1);\n            return this;\n        }\n    });\n\n    SortedArray.comparing = function (property, array) {\n        return new SortedArray(array, function (a, b) {\n            // This should be faster than calling functions.\n            // Besides, this way it is not needed to create useless function to return property value.\n            return compareDefault(a[property], b[property]);\n        });\n    };\n\n    return SortedArray;\n\n    function defclass(prototype) {\n        var constructor = prototype.constructor;\n        constructor.prototype = prototype;\n        return constructor;\n    }\n\n    function compareDefault(a, b) {\n        // Equality has a very low chance to happen. It should be the last option.\n        if (a < b)\n            return -1;\n        else if (a > b)\n            return 1;\n        else\n            return 0;\n    }\n}());\n\nif (typeof module === \"object\") module.exports = SortedArray;\nif (typeof define === \"function\" && define.amd)\n    define(function () { return SortedArray; });\n","import SortedArray from \"sorted-array\";\nimport type { Matcher } from \"./deep-partial-matcher\";\nimport createObjectMatcher from \"./deep-partial-matcher\";\n\nexport { default as createObjectMatcher } from \"./deep-partial-matcher\";\n\n/** create a matcher function that matches exactly */\nfunction createBasicMatcher(seed: any): Matcher {\n  /** a simple matcher function that only matches itself */\n  const matcher = (match: any) => seed === match;\n  matcher.count = 1;\n\n  return matcher;\n}\n\ninterface RegistryIndex<V> {\n  /** The original object we wanted to match on  */\n  key: object;\n\n  /** The value to return */\n  value: V;\n\n  /** The matcher function for this entry */\n  matcher: Matcher;\n}\n\n/** create an empty sorted array using the matcher count */\nconst createSortedArray = <V>() =>\n  new SortedArray<RegistryIndex<V>>([], (c) => c.matcher.count);\n\n/**\n * A partial match registry is a map that uses an object to \"match\" against keys.\n * More specific matches take precedence over less specific ones.\n */\nexport class Registry<V> {\n  private store = createSortedArray<V>();\n\n  constructor(initialSet?: Array<[any, V]>) {\n    initialSet?.forEach(([match, value]) => {\n      this.set(match, value);\n    });\n  }\n\n  /** Add match -> value mapping to the registry */\n  set(match: any, value: V) {\n    const matcher =\n      typeof match === \"object\"\n        ? createObjectMatcher(match)\n        : createBasicMatcher(match);\n\n    this.store.insert({\n      key: match,\n      value,\n      matcher,\n    });\n  }\n\n  /** Fetch the best match in the registry */\n  get(query: any): V | undefined {\n    for (const entry of this.store.array) {\n      if (entry.matcher(query)) {\n        return entry.value;\n      }\n    }\n  }\n\n  /** Loop over all entries and run callback */\n  forEach(callbackfn: (value: RegistryIndex<V>) => void): void {\n    for (const entry of this.store.array) {\n      callbackfn(entry);\n    }\n  }\n\n  /** Reset the items in the registry */\n  clear() {\n    this.store = createSortedArray<V>();\n  }\n}\n","export default function dlv(obj, key, def, p, undef) {\n\tkey = key.split ? key.split('.') : key;\n\tfor (p = 0; p < key.length; p++) {\n\t\tobj = obj ? obj[key[p]] : undef;\n\t}\n\treturn obj === undef ? def : obj;\n}\n","import dlv from \"dlv\";\n\n/** A function that checks overlapping properties against a reference value */\nexport type Matcher = ((searchObj: object) => boolean) & {\n  /** The count represents the specificity of this matcher */\n  count: number;\n};\n\n/** Traverse an object and collect any key/value pairs including nested keys */\nfunction traverseObj(\n  object: Record<any, any>,\n  path: string[] = [],\n  pairs: Map<string[], any> = new Map(),\n): Map<string[], any> {\n  for (const key of Object.keys(object)) {\n    const val: any = object[key];\n    const nestedPath = [...path, key];\n    (\"\");\n\n    if (typeof val === \"object\") {\n      traverseObj(val, nestedPath, pairs);\n    } else {\n      pairs.set(nestedPath, val);\n    }\n  }\n\n  return pairs;\n}\n\n/** Given an object, create a function that compares any set key/value pairs in the given object against a new value */\nexport default function createMatcher(partialObj: object): Matcher {\n  // Convert the partial object into a list of [key, value] pairs;\n  const pairs = traverseObj(partialObj);\n\n  /** Generate a function to match against all of the properties we care about */\n  const matchFunction = (searchObj: object) => {\n    for (const entry of Array.from(pairs)) {\n      const [path, value] = entry;\n\n      if (dlv(searchObj, path) !== value) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  // Keep track of the specificity of the comparator\n  matchFunction.count = pairs.size;\n\n  return matchFunction;\n}\n"],"mappings":"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","names":["SortedArray","obj","key","def","p","undef","split","length","SortedArray"]}