{"version":3,"sources":["../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/ts-nested-error@1.2.1/node_modules/ts-nested-error/src/nested-error.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/timm@1.7.1/node_modules/timm/lib/timm.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/p-defer@3.0.0/node_modules/p-defer/index.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/queue-microtask@1.2.3/node_modules/queue-microtask/index.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/sorted-array@2.0.4/node_modules/sorted-array/sorted-array.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/common-types/core/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/types-provider/core/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/common-types/core/src/validators/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/tapable-ts@0.2.4/node_modules/tapable-ts/src/utils.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/tapable-ts@0.2.4/node_modules/tapable-ts/src/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/resolver.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dlv@1.1.3/node_modules/dlv/index.js","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/local-model.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/evaluator.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/string-resolver/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/validator/validation-middleware.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/resolver/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dequal@2.0.3/node_modules/dequal/dist/index.mjs","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/parser/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/string-resolver.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/applicability.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/player.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/flow/flow.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/validation/controller.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/view/controller.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/partial-match-registry/src/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/partial-match-registry/src/deep-partial-matcher.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding-grammar/ast.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding-grammar/custom/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/utils.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/binding.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/dependency-tracker.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/noop-model.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/model.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/types.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/parser.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/evaluator-functions.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/utils.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/logger/tapableLogger.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/logger/proxyLogger.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/schema/schema.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/validator/binding-map-splice.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/validator/registry.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/parser/utils.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/resolver/utils.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/view.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/template.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/switch.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/multi-node.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/asset.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/flow/controller.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/utils/replaceParams.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/validation/binding-tracker.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/view/store.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/view/asset-transform.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/data/utils.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/data/controller.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/constants/utils.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/constants/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/plugins/flow-exp-plugin.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/plugins/default-exp-plugin.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/types.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/plugins/default-view-plugin.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/common-types/core/src/data-types/types.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/common-types/core/src/formats/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/common-types/core/src/formats/utils.ts"],"names":["NestedError","clone","addLast","removeAt","set","setIn","omit","deferred","SortedArray","length","t","import_ts_nested_error","obj","key","def","p","undef","split","import_timm","import_p_defer","expression","regex","normalized","__export","SyncWaterfallHook","SyncBailHook","SyncHook","parse","value","children","update","defer","queueMicrotask","dequal","_Player","integer","phone"],"mappings":"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","sourcesContent":["/**\n * Subclass of standard `Error` that eagerly collects the callstack of the error\n * that caused it. This way you can investigate the core problem that happened\n * by looking at the callstack from up to bottom (from higher level errors to\n * lower level).\n */\nexport class NestedError extends Error {\n    /**\n     * Combined callstack of this error and the errors that it wraps.\n     * If the JavaScript runtime doesn't support `Error::stack` property\n     * this will contain only the concatenated messages.\n     */\n    readonly stack: string;\n\n    /**\n     * The list of lower-level errors wrapped by this error.\n     */\n    readonly innerErrors: Error[];\n\n    /**\n     * Provides the first `Error` of the `innerErrors` (if it exists);\n     * otherwise, `null`.\n     *\n     * @deprecated Please shift to using the `innerErrors` (with an 's') property.\n     */\n    get innerError(): Error | null {\n        return this.innerErrors.length === 0\n            ? null\n            : this.innerErrors[0];\n    }\n\n    private static readonly getErrorReport = typeof new Error().stack === 'string'\n        ? (err: Error) => err.stack!\n        : (err: Error) => `${err.name}: ${err.message}`;\n\n    /**\n     * Returns the function that accepts any value that was thrown as the first argument and\n     * throws it wrapped into `NestedError` or class derived from `NestedError` (provided\n     * this method was called directly in the context of that dervied class constructor)\n     * with the given `message`.\n     * Returned function will pass accepted `Error` object directly to `NestedError`\n     * as `innerErrors` by invoking `toError(err)` on it.\n     *\n     * You'll most likely want to use this method with promises:\n     *\n     * ```ts\n     * userService.getPage().then(\n     *     data => console.log(`Hooray! data: ${data}`),\n     *     NestedError.rethrow('failed to fetch users page')\n     * );\n     * ```\n     *\n     * @param message Message to attach `NestedError` created by the returned function.\n     */\n    static rethrow(message: string) {\n        return (...errs: unknown[]) => { throw new this(message, ...errs); };\n    }\n\n    /**\n     * Allocates an instance of `NestedError` with the given error `message` and\n     * optional `innerError` (which will be automatically coerced using `toError()`).\n     *\n     * @param message     Laconic error message to attach to the created `NestedError`.\n     * @param innerErrors Optional errors that will be wrapped by this higher level\n     *                    error. This value will be automatically coerced using `toError()`.\n     */\n    constructor(message?: string, ...innerErrors: unknown[]) {\n        super(message);\n        const thisErrorReport = NestedError.getErrorReport(this);\n        if (innerErrors.length === 1) {\n            const innerError = toError(innerErrors[0]);\n            this.innerErrors = [innerError];\n            const errReport = NestedError.getErrorReport(innerError);\n            this.stack = `${thisErrorReport}\\n\\n======= INNER ERROR =======\\n\\n${errReport}`;\n            return;\n        }\n        this.innerErrors = innerErrors.map(err => toError(err));\n        const innerErrorReports = this.innerErrors\n            .map((error, idx) => {\n                const errReport = NestedError.getErrorReport(error);\n                return `======= INNER ERROR (${idx + 1} of ${innerErrors.length}) =======\\n\\n${errReport}`;\n            })\n            .join(\"\\n\\n\");\n        this.stack = `${thisErrorReport}\\n\\n${innerErrorReports}`;\n    }\n}\n\nNestedError.prototype.name = nameof(NestedError);\n\n/**\n * @deprecated You should not call this function on an object of statically assumed `Error` type,\n *             because it is intended to be used in a dynamic context where the type of thrown value\n *             is not known ahead of time (during the compile time).\n */\nexport function toError(err: Error): Error;\n\n/**\n * Returns `err` itself if `err instanceof Error === true`, otherwise attemts to\n * stringify it and wrap into `Error` object to be returned.\n *\n * **This function is guaranteed never to throw.**\n *\n * @param err Possbile `instanceof Error` to return or value of any type that will\n *            be wrapped into a fully-fledged `Error` object.\n */\nexport function toError(err: unknown): Error;\n\nexport function toError(err: unknown) {\n    try {\n        return err instanceof Error\n            ? err\n            : new Error(`Value that is not an instance of Error was thrown: ${err}`);\n    } catch {\n        return new Error(\n            \"Failed to stringify non-instance of Error that was thrown.\" +\n            \"This is possibly due to the fact that toString() method of the value\" +\n            \"doesn't return a primitive value.\"\n        );\n    }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clone = clone;\nexports.addLast = addLast;\nexports.addFirst = addFirst;\nexports.removeLast = removeLast;\nexports.removeFirst = removeFirst;\nexports.insert = insert;\nexports.removeAt = removeAt;\nexports.replaceAt = replaceAt;\nexports.getIn = getIn;\nexports.set = set;\nexports.setIn = setIn;\nexports.update = update;\nexports.updateIn = updateIn;\nexports.merge = merge;\nexports.mergeDeep = mergeDeep;\nexports.mergeIn = mergeIn;\nexports.omit = omit;\nexports.addDefaults = addDefaults;\nexports.default = void 0;\n\n/* eslint-disable @typescript-eslint/ban-types */\n\n/*!\n * Timm\n *\n * Immutability helpers with fast reads and acceptable writes.\n *\n * @copyright Guillermo Grau Panea 2016\n * @license MIT\n */\nconst INVALID_ARGS = 'INVALID_ARGS';\nconst IS_DEV = process.env.NODE_ENV !== 'production';\n\n// ===============================================\n// ### Helpers\n// ===============================================\nfunction throwStr(msg) {\n  throw new Error(msg);\n}\n\nfunction getKeysAndSymbols(obj) {\n  const keys = Object.keys(obj);\n\n  if (Object.getOwnPropertySymbols) {\n    // @ts-ignore\n    return keys.concat(Object.getOwnPropertySymbols(obj));\n  }\n\n  return keys;\n}\n\nconst hasOwnProperty = {}.hasOwnProperty;\n\nfunction clone(obj0) {\n  // As array\n  if (Array.isArray(obj0)) return obj0.slice(); // As object\n\n  const obj = obj0;\n  const keys = getKeysAndSymbols(obj);\n  const out = {};\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    out[key] = obj[key];\n  } // @ts-ignore (see type tests)\n\n\n  return out;\n} // Custom guard\n\n\nfunction isObject(o) {\n  return o != null && typeof o === 'object';\n} // _deepFreeze = (obj) ->\n//   Object.freeze obj\n//   for key in Object.getOwnPropertyNames obj\n//     val = obj[key]\n//     if isObject(val) and not Object.isFrozen val\n//       _deepFreeze val\n//   obj\n// ===============================================\n// -- ### Arrays\n// ===============================================\n// -- #### addLast()\n// -- Returns a new array with an appended item or items.\n// --\n// -- Usage: `addLast(array, val)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = addLast(arr, 'c')\n// -- // ['a', 'b', 'c']\n// -- arr2 === arr\n// -- // false\n// -- arr3 = addLast(arr, ['c', 'd'])\n// -- // ['a', 'b', 'c', 'd']\n// -- ```\n// `array.concat(val)` also handles the scalar case,\n// but is apparently very slow\n\n\nfunction addLast(array, val) {\n  if (Array.isArray(val)) return array.concat(val);\n  return array.concat([val]);\n} // -- #### addFirst()\n// -- Returns a new array with a prepended item or items.\n// --\n// -- Usage: `addFirst(array, val)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = addFirst(arr, 'c')\n// -- // ['c', 'a', 'b']\n// -- arr2 === arr\n// -- // false\n// -- arr3 = addFirst(arr, ['c', 'd'])\n// -- // ['c', 'd', 'a', 'b']\n// -- ```\n\n\nfunction addFirst(array, val) {\n  if (Array.isArray(val)) return val.concat(array);\n  return [val].concat(array);\n} // -- #### removeLast()\n// -- Returns a new array removing the last item.\n// --\n// -- Usage: `removeLast(array)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = removeLast(arr)\n// -- // ['a']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- arr3 = []\n// -- removeLast(arr3) === arr3\n// -- // true\n// -- ```\n\n\nfunction removeLast(array) {\n  if (!array.length) return array;\n  return array.slice(0, array.length - 1);\n} // -- #### removeFirst()\n// -- Returns a new array removing the first item.\n// --\n// -- Usage: `removeFirst(array)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = removeFirst(arr)\n// -- // ['b']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- arr3 = []\n// -- removeFirst(arr3) === arr3\n// -- // true\n// -- ```\n\n\nfunction removeFirst(array) {\n  if (!array.length) return array;\n  return array.slice(1);\n} // -- #### insert()\n// -- Returns a new array obtained by inserting an item or items\n// -- at a specified index.\n// --\n// -- Usage: `insert(array, idx, val)`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = insert(arr, 1, 'd')\n// -- // ['a', 'd', 'b', 'c']\n// -- arr2 === arr\n// -- // false\n// -- insert(arr, 1, ['d', 'e'])\n// -- // ['a', 'd', 'e', 'b', 'c']\n// -- ```\n\n\nfunction insert(array, idx, val) {\n  return array.slice(0, idx).concat(Array.isArray(val) ? val : [val]).concat(array.slice(idx));\n} // -- #### removeAt()\n// -- Returns a new array obtained by removing an item at\n// -- a specified index.\n// --\n// -- Usage: `removeAt(array, idx)`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = removeAt(arr, 1)\n// -- // ['a', 'c']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- removeAt(arr, 4) === arr\n// -- // true\n// -- ```\n\n\nfunction removeAt(array, idx) {\n  if (idx >= array.length || idx < 0) return array;\n  return array.slice(0, idx).concat(array.slice(idx + 1));\n} // -- #### replaceAt()\n// -- Returns a new array obtained by replacing an item at\n// -- a specified index. If the provided item is the same as\n// -- (*referentially equal to*) the previous item at that position,\n// -- the original array is returned.\n// --\n// -- Usage: `replaceAt(array, idx, newItem)`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = replaceAt(arr, 1, 'd')\n// -- // ['a', 'd', 'c']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- replaceAt(arr, 1, 'b') === arr\n// -- // true\n// -- ```\n\n\nfunction replaceAt(array, idx, newItem) {\n  if (array[idx] === newItem) return array;\n  const len = array.length;\n  const result = Array(len);\n\n  for (let i = 0; i < len; i++) {\n    result[i] = array[i];\n  }\n\n  result[idx] = newItem;\n  return result;\n} // ===============================================\n// -- ### Collections (objects and arrays)\n// ===============================================\n// -- #### getIn()\n// -- Returns a value from an object at a given path. Works with\n// -- nested arrays and objects. If the path does not exist, it returns\n// -- `undefined`.\n// --\n// -- Usage: `getIn(obj, path)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: ['a', 'b', 'c'] }\n// -- getIn(obj, ['d', 'd1'])\n// -- // 3\n// -- getIn(obj, ['e', 1])\n// -- // 'b'\n// -- ```\n\n\nfunction getIn(obj, path) {\n  if (!Array.isArray(path)) {\n    throwStr(IS_DEV ? 'A path array should be provided when calling getIn()' : INVALID_ARGS);\n  }\n\n  if (obj == null) return undefined;\n  let ptr = obj;\n\n  for (let i = 0; i < path.length; i++) {\n    const key = path[i];\n    ptr = ptr != null ? ptr[key] : undefined;\n    if (ptr === undefined) return ptr;\n  }\n\n  return ptr;\n} // -- #### set()\n// -- Returns a new object with a modified attribute.\n// -- If the provided value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `set(obj, key, val)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3 }\n// -- obj2 = set(obj, 'b', 5)\n// -- // { a: 1, b: 5, c: 3 }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- set(obj, 'b', 2) === obj\n// -- // true\n// -- ```\n// When called with an undefined/null `obj`, `set()` returns either\n// a single-element array, or a single-key object\n\n\n// Implementation\nfunction set(obj0, key, val) {\n  let obj = obj0;\n  if (obj == null) obj = typeof key === 'number' ? [] : {};\n  if (obj[key] === val) return obj;\n  const obj2 = clone(obj);\n  obj2[key] = val;\n  return obj2;\n} // -- #### setIn()\n// -- Returns a new object with a modified **nested** attribute.\n// --\n// -- Notes:\n// --\n// -- * If the provided value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// -- * If the path does not exist, it will be created before setting\n// -- the new value.\n// --\n// -- Usage: `setIn(obj, path, val)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj2 = setIn(obj, ['d', 'd1'], 4)\n// -- // { a: 1, b: 2, d: { d1: 4, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj2 === obj\n// -- // false\n// -- obj2.d === obj.d\n// -- // false\n// -- obj2.e === obj.e\n// -- // true\n// --\n// -- // The same object is returned if there are no changes:\n// -- obj3 = setIn(obj, ['d', 'd1'], 3)\n// -- // { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj3 === obj\n// -- // true\n// -- obj3.d === obj.d\n// -- // true\n// -- obj3.e === obj.e\n// -- // true\n// --\n// -- // ... unknown paths create intermediate keys. Numeric segments are treated as array indices:\n// -- setIn({ a: 3 }, ['unknown', 0, 'path'], 4)\n// -- // { a: 3, unknown: [{ path: 4 }] }\n// -- ```\n\n\nfunction setIn(obj, path, val) {\n  if (!path.length) return val;\n  return doSetIn(obj, path, val, 0);\n}\n\nfunction doSetIn(obj, path, val, idx) {\n  let newValue;\n  const key = path[idx];\n\n  if (idx === path.length - 1) {\n    newValue = val;\n  } else {\n    const nestedObj = isObject(obj) && isObject(obj[key]) ? obj[key] : typeof path[idx + 1] === 'number' ? [] : {};\n    newValue = doSetIn(nestedObj, path, val, idx + 1);\n  }\n\n  return set(obj, key, newValue);\n} // -- #### update()\n// -- Returns a new object with a modified attribute,\n// -- calculated via a user-provided callback based on the current value.\n// -- If the calculated value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `update(obj, key, fnUpdate)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3 }\n// -- obj2 = update(obj, 'b', (val) => val + 1)\n// -- // { a: 1, b: 3, c: 3 }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- update(obj, 'b', (val) => val) === obj\n// -- // true\n// -- ```\n\n\nfunction update(obj, key, fnUpdate) {\n  const prevVal = obj == null ? undefined : obj[key];\n  const nextVal = fnUpdate(prevVal);\n  return set(obj, key, nextVal);\n} // -- #### updateIn()\n// -- Returns a new object with a modified **nested** attribute,\n// -- calculated via a user-provided callback based on the current value.\n// -- If the calculated value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `updateIn<T: ArrayOrObject>(obj: T, path: Array<Key>,\n// -- fnUpdate: (prevValue: any) => any): T`\n// --\n// -- ```js\n// -- obj = { a: 1, d: { d1: 3, d2: 4 } }\n// -- obj2 = updateIn(obj, ['d', 'd1'], (val) => val + 1)\n// -- // { a: 1, d: { d1: 4, d2: 4 } }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- obj3 = updateIn(obj, ['d', 'd1'], (val) => val)\n// -- // { a: 1, d: { d1: 3, d2: 4 } }\n// -- obj3 === obj\n// -- // true\n// -- ```\n\n\nfunction updateIn(obj, path, fnUpdate) {\n  const prevVal = getIn(obj, path);\n  const nextVal = fnUpdate(prevVal);\n  return setIn(obj, path, nextVal);\n} // -- #### merge()\n// -- Returns a new object built as follows: the overlapping keys from the\n// -- second one overwrite the corresponding entries from the first one.\n// -- Similar to `Object.assign()`, but immutable.\n// --\n// -- Usage:\n// --\n// -- * `merge(obj1, obj2)`\n// -- * `merge(obj1, ...objects)`\n// --\n// -- The unmodified `obj1` is returned if `obj2` does not *provide something\n// -- new to* `obj1`, i.e. if either of the following\n// -- conditions are true:\n// --\n// -- * `obj2` is `null` or `undefined`\n// -- * `obj2` is an object, but it is empty\n// -- * All attributes of `obj2` are `undefined`\n// -- * All attributes of `obj2` are referentially equal to the\n// --   corresponding attributes of `obj1`\n// --\n// -- Note that `undefined` attributes in `obj2` do not modify the\n// -- corresponding attributes in `obj1`.\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: 3 }\n// -- obj2 = { c: 4, d: 5 }\n// -- obj3 = merge(obj1, obj2)\n// -- // { a: 1, b: 2, c: 4, d: 5 }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- merge(obj1, { c: 3 }) === obj1\n// -- // true\n// -- ```\n// Signatures:\n// - 1 arg\n\n\n// Implementation\nfunction merge(a, b, c, d, e, f, ...rest) {\n  return rest.length ? doMerge.call(null, false, false, a, b, c, d, e, f, ...rest) : doMerge(false, false, a, b, c, d, e, f);\n} // -- #### mergeDeep()\n// -- Returns a new object built as follows: the overlapping keys from the\n// -- second one overwrite the corresponding entries from the first one.\n// -- If both the first and second entries are objects they are merged recursively.\n// -- Similar to `Object.assign()`, but immutable, and deeply merging.\n// --\n// -- Usage:\n// --\n// -- * `mergeDeep(obj1, obj2)`\n// -- * `mergeDeep(obj1, ...objects)`\n// --\n// -- The unmodified `obj1` is returned if `obj2` does not *provide something\n// -- new to* `obj1`, i.e. if either of the following\n// -- conditions are true:\n// --\n// -- * `obj2` is `null` or `undefined`\n// -- * `obj2` is an object, but it is empty\n// -- * All attributes of `obj2` are `undefined`\n// -- * All attributes of `obj2` are referentially equal to the\n// --   corresponding attributes of `obj1`\n// --\n// -- Note that `undefined` attributes in `obj2` do not modify the\n// -- corresponding attributes in `obj1`.\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: { a: 1 } }\n// -- obj2 = { b: 3, c: { b: 2 } }\n// -- obj3 = mergeDeep(obj1, obj2)\n// -- // { a: 1, b: 3, c: { a: 1, b: 2 }  }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- mergeDeep(obj1, { c: { a: 1 } }) === obj1\n// -- // true\n// -- ```\n\n\nfunction mergeDeep(a, b, c, d, e, f, ...rest) {\n  return rest.length ? doMerge.call(null, false, true, a, b, c, d, e, f, ...rest) : doMerge(false, true, a, b, c, d, e, f);\n} // -- #### mergeIn()\n// -- Similar to `merge()`, but merging the value at a given nested path.\n// --\n// -- Usage examples:\n// --\n// -- * `mergeIn(obj1, path, obj2)`\n// -- * `mergeIn(obj1, path, ...objects)`\n// --\n// -- ```js\n// -- obj1 = { a: 1, d: { b: { d1: 3, d2: 4 } } }\n// -- obj2 = { d3: 5 }\n// -- obj3 = mergeIn(obj1, ['d', 'b'], obj2)\n// -- // { a: 1, d: { b: { d1: 3, d2: 4, d3: 5 } } }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- mergeIn(obj1, ['d', 'b'], { d2: 4 }) === obj1\n// -- // true\n// -- ```\n\n\nfunction mergeIn(a, path, b, c, d, e, f, ...rest) {\n  let prevVal = getIn(a, path);\n  if (prevVal == null) prevVal = {};\n  let nextVal;\n\n  if (rest.length) {\n    nextVal = doMerge.call(null, false, false, prevVal, b, c, d, e, f, ...rest);\n  } else {\n    nextVal = doMerge(false, false, prevVal, b, c, d, e, f);\n  }\n\n  return setIn(a, path, nextVal);\n} // -- #### omit()\n// -- Returns an object excluding one or several attributes.\n// --\n// -- Usage: `omit(obj, attrs)`\n//\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3, d: 4 }\n// -- omit(obj, 'a')\n// -- // { b: 2, c: 3, d: 4 }\n// -- omit(obj, ['b', 'c'])\n// -- // { a: 1, d: 4 }\n// --\n// -- // The same object is returned if there are no changes:\n// -- omit(obj, 'z') === obj1\n// -- // true\n// -- ```\n\n\nfunction omit(obj, attrs) {\n  const omitList = Array.isArray(attrs) ? attrs : [attrs];\n  let fDoSomething = false;\n\n  for (let i = 0; i < omitList.length; i++) {\n    if (hasOwnProperty.call(obj, omitList[i])) {\n      fDoSomething = true;\n      break;\n    }\n  }\n\n  if (!fDoSomething) return obj;\n  const out = {};\n  const keys = getKeysAndSymbols(obj);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (omitList.indexOf(key) >= 0) continue;\n    out[key] = obj[key];\n  }\n\n  return out;\n} // -- #### addDefaults()\n// -- Returns a new object built as follows: `undefined` keys in the first one\n// -- are filled in with the corresponding values from the second one\n// -- (even if they are `null`).\n// --\n// -- Usage:\n// --\n// -- * `addDefaults(obj, defaults)`\n// -- * `addDefaults(obj, ...defaultObjects)`\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: 3 }\n// -- obj2 = { c: 4, d: 5, e: null }\n// -- obj3 = addDefaults(obj1, obj2)\n// -- // { a: 1, b: 2, c: 3, d: 5, e: null }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- addDefaults(obj1, { c: 4 }) === obj1\n// -- // true\n// -- ```\n// Signatures:\n// - 2 args\n\n\n// Implementation and catch-all\nfunction addDefaults(a, b, c, d, e, f, ...rest) {\n  return rest.length ? doMerge.call(null, true, false, a, b, c, d, e, f, ...rest) : doMerge(true, false, a, b, c, d, e, f);\n}\n\nfunction doMerge(fAddDefaults, fDeep, first, ...rest) {\n  let out = first;\n\n  if (!(out != null)) {\n    throwStr(IS_DEV ? 'At least one object should be provided to merge()' : INVALID_ARGS);\n  }\n\n  let fChanged = false;\n\n  for (let idx = 0; idx < rest.length; idx++) {\n    const obj = rest[idx];\n    if (obj == null) continue;\n    const keys = getKeysAndSymbols(obj);\n    if (!keys.length) continue;\n\n    for (let j = 0; j <= keys.length; j++) {\n      const key = keys[j];\n      if (fAddDefaults && out[key] !== undefined) continue;\n      let nextVal = obj[key];\n\n      if (fDeep && isObject(out[key]) && isObject(nextVal)) {\n        nextVal = doMerge(fAddDefaults, fDeep, out[key], nextVal);\n      }\n\n      if (nextVal === undefined || nextVal === out[key]) continue;\n\n      if (!fChanged) {\n        fChanged = true;\n        out = clone(out);\n      }\n\n      out[key] = nextVal;\n    }\n  }\n\n  return out;\n} // ===============================================\n// ### Public API\n// ===============================================\n\n\nconst timm = {\n  clone,\n  addLast,\n  addFirst,\n  removeLast,\n  removeFirst,\n  insert,\n  removeAt,\n  replaceAt,\n  getIn,\n  set,\n  setIn,\n  update,\n  updateIn,\n  merge,\n  mergeDeep,\n  mergeIn,\n  omit,\n  addDefaults\n};\nvar _default = timm;\nexports.default = _default;","'use strict';\n\nconst pDefer = () => {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n};\n\nmodule.exports = pDefer;\n","/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n","var SortedArray = (function () {\n    var SortedArray = defclass({\n\n        constructor: function (array, compare) {\n            this.array   = [];\n            this.compare = compare || compareDefault;\n            var length   = array.length,\n                index    = 0;\n            while (index < length) this.insert(array[index++]);\n        },\n        insert: function (element) {\n            var array   = this.array,\n                compare = this.compare,\n                high    = array.length-1,\n                low     = 0,\n                pos = -1,\n                index,\n                ordering;\n\n            // The array is sorted. You must find the position of new element in O(log(n)), not O(n).\n            while (high >= low) {\n                index    = (high + low) / 2 >>> 0;\n                ordering = compare(array[index], element);                \n                if (ordering < 0) low  = index + 1;\n                else if (ordering > 0) high = index - 1;\n                else {\n                    pos = index;\n                    break;\n                };\n            }\n\n            if (pos === -1) {\n                // if element was not found, high < low.\n                pos = high;\n            }\n            // This assures that equal elements inserted after will be in a higher position in array.\n            // They can be equal for comparison purposes, but different objects with different data.\n            // Respecting the chronological order can be important for many applications.\n            pos++;\n            high = array.length-1;\n            while ((pos < high) && (compare(element, array[pos]) === 0)){\n                pos++;\n            }\n            index = array.length;\n            // Just to increase array size.\n            array.push(element);            \n            // Much faster. No need to elements swap.\n            while (index > pos) {\n                array[index] = array[--index];\n            }\n            // Set the new element on its correct position.\n            array[pos] = element;\n\n            return this;\n        },\n        search: function (element) {\n            var array   = this.array,\n                compare = this.compare,\n                high    = array.length-1,\n                low     = 0,\n                // In most languages, inner variable declaration makes the code slower.\n                index,\n                ordering;\n\n            while (high >= low) {\n                index    = (high + low) / 2 >>> 0;\n                ordering = compare(array[index], element);\n\n                     if (ordering < 0) low  = index + 1;\n                else if (ordering > 0) high = index - 1;\n                else return index;\n            }\n\n            return -1;\n        },\n        remove: function (element) {\n            var index = this.search(element);\n            if (index >= 0) this.array.splice(index, 1);\n            return this;\n        }\n    });\n\n    SortedArray.comparing = function (property, array) {\n        return new SortedArray(array, function (a, b) {\n            // This should be faster than calling functions.\n            // Besides, this way it is not needed to create useless function to return property value.\n            return compareDefault(a[property], b[property]);\n        });\n    };\n\n    return SortedArray;\n\n    function defclass(prototype) {\n        var constructor = prototype.constructor;\n        constructor.prototype = prototype;\n        return constructor;\n    }\n\n    function compareDefault(a, b) {\n        // Equality has a very low chance to happen. It should be the last option.\n        if (a < b)\n            return -1;\n        else if (a > b)\n            return 1;\n        else\n            return 0;\n    }\n}());\n\nif (typeof module === \"object\") module.exports = SortedArray;\nif (typeof define === \"function\" && define.amd)\n    define(function () { return SortedArray; });\n","import type { Player, ExtendedPlayerPlugin } from \"@player-ui/player\";\nimport { TypesProviderPlugin } from \"@player-ui/types-provider-plugin\";\n\nimport * as validators from \"./validators\";\nimport * as dataTypes from \"./data-types/types\";\nimport * as formats from \"./formats\";\nimport type {\n  BooleanType,\n  IntegerType,\n  IntegerPosType,\n  IntegerNNType,\n  StringType,\n  CollectionType,\n  DateType,\n  PhoneType,\n} from \"./data-types/types\";\n\nexport { validators, dataTypes, formats };\n\nexport * from \"./formats/utils\";\n\n/**\n * Exposes a lot of common DataTypes, validations, and formats to Player instance.\n */\nexport class CommonTypesPlugin\n  implements\n    ExtendedPlayerPlugin<\n      [],\n      [],\n      [],\n      [\n        typeof BooleanType,\n        typeof IntegerType,\n        typeof IntegerPosType,\n        typeof IntegerNNType,\n        typeof StringType,\n        typeof CollectionType,\n        typeof DateType,\n        typeof PhoneType,\n      ]\n    >\n{\n  name = \"CommonTypes\";\n\n  apply(player: Player) {\n    player.registerPlugin(\n      new TypesProviderPlugin({\n        types: Object.values(dataTypes),\n        formats: Object.values(formats),\n        validators: Object.entries(validators),\n      }),\n    );\n  }\n}\n","import type {\n  Player,\n  PlayerPlugin,\n  ValidatorFunction,\n  FormatType,\n  Schema,\n} from \"@player-ui/player\";\n\nexport interface TypesConfig {\n  /**\n   * DataTypes to expose to Player instance.\n   * The schema definition in authored content can reference these to get common functionality across types\n   */\n  types?: Array<Schema.DataType<any>>;\n\n  /**\n   * Custom validators to add to this player instance.\n   * Anything defined here will be available for use in any DataType or view-validation\n   */\n  validators?: Array<[string, ValidatorFunction<any>]>;\n\n  /** A list of formats (and handler functions) to expose to DataTypes */\n  formats?: Array<FormatType<any, any, any>>;\n}\n\n/**\n * The TypesProvider plugin provides an easy way for users to expose custom validators, DataTypes, or formatters to the content\n */\nexport class TypesProviderPlugin implements PlayerPlugin {\n  name = \"TypesProviderPlugin\";\n\n  private config: TypesConfig;\n\n  constructor(config: TypesConfig) {\n    this.config = config;\n  }\n\n  apply(player: Player) {\n    player.hooks.schema.tap(this.name, (schema) => {\n      if (this.config.types) {\n        schema.addDataTypes(this.config.types);\n      }\n\n      if (this.config.formats) {\n        schema.addFormatters(this.config.formats);\n      }\n    });\n\n    if (this.config.validators) {\n      player.hooks.validationController.tap(\n        this.name,\n        (validationController) => {\n          validationController.hooks.createValidatorRegistry.tap(\n            this.name,\n            (validationRegistry) => {\n              this.config.validators?.forEach(([name, handler]) => {\n                validationRegistry.register(name, handler);\n              });\n            },\n          );\n        },\n      );\n    }\n  }\n}\n","import { resolveDataRefs } from \"@player-ui/player\";\nimport type { ValidatorFunction, Expression } from \"@player-ui/player\";\n\n// Shamelessly lifted from Scott Gonzalez via the Bassistance Validation plugin http://projects.scottsplayground.com/email_address_validation/\n\nconst EMAIL_REGEX =\n  /^((([a-z]|\\d|[!#$%&'*+\\-/=?^_`{|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#$%&'*+-/=?^_`{|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?$/i;\nconst PHONE_REGEX = /^\\+?[1]?[- ]?\\(?\\d{3}[)\\- ]?\\s?\\d{3}[ -]?\\d{4}$/;\nconst ZIP_REGEX = /^\\d{5}(-\\d{4})?$/;\n\n/** Skip any null or undefined value when running the validator */\nfunction skipNullish<T>(\n  validationFn: ValidatorFunction<T>,\n): ValidatorFunction<T> {\n  return (context, value, options) => {\n    if (value === null || value === undefined) {\n      return;\n    }\n\n    return validationFn(context, value, options);\n  };\n}\n\n/** Checks to see if the data-type is a string */\nexport const string: ValidatorFunction = skipNullish((context, value) => {\n  if (typeof value !== \"string\") {\n    const message = context.constants.getConstants(\n      \"validation.string\",\n      \"constants\",\n      \"Value must be a string\",\n    ) as string;\n\n    return {\n      message,\n      parameters: {\n        type: typeof value,\n      },\n    };\n  }\n});\n\n/** Validation for a non-mutable property */\nexport const readonly: ValidatorFunction = (context) => {\n  const message = context.constants.getConstants(\n    \"validation.readonly\",\n    \"constants\",\n    \"Value cannot be modified\",\n  ) as string;\n\n  return { message };\n};\n\n/** Check to see if the value represents an array of items */\nexport const collection: ValidatorFunction = skipNullish((context, value) => {\n  if (!Array.isArray(value)) {\n    const message = context.constants.getConstants(\n      \"validation.collection\",\n      \"constants\",\n      \"Cannot set collection to non-array\",\n    ) as string;\n\n    return { message };\n  }\n});\n\n/** Checks to see if the value is an integer */\nexport const integer: ValidatorFunction = skipNullish((context, value) => {\n  if (\n    value &&\n    (typeof value !== \"number\" ||\n      Math.floor(value) !== value ||\n      Number(value) > Number.MAX_SAFE_INTEGER ||\n      Number(value) < Number.MIN_SAFE_INTEGER)\n  ) {\n    const message = context.constants.getConstants(\n      \"validation.integer\",\n      \"constants\",\n      \"Value must be an integer\",\n    ) as string;\n\n    return {\n      message,\n      parameters: {\n        type: typeof value,\n        flooredValue: Math.floor(value),\n      },\n    };\n  }\n});\n\n/** An enum check to see if the value is in a provided list of acceptable options */\nexport const oneOf: ValidatorFunction<{\n  /** The enum values that are acceptable  */\n  options: Array<unknown>;\n}> = skipNullish((context, value, options) => {\n  if (options?.options === undefined || options.options?.includes(value)) {\n    return;\n  }\n\n  const message = context.constants.getConstants(\n    \"validation.oneOf\",\n    \"constants\",\n    \"Invalid entry\",\n  ) as string;\n\n  return { message };\n});\n\n/** A validator that evaluates an expression for validation */\nexport const expression: ValidatorFunction<{\n  /**\n   * The expression to evaluate.\n   * Falsy values indicate an invalid response\n   */\n  exp: Expression;\n}> = (context, value, options?) => {\n  if (options?.exp === undefined) {\n    context.logger.warn(\"No expression defined for validation\");\n\n    return;\n  }\n\n  const result = context.evaluate(options.exp);\n\n  if (!result) {\n    const message = context.constants.getConstants(\n      \"validation.expression\",\n      \"constants\",\n      \"Expression evaluation failed\",\n    ) as string;\n\n    return { message };\n  }\n};\n\n/** A validator that requires a non-null value */\nexport const required: ValidatorFunction<{\n  /** An optional expression to limit the required check only if true */\n  if?: Expression;\n\n  /** An optional expression to limit the required check only if false */\n  ifNot?: Expression;\n}> = (context, value, options) => {\n  if (\n    (options?.if && !context.evaluate(options.if)) ||\n    (options?.ifNot && context.evaluate(options.ifNot))\n  ) {\n    // Skipping due to if check\n    return;\n  }\n\n  if (value === undefined || value === null || value === \"\") {\n    const message = context.constants.getConstants(\n      \"validation.required\",\n      \"constants\",\n      \"A value is required\",\n    ) as string;\n\n    return { message, severity: \"error\" };\n  }\n};\n\n/** A validator that uses a regular expression */\nexport const regex: ValidatorFunction<{\n  /**\n   * The regular expression to test: /pattern/\n   * Can optionally include flags after the pattern: /pattern/flags\n   */\n  regex: string;\n}> = skipNullish((context, value, options) => {\n  if (\n    value === undefined ||\n    value === null ||\n    value === \"\" ||\n    typeof options?.regex !== \"string\"\n  ) {\n    return;\n  }\n\n  const resolvedRegex = resolveDataRefs(options.regex, context);\n  // Split up /pattern/flags into [pattern, flags]\n  const patternMatch = resolvedRegex.match(/^\\/(.*)\\/(\\w)*$/);\n\n  const regexp = patternMatch\n    ? new RegExp(patternMatch[1], patternMatch[2])\n    : new RegExp(resolvedRegex);\n\n  if (!regexp.test(value)) {\n    const message = context.constants.getConstants(\n      \"validation.regex\",\n      \"constants\",\n      \"Invalid entry\",\n    ) as string;\n\n    return { message };\n  }\n});\n\n/** Checks the length of a value  */\nexport const length: ValidatorFunction<\n  | {\n      /** The minimum length to check against  */\n      min?: number;\n\n      /** The maximum length to check against  */\n      max?: number;\n    }\n  | {\n      /** The exact length to match against */\n      exact: number;\n    }\n> = skipNullish((context, value, options) => {\n  if (typeof options !== \"object\") {\n    context.logger.warn(\"Missing comparison in length validation\");\n\n    return;\n  }\n\n  let valLength: number | undefined;\n  let itemName = \"items\";\n\n  if (typeof value === \"string\") {\n    valLength = value.length;\n    itemName = \"characters\";\n  } else if (typeof value === \"object\" && value !== null) {\n    valLength = Object.keys(value).length;\n  }\n\n  if (valLength === undefined) {\n    context.logger.warn(\n      `Unable to determine a length for value of type: ${value}`,\n    );\n\n    return;\n  }\n\n  if (\"exact\" in options) {\n    if (valLength !== options.exact) {\n      return {\n        message: `Must be exactly ${options.exact} ${itemName} long`,\n        parameters: {\n          validationLength: valLength,\n        },\n      };\n    }\n\n    return;\n  }\n\n  if (options.min !== undefined && valLength < options.min) {\n    const message = context.constants.getConstants(\n      \"validation.length.minimum\",\n      \"constants\",\n      `At least ${options.min} ${itemName} needed`,\n    ) as string;\n\n    return {\n      message,\n      parameters: {\n        validationLength: valLength,\n      },\n    };\n  }\n\n  if (options.max !== undefined && valLength > options.max) {\n    const message = context.constants.getConstants(\n      \"validation.length.maximum\",\n      \"constants\",\n      `Up to ${options.max} ${itemName} allowed`,\n    ) as string;\n\n    return {\n      message,\n      parameters: {\n        validationLength: valLength,\n      },\n    };\n  }\n});\n\n/**\n * Checks that the given value is at least the expected one\n */\nexport const min: ValidatorFunction<{\n  /** The minimum value */\n  value: number;\n}> = skipNullish((context, value, options) => {\n  if (typeof value !== \"number\" || options?.value === undefined) {\n    return;\n  }\n\n  if (value < options.value) {\n    const message = context.constants.getConstants(\n      \"validation.min\",\n      \"constants\",\n      `Must be at least ${options.value}`,\n    ) as string;\n\n    return { message };\n  }\n});\n\n/**\n * Checks that the given value is at least the expected one\n */\nexport const max: ValidatorFunction<{\n  /** The minimum value */\n  value: number;\n}> = skipNullish((context, value, options) => {\n  if (typeof value !== \"number\" || options?.value === undefined) {\n    return;\n  }\n\n  if (value > options.value) {\n    const message = context.constants.getConstants(\n      \"validation.max\",\n      \"constants\",\n      `Cannot exceed ${options.value}`,\n    ) as string;\n\n    return { message };\n  }\n});\n\n/** Create a validator using a regular expression */\nconst stringRegexValidator = (\n  test: RegExp,\n  messagePath: string,\n  invalidMessage: string,\n): ValidatorFunction => {\n  return skipNullish((context, value) => {\n    if (typeof value === \"string\" && value === \"\") {\n      return;\n    }\n\n    if (typeof value !== \"string\" || !test.test(value)) {\n      const message = context.constants.getConstants(\n        messagePath,\n        \"constants\",\n        invalidMessage,\n      ) as string;\n\n      return { message };\n    }\n  });\n};\n\n/** Checks that the given value represents an email */\nexport const email = stringRegexValidator(\n  EMAIL_REGEX,\n  \"validation.email\",\n  \"Improper email format\",\n);\n\n/** Checks that the given value represents a phone number */\nexport const phone = stringRegexValidator(\n  PHONE_REGEX,\n  \"validation.phone\",\n  \"Invalid phone number\",\n);\n\n/** Checks that the given value represents a phone number */\nexport const zip = stringRegexValidator(\n  ZIP_REGEX,\n  \"validation.regex\",\n  \"Invalid zip code\",\n);\n","/**\n * Checks if `value` is equal to `check` if `check` is a string or in `check` if check is an Array\n *\n * @param value - the value being searched for\n * @param check - the values to check against\n * @returns `boolean`\n */\nexport function equalToOrIn(value: string, check: string | Array<string>) {\n  if (Array.isArray(check)) {\n    return check.includes(value);\n  }\n\n  return check === value;\n}\n","import { equalToOrIn } from \"./utils\";\n\nexport type Interceptor<Args extends any[], ReturnType, ContextType> = {\n  /** An optional name for the interceptor */\n  name?: string;\n  /** Callback for each loop when used by the hook */\n  loop?: (...args: Args) => void;\n  /** Callback when an error occurs during the hook's call */\n  error?: (err: Error) => void;\n  /** Callback when a result is found for a hook's invocation */\n  result?: (\n    r: ReturnType extends Promise<infer AwaitedValue>\n      ? AwaitedValue\n      : ReturnType\n  ) => void;\n  /** Callback when a hook's call is complete */\n  done?: () => void;\n  /** Callback when a hook is tapped */\n  tap?: (tap: Tap<Args, ReturnType, ContextType>) => void;\n} & (\n  | {\n      /** If context should be omitted from the 'call'. This is the default */\n      context?: false;\n      /** Callback when the hook is tapped without context */\n      call?: (...args: Args) => void;\n    }\n  | {\n      /** If context should be included in the 'call' */\n      context: true;\n      /** Callback when the hook is tapped with context */\n      call?: (context: ContextType, ...args: Args) => void;\n    }\n);\n\nexport type Tap<Args extends any[], ReturnType, ContextType = unknown> = {\n  key: symbol;\n  name: string;\n  before?: string | Array<string>;\n} & (\n  | {\n      context: false;\n      callback: (...args: Args) => ReturnType;\n    }\n  | {\n      context: true;\n      callback: (context: ContextType, ...args: Args) => ReturnType;\n    }\n);\n\ntype BasicTap<Args extends any[], ReturnType, ContextType> = (\n  name: string,\n  callback: (...args: Args) => ReturnType,\n  before?: string | Array<string>\n) => Tap<Args, ReturnType, ContextType>;\n\ntype TapWithContext<Args extends any[], ReturnType, ContextType> =\n  | ((\n      options: {\n        name: string;\n        context?: false;\n        before?: string | Array<string>;\n      },\n      callback: (...args: Args) => ReturnType\n    ) => Tap<Args, ReturnType>)\n  | ((\n      options: {\n        name: string;\n        context: true;\n        before?: string | Array<string>;\n      },\n      callback: (context: ContextType, ...args: Args) => ReturnType\n    ) => Tap<Args, ReturnType>);\n\ninterface SyncBaseHookType<Args extends any[], ReturnType, ContextType> {\n  tap:\n    | BasicTap<Args, ReturnType, ContextType>\n    | TapWithContext<Args, ReturnType, ContextType>;\n  call(...args: Args): void;\n  untap(key: Tap<Args, ReturnType>): void;\n  isUsed(): boolean;\n  intercept(int: Interceptor<Args, ReturnType, ContextType>): void;\n}\n\nfunction callTap<Args extends any[], ReturnType, ContextType>(\n  tap: Tap<Args, ReturnType, ContextType>,\n  args: Args,\n  ctx: ContextType\n) {\n  if (tap.context) {\n    return tap.callback(ctx, ...args);\n  }\n\n  return tap.callback(...args);\n}\n\n/** A manager for all intercepts inside of a tap */\nclass InterceptionManager<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> {\n  protected interceptions: Array<Interceptor<Args, ReturnType, ContextType>>;\n  private interceptionKeySet: Set<\n    keyof Interceptor<Args, ReturnType, ContextType>\n  >;\n\n  constructor() {\n    this.interceptions = [];\n    this.interceptionKeySet = new Set();\n  }\n\n  isUsed() {\n    return this.interceptions.length > 0;\n  }\n\n  intercept(int: Interceptor<Args, ReturnType, ContextType>): void {\n    this.interceptions.push(int);\n    Object.keys(int).forEach((s) => {\n      this.interceptionKeySet.add(s as any);\n    });\n  }\n\n  tap(tap: Tap<Args, ReturnType, ContextType>): void {\n    if (this.interceptionKeySet.has(\"tap\")) {\n      this.interceptions.forEach((i) => {\n        i.tap?.(tap);\n      });\n    }\n  }\n\n  call(ctx: ContextType, ...args: Args): void {\n    if (this.interceptionKeySet.has(\"call\")) {\n      this.interceptions.forEach((i) => {\n        if (i.context) {\n          i.call?.(ctx, ...args);\n        } else {\n          i.call?.(...args);\n        }\n      });\n    }\n  }\n\n  loop(...args: Args): void {\n    if (this.interceptionKeySet.has(\"loop\")) {\n      this.interceptions.forEach((i) => {\n        i.loop?.(...args);\n      });\n    }\n  }\n\n  error(err: unknown): void {\n    if (this.interceptionKeySet.has(\"error\")) {\n      if (err instanceof Error) {\n        const asError: Error = err;\n        this.interceptions.forEach((i) => {\n          i.error?.(asError);\n        });\n      }\n    }\n  }\n\n  result(\n    r: ReturnType extends Promise<infer AwaitedValue>\n      ? AwaitedValue\n      : ReturnType\n  ): void {\n    if (this.interceptionKeySet.has(\"result\")) {\n      this.interceptions.forEach((i) => {\n        i.result?.(r);\n      });\n    }\n  }\n\n  done(): void {\n    if (this.interceptionKeySet.has(\"done\")) {\n      this.interceptions.forEach((i) => {\n        i.done?.();\n      });\n    }\n  }\n}\n\nabstract class Hook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> implements SyncBaseHookType<Args, ReturnType, ContextType>\n{\n  protected taps: Array<Tap<Args, ReturnType, ContextType>>;\n  protected interceptions: InterceptionManager<Args, ReturnType, ContextType>;\n\n  constructor() {\n    this.taps = [];\n    this.interceptions = new InterceptionManager<\n      Args,\n      ReturnType,\n      ContextType\n    >();\n  }\n\n  public tap(\n    options: { name: string; context?: false; before?: string | Array<string> },\n    callback: (...args: Args) => ReturnType\n  ): Tap<Args, ReturnType, ContextType>;\n\n  public tap(\n    options: { name: string; context: true; before?: string | Array<string> },\n    callback: (ctx: ContextType, ...args: Args) => ReturnType\n  ): Tap<Args, ReturnType, ContextType>;\n\n  public tap(\n    name: string,\n    callback: (...args: Args) => ReturnType\n  ): Tap<Args, ReturnType, ContextType>;\n\n  public tap(options: any, callback: any): Tap<Args, ReturnType, ContextType> {\n    const resolvedOptions =\n      typeof options === \"string\"\n        ? {\n            name: options,\n            context: false,\n          }\n        : {\n            context: false,\n            ...options,\n          };\n\n    const key = Symbol(resolvedOptions.name);\n    const tap: Tap<Args, ReturnType, ContextType> = {\n      key,\n      ...resolvedOptions,\n      callback,\n    };\n\n    if (tap.before) {\n      let insertionIndex = this.taps.length;\n      const beforeSet = new Set(\n        Array.isArray(tap.before) ? tap.before : [tap.before]\n      );\n      for (\n        insertionIndex;\n        insertionIndex > 0 && beforeSet.size > 0;\n        insertionIndex--\n      ) {\n        const t = this.taps[insertionIndex - 1];\n        if (beforeSet.has(t.name)) {\n          beforeSet.delete(t.name);\n        }\n\n        if (t.before && equalToOrIn(tap.name, t.before)) {\n          break;\n        }\n      }\n\n      this.taps.splice(insertionIndex, 0, tap);\n    } else {\n      this.taps.push(tap);\n    }\n\n    this.interceptions.tap(tap);\n\n    return tap;\n  }\n\n  abstract call(...args: Args): ReturnType;\n\n  public untap(tap: Tap<Args, ReturnType, ContextType>) {\n    this.taps = this.taps.filter((t) => t.key !== tap.key);\n  }\n\n  public isUsed() {\n    return this.taps.length > 0 || this.interceptions.isUsed();\n  }\n\n  public intercept(int: Interceptor<Args, ReturnType, ContextType>): void {\n    this.interceptions.intercept(int);\n  }\n}\n\nexport class SyncHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, void, ContextType> {\n  public call(...args: Args) {\n    if (!this.isUsed()) {\n      return;\n    }\n\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      this.taps.forEach((t) => {\n        callTap(t, args, ctx);\n      });\n    } catch (err: unknown) {\n      this.interceptions.error(err);\n\n      throw err;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class SyncBailHook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> extends Hook<Args, ReturnType | undefined | null, ContextType> {\n  public call(...args: Args): ReturnType | undefined | null {\n    if (!this.isUsed()) {\n      return;\n    }\n\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n      const rtn = callTap(this.taps[tapIndex], args, ctx);\n      if (rtn !== undefined) {\n        this.interceptions.result(rtn as any);\n        return rtn;\n      }\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class SyncWaterfallHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Args[0], ContextType> {\n  public call(...args: Args): Args[0] {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    // eslint-disable-next-line prefer-const\n    let [rtn, ...rest] = args;\n\n    for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n      const tapValue = callTap(this.taps[tapIndex], [rtn, ...rest] as any, ctx);\n      if (tapValue !== undefined) {\n        rtn = tapValue;\n      }\n    }\n\n    this.interceptions.result(rtn);\n\n    return rtn;\n  }\n}\n\nexport class SyncLoopHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, void, ContextType> {\n  public call(...args: Args) {\n    let finished = false;\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      while (finished !== true) {\n        finished = true;\n        this.interceptions.loop(...args);\n        for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n          const rtn = callTap(this.taps[tapIndex], args, ctx);\n\n          if (rtn !== undefined) {\n            finished = false;\n            break;\n          }\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncParallelHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<void>, ContextType> {\n  public async call(...args: Args): Promise<void> {\n    const ctx: ContextType = {} as any;\n    this.interceptions.call(ctx, ...args);\n\n    await Promise.allSettled(this.taps.map((tap) => callTap(tap, args, ctx)));\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncParallelBailHook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<ReturnType>, ContextType> {\n  public async call(...args: Args): Promise<ReturnType> {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      const rtn = await Promise.race(\n        this.taps.map((tap) => callTap(tap, args, ctx))\n      );\n\n      this.interceptions.result(rtn as any);\n      return rtn;\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n  }\n}\n\nexport class AsyncSeriesHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<void>, ContextType> {\n  public async call(...args: Args): Promise<void> {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        await callTap(this.taps[tapIndex], args, ctx);\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncSeriesBailHook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<ReturnType | undefined | null>, ContextType> {\n  public async call(...args: Args): Promise<ReturnType | undefined | null> {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        const rtn = await callTap(this.taps[tapIndex], args, ctx);\n        if (rtn !== undefined) {\n          this.interceptions.result(rtn);\n          return rtn;\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncSeriesWaterfallHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<Args[0]>, ContextType> {\n  public async call(...args: Args): Promise<Args[0]> {\n    // eslint-disable-next-line prefer-const\n    let [rtn, ...rest] = args;\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        const tapValue = await callTap(\n          this.taps[tapIndex],\n          [rtn, ...rest] as any,\n          ctx\n        );\n        if (tapValue !== undefined) {\n          rtn = tapValue;\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.result(rtn);\n\n    return rtn;\n  }\n}\n\nexport class AsyncSeriesLoopHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<void>, ContextType> {\n  public async call(...args: Args): Promise<void> {\n    let finished = false;\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      while (finished !== true) {\n        finished = true;\n        this.interceptions.loop(...args);\n        for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n          const rtn = await callTap(this.taps[tapIndex], args, ctx);\n\n          if (rtn !== undefined) {\n            finished = false;\n            break;\n          }\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n","import { SyncBailHook, SyncWaterfallHook } from \"tapable-ts\";\nimport { NestedError } from \"ts-nested-error\";\nimport type { ParserResult, AnyNode } from \"../binding-grammar/index\";\nimport {\n  // We can swap this with whichever parser we want to use\n  parseCustom as parseBinding,\n} from \"../binding-grammar\";\nimport type { BindingParserOptions, BindingLike } from \"./binding\";\nimport { BindingInstance } from \"./binding\";\nimport { isBinding } from \"./utils\";\nimport type { NormalizedResult, ResolveBindingASTOptions } from \"./resolver\";\nimport { resolveBindingAST } from \"./resolver\";\n\nexport * from \"./utils\";\nexport * from \"./binding\";\n\nexport const SIMPLE_BINDING_REGEX = /^[\\w\\-@]+(\\.[\\w\\-@]+)*$/;\nexport const BINDING_BRACKETS_REGEX = /[\\s()*=`{}'\"[\\]]/;\nconst LAZY_BINDING_REGEX = /^[^.]+(\\..+)*$/;\n\nconst DEFAULT_OPTIONS: BindingParserOptions = {\n  get: () => {\n    throw new Error(\"Not Implemented\");\n  },\n  set: () => {\n    throw new Error(\"Not Implemented\");\n  },\n  evaluate: () => {\n    throw new Error(\"Not Implemented\");\n  },\n};\n\ntype BeforeResolveNodeContext = Required<NormalizedResult> &\n  ResolveBindingASTOptions;\n\n/** A parser for creating bindings from a string */\nexport class BindingParser {\n  private cache: Record<string, BindingInstance>;\n  private parseCache: Record<string, ParserResult>;\n  private parserOptions: BindingParserOptions;\n\n  public hooks = {\n    skipOptimization: new SyncBailHook<[string], boolean>(),\n    beforeResolveNode: new SyncWaterfallHook<\n      [AnyNode, BeforeResolveNodeContext]\n    >(),\n  };\n\n  constructor(options?: Partial<BindingParserOptions>) {\n    this.parserOptions = { ...DEFAULT_OPTIONS, ...options };\n    this.cache = {};\n    this.parseCache = {};\n    this.parse = this.parse.bind(this);\n  }\n\n  /**\n   * Takes a binding path, parses it, and returns an equivalent, normalized\n   * representation of that path.\n   */\n  private normalizePath(\n    path: string,\n    resolveOptions: ResolveBindingASTOptions,\n  ) {\n    /**\n     * Ensure no binding characters exist in path and the characters remaining\n     * look like a binding format.\n     */\n    if (\n      !BINDING_BRACKETS_REGEX.test(path) &&\n      LAZY_BINDING_REGEX.test(path) &&\n      this.hooks.skipOptimization.call(path) !== true\n    ) {\n      return { path: path.split(\".\"), updates: undefined } as NormalizedResult;\n    }\n\n    const ast = this.parseCache[path] ?? parseBinding(path);\n    this.parseCache[path] = ast;\n\n    if (typeof ast !== \"object\" || !ast?.status) {\n      throw new TypeError(\n        `Cannot normalize path \"${path}\": ${ast?.error ?? \"Unknown Error.\"}`,\n      );\n    }\n\n    try {\n      return resolveBindingAST(ast.path, resolveOptions, this.hooks);\n    } catch (e: any) {\n      throw new NestedError(`Cannot resolve binding: ${path}`, e);\n    }\n  }\n\n  private getBindingForNormalizedResult(\n    normalized: NormalizedResult,\n  ): BindingInstance {\n    const normalizedStr = normalized.path.join(\".\");\n\n    if (this.cache[normalizedStr]) {\n      return this.cache[normalizedStr];\n    }\n\n    const created = new BindingInstance(\n      normalizedStr === \"\" ? [] : normalized.path,\n      this.parse,\n    );\n    this.cache[normalizedStr] = created;\n\n    return created;\n  }\n\n  public parse(\n    rawBinding: BindingLike,\n    overrides: Partial<BindingParserOptions> = {},\n  ): BindingInstance {\n    if (isBinding(rawBinding)) {\n      return rawBinding;\n    }\n\n    const options = {\n      ...this.parserOptions,\n      ...overrides,\n    };\n\n    let updates: Record<string, any> = {};\n\n    const joined = Array.isArray(rawBinding)\n      ? rawBinding.join(\".\")\n      : String(rawBinding);\n\n    const normalizeConfig: ResolveBindingASTOptions = {\n      getValue: (path: Array<string | number>) => {\n        const normalized = this.normalizePath(path.join(\".\"), normalizeConfig);\n\n        return options.get(this.getBindingForNormalizedResult(normalized));\n      },\n      evaluate: (exp) => {\n        return options.evaluate(exp);\n      },\n      convertToPath: (path: any) => {\n        if (path === undefined) {\n          throw new Error(\n            \"Attempted to convert undefined value to binding path\",\n          );\n        }\n\n        if (\n          typeof path !== \"string\" &&\n          typeof path !== \"number\" &&\n          typeof path !== \"boolean\"\n        ) {\n          throw new Error(\n            `Attempting to convert ${typeof path} to a binding path.`,\n          );\n        }\n\n        const normalized = this.normalizePath(String(path), normalizeConfig);\n\n        if (normalized.updates) {\n          updates = {\n            ...updates,\n            ...normalized.updates,\n          };\n        }\n\n        const joinedNormalizedPath = normalized.path.join(\".\");\n\n        if (joinedNormalizedPath === \"\") {\n          throw new Error(\"Nested path resolved to an empty path\");\n        }\n\n        return joinedNormalizedPath;\n      },\n    };\n\n    const normalized = this.normalizePath(joined, normalizeConfig);\n\n    if (normalized.updates) {\n      updates = {\n        ...updates,\n        ...normalized.updates,\n      };\n    }\n\n    const updateKeys = Object.keys(updates);\n\n    if (!options.readOnly && updateKeys.length > 0) {\n      const updateTransaction = updateKeys.map<[BindingInstance, any]>(\n        (updatedBinding) => [\n          this.parse(updatedBinding),\n          updates[updatedBinding],\n        ],\n      );\n\n      options.set(updateTransaction);\n    }\n\n    return this.getBindingForNormalizedResult(normalized);\n  }\n}\n","import { NestedError } from \"ts-nested-error\";\nimport type { SyncWaterfallHook } from \"tapable-ts\";\nimport type { PathNode, AnyNode } from \"../binding-grammar\";\nimport { findInArray, maybeConvertToNum } from \"./utils\";\n\nexport interface NormalizedResult {\n  /** The normalized path */\n  path: Array<string | number>;\n\n  /** Any new updates that need to happen for this binding to be resolved */\n  updates?: Record<string, any>;\n}\n\nexport interface ResolveBindingASTOptions {\n  /** Get the value of the model at the given path */\n  getValue: (path: Array<string | number>) => any;\n\n  /** Convert the value into valid path segments */\n  convertToPath: (value: any) => string;\n\n  /** Convert the value into valid path segments */\n  evaluate: (exp: string) => any;\n}\n\nexport interface ResolveBindingASTHooks {\n  /** A hook for transforming a node before fully resolving it */\n  beforeResolveNode: SyncWaterfallHook<\n    [AnyNode, Required<NormalizedResult> & ResolveBindingASTOptions]\n  >;\n}\n\n/** Given a binding AST, resolve it */\nexport function resolveBindingAST(\n  bindingPathNode: PathNode,\n  options: ResolveBindingASTOptions,\n  hooks?: ResolveBindingASTHooks,\n): NormalizedResult {\n  const context: Required<NormalizedResult> = {\n    updates: {},\n    path: [],\n  };\n\n  // let updates: Record<string, any> = {};\n  // const path: Array<string | number> = [];\n\n  /** Get the value for any child node */\n  function getValueForNode(node: AnyNode): any {\n    if (node.name === \"Value\") {\n      return node.value;\n    }\n\n    if (node.name === \"PathNode\") {\n      const nestedResolvedValue = resolveBindingAST(node, options);\n\n      if (nestedResolvedValue.updates) {\n        context.updates = {\n          ...context.updates,\n          ...nestedResolvedValue.updates,\n        };\n      }\n\n      try {\n        return options.convertToPath(\n          options.getValue(nestedResolvedValue.path),\n        );\n      } catch (e: any) {\n        throw new NestedError(\n          `Unable to resolve path segment: ${nestedResolvedValue.path}`,\n          e,\n        );\n      }\n    }\n\n    if (node.name === \"Expression\") {\n      try {\n        const actualValue = options.evaluate(node.value);\n\n        return options.convertToPath(actualValue);\n      } catch (e: any) {\n        throw new NestedError(`Unable to resolve path: ${node.value}`, e);\n      }\n    }\n\n    throw new Error(`Unable to resolve value for node: ${node.name}`);\n  }\n\n  /** Handle when path segments are binding paths (foo.bar) or single segments (foo) */\n  function appendPathSegments(segment: string | number) {\n    if (typeof segment === \"string\" && segment.indexOf(\".\") > -1) {\n      segment.split(\".\").forEach((i) => {\n        context.path.push(maybeConvertToNum(i));\n      });\n    } else {\n      context.path.push(segment);\n    }\n  }\n\n  /** Compute the _actual_ binding val from the AST */\n  function resolveNode(_node: AnyNode) {\n    const resolvedNode =\n      hooks?.beforeResolveNode.call(_node, { ...context, ...options }) ?? _node;\n\n    switch (resolvedNode.name) {\n      case \"Expression\":\n      case \"PathNode\":\n        appendPathSegments(getValueForNode(resolvedNode));\n        break;\n\n      case \"Value\":\n        appendPathSegments(resolvedNode.value);\n        break;\n\n      case \"Query\": {\n        // Look for an object at the path with the given key/val criteria\n        const objToQuery: Record<string, any>[] =\n          options.getValue(context.path) ?? [];\n\n        const { key, value } = resolvedNode;\n\n        const resolvedKey = getValueForNode(key);\n        const resolvedValue = value && getValueForNode(value);\n\n        const index = findInArray(objToQuery, resolvedKey, resolvedValue);\n\n        if (index === undefined || index === -1) {\n          context.updates[\n            [...context.path, objToQuery.length, resolvedKey].join(\".\")\n          ] = resolvedValue;\n          context.path.push(objToQuery.length);\n        } else {\n          context.path.push(index);\n        }\n\n        break;\n      }\n\n      case \"Concatenated\":\n        context.path.push(resolvedNode.value.map(getValueForNode).join(\"\"));\n        break;\n\n      default:\n        throw new Error(`Unsupported node type: ${(resolvedNode as any).name}`);\n    }\n  }\n\n  bindingPathNode.path.forEach(resolveNode);\n\n  return {\n    path: context.path,\n    updates:\n      Object.keys(context.updates ?? {}).length > 0\n        ? context.updates\n        : undefined,\n  };\n}\n","export default function dlv(obj, key, def, p, undef) {\n\tkey = key.split ? key.split('.') : key;\n\tfor (p = 0; p < key.length; p++) {\n\t\tobj = obj ? obj[key[p]] : undef;\n\t}\n\treturn obj === undef ? def : obj;\n}\n","import get from \"dlv\";\nimport { setIn, omit, removeAt } from \"timm\";\nimport type { BindingInstance } from \"../binding\";\nimport type { BatchSetTransaction, DataModelImpl, Updates } from \"./model\";\n\n/**\n * A data model that stores data in an in-memory JS object\n */\nexport class LocalModel implements DataModelImpl {\n  public model: {\n    [key: string]: any;\n  };\n\n  constructor(model = {}) {\n    this.model = model;\n    this.get = this.get.bind(this);\n    this.set = this.set.bind(this);\n  }\n\n  public reset(model = {}) {\n    this.model = model;\n  }\n\n  public get(binding?: BindingInstance) {\n    if (!binding || !binding.asString()) {\n      return this.model;\n    }\n\n    return get(this.model, binding.asArray() as string[]);\n  }\n\n  public set(transaction: BatchSetTransaction) {\n    const effectiveOperations: Updates = [];\n    transaction.forEach(([binding, value]) => {\n      const oldValue = this.get(binding);\n      this.model = setIn(this.model, binding.asArray(), value) as any;\n      effectiveOperations.push({ binding, oldValue, newValue: value });\n    });\n    return effectiveOperations;\n  }\n\n  public delete(binding: BindingInstance) {\n    const parentBinding = binding.parent();\n\n    if (parentBinding) {\n      const parentValue = this.get(parentBinding);\n\n      if (parentValue !== undefined) {\n        if (Array.isArray(parentValue)) {\n          this.model = setIn(\n            this.model,\n            parentBinding.asArray(),\n            removeAt(parentValue, binding.key() as number),\n          ) as any;\n        } else {\n          this.model = setIn(\n            this.model,\n            parentBinding.asArray(),\n            omit(parentValue, binding.key() as string),\n          ) as any;\n        }\n      }\n    }\n  }\n}\n","import { SyncWaterfallHook, SyncBailHook } from \"tapable-ts\";\nimport { NestedError } from \"ts-nested-error\";\nimport { parseExpression } from \"./parser\";\nimport * as DEFAULT_EXPRESSION_HANDLERS from \"./evaluator-functions\";\nimport { isExpressionNode } from \"./types\";\nimport { isObjectExpression } from \"./utils\";\nimport type {\n  ExpressionNode,\n  BinaryOperator,\n  UnaryOperator,\n  ExpressionType,\n  ExpressionContext,\n  ExpressionHandler,\n} from \"./types\";\n\n/** a && b -- but handles short cutting if the first value is false */\nconst andandOperator: BinaryOperator = (ctx, a, b) => {\n  return ctx.evaluate(a) && ctx.evaluate(b);\n};\n\nandandOperator.resolveParams = false;\n\n/** a || b -- but with short cutting if first value is true */\nconst ororOperator: BinaryOperator = (ctx, a, b) => {\n  return ctx.evaluate(a) || ctx.evaluate(b);\n};\n\nororOperator.resolveParams = false;\n\nconst DEFAULT_BINARY_OPERATORS: Record<string, BinaryOperator> = {\n  // TODO: A lot of these functions used to do type coercion. Not sure if we want to keep that behavior or not.\n  \"+\": (a: any, b: any) => a + b,\n  \"-\": (a: any, b: any) => a - b,\n  \"*\": (a: any, b: any) => a * b,\n  \"/\": (a: any, b: any) => a / b,\n  \"%\": (a: any, b: any) => a % b,\n\n  // eslint-disable-next-line\n  \"==\": (a: any, b: any) => a == b,\n\n  // eslint-disable-next-line\n  \"!=\": (a: any, b: any) => a != b,\n  \">\": (a: any, b: any) => a > b,\n  \">=\": (a: any, b: any) => a >= b,\n  \"<\": (a: any, b: any) => a < b,\n  \"<=\": (a: any, b: any) => a <= b,\n  \"&&\": andandOperator,\n  \"||\": ororOperator,\n  \"!==\": (a: any, b: any) => a !== b,\n  \"===\": (a: any, b: any) => a === b,\n\n  // eslint-disable-next-line\n  \"|\": (a: any, b: any) => a | b,\n\n  // eslint-disable-next-line\n  \"&\": (a: any, b: any) => a & b,\n  \"+=\": (a: any, b: any) => a + b,\n  \"-=\": (a: any, b: any) => a - b,\n\n  // eslint-disable-next-line\n  \"&=\": (a: any, b: any) => a & b,\n\n  // eslint-disable-next-line\n  \"|=\": (a: any, b: any) => a | b,\n};\n\nconst DEFAULT_UNARY_OPERATORS: Record<string, UnaryOperator> = {\n  \"-\": (a: any) => -a,\n  \"+\": (a: any) => Number(a),\n  \"!\": (a: any) => !a,\n};\n\nexport interface HookOptions extends ExpressionContext {\n  /** Given an expression node  */\n  resolveNode: (node: ExpressionNode) => any;\n\n  /** Enabling this flag skips calling the onError hook, and just throws errors back to the caller.\n   * The caller is responsible for handling the error.\n   */\n  throwErrors?: boolean;\n\n  /** Whether expressions should be parsed strictly or not */\n  strict?: boolean;\n}\n\nexport type ExpressionEvaluatorOptions = Omit<\n  HookOptions,\n  \"resolveNode\" | \"evaluate\"\n>;\n\nexport type ExpressionEvaluatorFunction = (\n  exp: ExpressionType,\n  options?: ExpressionEvaluatorOptions,\n) => any;\n\n/**\n * The expression evaluator is responsible for parsing and executing anything in the custom expression language\n * */\nexport class ExpressionEvaluator {\n  private readonly vars: Record<string, any> = {};\n  public readonly hooks = {\n    /** Resolve an AST node for an expression to a value */\n    resolve: new SyncWaterfallHook<[any, ExpressionNode, HookOptions]>(),\n\n    /** Gets the options that will be passed in calls to the resolve hook */\n    resolveOptions: new SyncWaterfallHook<[HookOptions]>(),\n\n    /** Allows users to change the expression to be evaluated before processing */\n    beforeEvaluate: new SyncWaterfallHook<[ExpressionType, HookOptions]>(),\n\n    /**\n     * An optional means of handling an error in the expression execution\n     * Return true if handled, to stop propagation of the error\n     */\n    onError: new SyncBailHook<[Error], true>(),\n  };\n\n  private readonly expressionsCache: Map<string, ExpressionNode> = new Map();\n\n  private readonly defaultHookOptions: HookOptions;\n\n  public readonly operators = {\n    binary: new Map(Object.entries(DEFAULT_BINARY_OPERATORS)),\n    unary: new Map(Object.entries(DEFAULT_UNARY_OPERATORS)),\n    expressions: new Map<string, ExpressionHandler<any, any>>(\n      Object.entries(DEFAULT_EXPRESSION_HANDLERS),\n    ),\n  };\n\n  public reset(): void {\n    this.expressionsCache.clear();\n  }\n\n  constructor(defaultOptions: ExpressionEvaluatorOptions) {\n    this.defaultHookOptions = {\n      ...defaultOptions,\n      evaluate: (expr) => this.evaluate(expr, this.defaultHookOptions),\n      resolveNode: (node: ExpressionNode) =>\n        this._execAST(node, this.defaultHookOptions),\n    };\n\n    this.hooks.resolve.tap(\"ExpressionEvaluator\", this._resolveNode.bind(this));\n    this.evaluate = this.evaluate.bind(this);\n  }\n\n  public evaluate(\n    expr: ExpressionType,\n    options?: ExpressionEvaluatorOptions,\n  ): any {\n    const resolvedOpts = this.hooks.resolveOptions.call({\n      ...this.defaultHookOptions,\n      ...options,\n      resolveNode: (node: ExpressionNode) => this._execAST(node, resolvedOpts),\n    });\n\n    let expression = this.hooks.beforeEvaluate.call(expr, resolvedOpts) ?? expr;\n\n    // Unwrap any returned expression type\n    // Since this could also be an object type, we need to recurse through it until we find the end\n    while (isObjectExpression(expression)) {\n      expression = expression.value;\n    }\n\n    // Check for literals\n    if (\n      typeof expression === \"number\" ||\n      typeof expression === \"boolean\" ||\n      expression === undefined ||\n      expression === null\n    ) {\n      return expression;\n    }\n\n    // Skip doing anything with objects that are _actually_ just parsed expression nodes\n    if (isExpressionNode(expression)) {\n      return this._execAST(expression, resolvedOpts);\n    }\n\n    if (Array.isArray(expression)) {\n      return expression.reduce(\n        (_nothing, exp) => this.evaluate(exp, options),\n        null,\n      );\n    }\n\n    return this._execString(String(expression), resolvedOpts);\n  }\n\n  public addExpressionFunction<T extends readonly unknown[], R>(\n    name: string,\n    handler: ExpressionHandler<T, R>,\n  ): void {\n    this.operators.expressions.set(name, handler);\n  }\n\n  public addBinaryOperator(operator: string, handler: BinaryOperator) {\n    this.operators.binary.set(operator, handler);\n  }\n\n  public addUnaryOperator(operator: string, handler: UnaryOperator) {\n    this.operators.unary.set(operator, handler);\n  }\n\n  public setExpressionVariable(name: string, value: unknown) {\n    this.vars[name] = value;\n  }\n\n  public getExpressionVariable(name: string): unknown {\n    return this.vars[name];\n  }\n\n  private _execAST(node: ExpressionNode, options: HookOptions): any {\n    return this.hooks.resolve.call(undefined, node, options);\n  }\n\n  private _execString(exp: string, options: HookOptions) {\n    if (exp === \"\") {\n      return exp;\n    }\n\n    const matches = exp.match(/^@\\[(.*)\\]@$/);\n    let matchedExp = exp;\n\n    if (matches) {\n      [, matchedExp] = Array.from(matches); // In case the expression was surrounded by @[ ]@\n    }\n\n    let storedAST: ExpressionNode;\n\n    try {\n      storedAST =\n        this.expressionsCache.get(matchedExp) ??\n        parseExpression(matchedExp, { strict: options.strict });\n      this.expressionsCache.set(matchedExp, storedAST);\n    } catch (e: any) {\n      if (options.throwErrors || !this.hooks.onError.call(e)) {\n        // Only throw the error if it's not handled by the hook, or throwErrors is true\n        throw new NestedError(`Error parsing expression: ${exp}`, e);\n      }\n\n      return;\n    }\n\n    try {\n      return this._execAST(storedAST, options);\n    } catch (e: any) {\n      if (options.throwErrors || !this.hooks.onError.call(e)) {\n        // Only throw the error if it's not handled by the hook, or throwErrors is true\n        throw new NestedError(`Error evaluating expression: ${exp}`, e);\n      }\n    }\n  }\n\n  private _resolveNode(\n    _currentValue: any,\n    node: ExpressionNode,\n    options: HookOptions,\n  ) {\n    const { resolveNode, model } = options;\n\n    const expressionContext: ExpressionContext = {\n      ...options,\n      evaluate: (expr) => this.evaluate(expr, options),\n    };\n\n    if (node.type === \"Literal\") {\n      return node.value;\n    }\n\n    if (node.type === \"Identifier\") {\n      return this.vars[node.name];\n    }\n\n    if (node.type === \"Compound\" || node.type === \"ThisExpression\") {\n      throw new Error(`Expression type: ${node.type} is not supported`);\n    }\n\n    if (node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\") {\n      const operator = this.operators.binary.get(node.operator);\n\n      if (operator) {\n        if (\"resolveParams\" in operator) {\n          if (operator.resolveParams === false) {\n            return operator(expressionContext, node.left, node.right);\n          }\n\n          return operator(\n            expressionContext,\n            resolveNode(node.left),\n            resolveNode(node.right),\n          );\n        }\n\n        return operator(resolveNode(node.left), resolveNode(node.right));\n      }\n\n      return;\n    }\n\n    if (node.type === \"UnaryExpression\") {\n      const operator = this.operators.unary.get(node.operator);\n\n      if (operator) {\n        if (\"resolveParams\" in operator) {\n          return operator(\n            expressionContext,\n            operator.resolveParams === false\n              ? node.argument\n              : resolveNode(node.argument),\n          );\n        }\n\n        return operator(resolveNode(node.argument));\n      }\n\n      return;\n    }\n\n    if (node.type === \"Object\") {\n      const { attributes } = node;\n      const resolvedAttributes: any = {};\n\n      attributes.forEach((attr) => {\n        const key = resolveNode(attr.key);\n        const value = resolveNode(attr.value);\n        resolvedAttributes[key] = value;\n      });\n\n      return resolvedAttributes;\n    }\n\n    if (node.type === \"CallExpression\") {\n      const expressionName = node.callTarget.name;\n\n      const operator = this.operators.expressions.get(expressionName);\n\n      if (!operator) {\n        throw new Error(`Unknown expression function: ${expressionName}`);\n      }\n\n      if (\"resolveParams\" in operator && operator.resolveParams === false) {\n        return operator(expressionContext, ...node.args);\n      }\n\n      const args = node.args.map((n) => resolveNode(n));\n\n      return operator(expressionContext, ...args);\n    }\n\n    if (node.type === \"ModelRef\") {\n      return model.get(node.ref, { context: { model: options.model } });\n    }\n\n    if (node.type === \"MemberExpression\") {\n      const obj = resolveNode(node.object);\n      const prop = resolveNode(node.property);\n\n      return obj[prop];\n    }\n\n    if (node.type === \"Assignment\") {\n      if (node.left.type === \"ModelRef\") {\n        const value = resolveNode(node.right);\n        model.set([[node.left.ref, value]]);\n\n        return value;\n      }\n\n      if (node.left.type === \"Identifier\") {\n        const value = resolveNode(node.right);\n        this.vars[node.left.name] = value;\n        return value;\n      }\n\n      return;\n    }\n\n    if (node.type === \"ConditionalExpression\") {\n      const result = resolveNode(node.test) ? node.consequent : node.alternate;\n\n      return resolveNode(result);\n    }\n\n    if (node.type === \"ArrayExpression\") {\n      return node.elements.map((ele) => resolveNode(ele));\n    }\n\n    if (node.type === \"Modification\") {\n      const operation = this.operators.binary.get(node.operator);\n\n      if (operation) {\n        let newValue;\n\n        if (\"resolveParams\" in operation) {\n          if (operation.resolveParams === false) {\n            newValue = operation(expressionContext, node.left, node.right);\n          } else {\n            newValue = operation(\n              expressionContext,\n              resolveNode(node.left),\n              resolveNode(node.right),\n            );\n          }\n        } else {\n          newValue = operation(resolveNode(node.left), resolveNode(node.right));\n        }\n\n        if (node.left.type === \"ModelRef\") {\n          model.set([[node.left.ref, newValue]]);\n        } else if (node.left.type === \"Identifier\") {\n          this.vars[node.left.name] = newValue;\n        }\n\n        return newValue;\n      }\n\n      return resolveNode(node.left);\n    }\n  }\n}\n","import { setIn } from \"timm\";\nimport type { Expression } from \"@player-ui/types\";\nimport type { DataModelWithParser } from \"../data\";\n\nconst DOUBLE_OPEN_CURLY = \"{{\";\nconst DOUBLE_CLOSE_CURLY = \"}}\";\n\nexport interface Options {\n  /**\n   * The model to use when resolving refs\n   * Passing `false` will skip trying to resolve any direct model refs ({{foo}})\n   */\n  model: false | DataModelWithParser;\n\n  /**\n   * A function to evaluate an expression\n   * Passing `false` will skip trying to evaluate any expressions (@[ foo() ]@)\n   */\n  evaluate: false | ((exp: Expression) => any);\n\n  /**\n   * Optionaly resolve binding without formatting in case Type format applies\n   */\n  formatted?: boolean;\n}\n\n/** Search the given string for the coordinates of the next expression to resolve */\nexport function findNextExp(str: string) {\n  const expStart = str.indexOf(DOUBLE_OPEN_CURLY);\n\n  if (expStart === -1) {\n    return undefined;\n  }\n\n  let count = 1;\n  let offset = expStart + DOUBLE_OPEN_CURLY.length;\n  let workingString = str.substring(expStart + DOUBLE_OPEN_CURLY.length);\n\n  while (count > 0 && workingString.length > 0) {\n    // Find the next open or close curly\n    const nextCloseCurly = workingString.indexOf(DOUBLE_CLOSE_CURLY);\n\n    // We can't close anything, so there's no point in going on with life.\n    if (nextCloseCurly === -1) {\n      break;\n    }\n\n    const nextOpenCurly = workingString.indexOf(DOUBLE_OPEN_CURLY);\n\n    if (nextOpenCurly !== -1 && nextOpenCurly < nextCloseCurly) {\n      // We've hit another open bracket before closing out the one we want\n      // Move everything over and bump our close count by 1\n      count++;\n      workingString = workingString.substring(\n        nextOpenCurly + DOUBLE_OPEN_CURLY.length,\n      );\n      offset += nextOpenCurly + DOUBLE_OPEN_CURLY.length;\n    } else {\n      // We've hit another closing bracket\n      // Decrement our count and updates offsets\n      count--;\n      workingString = workingString.substring(\n        nextCloseCurly + DOUBLE_CLOSE_CURLY.length,\n      );\n      offset += nextCloseCurly + DOUBLE_CLOSE_CURLY.length;\n    }\n  }\n\n  if (count !== 0) {\n    throw new Error(`Unbalanced {{ and }} in exp: ${str}`);\n  }\n\n  return {\n    start: expStart,\n    end: offset,\n  };\n}\n\n/** Finds any subset of the string wrapped in @[]@ and evaluates it as an expression */\nexport function resolveExpressionsInString(\n  val: string,\n  { evaluate }: Options,\n): string {\n  if (!evaluate) {\n    return val;\n  }\n\n  const expMatch = /@\\[.*?\\]@/;\n  let newVal = val;\n  let match = newVal.match(expMatch);\n\n  while (match !== null) {\n    const expStrWithBrackets = match[0];\n    const matchStart = newVal.indexOf(expStrWithBrackets);\n\n    const expString = expStrWithBrackets.substr(\n      \"@[\".length,\n      expStrWithBrackets.length - \"@[\".length - \"]@\".length,\n    );\n    const expValue = evaluate(expString);\n\n    // The string is only the expression, return the raw value.\n    if (\n      matchStart === 0 &&\n      expStrWithBrackets === val &&\n      typeof expValue !== \"string\"\n    ) {\n      return expValue;\n    }\n\n    newVal =\n      newVal.substr(0, matchStart) +\n      expValue +\n      newVal.substr(matchStart + expStrWithBrackets.length);\n    // remove the surrounding @[]@ to get the expression\n    match = newVal.match(expMatch);\n  }\n\n  return newVal;\n}\n\n/** Return a string with all data model references resolved */\nexport function resolveDataRefsInString(val: string, options: Options): string {\n  const { model, formatted = true } = options;\n  let workingString = resolveExpressionsInString(val, options);\n\n  if (\n    !model ||\n    typeof workingString !== \"string\" ||\n    workingString.indexOf(DOUBLE_OPEN_CURLY) === -1\n  ) {\n    return workingString;\n  }\n\n  while (workingString.indexOf(DOUBLE_OPEN_CURLY) !== -1) {\n    const expLocation = findNextExp(workingString);\n\n    if (!expLocation) {\n      return workingString;\n    }\n\n    const { start, end } = expLocation;\n\n    // Strip out the wrapping curlies from {{binding}} before passing to the model\n    const binding = workingString\n      .substring(\n        start + DOUBLE_OPEN_CURLY.length,\n        end - DOUBLE_OPEN_CURLY.length,\n      )\n      .trim();\n\n    const evaledVal = model.get(binding, { formatted });\n\n    // Exit early if the string is _just_ a model lookup\n    // If the result is a string, we may need further processing for nested bindings\n    if (\n      start === 0 &&\n      end === workingString.length &&\n      typeof evaledVal !== \"string\"\n    ) {\n      return evaledVal;\n    }\n\n    workingString =\n      workingString.substr(0, start) + evaledVal + workingString.substr(end);\n  }\n\n  return workingString;\n}\n\n/** Traverse the thing and replace any model refs */\nfunction traverseObject<T>(val: T, options: Options): T {\n  switch (typeof val) {\n    case \"string\": {\n      return resolveDataRefsInString(val as string, options) as unknown as T;\n    }\n\n    case \"object\": {\n      if (!val) return val;\n      // TODO: Do we care refs in keys?\n      const keys = Object.keys(val);\n      let newVal = val;\n\n      if (keys.length > 0) {\n        keys.forEach((key) => {\n          newVal = setIn(\n            newVal as any,\n            [key],\n            traverseObject((val as any)[key], options),\n          ) as any;\n        });\n      }\n\n      return newVal;\n    }\n\n    default:\n      return val;\n  }\n}\n\n/** Recursively resolve all model refs in whatever you pass in */\nexport function resolveDataRefs<T>(val: T, options: Options): T {\n  return traverseObject(val, options);\n}\n","import { setIn } from \"timm\";\nimport type { BindingInstance } from \"../binding\";\nimport type {\n  BatchSetTransaction,\n  DataModelImpl,\n  DataModelOptions,\n  DataModelMiddleware,\n  Updates,\n} from \"../data\";\nimport { toModel } from \"../data\";\nimport type { Logger } from \"../logger\";\n\nimport type { ValidationResponse } from \"./types\";\nimport { removeBindingAndChildrenFromMap } from \"./binding-map-splice\";\n\n/**\n * A BindingInstance with an indicator of whether or not it's a strong binding\n */\nexport type StrongOrWeakBinding = {\n  /** BindingInstance in question */\n  binding: BindingInstance;\n  /** Boolean indicating whether the relevant BindingInstance is a strong binding */\n  isStrong: boolean;\n};\n\n/**\n * Returns a validation object if the data is invalid or an set of BindingsInstances if the binding itself is a weak ref of another invalid validation\n */\nexport type MiddlewareChecker = (\n  binding: BindingInstance,\n  model: DataModelImpl,\n) => ValidationResponse | Set<StrongOrWeakBinding> | undefined;\n\n/**\n * Middleware for the data-model that caches the results of invalid data\n */\nexport class ValidationMiddleware implements DataModelMiddleware {\n  public validator: MiddlewareChecker;\n  public shadowModelPaths: Map<BindingInstance, any>;\n  private logger?: Logger;\n  private shouldIncludeInvalid?: (options?: DataModelOptions) => boolean;\n\n  constructor(\n    validator: MiddlewareChecker,\n    options?: {\n      /** A logger instance */\n      logger?: Logger;\n      /** Optional function to include data staged in shadowModel */\n      shouldIncludeInvalid?: (options?: DataModelOptions) => boolean;\n    },\n  ) {\n    this.validator = validator;\n    this.shadowModelPaths = new Map();\n    this.logger = options?.logger;\n    this.shouldIncludeInvalid = options?.shouldIncludeInvalid;\n  }\n\n  public set(\n    transaction: BatchSetTransaction,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ): Updates {\n    const asModel = toModel(this, { ...options, includeInvalid: true }, next);\n    const nextTransaction: BatchSetTransaction = [];\n\n    const includedBindings = new Set<BindingInstance>();\n\n    transaction.forEach(([binding, value]) => {\n      this.shadowModelPaths.set(binding, value);\n      includedBindings.add(binding);\n    });\n\n    const invalidBindings: Array<BindingInstance> = [];\n\n    this.shadowModelPaths.forEach((value, binding) => {\n      const validations = this.validator(binding, asModel);\n\n      if (validations === undefined) {\n        nextTransaction.push([binding, value]);\n      } else if (validations instanceof Set) {\n        validations.forEach((validation) => {\n          invalidBindings.push(validation.binding);\n          if (\n            !validation.isStrong &&\n            validation.binding.asString() === binding.asString()\n          ) {\n            nextTransaction.push([validation.binding, value]);\n          }\n        });\n      } else if (includedBindings.has(binding)) {\n        invalidBindings.push(binding);\n        this.logger?.debug(\n          `Invalid value for path: ${binding.asString()} - ${\n            validations.severity\n          } - ${validations.message}`,\n        );\n      }\n    });\n\n    let validResults: Updates = [];\n\n    if (next && nextTransaction.length > 0) {\n      // defer clearing the shadow model to prevent validations that are run twice due to weak binding refs still needing the data\n      nextTransaction.forEach(([binding]) =>\n        this.shadowModelPaths.delete(binding),\n      );\n      const result = next.set(nextTransaction, options);\n      if (invalidBindings.length === 0) {\n        return result;\n      }\n\n      validResults = result;\n    }\n\n    const invalidResults = invalidBindings.map((binding) => {\n      return {\n        binding,\n        oldValue: asModel.get(binding),\n        newValue: asModel.get(binding),\n        force: true,\n      };\n    });\n\n    return [...validResults, ...invalidResults];\n  }\n\n  public get(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ) {\n    let val = next?.get(binding, options);\n\n    if (\n      this.shouldIncludeInvalid?.(options) ??\n      options?.includeInvalid === true\n    ) {\n      this.shadowModelPaths.forEach((shadowValue, shadowBinding) => {\n        if (shadowBinding === binding) {\n          val = shadowValue;\n\n          return;\n        }\n\n        if (binding.contains(shadowBinding)) {\n          val = setIn(val, shadowBinding.relative(binding), shadowValue);\n        }\n      });\n    }\n\n    return val;\n  }\n\n  public delete(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ) {\n    this.shadowModelPaths = removeBindingAndChildrenFromMap(\n      this.shadowModelPaths,\n      binding,\n    );\n\n    return next?.delete(binding, options);\n  }\n}\n","import { SyncWaterfallHook, SyncHook } from \"tapable-ts\";\nimport { setIn, addLast, clone } from \"timm\";\nimport dlv from \"dlv\";\nimport { dequal } from \"dequal\";\nimport type { BindingInstance, BindingLike } from \"../../binding\";\nimport type {\n  DataModelOptions,\n  DataModelWithParser,\n  Updates,\n} from \"../../data\";\nimport { DependencyModel, withParser } from \"../../data\";\nimport type { Logger } from \"../../logger\";\nimport type { Node } from \"../parser\";\nimport { NodeType } from \"../parser\";\nimport { caresAboutDataChanges, toNodeResolveOptions } from \"./utils\";\nimport type { Resolve } from \"./types\";\nimport { getNodeID } from \"../parser/utils\";\n\nexport * from \"./types\";\nexport * from \"./utils\";\n\ninterface NodeUpdate extends Resolve.ResolvedNode {\n  /** A flag to track if a node has changed since the last resolution */\n  updated: boolean;\n}\n\n/** Add model context to the data model */\nconst withContext = (model: DataModelWithParser): DataModelWithParser => {\n  return {\n    get: (binding: BindingLike, options?: DataModelOptions): any => {\n      return model.get(binding, {\n        context: { model },\n        ...options,\n      });\n    },\n\n    set: (\n      transaction: [BindingLike, any][],\n      options?: DataModelOptions,\n    ): Updates => {\n      return model.set(transaction, {\n        context: { model },\n        ...options,\n      });\n    },\n\n    delete: (binding: BindingLike, options?: DataModelOptions): void => {\n      return model.delete(binding, {\n        context: { model },\n        ...options,\n      });\n    },\n  };\n};\n\n/**\n * The Resolver is the way to take a parsed AST graph of a view and resolve it to a concrete representation of the current user state\n * It combines the ability to mutate ast nodes before resolving, as well as the mutating the resolved objects while parsing\n */\nexport class Resolver {\n  public readonly hooks = {\n    /** A hook to allow skipping of the resolution tree for a specific node */\n    skipResolve: new SyncWaterfallHook<\n      [boolean, Node.Node, Resolve.NodeResolveOptions]\n    >(),\n\n    /** An event emitted before calculating the next update */\n    beforeUpdate: new SyncHook<[Set<BindingInstance> | undefined]>(),\n\n    /** An event emitted after calculating the next update */\n    afterUpdate: new SyncHook<[any]>(),\n\n    /** The options passed to a node to resolve it to an object */\n    resolveOptions: new SyncWaterfallHook<\n      [Resolve.NodeResolveOptions, Node.Node]\n    >(),\n\n    /** A hook to transform the AST node into a new AST node before resolving it */\n    beforeResolve: new SyncWaterfallHook<\n      [Node.Node | null, Resolve.NodeResolveOptions]\n    >(),\n\n    /**\n     * A hook to transform an AST node into it's resolved value.\n     * This runs _before_ any children are resolved\n     */\n    resolve: new SyncWaterfallHook<\n      [any, Node.Node, Resolve.NodeResolveOptions]\n    >(),\n\n    /**\n     * A hook to transform the resolved value of an AST node.\n     * This runs _after_ all children nodes are resolved\n     */\n    afterResolve: new SyncWaterfallHook<\n      [any, Node.Node, Resolve.NodeResolveOptions]\n    >(),\n\n    /** Called at the very end of a node's tree being updated */\n    afterNodeUpdate: new SyncHook<\n      [Node.Node, Node.Node | undefined, NodeUpdate]\n    >(),\n  };\n\n  /**\n   * The AST tree after beforeResolve is ran mapped to the AST before beforeResolve is ran\n   */\n  private readonly ASTMap: Map<Node.Node, Node.Node>;\n  /**\n   * The root node in the AST tree we want to resolve\n   */\n  public readonly root: Node.Node;\n\n  /**\n   * The cache of the last resolved values when walking the tree.\n   * This gets recycled every update to avoid stale data if a node is unused in an update\n   */\n  private resolveCache: Map<Node.Node, Resolve.ResolvedNode>;\n\n  /**\n   * Cache of node IDs that have been processed to track if nodes have duplicate IDs\n   */\n  private idCache: Set<string>;\n\n  /**\n   * The parameters required to resolve AST nodes\n   */\n  private readonly options: Resolve.ResolverOptions;\n\n  /**\n   * Tapable logger for logging errors encountered during view resolution\n   */\n  private logger?: Logger;\n\n  constructor(root: Node.Node, options: Resolve.ResolverOptions) {\n    this.root = root;\n    this.options = options;\n    this.resolveCache = new Map();\n    this.ASTMap = new Map();\n    this.logger = options.logger;\n    this.idCache = new Set();\n  }\n\n  public getSourceNode(convertedAST: Node.Node) {\n    return this.ASTMap.get(convertedAST);\n  }\n\n  public update(changes?: Set<BindingInstance>): any {\n    this.hooks.beforeUpdate.call(changes);\n    const resolveCache = new Map<Node.Node, Resolve.ResolvedNode>();\n    this.idCache.clear();\n    const prevASTMap = new Map(this.ASTMap);\n    this.ASTMap.clear();\n\n    const updated = this.computeTree(\n      this.root,\n      undefined,\n      changes,\n      resolveCache,\n      toNodeResolveOptions(this.options),\n      undefined,\n      prevASTMap,\n    );\n    this.resolveCache = resolveCache;\n    this.hooks.afterUpdate.call(updated.value);\n\n    return updated.value;\n  }\n\n  public getResolveCache() {\n    return new Map(this.resolveCache);\n  }\n\n  private getPreviousResult(node: Node.Node): Resolve.ResolvedNode | undefined {\n    if (!node) {\n      return;\n    }\n\n    const isFirstUpdate = this.resolveCache.size === 0;\n    const id = getNodeID(node);\n\n    if (id) {\n      if (this.idCache.has(id)) {\n        // Only log this conflict once to cut down on noise\n        // May want to swap this to logging when we first see the id -- which may not be the first render\n        if (isFirstUpdate) {\n          if (node.type === NodeType.Asset || node.type === NodeType.View) {\n            this.logger?.error(\n              `Cache conflict: Found Asset/View nodes that have conflicting ids: ${id}, may cause cache issues.`,\n            );\n          } else if (node.type === NodeType.Value) {\n            this.logger?.info(\n              `Cache conflict: Found Value nodes that have conflicting ids: ${id}, may cause cache issues. To improve performance make value node IDs globally unique.`,\n            );\n          }\n        }\n\n        // Don't use anything from a prev result if there's a duplicate id detected\n        return;\n      }\n\n      this.idCache.add(id);\n    }\n\n    return this.resolveCache.get(node);\n  }\n\n  private cloneNode(node: any) {\n    const clonedNode = clone(node);\n\n    Object.keys(clonedNode).forEach((key) => {\n      if (key === \"parent\") return;\n\n      const value = clonedNode[key];\n      if (typeof value === \"object\" && value !== null) {\n        clonedNode[key] = Array.isArray(value) ? [...value] : { ...value };\n      }\n    });\n\n    return clonedNode;\n  }\n\n  private computeTree(\n    node: Node.Node,\n    rawParent: Node.Node | undefined,\n    dataChanges: Set<BindingInstance> | undefined,\n    cacheUpdate: Map<Node.Node, Resolve.ResolvedNode>,\n    options: Resolve.NodeResolveOptions,\n    partiallyResolvedParent: Node.Node | undefined,\n    prevASTMap: Map<Node.Node, Node.Node>,\n  ): NodeUpdate {\n    const dependencyModel = new DependencyModel(options.data.model);\n\n    dependencyModel.trackSubset(\"core\");\n    const depModelWithParser = withContext(\n      withParser(dependencyModel, this.options.parseBinding),\n    );\n\n    const resolveOptions = this.hooks.resolveOptions.call(\n      {\n        ...options,\n        data: {\n          ...options.data,\n          model: depModelWithParser,\n        },\n        evaluate: (exp) =>\n          this.options.evaluator.evaluate(exp, { model: depModelWithParser }),\n        node,\n      },\n      node,\n    );\n\n    const previousResult = this.getPreviousResult(node);\n    const previousDeps = previousResult?.dependencies;\n\n    const dataChanged = caresAboutDataChanges(dataChanges, previousDeps);\n    const shouldUseLastValue = this.hooks.skipResolve.call(\n      !dataChanged,\n      node,\n      resolveOptions,\n    );\n\n    // Shallow clone the node so that changes to it during the resolve steps don't impact the original.\n    // We are trusting that this becomes a deep clone once the whole node tree has been traversed.\n    const clonedNode = {\n      ...this.cloneNode(node),\n      parent: partiallyResolvedParent,\n    };\n    const resolvedAST = this.hooks.beforeResolve.call(\n      clonedNode,\n      resolveOptions,\n    ) ?? {\n      type: NodeType.Empty,\n    };\n\n    const isNestedMultiNode =\n      resolvedAST.type === NodeType.MultiNode &&\n      partiallyResolvedParent?.parent?.type === NodeType.MultiNode &&\n      partiallyResolvedParent.type === NodeType.Value;\n\n    if (previousResult && shouldUseLastValue) {\n      const update = {\n        ...previousResult,\n        updated: false,\n      };\n\n      /** Recursively repopulate the AST map given some AST Node and it's resolved AST representation */\n      const repopulateASTMapFromCache = (\n        resolvedNode: Resolve.ResolvedNode,\n        AST: Node.Node,\n        ASTParent: Node.Node | undefined,\n      ) => {\n        const { node: resolvedASTLocal } = resolvedNode;\n        this.ASTMap.set(resolvedASTLocal, AST);\n        const resolvedUpdate = {\n          ...resolvedNode,\n          updated: false,\n        };\n        cacheUpdate.set(AST, resolvedUpdate);\n\n        /** Helper function for recursing over child node */\n        const handleChildNode = (childNode: Node.Node) => {\n          // In order to get the correct results, we need to use the node references from the last update.\n          const originalChildNode = prevASTMap.get(childNode) ?? childNode;\n          const previousChildResult = this.getPreviousResult(originalChildNode);\n          if (!previousChildResult) return;\n\n          repopulateASTMapFromCache(\n            previousChildResult,\n            originalChildNode,\n            AST,\n          );\n        };\n\n        if (\"children\" in resolvedASTLocal) {\n          resolvedASTLocal.children?.forEach(({ value: childAST }) =>\n            handleChildNode(childAST),\n          );\n        } else if (resolvedASTLocal.type === NodeType.MultiNode) {\n          resolvedASTLocal.values.forEach(handleChildNode);\n        }\n\n        this.hooks.afterNodeUpdate.call(AST, ASTParent, resolvedUpdate);\n      };\n\n      // Point the root of the cached node to the new resolved node.\n      previousResult.node.parent = partiallyResolvedParent;\n\n      repopulateASTMapFromCache(previousResult, node, rawParent);\n\n      return update;\n    }\n\n    resolvedAST.parent = partiallyResolvedParent;\n\n    resolveOptions.node = resolvedAST;\n\n    this.ASTMap.set(resolvedAST, node);\n\n    let resolved = this.hooks.resolve.call(\n      undefined,\n      resolvedAST,\n      resolveOptions,\n    );\n\n    let updated = !dequal(previousResult?.value, resolved);\n\n    if (previousResult && !updated) {\n      resolved = previousResult?.value;\n    }\n\n    const childDependencies = new Set<BindingInstance>();\n    dependencyModel.trackSubset(\"children\");\n\n    if (\"children\" in resolvedAST) {\n      const newChildren = resolvedAST.children?.map((child) => {\n        const computedChildTree = this.computeTree(\n          child.value,\n          node,\n          dataChanges,\n          cacheUpdate,\n          resolveOptions,\n          resolvedAST,\n          prevASTMap,\n        );\n        const {\n          dependencies: childTreeDeps,\n          node: childNode,\n          updated: childUpdated,\n          value: childValue,\n        } = computedChildTree;\n\n        childTreeDeps.forEach((binding) => childDependencies.add(binding));\n\n        if (childValue) {\n          if (childNode.type === NodeType.MultiNode && !childNode.override) {\n            const arr = addLast(\n              dlv(resolved, child.path as any[], []),\n              childValue,\n            );\n            resolved = setIn(resolved, child.path, arr);\n          } else {\n            resolved = setIn(resolved, child.path, childValue);\n          }\n        }\n\n        updated = updated || childUpdated;\n\n        return { ...child, value: childNode };\n      });\n\n      resolvedAST.children = newChildren;\n    } else if (resolvedAST.type === NodeType.MultiNode) {\n      const childValue: any = [];\n      const rawParentToPassIn = isNestedMultiNode\n        ? partiallyResolvedParent?.parent\n        : node;\n\n      const newValues = resolvedAST.values.map((mValue) => {\n        const mTree = this.computeTree(\n          mValue,\n          rawParentToPassIn,\n          dataChanges,\n          cacheUpdate,\n          resolveOptions,\n          resolvedAST,\n          prevASTMap,\n        );\n\n        if (mTree.value !== undefined && mTree.value !== null) {\n          childValue.push(mTree.value);\n        }\n\n        mTree.dependencies.forEach((bindingDep) =>\n          childDependencies.add(bindingDep),\n        );\n\n        updated = updated || mTree.updated;\n\n        return mTree.node;\n      });\n\n      resolvedAST.values = newValues;\n      resolved = childValue;\n    }\n\n    childDependencies.forEach((bindingDep) =>\n      dependencyModel.addChildReadDep(bindingDep),\n    );\n\n    dependencyModel.trackSubset(\"core\");\n    if (previousResult && !updated) {\n      resolved = previousResult?.value;\n    }\n\n    resolved = this.hooks.afterResolve.call(resolved, resolvedAST, {\n      ...resolveOptions,\n      getDependencies: (scope?: \"core\" | \"children\") =>\n        dependencyModel.getDependencies(scope),\n    });\n\n    const update: NodeUpdate = {\n      node: resolvedAST,\n      updated,\n      value: resolved,\n      dependencies: new Set([\n        ...dependencyModel.getDependencies(),\n        ...childDependencies,\n      ]),\n    };\n\n    this.hooks.afterNodeUpdate.call(\n      node,\n      isNestedMultiNode ? partiallyResolvedParent?.parent : rawParent,\n      update,\n    );\n    cacheUpdate.set(node, update);\n\n    return update;\n  }\n}\n","var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import { setIn } from \"timm\";\nimport { SyncBailHook, SyncWaterfallHook } from \"tapable-ts\";\nimport type { AnyAssetType, Node } from \"./types\";\nimport { NodeType } from \"./types\";\n\nexport * from \"./types\";\nexport * from \"./utils\";\n\nexport const EMPTY_NODE: Node.Empty = {\n  type: NodeType.Empty,\n};\n\nexport interface ParseObjectOptions {\n  /** how nested the templated is */\n  templateDepth?: number;\n}\n\nexport interface ParseObjectChildOptions {\n  key: string;\n  path: Node.PathSegment[];\n  parentObj: object;\n}\n\ninterface NestedObj {\n  /** The values of a nested local object */\n  children: Node.Child[];\n\n  value: any;\n}\n/**\n * The Parser is the way to take an incoming view from the user and parse it into an AST.\n * It provides a few ways to interact with the parsing, including mutating an object before and after creation of an AST node\n */\nexport class Parser {\n  public readonly hooks = {\n    /**\n     * A hook to interact with an object _before_ parsing it into an AST\n     *\n     * @param value - The object we're are about to parse\n     * @returns - A new value to parse.\n     *  If undefined, the original value is used.\n     *  If null, we stop parsing this node.\n     */\n    onParseObject: new SyncWaterfallHook<[object, NodeType]>(),\n\n    /**\n     * A callback to interact with an AST _after_ we parse it into the AST\n     *\n     * @param value - The object we parsed\n     * @param node - The AST node we generated\n     * @returns - A new AST node to use\n     *   If undefined, the original value is used.\n     *   If null, we ignore this node all together\n     */\n    onCreateASTNode: new SyncWaterfallHook<\n      [Node.Node | undefined | null, object]\n    >(),\n\n    parseNode: new SyncBailHook<\n      [\n        obj: object,\n        nodeType: Node.ChildrenTypes,\n        parseOptions: ParseObjectOptions,\n        childOptions?: ParseObjectChildOptions,\n      ],\n      Node.Node | Node.Child[]\n    >(),\n  };\n\n  public parseView(value: AnyAssetType): Node.View {\n    const viewNode = this.parseObject(value, NodeType.View);\n\n    if (!viewNode) {\n      throw new Error(\"Unable to parse object into a view\");\n    }\n\n    return viewNode as Node.View;\n  }\n\n  public createASTNode(node: Node.Node | null, value: any): Node.Node | null {\n    const tapped = this.hooks.onCreateASTNode.call(node, value);\n\n    if (tapped === undefined) {\n      return node;\n    }\n\n    return tapped;\n  }\n\n  public parseObject(\n    obj: object,\n    type: Node.ChildrenTypes = NodeType.Value,\n    options: ParseObjectOptions = { templateDepth: 0 },\n  ): Node.Node | null {\n    const parsedNode = this.hooks.parseNode.call(\n      obj,\n      type,\n      options,\n    ) as Node.Node | null;\n\n    if (parsedNode || parsedNode === null) {\n      return parsedNode;\n    }\n\n    const parseLocalObject = (\n      currentValue: any,\n      objToParse: unknown,\n      path: string[] = [],\n    ): NestedObj => {\n      if (typeof objToParse !== \"object\" || objToParse === null) {\n        return { value: objToParse, children: [] };\n      }\n\n      const localObj = this.hooks.onParseObject.call(objToParse, type);\n\n      if (!localObj) {\n        return currentValue;\n      }\n\n      const objEntries = Array.isArray(localObj)\n        ? localObj.map((v, i) => [i, v])\n        : [\n            ...Object.entries(localObj),\n            ...Object.getOwnPropertySymbols(localObj).map((s) => [\n              s,\n              (localObj as any)[s],\n            ]),\n          ];\n\n      const defaultValue: NestedObj = {\n        children: [],\n        value: currentValue,\n      };\n\n      const newValue = objEntries.reduce((accumulation, current): NestedObj => {\n        let { value } = accumulation;\n        const { children } = accumulation;\n        const [localKey, localValue] = current;\n\n        const newChildren = this.hooks.parseNode.call(\n          localValue,\n          NodeType.Value,\n          options,\n          {\n            path,\n            key: localKey,\n            parentObj: localObj,\n          },\n        ) as Node.Child[];\n\n        if (newChildren) {\n          children.push(...newChildren);\n        } else if (localValue && typeof localValue === \"object\") {\n          const result = parseLocalObject(accumulation.value, localValue, [\n            ...path,\n            localKey,\n          ]);\n\n          value = result.value;\n          children.push(...result.children);\n        } else {\n          value = setIn(accumulation.value, [...path, localKey], localValue);\n        }\n\n        return {\n          value,\n          children,\n        };\n      }, defaultValue);\n\n      return newValue;\n    };\n\n    const { value, children } = parseLocalObject(undefined, obj);\n\n    const baseAst =\n      value === undefined && !children.length\n        ? undefined\n        : {\n            type,\n            value,\n          };\n\n    if (baseAst && children.length) {\n      const parent: Node.BaseWithChildren<any> = baseAst;\n      parent.children = children;\n      children.forEach((child) => {\n        child.value.parent = parent;\n      });\n    }\n\n    return this.hooks.onCreateASTNode.call(baseAst, obj) ?? null;\n  }\n}\n","import { set } from \"timm\";\nimport { resolveDataRefs } from \"../../string-resolver\";\nimport type { Options } from \"./options\";\nimport type { Node } from \"../parser\";\nimport { NodeType } from \"../parser\";\nimport type { Resolver } from \"../resolver\";\nimport { ViewInstance, ViewPlugin } from \"../view\";\n\n/** Create a function that checks for a start/end sequence in a string */\nconst createPatternMatcher = (start: string, end: string) => {\n  return (testStr: string) => {\n    const startLocation = testStr.indexOf(start);\n\n    if (startLocation === -1) {\n      return false;\n    }\n\n    const endLocation = testStr.indexOf(end);\n\n    if (endLocation === -1) {\n      return false;\n    }\n\n    return startLocation < endLocation;\n  };\n};\n\nconst bindingResolveLookup = createPatternMatcher(\"{{\", \"}}\");\nconst expressionResolveLookup = createPatternMatcher(\"@[\", \"]@\");\n\n/** Check to see if a string contains a reference to dynamic content */\nfunction hasSomethingToResolve(str: string) {\n  return bindingResolveLookup(str) || expressionResolveLookup(str);\n}\n\n/** Resolve data refs in a string if necessary. */\nfunction resolveString(str: string, resolveOptions: Options) {\n  return hasSomethingToResolve(str)\n    ? resolveDataRefs(str, {\n        model: resolveOptions.data.model,\n        evaluate: resolveOptions.evaluate,\n      })\n    : str;\n}\n\n/** Recursively resolve all string references in an object or array */\nexport function resolveAllRefs(\n  node: any,\n  resolveOptions: Options,\n  propertiesToSkip: Set<string | number>,\n): any {\n  if (\n    node === null ||\n    node === undefined ||\n    (typeof node !== \"object\" && typeof node !== \"string\")\n  ) {\n    return node;\n  }\n\n  if (typeof node === \"string\") {\n    return resolveString(node, resolveOptions);\n  }\n\n  let newNode = node;\n\n  Object.keys(node).forEach((key: string | number) => {\n    if (propertiesToSkip.has(key)) {\n      return;\n    }\n\n    const val = node[key];\n\n    let newVal = val;\n\n    if (typeof val === \"object\") {\n      newVal = resolveAllRefs(val, resolveOptions, propertiesToSkip);\n    } else if (typeof val === \"string\") {\n      newVal = resolveString(val, resolveOptions);\n    }\n\n    if (newVal !== val) {\n      newNode = set(newNode, key as any, newVal);\n    }\n  });\n\n  return newNode;\n}\n\n/** Traverse up the node tree finding the first available 'path' */\nconst findBasePath = (\n  node: Node.Node,\n  resolver: Resolver,\n): Node.PathSegment[] => {\n  const parentNode = node.parent;\n  if (!parentNode) {\n    return [];\n  }\n\n  if (\"children\" in parentNode) {\n    const original = resolver.getSourceNode(node);\n    return (\n      parentNode.children?.find((child) => child.value === original)?.path ?? []\n    );\n  }\n\n  if (parentNode.type !== NodeType.MultiNode) {\n    return [];\n  }\n\n  return findBasePath(parentNode, resolver);\n};\n\n/** A plugin that resolves all string references for each node */\nexport default class StringResolverPlugin implements ViewPlugin {\n  private propertiesToSkipCache: Map<string, Set<string>>;\n\n  constructor() {\n    this.propertiesToSkipCache = new Map();\n  }\n\n  applyResolver(resolver: Resolver) {\n    resolver.hooks.resolve.tap(\"string-resolver\", (value, node, options) => {\n      if (node.type === NodeType.Empty || node.type === NodeType.Unknown) {\n        return null;\n      }\n\n      if (\n        node.type === NodeType.Value ||\n        node.type === NodeType.Asset ||\n        node.type === NodeType.View\n      ) {\n        /** Use specified properties to skip during string resolution, or default */\n        let propsToSkip: Set<string>;\n        if (node.type === NodeType.Asset || node.type === NodeType.View) {\n          propsToSkip = new Set(\n            node.plugins?.stringResolver?.propertiesToSkip ?? [\"exp\"],\n          );\n          if (node.value?.id) {\n            this.propertiesToSkipCache.set(node.value.id, propsToSkip);\n          }\n        } else if (\n          node.parent?.type === NodeType.MultiNode &&\n          (node.parent?.parent?.type === NodeType.Asset ||\n            node.parent?.parent?.type === NodeType.View) &&\n          node.parent.parent.value?.id &&\n          this.propertiesToSkipCache.has(node.parent.parent.value.id)\n        ) {\n          propsToSkip = this.propertiesToSkipCache.get(\n            node.parent.parent.value.id,\n          ) as Set<string>;\n        } else {\n          propsToSkip = new Set([\"exp\"]);\n        }\n\n        const nodePath = findBasePath(node, resolver);\n\n        /** If the path includes something that is supposed to be skipped, this node should be skipped too. */\n        if (\n          nodePath.length > 0 &&\n          nodePath.some((segment) => propsToSkip.has(segment.toString()))\n        ) {\n          return node.value;\n        }\n\n        return resolveAllRefs(node.value, options, propsToSkip);\n      }\n\n      return value;\n    });\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.resolver.tap(\"string-resolver\", this.applyResolver.bind(this));\n  }\n}\n","import { omit } from \"timm\";\nimport type { Options } from \"./options\";\nimport type { Resolver } from \"../resolver\";\nimport type {\n  Node,\n  ParseObjectOptions,\n  ParseObjectChildOptions,\n  Parser,\n} from \"../parser\";\nimport { NodeType } from \"../parser\";\nimport { ViewInstance, ViewPlugin } from \"../view\";\n\n/** A view plugin to remove inapplicable assets from the tree */\nexport default class ApplicabilityPlugin implements ViewPlugin {\n  private isApplicability(obj: any) {\n    return obj && Object.prototype.hasOwnProperty.call(obj, \"applicability\");\n  }\n\n  applyResolver(resolver: Resolver) {\n    resolver.hooks.beforeResolve.tap(\n      \"applicability\",\n      (node: Node.Node | null, options: Options) => {\n        let newNode = node;\n\n        if (node?.type === NodeType.Applicability) {\n          const isApplicable = options.evaluate(node.expression);\n\n          if (isApplicable === false) {\n            return null;\n          }\n\n          newNode = node.value;\n        }\n\n        return newNode;\n      },\n    );\n  }\n\n  applyParser(parser: Parser) {\n    parser.hooks.parseNode.tap(\n      \"applicability\",\n      (\n        obj: any,\n        nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        childOptions?: ParseObjectChildOptions,\n      ) => {\n        if (this.isApplicability(obj)) {\n          const parsedApplicability = parser.parseObject(\n            omit(obj, \"applicability\"),\n            nodeType,\n            options,\n          );\n\n          if (!parsedApplicability) {\n            return childOptions ? [] : null;\n          }\n\n          const applicabilityNode = parser.createASTNode(\n            {\n              type: NodeType.Applicability,\n              expression: (obj as any).applicability,\n              value: parsedApplicability,\n            },\n            obj,\n          );\n\n          if (!applicabilityNode) {\n            return childOptions ? [] : null;\n          }\n\n          if (applicabilityNode.type === NodeType.Applicability) {\n            applicabilityNode.value.parent = applicabilityNode;\n          }\n\n          return childOptions\n            ? [\n                {\n                  path: [...childOptions.path, childOptions.key],\n                  value: applicabilityNode,\n                },\n              ]\n            : applicabilityNode;\n        }\n      },\n    );\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.resolver.tap(\"applicability\", this.applyResolver.bind(this));\n    view.hooks.parser.tap(\"applicability\", this.applyParser.bind(this));\n  }\n}\n","import { setIn } from \"timm\";\nimport deferred from \"p-defer\";\nimport type { Flow as FlowType, FlowResult } from \"@player-ui/types\";\n\nimport { SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport type { Logger } from \"./logger\";\nimport { TapableLogger } from \"./logger\";\nimport type { ExpressionType } from \"./expressions\";\nimport { ExpressionEvaluator } from \"./expressions\";\nimport { SchemaController } from \"./schema\";\nimport { BindingParser } from \"./binding\";\nimport type { ViewInstance } from \"./view\";\nimport { resolveDataRefs } from \"./string-resolver\";\nimport type { FlowInstance } from \"./controllers\";\nimport {\n  ConstantsController,\n  ViewController,\n  DataController,\n  ValidationController,\n  FlowController,\n} from \"./controllers\";\nimport { FlowExpPlugin } from \"./plugins/flow-exp-plugin\";\nimport { DefaultExpPlugin } from \"./plugins/default-exp-plugin\";\nimport type {\n  PlayerFlowState,\n  InProgressState,\n  CompletedState,\n  ErrorState,\n} from \"./types\";\nimport { NOT_STARTED_STATE } from \"./types\";\nimport { DefaultViewPlugin } from \"./plugins/default-view-plugin\";\n\n// Variables injected at build time\nconst PLAYER_VERSION = \"__VERSION__\";\nconst COMMIT = \"__GIT_COMMIT__\";\n\nexport interface PlayerPlugin {\n  /**\n   * Unique identifier of the plugin.\n   * Enables the plugin to be retrievable from Player.\n   */\n  symbol?: symbol;\n\n  /** The name of the plugin */\n  name: string;\n\n  /**\n   * Use this to tap into Player hooks\n   */\n  apply: (player: Player) => void;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ExtendedPlayerPlugin<\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  Assets = void,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  Views = void,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  Expressions = void,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  DataTypes = void,\n> {}\n\nexport interface PlayerConfigOptions {\n  /** A set of plugins to load  */\n  plugins?: PlayerPlugin[];\n\n  /** A logger to use */\n  logger?: Logger;\n}\n\nexport interface PlayerInfo {\n  /** Version of the running player */\n  version: string;\n\n  /** Hash of the HEAD commit used to build the current version */\n  commit: string;\n}\n\n/**\n * This is it.\n */\nexport class Player {\n  public static readonly info: PlayerInfo = {\n    version: PLAYER_VERSION,\n    commit: COMMIT,\n  };\n\n  public readonly logger = new TapableLogger();\n  public readonly constantsController = new ConstantsController();\n  private config: PlayerConfigOptions;\n  private state: PlayerFlowState = NOT_STARTED_STATE;\n\n  public readonly hooks = {\n    /** The hook that fires every time we create a new flowController (a new Content blob is passed in) */\n    flowController: new SyncHook<[FlowController]>(),\n\n    /** The hook that updates/handles views */\n    viewController: new SyncHook<[ViewController]>(),\n\n    /** A hook called every-time there's a new view. This is equivalent to the view hook on the view-controller */\n    view: new SyncHook<[ViewInstance]>(),\n\n    /** Called when an expression evaluator was created */\n    expressionEvaluator: new SyncHook<[ExpressionEvaluator]>(),\n\n    /** The hook that creates and manages data */\n    dataController: new SyncHook<[DataController]>(),\n\n    /** Called after the schema is created for a flow */\n    schema: new SyncHook<[SchemaController]>(),\n\n    /** Manages validations (schema and x-field ) */\n    validationController: new SyncHook<[ValidationController]>(),\n\n    /** Manages parsing binding */\n    bindingParser: new SyncHook<[BindingParser]>(),\n\n    /** A that's called for state changes in the flow execution */\n    state: new SyncHook<[PlayerFlowState]>(),\n\n    /** A hook to access the current flow */\n    onStart: new SyncHook<[FlowType]>(),\n\n    /** A hook for when the flow ends either in success or failure */\n    onEnd: new SyncHook<[]>(),\n    /** Mutate the Content flow before starting */\n    resolveFlowContent: new SyncWaterfallHook<[FlowType]>(),\n  };\n\n  constructor(config?: PlayerConfigOptions) {\n    if (config?.logger) {\n      this.logger.addHandler(config.logger);\n    }\n\n    this.config = config || {};\n    this.config.plugins = [\n      new DefaultExpPlugin(),\n      new DefaultViewPlugin(),\n      ...(this.config.plugins || []),\n      new FlowExpPlugin(),\n    ];\n    this.config.plugins?.forEach((plugin) => {\n      plugin.apply(this);\n    });\n  }\n\n  /**  Returns currently registered plugins */\n  public getPlugins(): PlayerPlugin[] {\n    return this.config.plugins ?? [];\n  }\n\n  /** Find instance of [Plugin] that has been registered to Player */\n  public findPlugin<Plugin extends PlayerPlugin>(\n    symbol: symbol,\n  ): Plugin | undefined {\n    return this.config.plugins?.find((el) => el.symbol === symbol) as Plugin;\n  }\n\n  /** Retrieve an instance of [Plugin] and conditionally invoke [apply] if it exists */\n  public applyTo<Plugin extends PlayerPlugin>(\n    symbol: symbol,\n    apply: (plugin: Plugin) => void,\n  ): void {\n    const plugin = this.findPlugin<Plugin>(symbol);\n\n    if (plugin) {\n      apply(plugin);\n    }\n  }\n\n  /** Register and apply [Plugin] if one with the same symbol is not already registered. */\n  public registerPlugin(plugin: PlayerPlugin) {\n    plugin.apply(this);\n    this.config.plugins?.push(plugin);\n  }\n\n  /** Returns the current version of the running player */\n  public getVersion(): string {\n    return Player.info.version;\n  }\n\n  /** Returns the git commit used to build Player version */\n  public getCommit(): string {\n    return Player.info.commit;\n  }\n\n  /**\n   * Fetch the current state of Player.\n   * It will return either `not-started`, `in-progress`, `completed`\n   * with some extra data in each\n   */\n  public getState(): PlayerFlowState {\n    return this.state;\n  }\n\n  /**\n   * A private means of setting the state of Player\n   * Calls the hooks for subscribers to listen for this event\n   */\n  private setState(state: PlayerFlowState) {\n    this.state = state;\n    this.hooks.state.call(state);\n  }\n\n  /** Start Player with the given flow */\n  private setupFlow(userContent: FlowType): {\n    /** a callback to _actually_ start the flow */\n    start: () => void;\n\n    /** the state object to kick if off */\n    state: Omit<InProgressState, \"ref\">;\n  } {\n    const userFlow = this.hooks.resolveFlowContent.call(userContent);\n\n    const flowController = new FlowController(userFlow.navigation, {\n      logger: this.logger,\n    });\n\n    this.hooks.onStart.call(userFlow);\n\n    this.hooks.flowController.call(flowController);\n\n    // eslint-disable-next-line prefer-const\n    let expressionEvaluator: ExpressionEvaluator;\n    // eslint-disable-next-line prefer-const\n    let dataController: DataController;\n\n    const pathResolver = new BindingParser({\n      get: (binding) => {\n        return dataController.get(binding);\n      },\n      set: (transaction) => {\n        return dataController.set(transaction);\n      },\n      evaluate: (expression) => {\n        return expressionEvaluator.evaluate(expression);\n      },\n    });\n\n    this.hooks.bindingParser.call(pathResolver);\n    const parseBinding = pathResolver.parse;\n    const flowResultDeferred = deferred<FlowResult>();\n\n    const schema = new SchemaController(userFlow.schema);\n    this.hooks.schema.call(schema);\n\n    const validationController = new ValidationController(schema);\n\n    this.hooks.validationController.call(validationController);\n\n    dataController = new DataController(userFlow.data, {\n      pathResolver,\n      middleware: validationController.getDataMiddleware(),\n      logger: this.logger,\n    });\n\n    dataController.hooks.format.tap(\"player\", (value, binding) => {\n      const formatter = schema.getFormatter(binding);\n\n      return formatter ? formatter.format(value) : value;\n    });\n\n    dataController.hooks.deformat.tap(\"player\", (value, binding) => {\n      const formatter = schema.getFormatter(binding);\n\n      return formatter ? formatter.deformat(value) : value;\n    });\n\n    dataController.hooks.resolveDefaultValue.tap(\n      \"player\",\n      (binding) => schema.getApparentType(binding)?.default,\n    );\n\n    // eslint-disable-next-line prefer-const\n    let viewController: ViewController;\n\n    expressionEvaluator = new ExpressionEvaluator({\n      model: dataController,\n      logger: this.logger,\n    });\n\n    this.hooks.expressionEvaluator.call(expressionEvaluator);\n\n    expressionEvaluator.hooks.onError.tap(\"player\", (e) => {\n      flowResultDeferred.reject(e);\n\n      return true;\n    });\n\n    /** Resolve any data references in a string */\n    function resolveStrings<T>(val: T, formatted?: boolean) {\n      return resolveDataRefs(val, {\n        model: dataController,\n        evaluate: expressionEvaluator.evaluate,\n        formatted,\n      });\n    }\n\n    flowController.hooks.flow.tap(\"player\", (flow: FlowInstance) => {\n      flow.hooks.beforeTransition.tap(\"player\", (state, transitionVal) => {\n        /** Checks to see if there are any transitions for a specific transition state (i.e. next, back). If not, it will default to * */\n        const computedTransitionVal = state.transitions[transitionVal]\n          ? transitionVal\n          : \"*\";\n        if (state.onEnd && state.transitions[computedTransitionVal]) {\n          if (typeof state.onEnd === \"object\" && \"exp\" in state.onEnd) {\n            expressionEvaluator?.evaluate(state.onEnd.exp);\n          } else {\n            expressionEvaluator?.evaluate(state.onEnd as ExpressionType);\n          }\n        }\n\n        /** If the transition does not exist, then do not resolve any expressions */\n        if (\n          !(\"transitions\" in state) ||\n          !state.transitions[computedTransitionVal]\n        ) {\n          return state;\n        }\n\n        /** resolves and sets the transition to the computed exp */\n        return setIn(\n          state,\n          [\"transitions\", computedTransitionVal],\n          resolveStrings(state.transitions[computedTransitionVal]),\n        ) as any;\n      });\n\n      flow.hooks.skipTransition.tap(\"validation\", (currentState) => {\n        if (currentState?.value.state_type === \"VIEW\") {\n          const { canTransition, validations } =\n            validationController.validateView(\"navigation\");\n\n          if (!canTransition && validations) {\n            const bindings = new Set(validations.keys());\n            viewController?.currentView?.update(bindings);\n\n            return true;\n          }\n        }\n\n        return undefined;\n      });\n\n      flow.hooks.resolveTransitionNode.tap(\"player\", (state) => {\n        let newState = state;\n\n        if (\"ref\" in state) {\n          newState = setIn(state, [\"ref\"], resolveStrings(state.ref)) as any;\n        }\n\n        if (\"param\" in state) {\n          newState = setIn(\n            state,\n            [\"param\"],\n            resolveStrings(state.param, false),\n          ) as any;\n        }\n\n        return newState;\n      });\n\n      flow.hooks.transition.tap(\"player\", (_oldState, newState) => {\n        if (newState.value.state_type !== \"VIEW\") {\n          validationController.reset();\n        }\n      });\n\n      flow.hooks.afterTransition.tap(\"player\", (flowInstance) => {\n        const value = flowInstance.currentState?.value;\n        if (value && value.state_type === \"ACTION\") {\n          const { exp } = value;\n          flowController?.transition(\n            String(expressionEvaluator?.evaluate(exp)),\n          );\n        }\n\n        expressionEvaluator.reset();\n      });\n    });\n\n    this.hooks.dataController.call(dataController);\n\n    validationController.setOptions({\n      parseBinding,\n      model: dataController,\n      logger: this.logger,\n      evaluate: expressionEvaluator.evaluate,\n      constants: this.constantsController,\n    });\n\n    viewController = new ViewController(userFlow.views || [], {\n      evaluator: expressionEvaluator,\n      parseBinding,\n      transition: flowController.transition,\n      model: dataController,\n      utils: {\n        findPlugin: <Plugin = unknown>(pluginSymbol: symbol) => {\n          return this.findPlugin(pluginSymbol) as unknown as Plugin;\n        },\n      },\n      logger: this.logger,\n      flowController,\n      schema,\n      format: (binding, value) => {\n        const formatter = schema.getFormatter(binding);\n\n        return formatter?.format ? formatter.format(value) : value;\n      },\n      formatValue: (ref, value) => {\n        const formatter = schema.getFormatterForType(ref);\n\n        return formatter?.format ? formatter.format(value) : value;\n      },\n      validation: {\n        ...validationController.forView(parseBinding),\n        type: (b) => schema.getType(parseBinding(b)),\n      },\n      constants: this.constantsController,\n    });\n    viewController.hooks.view.tap(\"player\", (view) => {\n      validationController.onView(view);\n      this.hooks.view.call(view);\n    });\n    this.hooks.viewController.call(viewController);\n\n    return {\n      start: () => {\n        flowController\n          .start()\n          .then((endState) => {\n            const flowResult: FlowResult = {\n              endState: resolveStrings(endState, false),\n              data: dataController.serialize(),\n            };\n\n            return flowResult;\n          })\n          .then(flowResultDeferred.resolve)\n          .catch((e) => {\n            this.logger.error(`Something went wrong: ${e.message}`);\n            throw e;\n          })\n          .catch(flowResultDeferred.reject)\n          .finally(() => this.hooks.onEnd.call());\n      },\n      state: {\n        status: \"in-progress\",\n        flowResult: flowResultDeferred.promise,\n        controllers: {\n          data: dataController,\n          view: viewController,\n          flow: flowController,\n          schema,\n          expression: expressionEvaluator,\n          binding: pathResolver,\n          validation: validationController,\n        },\n        fail: flowResultDeferred.reject,\n        flow: userFlow,\n        logger: this.logger,\n      },\n    };\n  }\n\n  public async start(payload: FlowType): Promise<CompletedState> {\n    const ref = Symbol(payload?.id ?? \"payload\");\n\n    /** A check to avoid updating the state for a flow that's not the current one */\n    const maybeUpdateState = <T extends PlayerFlowState>(newState: T) => {\n      if (this.state.ref !== ref) {\n        this.logger.warn(\n          `Received update for a flow that's not the current one`,\n        );\n\n        return newState;\n      }\n\n      this.setState(newState);\n\n      return newState;\n    };\n\n    this.setState({\n      status: \"not-started\",\n      ref,\n    });\n\n    try {\n      const { state, start } = this.setupFlow(payload);\n      this.setState({\n        ref,\n        ...state,\n      });\n\n      start();\n\n      // common data for the end state\n      // make sure to use the same ref as the starting one\n      const endProps = {\n        ref,\n        status: \"completed\",\n        flow: state.flow,\n        controllers: {\n          data: state.controllers.data.makeReadOnly(),\n        },\n      } as const;\n\n      return maybeUpdateState({\n        ...(await state.flowResult),\n        ...endProps,\n      });\n    } catch (error: any) {\n      const errorState: ErrorState = {\n        status: \"error\",\n        ref,\n        flow: payload,\n        error,\n      };\n\n      maybeUpdateState(errorState);\n\n      throw error;\n    }\n  }\n}\n","import { SyncBailHook, SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport type { DeferredPromise } from \"p-defer\";\nimport defer from \"p-defer\";\nimport type {\n  NavigationFlow,\n  NavigationFlowState,\n  NavigationFlowEndState,\n} from \"@player-ui/types\";\nimport type { Logger } from \"../../logger\";\n\nexport interface NamedState {\n  /** The name of the navigation node */\n  name: string;\n\n  /** The nav node */\n  value: NavigationFlowState;\n}\n\nexport interface TransitionOptions {\n  /** Ignore any validations or other signals preventing the transition from taking place  */\n  force?: boolean;\n}\nexport type TransitionFunction = (\n  name: string,\n  options?: TransitionOptions,\n) => void;\n\n/** The Content navigation state machine */\nexport class FlowInstance {\n  private flow: NavigationFlow;\n  private log?: Logger;\n  private history: string[];\n  private isTransitioning = false;\n  private flowPromise?: DeferredPromise<NavigationFlowEndState>;\n  public readonly id: string;\n  public currentState?: NamedState;\n  public readonly hooks = {\n    beforeStart: new SyncBailHook<[NavigationFlow], NavigationFlow>(),\n\n    /** A callback when the onStart node was present */\n    onStart: new SyncHook<[any]>(),\n\n    /** A callback when the onEnd node was present */\n    onEnd: new SyncHook<[any]>(),\n\n    /** A hook to intercept and block a transition */\n    skipTransition: new SyncBailHook<\n      [NamedState | undefined],\n      boolean | undefined\n    >(),\n\n    /** A chance to manipulate the flow-node used to calculate the given transition used  */\n    beforeTransition: new SyncWaterfallHook<\n      [Exclude<NavigationFlowState, NavigationFlowEndState>, string]\n    >(),\n\n    /** A chance to manipulate the flow-node calculated after a transition */\n    resolveTransitionNode: new SyncWaterfallHook<[NavigationFlowState]>(),\n\n    /** A callback when a transition from 1 state to another was made */\n    transition: new SyncHook<[NamedState | undefined, NamedState]>(),\n\n    /** A callback to run actions after a transition occurs */\n    afterTransition: new SyncHook<[FlowInstance]>(),\n  };\n\n  constructor(\n    id: string,\n    flow: NavigationFlow,\n    options?: {\n      /** Logger instance to use */\n      logger?: Logger;\n    },\n  ) {\n    this.id = id;\n    this.flow = flow;\n    this.log = options?.logger;\n    this.history = [];\n\n    this.hooks.transition.tap(\n      \"startPromise\",\n      async (_oldState, nextState: NamedState) => {\n        const newState = nextState.value;\n\n        if (this.flowPromise && newState.state_type === \"END\") {\n          this.flowPromise.resolve(newState);\n        }\n      },\n    );\n  }\n\n  /** Start the state machine */\n  public async start(): Promise<NavigationFlowEndState> {\n    if (this.flowPromise) {\n      this.log?.warn(\"Already called start for flow\");\n\n      return this.flowPromise.promise;\n    }\n\n    this.flow = this.hooks.beforeStart.call(this.flow) || this.flow;\n\n    if (this.flow.onStart) {\n      this.hooks.onStart.call(this.flow.onStart);\n    }\n\n    const initialState = this.flow.startState;\n\n    if (!initialState) {\n      return Promise.reject(new Error(\"No 'startState' defined for flow\"));\n    }\n\n    this.flowPromise = defer();\n    this.pushHistory(initialState);\n\n    return this.flowPromise.promise;\n  }\n\n  public transition(transitionValue: string, options?: TransitionOptions) {\n    if (this.isTransitioning) {\n      throw new Error(\n        `Transitioning while ongoing transition from ${this.currentState?.name} is in progress is not supported`,\n      );\n    }\n\n    if (this.currentState?.value.state_type === \"END\") {\n      this.log?.warn(\n        `Skipping transition using ${transitionValue}. Already at and END state`,\n      );\n\n      return;\n    }\n\n    if (this.currentState === undefined) {\n      throw new Error(\"Cannot transition when there's no current state\");\n    }\n\n    if (options?.force) {\n      this.log?.debug(`Forced transition. Skipping validation checks`);\n    } else {\n      const skipTransition = this.hooks.skipTransition.call(this.currentState);\n\n      if (skipTransition) {\n        this.log?.debug(\n          `Skipping transition from ${this.currentState.name} b/c hook told us to`,\n        );\n        return;\n      }\n    }\n\n    const state = this.hooks.beforeTransition.call(\n      this.currentState.value,\n      transitionValue,\n    );\n\n    if (!(\"transitions\" in state)) {\n      throw new Error(`No transitions defined for ${this.currentState.value}`);\n    }\n\n    const { transitions } = state;\n    const nextState = transitions[transitionValue] || transitions[\"*\"];\n\n    if (nextState === undefined) {\n      this.log?.warn(\n        `No transition from ${this.currentState.name} using ${transitionValue} or *`,\n      );\n\n      return;\n    }\n\n    this.log?.debug(\n      `Transitioning from ${this.currentState.name} to ${nextState} using ${transitionValue} `,\n    );\n\n    return this.pushHistory(nextState, options);\n  }\n\n  private pushHistory(stateName: string, options?: TransitionOptions) {\n    if (!Object.prototype.hasOwnProperty.call(this.flow, stateName)) {\n      throw new Error(`No flow definition for: ${stateName} was found.`);\n    }\n\n    let nextState = this.flow[stateName];\n\n    if (\n      !this.flow[stateName] ||\n      typeof nextState !== \"object\" ||\n      !(\"state_type\" in nextState)\n    ) {\n      this.log?.error(`Flow doesn't contain any states named: ${stateName}`);\n\n      return;\n    }\n\n    const prevState = this.currentState;\n\n    this.isTransitioning = true;\n    nextState = this.hooks.resolveTransitionNode.call(nextState);\n\n    const newCurrentState = {\n      name: stateName,\n      value: nextState,\n    } as NamedState;\n    this.currentState = newCurrentState;\n    this.history.push(stateName);\n\n    // If the new state is an END state call the `onEnd` if it exists\n\n    if (newCurrentState.value.state_type === \"END\" && this.flow.onEnd) {\n      this.hooks.onEnd.call(this.flow.onEnd);\n    }\n\n    this.hooks.transition.call(prevState, {\n      ...newCurrentState,\n    });\n\n    this.isTransitioning = false;\n\n    this.hooks.afterTransition.call(this);\n  }\n}\n","import type { Validation } from \"@player-ui/types\";\nimport { SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport { setIn } from \"timm\";\n\nimport type { BindingInstance, BindingFactory } from \"../../binding\";\nimport { isBinding } from \"../../binding\";\nimport type { DataModelWithParser, DataModelMiddleware } from \"../../data\";\nimport type { SchemaController } from \"../../schema\";\nimport type {\n  ErrorValidationResponse,\n  ValidationObject,\n  ValidationObjectWithHandler,\n  ValidatorContext,\n  ValidationProvider,\n  ValidationResponse,\n  WarningValidationResponse,\n  StrongOrWeakBinding,\n} from \"../../validator\";\nimport {\n  ValidationMiddleware,\n  ValidatorRegistry,\n  removeBindingAndChildrenFromMap,\n} from \"../../validator\";\nimport type { Logger } from \"../../logger\";\nimport { ProxyLogger } from \"../../logger\";\nimport type { Resolve, ViewInstance } from \"../../view\";\nimport { caresAboutDataChanges } from \"../../view\";\nimport { replaceParams } from \"../../utils\";\nimport { resolveDataRefs } from \"../../string-resolver\";\nimport type {\n  ExpressionEvaluatorOptions,\n  ExpressionType,\n} from \"../../expressions\";\nimport type { BindingTracker } from \"./binding-tracker\";\nimport { ValidationBindingTrackerViewPlugin } from \"./binding-tracker\";\n\nexport const SCHEMA_VALIDATION_PROVIDER_NAME = \"schema\";\nexport const VIEW_VALIDATION_PROVIDER_NAME = \"view\";\n\nexport const VALIDATION_PROVIDER_NAME_SYMBOL: unique symbol = Symbol.for(\n  \"validation-provider-name\",\n);\n\nexport type ValidationObjectWithSource = ValidationObjectWithHandler & {\n  /** The name of the validation */\n  [VALIDATION_PROVIDER_NAME_SYMBOL]: string;\n};\n\ntype SimpleValidatorContext = Omit<\n  ValidatorContext,\n  \"validation\" | \"schemaType\"\n>;\n\ninterface BaseActiveValidation<T> {\n  /** The validation is being actively shown */\n  state: \"active\";\n\n  /** The validation response */\n  response: T;\n}\n\ntype ActiveWarning = BaseActiveValidation<WarningValidationResponse> & {\n  /** Warnings track if they can be dismissed automatically (by navigating) */\n  dismissable: boolean;\n};\ntype ActiveError = BaseActiveValidation<ErrorValidationResponse>;\n\n/**\n * warnings that keep track of their active state\n */\ntype StatefulWarning = {\n  /** A common key to differentiate between errors and warnings */\n  type: \"warning\";\n\n  /** The underlying validation this tracks */\n  value: ValidationObjectWithSource;\n\n  /** If this is currently preventing navigation from continuing */\n  isBlockingNavigation: boolean;\n} & (\n  | {\n      /** warnings start with no state, but can active or dismissed */\n      state: \"none\" | \"dismissed\";\n    }\n  | ActiveWarning\n);\n\n/** Errors that keep track of their state */\ntype StatefulError = {\n  /** A common key to differentiate between errors and warnings */\n  type: \"error\";\n\n  /** The underlying validation this tracks */\n  value: ValidationObjectWithSource;\n\n  /** If this is currently preventing navigation from continuing */\n  isBlockingNavigation: boolean;\n} & (\n  | {\n      /** Errors start with no state an can be activated */\n      state: \"none\";\n    }\n  | ActiveError\n);\n\nexport type StatefulValidationObject = StatefulWarning | StatefulError;\n\n/** Helper function to determin if the subset is within the containingSet */\nfunction isSubset<T>(subset: Set<T>, containingSet: Set<T>): boolean {\n  if (subset.size > containingSet.size) return false;\n  for (const entry of subset) if (!containingSet.has(entry)) return false;\n  return true;\n}\n\n/** Helper for initializing a validation object that tracks state */\nfunction createStatefulValidationObject(\n  obj: ValidationObjectWithSource,\n): StatefulValidationObject {\n  return {\n    value: obj,\n    type: obj.severity,\n    state: \"none\",\n    isBlockingNavigation: false,\n  };\n}\n\ntype ValidationRunner = (obj: ValidationObjectWithHandler) =>\n  | {\n      /** A validation message */\n      message: string;\n    }\n  | undefined;\n\n/** A class that manages validating bindings across phases */\nclass ValidatedBinding {\n  public currentPhase?: Validation.Trigger;\n  private applicableValidations: Array<StatefulValidationObject> = [];\n  private validationsByState: Record<\n    Validation.Trigger,\n    Array<StatefulValidationObject>\n  > = {\n    load: [],\n    change: [],\n    navigation: [],\n  };\n\n  public get allValidations(): Array<StatefulValidationObject> {\n    return Object.values(this.validationsByState).flat();\n  }\n\n  public weakBindings: Set<BindingInstance>;\n\n  private onDismiss?: () => void;\n\n  constructor(\n    possibleValidations: Array<ValidationObjectWithSource>,\n    onDismiss?: () => void,\n    log?: Logger,\n    weakBindings?: Set<BindingInstance>,\n  ) {\n    this.onDismiss = onDismiss;\n    possibleValidations.forEach((vObj) => {\n      const { trigger } = vObj;\n\n      if (this.validationsByState[trigger]) {\n        const statefulValidationObject = createStatefulValidationObject(vObj);\n        this.validationsByState[trigger].push(statefulValidationObject);\n      } else {\n        log?.warn(`Unknown validation trigger: ${trigger}`);\n      }\n    });\n    this.weakBindings = weakBindings ?? new Set();\n  }\n\n  private checkIfBlocking(statefulObj: StatefulValidationObject) {\n    if (statefulObj.state === \"active\") {\n      const { isBlockingNavigation } = statefulObj;\n      return isBlockingNavigation;\n    }\n\n    return false;\n  }\n\n  public getAll(): Array<ValidationResponse> {\n    return this.applicableValidations.reduce((all, statefulObj) => {\n      if (statefulObj.state === \"active\" && statefulObj.response) {\n        all.push({\n          ...statefulObj.response,\n          blocking: this.checkIfBlocking(statefulObj),\n        });\n      }\n\n      return all;\n    }, [] as Array<ValidationResponse>);\n  }\n\n  public get(): ValidationResponse | undefined {\n    const firstInvalid = this.applicableValidations.find((statefulObj) => {\n      return statefulObj.state === \"active\" && statefulObj.response;\n    });\n\n    if (firstInvalid?.state === \"active\") {\n      return {\n        ...firstInvalid.response,\n        blocking: this.checkIfBlocking(firstInvalid),\n      };\n    }\n  }\n\n  private runApplicableValidations(\n    runner: ValidationRunner,\n    canDismiss: boolean,\n    phase: Validation.Trigger,\n  ) {\n    // If the currentState is not load, skip those\n    this.applicableValidations = this.applicableValidations.map(\n      (originalValue) => {\n        if (originalValue.state === \"dismissed\") {\n          // Don't rerun any dismissed warnings\n          return originalValue;\n        }\n\n        // treat all warnings the same and block it once (unless blocking is true)\n        const blocking =\n          originalValue.value.blocking ??\n          ((originalValue.value.severity === \"warning\" && \"once\") || true);\n\n        const obj = setIn(\n          originalValue,\n          [\"value\", \"blocking\"],\n          blocking,\n        ) as StatefulValidationObject;\n\n        const isBlockingNavigation =\n          blocking === true || (blocking === \"once\" && !canDismiss);\n\n        if (\n          phase === \"navigation\" &&\n          obj.state === \"active\" &&\n          obj.value.blocking !== true\n        ) {\n          if (obj.value.severity === \"warning\") {\n            const warn = obj as ActiveWarning;\n            if (\n              warn.dismissable &&\n              warn.response.dismiss &&\n              (warn.response.blocking !== \"once\" || !warn.response.blocking)\n            ) {\n              warn.response.dismiss();\n            } else {\n              if (warn?.response.blocking === \"once\") {\n                warn.response.blocking = false;\n              }\n\n              warn.dismissable = true;\n            }\n\n            return warn as StatefulValidationObject;\n          }\n        }\n\n        const response = runner(obj.value);\n\n        const newState = {\n          type: obj.type,\n          value: obj.value,\n          state: response ? \"active\" : \"none\",\n          isBlockingNavigation,\n          dismissable:\n            obj.value.severity === \"warning\" && phase === \"navigation\",\n          response: response\n            ? {\n                ...obj.value,\n                message: response.message ?? \"Something is broken\",\n                severity: obj.value.severity,\n                displayTarget: obj.value.displayTarget ?? \"field\",\n              }\n            : undefined,\n        } as StatefulValidationObject;\n\n        if (newState.state === \"active\" && obj.value.severity === \"warning\") {\n          (newState.response as WarningValidationResponse).dismiss = () => {\n            (newState as StatefulWarning).state = \"dismissed\";\n            this.onDismiss?.();\n          };\n        }\n\n        return newState;\n      },\n    );\n  }\n\n  public update(\n    phase: Validation.Trigger,\n    canDismiss: boolean,\n    runner: ValidationRunner,\n  ) {\n    const newApplicableValidations: StatefulValidationObject[] = [];\n\n    if (phase === \"load\" && this.currentPhase !== undefined) {\n      // Tried to run the 'load' phase twice. Aborting\n      return;\n    }\n\n    if (this.currentPhase === \"navigation\" || phase === this.currentPhase) {\n      // Already added all the types. No need to continue adding new validations\n      this.runApplicableValidations(runner, canDismiss, phase);\n      return;\n    }\n\n    if (phase === \"load\") {\n      this.currentPhase = \"load\";\n      this.applicableValidations = [...this.validationsByState.load];\n    } else if (phase === \"change\" && this.currentPhase === \"load\") {\n      this.currentPhase = \"change\";\n      // The transition to the 'change' type can only come from a 'load' type\n      this.applicableValidations = [\n        ...this.applicableValidations,\n        ...this.validationsByState.change,\n      ];\n    } else if (\n      phase === \"navigation\" &&\n      (this.currentPhase === \"load\" || this.currentPhase === \"change\")\n    ) {\n      // Can transition to a nav state from a change or load\n\n      // if there is an non-blocking error that is active then remove the error from applicable validations so it can no longer be shown\n      // which is needed if there are additional warnings to become active for that binding after the error is shown\n      this.applicableValidations.forEach((element) => {\n        if (\n          !(\n            element.type === \"error\" &&\n            element.state === \"active\" &&\n            element.isBlockingNavigation === false\n          )\n        ) {\n          newApplicableValidations.push(element);\n        }\n      });\n\n      this.applicableValidations = [\n        ...newApplicableValidations,\n        ...this.validationsByState.navigation,\n        ...(this.currentPhase === \"load\" ? this.validationsByState.change : []),\n      ];\n      this.currentPhase = \"navigation\";\n    }\n\n    this.runApplicableValidations(runner, canDismiss, phase);\n  }\n}\n\n/**\n * A controller for orchestrating validation within a running player\n *\n * The current validation flow is as follows:\n *\n *   - When a binding is first seen, gather all of the possible validations for it from the providers\n *     - Schema and Crossfield (view) are both providers of possible validations\n *     - Run all of the applicable validations for that binding for the `load` trigger\n *\n *   - When a change occurs, set the phase of the binding to `change`.\n *     - Run all of the `change` triggered validations for that binding.\n *\n *   - When a navigation event occurs, set the phase of the binding to `navigate`.\n *     - Run all `change` and `navigate` validations for each tracked binding.\n *     - For any warnings, also keep a state of `shown` or `dismissed`.\n *       - Set all non-dismissed warnings to `shown`.\n *       - Set all `shown` warnings to `dismissed`.\n *     - Allow navigation forward if there are no non-dismissed warnings and no valid errors.\n */\nexport class ValidationController implements BindingTracker {\n  public readonly hooks = {\n    /** A hook called to tap into the validator registry for adding more validators */\n    createValidatorRegistry: new SyncHook<[ValidatorRegistry]>(),\n\n    /** A callback/event when a new validation is added to the view */\n    onAddValidation: new SyncWaterfallHook<\n      [ValidationResponse, BindingInstance]\n    >(),\n\n    /** The inverse of onAddValidation, this is called when a validation is removed from the list */\n    onRemoveValidation: new SyncWaterfallHook<\n      [ValidationResponse, BindingInstance]\n    >(),\n\n    resolveValidationProviders: new SyncWaterfallHook<\n      [\n        Array<{\n          /** The name of the provider */\n          source: string;\n          /** The provider itself */\n          provider: ValidationProvider;\n        }>,\n      ],\n      {\n        /** The view this is triggered for  */\n        view?: ViewInstance;\n      }\n    >(),\n\n    /** A hook called when a binding is added to the tracker */\n    onTrackBinding: new SyncHook<[BindingInstance]>(),\n  };\n\n  private tracker: BindingTracker | undefined;\n  private validations = new Map<BindingInstance, ValidatedBinding>();\n  private validatorRegistry?: ValidatorRegistry;\n  private schema: SchemaController;\n\n  private providers:\n    | Array<{\n        /** The name of the provider */\n        source: string;\n        /** The provider itself */\n        provider: ValidationProvider;\n      }>\n    | undefined;\n\n  private viewValidationProvider?: ValidationProvider;\n  private options?: SimpleValidatorContext;\n  private weakBindingTracker = new Set<BindingInstance>();\n\n  constructor(schema: SchemaController, options?: SimpleValidatorContext) {\n    this.schema = schema;\n    this.options = options;\n    this.reset();\n  }\n\n  setOptions(options: SimpleValidatorContext) {\n    this.options = options;\n  }\n\n  /** Return the middleware for the data-model to stop propagation of invalid data */\n  public getDataMiddleware(): Array<DataModelMiddleware> {\n    return [\n      {\n        set: (transaction, options, next) => {\n          return next?.set(transaction, options) ?? [];\n        },\n        get: (binding, options, next) => {\n          return next?.get(binding, options);\n        },\n        delete: (binding, options, next) => {\n          this.validations = removeBindingAndChildrenFromMap(\n            this.validations,\n            binding,\n          );\n\n          return next?.delete(binding, options);\n        },\n      },\n      new ValidationMiddleware(\n        (binding) => {\n          if (!this.options) {\n            return;\n          }\n\n          this.updateValidationsForBinding(binding, \"change\", this.options);\n          const strongValidation = this.getValidationForBinding(binding);\n\n          // return validation issues directly on bindings first\n          if (strongValidation?.get()?.severity === \"error\") {\n            return strongValidation.get();\n          }\n\n          // if none, check to see any validations this binding may be a weak ref of and return\n          const newInvalidBindings: Set<StrongOrWeakBinding> = new Set();\n          this.validations.forEach((weakValidation, strongBinding) => {\n            if (\n              caresAboutDataChanges(\n                new Set([binding]),\n                weakValidation.weakBindings,\n              ) &&\n              weakValidation?.get()?.severity === \"error\"\n            ) {\n              weakValidation?.weakBindings.forEach((weakBinding) => {\n                if (weakBinding === strongBinding) {\n                  newInvalidBindings.add({\n                    binding: weakBinding,\n                    isStrong: true,\n                  });\n                } else {\n                  newInvalidBindings.add({\n                    binding: weakBinding,\n                    isStrong: false,\n                  });\n                }\n              });\n            }\n          });\n\n          if (newInvalidBindings.size > 0) {\n            return newInvalidBindings;\n          }\n        },\n        { logger: new ProxyLogger(() => this.options?.logger) },\n      ),\n    ];\n  }\n\n  private getValidationProviders() {\n    if (this.providers) {\n      return this.providers;\n    }\n\n    this.providers = this.hooks.resolveValidationProviders.call([\n      {\n        source: SCHEMA_VALIDATION_PROVIDER_NAME,\n        provider: this.schema,\n      },\n      {\n        source: VIEW_VALIDATION_PROVIDER_NAME,\n        provider: {\n          getValidationsForBinding: (\n            binding: BindingInstance,\n          ): Array<ValidationObject> | undefined => {\n            return this.viewValidationProvider?.getValidationsForBinding?.(\n              binding,\n            );\n          },\n\n          getValidationsForView: (): Array<ValidationObject> | undefined => {\n            return this.viewValidationProvider?.getValidationsForView?.();\n          },\n        },\n      },\n    ]);\n\n    return this.providers;\n  }\n\n  public reset() {\n    this.validations.clear();\n    this.tracker = undefined;\n  }\n\n  public onView(view: ViewInstance): void {\n    this.validations.clear();\n    if (!this.options) {\n      return;\n    }\n\n    const bindingTrackerPlugin = new ValidationBindingTrackerViewPlugin({\n      ...this.options,\n      callbacks: {\n        onAdd: (binding) => {\n          if (\n            !this.options ||\n            this.getValidationForBinding(binding) !== undefined\n          ) {\n            return;\n          }\n\n          // Set the default value for the binding if we need to\n          const originalValue = this.options.model.get(binding);\n          const withoutDefault = this.options.model.get(binding, {\n            ignoreDefaultValue: true,\n          });\n\n          if (originalValue !== withoutDefault) {\n            // Don't trigger updates when setting the default value\n            this.options.model.set([[binding, originalValue]], {\n              silent: true,\n            });\n          }\n\n          this.updateValidationsForBinding(\n            binding,\n            \"load\",\n            this.options,\n            () => {\n              view.update(new Set([binding]));\n            },\n          );\n\n          this.hooks.onTrackBinding.call(binding);\n        },\n      },\n    });\n\n    this.tracker = bindingTrackerPlugin;\n    this.viewValidationProvider = view;\n\n    bindingTrackerPlugin.apply(view);\n  }\n\n  updateValidationsForBinding(\n    binding: BindingInstance,\n    trigger: Validation.Trigger,\n    validationContext?: SimpleValidatorContext,\n    onDismiss?: () => void,\n  ): void {\n    const context = validationContext ?? this.options;\n\n    if (!context) {\n      throw new Error(`Context is required for executing validations`);\n    }\n\n    if (trigger === \"load\") {\n      // Get all of the validations from each provider\n      const possibleValidations = this.getValidationProviders().reduce<\n        Array<ValidationObjectWithSource>\n      >((vals, provider) => {\n        vals.push(\n          ...(provider.provider\n            .getValidationsForBinding?.(binding)\n            ?.map((valObj) => ({\n              ...valObj,\n              [VALIDATION_PROVIDER_NAME_SYMBOL]: provider.source,\n            })) ?? []),\n        );\n\n        return vals;\n      }, []);\n\n      if (possibleValidations.length === 0) {\n        return;\n      }\n\n      this.validations.set(\n        binding,\n        new ValidatedBinding(\n          possibleValidations,\n          onDismiss,\n          this.options?.logger,\n        ),\n      );\n    }\n\n    const trackedValidations = this.validations.get(binding);\n    trackedValidations?.update(trigger, true, (validationObj) => {\n      const response = this.validationRunner(validationObj, binding, context);\n\n      if (this.weakBindingTracker.size > 0) {\n        const t = this.validations.get(binding) as ValidatedBinding;\n        this.weakBindingTracker.forEach((b) => t.weakBindings.add(b));\n      }\n\n      return response ? { message: response.message } : undefined;\n    });\n\n    // Also run any validations that binding or sub-binding is a weak binding of\n    if (trigger !== \"load\") {\n      this.validations.forEach((validation, vBinding) => {\n        if (\n          vBinding !== binding &&\n          caresAboutDataChanges(new Set([binding]), validation.weakBindings)\n        ) {\n          validation.update(trigger, true, (validationObj) => {\n            const response = this.validationRunner(\n              validationObj,\n              vBinding,\n              context,\n            );\n            return response ? { message: response.message } : undefined;\n          });\n        }\n      });\n    }\n  }\n\n  validationRunner(\n    validationObj: ValidationObjectWithHandler,\n    binding: BindingInstance,\n    context: SimpleValidatorContext | undefined = this.options,\n  ) {\n    if (!context) {\n      throw new Error(\"No context provided to validation runner\");\n    }\n\n    const handler =\n      validationObj.handler ?? this.getValidator(validationObj.type);\n\n    const weakBindings = new Set<BindingInstance>();\n\n    // For any data-gets in the validation runner, default to using the _invalid_ value (since that's what we're testing against)\n    const model: DataModelWithParser = {\n      get(b, options) {\n        weakBindings.add(isBinding(b) ? binding : context.parseBinding(b));\n        return context.model.get(b, { ...options, includeInvalid: true });\n      },\n      set: context.model.set,\n      delete: context.model.delete,\n    };\n\n    const result = handler?.(\n      {\n        ...context,\n        evaluate: (\n          exp: ExpressionType,\n          options: ExpressionEvaluatorOptions = { model },\n        ) => context.evaluate(exp, options),\n        model,\n        validation: validationObj,\n        schemaType: this.schema.getType(binding),\n      },\n      context.model.get(binding, {\n        includeInvalid: true,\n        formatted: validationObj.dataTarget === \"formatted\",\n      }),\n      validationObj,\n    );\n\n    this.weakBindingTracker = weakBindings;\n\n    if (result) {\n      let { message } = result;\n      const { parameters } = result;\n\n      if (validationObj.message) {\n        message = resolveDataRefs(validationObj.message, {\n          model,\n          evaluate: context.evaluate,\n        });\n        if (parameters) {\n          message = replaceParams(message, parameters);\n        }\n      }\n\n      return {\n        message,\n      };\n    }\n  }\n\n  private updateValidationsForView(trigger: Validation.Trigger): void {\n    const isNavigationTrigger = trigger === \"navigation\";\n    const lastActiveBindings = this.activeBindings;\n\n    /** Run validations for all bindings in view */\n    const updateValidations = (dismissValidations: boolean) => {\n      this.getBindings().forEach((binding) => {\n        this.validations\n          .get(binding)\n          ?.update(trigger, dismissValidations, (obj) => {\n            if (!this.options) {\n              return;\n            }\n\n            return this.validationRunner(obj, binding, this.options);\n          });\n      });\n    };\n\n    // Should dismiss for non-navigation triggers.\n    updateValidations(!isNavigationTrigger);\n\n    if (isNavigationTrigger) {\n      // If validations didn't change since last update, dismiss all dismissible validations.\n      const { activeBindings } = this;\n      if (isSubset(activeBindings, lastActiveBindings)) {\n        updateValidations(true);\n      }\n    }\n  }\n\n  private get activeBindings(): Set<BindingInstance> {\n    return new Set(\n      Array.from(this.getBindings()).filter(\n        (b) => this.validations.get(b)?.get() !== undefined,\n      ),\n    );\n  }\n\n  public getValidator(type: string) {\n    if (this.validatorRegistry) {\n      return this.validatorRegistry.get(type);\n    }\n\n    const registry = new ValidatorRegistry();\n    this.hooks.createValidatorRegistry.call(registry);\n    this.validatorRegistry = registry;\n\n    return registry.get(type);\n  }\n\n  getBindings(): Set<BindingInstance> {\n    return this.tracker?.getBindings() ?? new Set();\n  }\n\n  trackBinding(binding: BindingInstance): void {\n    this.tracker?.trackBinding(binding);\n  }\n\n  /** Executes all known validations for the tracked bindings using the given model */\n  validateView(trigger: Validation.Trigger = \"navigation\"): {\n    /** Indicating if the view can proceed without error */\n    canTransition: boolean;\n\n    /** the validations that are preventing the view from continuing */\n    validations?: Map<BindingInstance, ValidationResponse>;\n  } {\n    this.updateValidationsForView(trigger);\n\n    const validations = new Map<BindingInstance, ValidationResponse>();\n\n    let canTransition = true;\n\n    this.getBindings().forEach((b) => {\n      const allValidations = this.getValidationForBinding(b)?.getAll();\n\n      allValidations?.forEach((v) => {\n        if (trigger === \"navigation\" && v.blocking) {\n          this.options?.logger.debug(\n            `Validation on binding: ${b.asString()} is preventing navigation. ${JSON.stringify(\n              v,\n            )}`,\n          );\n\n          canTransition = false;\n        }\n\n        if (!validations.has(b)) {\n          validations.set(b, v);\n        }\n      });\n    });\n\n    return {\n      canTransition,\n      validations: validations.size ? validations : undefined,\n    };\n  }\n\n  /** Get the current tracked validation for the given binding */\n  public getValidationForBinding(\n    binding: BindingInstance,\n  ): ValidatedBinding | undefined {\n    return this.validations.get(binding);\n  }\n\n  forView(parser: BindingFactory): Resolve.Validation {\n    return {\n      _getValidationForBinding: (binding) => {\n        return this.getValidationForBinding(\n          isBinding(binding) ? binding : parser(binding),\n        );\n      },\n      getAll: () => {\n        const bindings = this.getBindings();\n        if (bindings.size === 0) {\n          return undefined;\n        }\n\n        const validationMapping = new Map<\n          BindingInstance,\n          ValidationResponse\n        >();\n\n        bindings.forEach((b) => {\n          const validation = this.getValidationForBinding(b)?.get();\n\n          if (validation) {\n            validationMapping.set(b, validation);\n          }\n        });\n\n        return validationMapping.size === 0 ? undefined : validationMapping;\n      },\n      get() {\n        throw new Error(\"Error Access be provided by the view plugin\");\n      },\n      getValidationsForBinding() {\n        throw new Error(\"Error rollup should be provided by the view plugin\");\n      },\n      getChildren() {\n        throw new Error(\"Error rollup should be provided by the view plugin\");\n      },\n      getValidationsForSection() {\n        throw new Error(\"Error rollup should be provided by the view plugin\");\n      },\n      track: () => {\n        throw new Error(\"Tracking should be provided by the view plugin\");\n      },\n      register: () => {\n        throw new Error(\n          \"Section functionality should be provided by the view plugin\",\n        );\n      },\n      type: (binding) =>\n        this.schema.getType(isBinding(binding) ? binding : parser(binding)),\n    };\n  }\n}\n","import { SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport queueMicrotask from \"queue-microtask\";\nimport { Registry } from \"@player-ui/partial-match-registry\";\nimport type { View, NavigationFlowViewState } from \"@player-ui/types\";\n\nimport { resolveDataRefsInString } from \"../../string-resolver\";\nimport type { Resolve } from \"../../view\";\nimport { ViewInstance } from \"../../view\";\nimport type { Logger } from \"../../logger\";\nimport type { FlowInstance, FlowController } from \"../flow\";\nimport type { DataController } from \"../data/controller\";\nimport { AssetTransformCorePlugin } from \"./asset-transform\";\nimport type { TransformRegistry } from \"./types\";\nimport type { BindingInstance } from \"../../binding\";\n\nexport interface ViewControllerOptions {\n  /** Where to get data from */\n  model: DataController;\n\n  /** Where to log data */\n  logger?: Logger;\n\n  /** A flow-controller instance to listen for view changes */\n  flowController: FlowController;\n}\n\n/** A controller to manage updating/switching views */\nexport class ViewController {\n  public readonly hooks = {\n    /** Do any processing before the `View` instance is created */\n    resolveView: new SyncWaterfallHook<\n      [View | undefined, string, NavigationFlowViewState]\n    >(),\n\n    // The hook right before the View starts resolving. Attach anything custom here\n    view: new SyncHook<[ViewInstance]>(),\n  };\n\n  private readonly viewMap: Record<string, View>;\n  private readonly viewOptions: Resolve.ResolverOptions & ViewControllerOptions;\n  private pendingUpdate?: {\n    /** pending data binding changes */\n    changedBindings?: Set<BindingInstance>;\n    /** Whether we have a microtask queued to handle this pending update */\n    scheduled?: boolean;\n  };\n\n  public currentView?: ViewInstance;\n  public transformRegistry: TransformRegistry = new Registry();\n  public optimizeUpdates = true;\n\n  constructor(\n    initialViews: View[],\n    options: Resolve.ResolverOptions & ViewControllerOptions,\n  ) {\n    this.viewOptions = options;\n    this.viewMap = initialViews.reduce<Record<string, View>>(\n      (viewMap, view) => {\n        // eslint-disable-next-line no-param-reassign\n        viewMap[view.id] = view;\n        return viewMap;\n      },\n      {},\n    );\n\n    new AssetTransformCorePlugin(this.transformRegistry).apply(this);\n\n    options.flowController.hooks.flow.tap(\n      \"viewController\",\n      (flow: FlowInstance) => {\n        flow.hooks.transition.tap(\"viewController\", (_oldState, newState) => {\n          if (newState.value.state_type === \"VIEW\") {\n            this.onView(newState.value);\n          } else {\n            this.currentView = undefined;\n          }\n        });\n      },\n    );\n\n    /** Trigger a view update */\n    const update = (updates: Set<BindingInstance>, silent = false) => {\n      if (this.currentView) {\n        if (this.optimizeUpdates) {\n          this.queueUpdate(updates, silent);\n        } else {\n          this.currentView.update();\n        }\n      }\n    };\n\n    options.model.hooks.onUpdate.tap(\n      \"viewController\",\n      (updates, updateOptions) => {\n        update(\n          new Set(updates.map((t) => t.binding)),\n          updateOptions?.silent ?? false,\n        );\n      },\n    );\n\n    options.model.hooks.onDelete.tap(\"viewController\", (binding) => {\n      const parentBinding = binding.parent();\n      const property = binding.key();\n\n      // Deleting an array item will trigger an update for the entire array\n      if (typeof property === \"number\" && parentBinding) {\n        update(new Set([parentBinding]));\n      } else {\n        update(new Set([binding]));\n      }\n    });\n  }\n\n  private queueUpdate(bindings: Set<BindingInstance>, silent = false) {\n    if (this.pendingUpdate?.changedBindings) {\n      // If there's already a pending update, just add to it don't worry about silent updates here yet\n      this.pendingUpdate.changedBindings = new Set([\n        ...this.pendingUpdate.changedBindings,\n        ...bindings,\n      ]);\n    } else {\n      this.pendingUpdate = { changedBindings: bindings, scheduled: false };\n    }\n\n    // If there's no pending update, schedule one only if this one isn't silent\n    // otherwise if this is silent, we'll just wait for the next non-silent update and make sure our bindings are included\n    if (!this.pendingUpdate.scheduled && !silent) {\n      this.pendingUpdate.scheduled = true;\n      queueMicrotask(() => {\n        const updates = this.pendingUpdate?.changedBindings;\n        this.pendingUpdate = undefined;\n        this.currentView?.update(updates);\n      });\n    }\n  }\n\n  private getViewForRef(viewRef: string): View | undefined {\n    // First look for a 1:1 viewRef -> id mapping (this is most common)\n    if (this.viewMap[viewRef]) {\n      return this.viewMap[viewRef];\n    }\n\n    // The view ids saved may also contain model refs, resolve those and try again\n    const matchingViewId = Object.keys(this.viewMap).find(\n      (possibleViewIdMatch) =>\n        viewRef ===\n        resolveDataRefsInString(possibleViewIdMatch, {\n          model: this.viewOptions.model,\n          evaluate: this.viewOptions.evaluator.evaluate,\n        }),\n    );\n\n    if (matchingViewId && this.viewMap[matchingViewId]) {\n      return this.viewMap[matchingViewId];\n    }\n  }\n\n  public onView(state: NavigationFlowViewState) {\n    const viewId = state.ref;\n\n    const source = this.hooks.resolveView.call(\n      this.getViewForRef(viewId),\n      viewId,\n      state,\n    );\n\n    if (!source) {\n      throw new Error(`No view with id ${viewId}`);\n    }\n\n    const view = new ViewInstance(source, this.viewOptions);\n    this.currentView = view;\n\n    // Give people a chance to attach their\n    // own listeners to the view before we resolve it\n    this.hooks.view.call(view);\n    view.update();\n  }\n}\n","import SortedArray from \"sorted-array\";\nimport type { Matcher } from \"./deep-partial-matcher\";\nimport createObjectMatcher from \"./deep-partial-matcher\";\n\nexport { default as createObjectMatcher } from \"./deep-partial-matcher\";\n\n/** create a matcher function that matches exactly */\nfunction createBasicMatcher(seed: any): Matcher {\n  /** a simple matcher function that only matches itself */\n  const matcher = (match: any) => seed === match;\n  matcher.count = 1;\n\n  return matcher;\n}\n\ninterface RegistryIndex<V> {\n  /** The original object we wanted to match on  */\n  key: object;\n\n  /** The value to return */\n  value: V;\n\n  /** The matcher function for this entry */\n  matcher: Matcher;\n}\n\n/** create an empty sorted array using the matcher count */\nconst createSortedArray = <V>() =>\n  new SortedArray<RegistryIndex<V>>([], (c) => c.matcher.count);\n\n/**\n * A partial match registry is a map that uses an object to \"match\" against keys.\n * More specific matches take precedence over less specific ones.\n */\nexport class Registry<V> {\n  private store = createSortedArray<V>();\n\n  constructor(initialSet?: Array<[any, V]>) {\n    initialSet?.forEach(([match, value]) => {\n      this.set(match, value);\n    });\n  }\n\n  /** Add match -> value mapping to the registry */\n  set(match: any, value: V) {\n    const matcher =\n      typeof match === \"object\"\n        ? createObjectMatcher(match)\n        : createBasicMatcher(match);\n\n    this.store.insert({\n      key: match,\n      value,\n      matcher,\n    });\n  }\n\n  /** Fetch the best match in the registry */\n  get(query: any): V | undefined {\n    for (const entry of this.store.array) {\n      if (entry.matcher(query)) {\n        return entry.value;\n      }\n    }\n  }\n\n  /** Loop over all entries and run callback */\n  forEach(callbackfn: (value: RegistryIndex<V>) => void): void {\n    for (const entry of this.store.array) {\n      callbackfn(entry);\n    }\n  }\n\n  /** Reset the items in the registry */\n  clear() {\n    this.store = createSortedArray<V>();\n  }\n\n  /** Check if the registry is empty*/\n  isRegistryEmpty() {\n    return this.store.array.length === 0;\n  }\n}\n","import dlv from \"dlv\";\n\n/** A function that checks overlapping properties against a reference value */\nexport type Matcher = ((searchObj: object) => boolean) & {\n  /** The count represents the specificity of this matcher */\n  count: number;\n};\n\n/** Traverse an object and collect any key/value pairs including nested keys */\nfunction traverseObj(\n  object: Record<any, any>,\n  path: string[] = [],\n  pairs: Map<string[], any> = new Map(),\n): Map<string[], any> {\n  for (const key of Object.keys(object)) {\n    const val: any = object[key];\n    const nestedPath = [...path, key];\n    (\"\");\n\n    if (typeof val === \"object\") {\n      traverseObj(val, nestedPath, pairs);\n    } else {\n      pairs.set(nestedPath, val);\n    }\n  }\n\n  return pairs;\n}\n\n/** Given an object, create a function that compares any set key/value pairs in the given object against a new value */\nexport default function createMatcher(partialObj: object): Matcher {\n  // Convert the partial object into a list of [key, value] pairs;\n  const pairs = traverseObj(partialObj);\n\n  /** Generate a function to match against all of the properties we care about */\n  const matchFunction = (searchObj: object) => {\n    for (const entry of Array.from(pairs)) {\n      const [path, value] = entry;\n\n      if (dlv(searchObj, path) !== value) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  // Keep track of the specificity of the comparator\n  matchFunction.count = pairs.size;\n\n  return matchFunction;\n}\n","export interface Node<T extends string> {\n  /** The basic node type */\n  name: T;\n}\n\n/**\n * An AST node that represents a nested path in the model\n * foo.{{bar}}.baz (this is {{bar}})\n */\nexport interface PathNode extends Node<\"PathNode\"> {\n  /** The path in the model that this node represents */\n  path: Array<AnyNode>;\n}\n\n/**\n * A segment representing a query\n * [foo=bar]\n */\nexport interface QueryNode extends Node<\"Query\"> {\n  /** The key to query */\n  key: AnyNode;\n\n  /** The target value */\n  value?: AnyNode;\n}\n\n/** A simple segment */\nexport interface ValueNode extends Node<\"Value\"> {\n  /** The segment value */\n  value: string | number;\n}\n\n/** A nested expression */\nexport interface ExpressionNode extends Node<\"Expression\"> {\n  /** The expression */\n  value: string;\n}\n\n/** Helper to create a value node */\nexport const toValue = (value: string | number): ValueNode => ({\n  name: \"Value\",\n  value,\n});\n\n/** Helper to create an expression node */\nexport const toExpression = (value: string): ExpressionNode => ({\n  name: \"Expression\",\n  value,\n});\n\n/** Helper to create a nested path node */\nexport const toPath = (path: Array<AnyNode>): PathNode => ({\n  name: \"PathNode\",\n  path,\n});\n\n/** Helper to create a query node */\nexport const toQuery = (key: AnyNode, value?: AnyNode): QueryNode => ({\n  name: \"Query\",\n  key,\n  value,\n});\n\n/** Create a concat node */\nexport const toConcatenatedNode = (\n  values: Array<PathNode | ValueNode | ExpressionNode>,\n): PathNode | ValueNode | ConcatenatedNode | ExpressionNode => {\n  if (values.length === 1) {\n    return values[0];\n  }\n\n  return {\n    name: \"Concatenated\",\n    value: values,\n  };\n};\n\n/**\n * A binding segment that's multiple smaller ones\n * {{foo}}_bar_{{baz}}\n */\nexport interface ConcatenatedNode extends Node<\"Concatenated\"> {\n  /** A list of nested paths, or value nodes to concat together to form a segment */\n  value: Array<PathNode | ValueNode | ExpressionNode>;\n}\n\nexport type AnyNode =\n  | PathNode\n  | QueryNode\n  | ValueNode\n  | ConcatenatedNode\n  | ExpressionNode;\nexport type Path = Array<AnyNode>;\n\nexport interface ParserSuccessResult {\n  /** A successful parse result */\n  status: true;\n\n  /** The path the binding represents */\n  path: PathNode;\n}\n\nexport interface ParserFailureResult {\n  /** A failed parse result */\n  status: false;\n\n  /** The message representing the reason the parse result failed */\n  error: string;\n}\n\nexport type ParserResult = ParserSuccessResult | ParserFailureResult;\n\nexport type Parser = (raw: string) => ParserResult;\n","import type {\n  Parser,\n  AnyNode,\n  PathNode,\n  ConcatenatedNode,\n  ValueNode,\n  QueryNode,\n  ExpressionNode,\n} from \"../ast\";\nimport {\n  toValue,\n  toPath,\n  toConcatenatedNode,\n  toQuery,\n  toExpression,\n} from \"../ast\";\n\nconst SEGMENT_SEPARATOR = \".\";\nconst OPEN_CURL = \"{\";\nconst CLOSE_CURL = \"}\";\nconst OPEN_BRACKET = \"[\";\nconst CLOSE_BRACKET = \"]\";\nconst EQUALS = \"=\";\nconst SINGLE_QUOTE = \"'\";\nconst DOUBLE_QUOTE = '\"';\nconst BACK_TICK = \"`\";\n// const IDENTIFIER_REGEX = /[\\w\\-@]+/;\n\n/** A _faster_ way to match chars instead of a regex. */\nconst isIdentifierChar = (char?: string): boolean => {\n  if (!char) {\n    return false;\n  }\n\n  const charCode = char.charCodeAt(0);\n\n  const matches =\n    charCode === 32 || // ' '\n    charCode === 34 || // \"\n    charCode === 39 || // '\n    charCode === 40 || // (\n    charCode === 41 || // )\n    charCode === 42 || // *\n    charCode === 46 || // .\n    charCode === 61 || // =\n    charCode === 91 || // [\n    charCode === 93 || // ]\n    charCode === 96 || // `\n    charCode === 123 || // {\n    charCode === 125; // }\n\n  return !matches;\n};\n\n/** Parse out a binding AST from a path */\nexport const parse: Parser = (path) => {\n  let index = 1;\n  let ch = path.charAt(0);\n\n  /** get the next char in the string */\n  const next = (expected?: string) => {\n    if (expected && ch !== expected) {\n      throw new Error(`Expected char: ${expected} but got: ${ch}`);\n    }\n\n    ch = path.charAt(index);\n    index += 1;\n    return ch;\n  };\n\n  /** gobble all whitespace */\n  const whitespace = () => {\n    /* eslint-disable no-unmodified-loop-condition */\n    while (ch === \" \") {\n      next();\n    }\n  };\n\n  /** get an identifier if you can */\n  const identifier = (): ValueNode | undefined => {\n    if (!isIdentifierChar(ch)) {\n      return;\n    }\n\n    let value = ch;\n\n    while (next()) {\n      if (!isIdentifierChar(ch)) {\n        break;\n      }\n\n      value += ch;\n    }\n\n    if (value) {\n      return toValue(value);\n    }\n  };\n\n  /** get an expression node if you can */\n  const expression = (): ExpressionNode | undefined => {\n    if (ch === BACK_TICK) {\n      next(BACK_TICK);\n\n      let exp = ch;\n\n      while (next()) {\n        if (ch === BACK_TICK) {\n          break;\n        }\n\n        exp += ch;\n      }\n\n      next(BACK_TICK);\n\n      if (exp) {\n        return toExpression(exp);\n      }\n    }\n  };\n\n  /** Grab a value using a regex */\n  const regex = (match: RegExp): ValueNode | undefined => {\n    if (!ch?.match(match)) {\n      return;\n    }\n\n    let value = ch;\n\n    while (next()) {\n      if (!ch?.match(match)) {\n        break;\n      }\n\n      value += ch;\n    }\n\n    if (value) {\n      return toValue(value);\n    }\n  };\n\n  /** parse out a nestedPath if you can */\n  const nestedPath = (): PathNode | undefined => {\n    if (ch === OPEN_CURL) {\n      next(OPEN_CURL);\n      next(OPEN_CURL);\n\n      /* eslint-disable-next-line @typescript-eslint/no-use-before-define */\n      const modelRef = parsePath();\n      next(CLOSE_CURL);\n      next(CLOSE_CURL);\n      return modelRef;\n    }\n  };\n\n  /** get a simple segment node */\n  const simpleSegment = () => nestedPath() ?? expression() ?? identifier();\n\n  /** Parse a segment */\n  const segment = ():\n    | ConcatenatedNode\n    | PathNode\n    | ValueNode\n    | ExpressionNode\n    | undefined => {\n    // Either a string, modelRef, or concatenated version (both)\n    const segments: Array<ValueNode | PathNode | ExpressionNode> = [];\n    let nextSegment = simpleSegment();\n\n    while (nextSegment !== undefined) {\n      segments.push(nextSegment);\n      nextSegment = simpleSegment();\n    }\n\n    if (segments.length === 0) {\n      return undefined;\n    }\n\n    return toConcatenatedNode(segments);\n  };\n\n  /** get an optionally quoted block */\n  const optionallyQuotedSegment = ():\n    | ValueNode\n    | PathNode\n    | ExpressionNode\n    | undefined => {\n    whitespace();\n\n    // see if we have a quote\n\n    if (ch === SINGLE_QUOTE || ch === DOUBLE_QUOTE) {\n      const singleQuote = ch === SINGLE_QUOTE;\n      next(singleQuote ? SINGLE_QUOTE : DOUBLE_QUOTE);\n      const id = regex(/[^'\"]+/);\n      next(singleQuote ? SINGLE_QUOTE : DOUBLE_QUOTE);\n      return id;\n    }\n\n    return simpleSegment();\n  };\n\n  /** eat equals signs */\n  const equals = (): boolean => {\n    if (ch !== EQUALS) {\n      return false;\n    }\n\n    while (ch === EQUALS) {\n      next();\n    }\n\n    return true;\n  };\n\n  /** Parse out a bracket */\n  const parseBracket = ():\n    | ValueNode\n    | QueryNode\n    | PathNode\n    | ExpressionNode\n    | undefined => {\n    if (ch === OPEN_BRACKET) {\n      next(OPEN_BRACKET);\n      whitespace();\n      let value: ValueNode | QueryNode | PathNode | ExpressionNode | undefined =\n        optionallyQuotedSegment();\n      if (value) {\n        whitespace();\n        if (equals()) {\n          whitespace();\n          const second = optionallyQuotedSegment();\n          value = toQuery(value, second);\n          whitespace();\n        }\n      } else {\n        throw new Error(`Expected identifier`);\n      }\n\n      if (value) {\n        next(CLOSE_BRACKET);\n      }\n\n      return value;\n    }\n  };\n\n  /** Parse a segment and any number of brackets following it */\n  const parseSegmentAndBrackets = (): Array<AnyNode> => {\n    // try to parse a segment first\n\n    const parsed: Array<AnyNode> = [];\n\n    const firstSegment = segment();\n\n    if (firstSegment) {\n      parsed.push(firstSegment);\n\n      let bracketSegment = parseBracket();\n\n      while (bracketSegment !== undefined) {\n        parsed.push(bracketSegment);\n        bracketSegment = parseBracket();\n      }\n    }\n\n    return parsed;\n  };\n\n  /** Parse out a path segment */\n  const parsePath = (): PathNode => {\n    const parts: AnyNode[] = [];\n\n    let nextSegment = parseSegmentAndBrackets();\n\n    while (nextSegment !== undefined) {\n      parts.push(...nextSegment);\n\n      if (!ch || ch === CLOSE_CURL) {\n        break;\n      }\n\n      if (nextSegment.length === 0 && ch) {\n        throw new Error(`Unexpected character: ${ch}`);\n      }\n\n      next(SEGMENT_SEPARATOR);\n      nextSegment = parseSegmentAndBrackets();\n    }\n\n    return toPath(parts);\n  };\n\n  try {\n    const result = parsePath();\n\n    return {\n      status: true,\n      path: result,\n    };\n  } catch (e: any) {\n    return {\n      status: false,\n      error: e.message,\n    };\n  }\n};\n","import type { BindingLike, BindingInstance } from \"./binding\";\n\n/** Check if the parameter representing a binding is already of the Binding class */\nexport function isBinding(binding: BindingLike): binding is BindingInstance {\n  return !(typeof binding === \"string\" || Array.isArray(binding));\n}\n\n/** Convert the string to an int if you can, otherwise just return the original string */\nexport function maybeConvertToNum(i: string): string | number {\n  const asInt = parseInt(i, 10);\n\n  if (isNaN(asInt)) {\n    return i;\n  }\n\n  return asInt;\n}\n\n/**\n * utility to convert binding into binding segments.\n */\nexport function getBindingSegments(\n  binding: BindingLike,\n): Array<string | number> {\n  if (Array.isArray(binding)) {\n    return binding;\n  }\n\n  if (typeof binding === \"string\") {\n    return binding.split(\".\");\n  }\n\n  return binding.asArray();\n}\n\n/** Like _.findIndex, but ignores types */\nexport function findInArray<T extends Record<string | number, object>>(\n  array: Array<T>,\n  key: string | number,\n  value: T,\n): number | undefined {\n  return array.findIndex((obj) => {\n    if (obj && typeof obj === \"object\") {\n      // Intentional double-equals because we want '4' to be coerced to 4\n      // eslint-disable-next-line eqeqeq\n      return obj[key] == value;\n    }\n\n    return false;\n  });\n}\n","import { getBindingSegments } from \"./utils\";\n\nexport interface BindingParserOptions {\n  /** Get the value for a specific binding */\n  get: (binding: BindingInstance) => any;\n\n  /**\n   * Set the values for bindings.\n   * This is used when the query syntax needs to modify an object\n   */\n  set: (transaction: Array<[BindingInstance, any]>) => void;\n\n  /**\n   * Get the result of evaluating an expression\n   */\n  evaluate: (exp: string) => any;\n\n  /**\n   * Without readOnly, if a binding such as this is used: arr[key='does not exist'],\n   * then an object with that key will be created.\n   * This is done to make assignment such as arr[key='abc'].val = 'foo' work smoothly.\n   * Setting readOnly to true will prevent this behavior, avoiding unintended data changes.\n   */\n  readOnly?: boolean;\n}\n\nexport type Getter = (path: BindingInstance) => any;\n\nexport type RawBindingSegment = number | string;\nexport type RawBinding = string | RawBindingSegment[];\nexport type BindingLike = RawBinding | BindingInstance;\nexport type BindingFactory = (\n  raw: RawBinding,\n  options?: Partial<BindingParserOptions>,\n) => BindingInstance;\n\n/**\n * A path in the data model\n */\nexport class BindingInstance {\n  private split: RawBindingSegment[];\n  private joined: string;\n  private factory: BindingFactory;\n\n  constructor(\n    raw: RawBinding,\n    factory = (rawBinding: RawBinding) => new BindingInstance(rawBinding),\n  ) {\n    const split = Array.isArray(raw) ? raw : raw.split(\".\");\n    this.split = split.map((segment) => {\n      if (typeof segment === \"number\") {\n        return segment;\n      }\n\n      const tryNum = Number(segment);\n      return isNaN(tryNum) ? segment : tryNum;\n    });\n    Object.freeze(this.split);\n    this.joined = this.split.join(\".\");\n    this.factory = factory;\n  }\n\n  asArray(): RawBindingSegment[] {\n    return this.split;\n  }\n\n  asString(): string {\n    return this.joined;\n  }\n\n  /**\n   * Check to see if the given binding is a sub-path of the current one\n   */\n  contains(binding: BindingInstance): boolean {\n    // need to account for partial key matches\n    // [foo, bar] !== [foo, ba]\n    const bindingAsArray = binding.asArray();\n\n    if (bindingAsArray.length < this.split.length) {\n      return false;\n    }\n\n    // Check every overlapping index to make sure they're the same\n    // Intentionally use a for loop for speeeed\n    for (let i = 0; i < this.split.length; i++) {\n      if (this.split[i] !== bindingAsArray[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  relative(binding: BindingInstance): RawBindingSegment[] {\n    return this.asArray().slice(binding.asArray().length);\n  }\n\n  parent(): BindingInstance {\n    return this.factory(this.split.slice(0, -1));\n  }\n\n  key(): RawBindingSegment {\n    return this.split[this.split.length - 1];\n  }\n\n  /**\n   * This is a utility method to get a binding that is a descendent of this binding\n   *\n   * @param relative - The relative path to descend to\n   */\n  descendent(relative: BindingLike): BindingInstance {\n    const descendentSegments = getBindingSegments(relative);\n\n    return this.factory(this.split.concat(descendentSegments));\n  }\n}\n","import type { BindingInstance } from \"../binding\";\nimport type {\n  BatchSetTransaction,\n  DataModelImpl,\n  DataModelMiddleware,\n  DataModelOptions,\n  Updates,\n} from \"./model\";\n\nexport type DependencySets = \"core\" | \"children\";\n\n/** A class to track usage of read/writes to/from a data model */\nexport class DependencyTracker {\n  protected readDeps: Set<BindingInstance>;\n  protected writeDeps: Set<BindingInstance>;\n  protected namedSet: DependencySets;\n\n  private namedDependencySets: Partial<\n    Record<\n      DependencySets,\n      {\n        /** readDeps */\n        readDeps: Set<BindingInstance>;\n        /** writeDeps */\n        writeDeps: Set<BindingInstance>;\n      }\n    >\n  >;\n\n  constructor() {\n    this.readDeps = new Set();\n    this.writeDeps = new Set();\n    this.namedDependencySets = {};\n    this.namedSet = \"core\";\n\n    this.createSubset(\"core\");\n    this.createSubset(\"children\");\n  }\n\n  protected createSubset(name: DependencySets, force = false): void {\n    if (force || !this.namedDependencySets[name]) {\n      this.namedDependencySets[name] = {\n        readDeps: new Set(),\n        writeDeps: new Set(),\n      };\n    }\n  }\n\n  /** Grab all of the bindings that this depended on */\n  public getDependencies(name?: DependencySets): Set<BindingInstance> {\n    if (name !== undefined) {\n      return this.namedDependencySets?.[name]?.readDeps ?? new Set();\n    }\n\n    return this.readDeps;\n  }\n\n  public trackSubset(name: DependencySets) {\n    this.createSubset(name);\n    this.namedSet = name;\n  }\n\n  public trackDefault() {\n    this.namedSet = \"core\";\n  }\n\n  /** Grab all of the bindings this wrote to */\n  public getModified(name?: DependencySets): Set<BindingInstance> {\n    if (name !== undefined) {\n      return this.namedDependencySets?.[name]?.writeDeps ?? new Set();\n    }\n\n    return this.writeDeps;\n  }\n\n  /**\n   * Check to see if the dataModel has read the value at the given binding\n   *\n   * @param binding - The binding you want to check for\n   */\n  public readsBinding(binding: BindingInstance): boolean {\n    return this.readDeps.has(binding);\n  }\n\n  /**\n   * Check to see if the dataModel has written to the binding\n   */\n  public writesBinding(binding: BindingInstance): boolean {\n    return this.writeDeps.has(binding);\n  }\n\n  /** Reset all tracking of dependencies */\n  public reset() {\n    this.readDeps = new Set();\n    this.writeDeps = new Set();\n    this.namedDependencySets = {};\n    this.namedSet = \"core\";\n\n    this.createSubset(\"core\", true);\n    this.createSubset(\"children\", true);\n  }\n\n  protected addReadDep(\n    binding: BindingInstance,\n    namedSet = this.namedSet,\n  ): void {\n    if (namedSet) {\n      this.namedDependencySets?.[namedSet]?.readDeps.add(binding);\n    }\n\n    this.readDeps.add(binding);\n  }\n\n  protected addWriteDep(\n    binding: BindingInstance,\n    namedSet = this.namedSet,\n  ): void {\n    if (namedSet) {\n      this.namedDependencySets?.[namedSet]?.writeDeps.add(binding);\n    }\n\n    this.writeDeps.add(binding);\n  }\n\n  public addChildReadDep(binding: BindingInstance): void {\n    this.addReadDep(binding, \"children\");\n  }\n}\n\n/** Middleware that tracks dependencies of read/written data */\nexport class DependencyMiddleware\n  extends DependencyTracker\n  implements DataModelMiddleware\n{\n  constructor() {\n    super();\n    this.get = this.get.bind(this);\n    this.set = this.set.bind(this);\n  }\n\n  public set(\n    transaction: BatchSetTransaction,\n    options?: DataModelOptions,\n    next?: DataModelImpl | undefined,\n  ): Updates {\n    transaction.forEach(([binding]) => this.addWriteDep(binding));\n\n    return next?.set(transaction, options) ?? [];\n  }\n\n  public get(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl | undefined,\n  ) {\n    this.addReadDep(binding);\n\n    return next?.get(binding, options);\n  }\n\n  public delete(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl | undefined,\n  ) {\n    this.addWriteDep(binding);\n    return next?.delete(binding, options);\n  }\n}\n\n/** A data-model that tracks dependencies of read/written data */\nexport class DependencyModel<Options = DataModelOptions>\n  extends DependencyTracker\n  implements DataModelImpl<Options>\n{\n  private readonly rootModel: DataModelImpl<Options>;\n\n  constructor(rootModel: DataModelImpl<Options>) {\n    super();\n    this.rootModel = rootModel;\n    this.set = this.set.bind(this);\n    this.get = this.get.bind(this);\n  }\n\n  public set(transaction: BatchSetTransaction, options?: Options): Updates {\n    transaction.forEach(([binding]) => this.addWriteDep(binding));\n\n    return this.rootModel.set(transaction, options);\n  }\n\n  public get(binding: BindingInstance, options?: Options) {\n    this.addReadDep(binding);\n\n    return this.rootModel.get(binding, options);\n  }\n\n  public delete(binding: BindingInstance, options?: Options) {\n    this.addWriteDep(binding);\n    return this.rootModel.delete(binding, options);\n  }\n}\n","import type { DataModelImpl } from \"./model\";\n\n/**\n * A model that does nothing\n * Helpful for testing and other default DataModel applications\n */\nexport class NOOPDataModel implements DataModelImpl {\n  get() {\n    return undefined;\n  }\n\n  set() {\n    return [];\n  }\n\n  delete() {}\n}\n\n/** You only really need 1 instance of the NOOP model */\nexport const NOOP_MODEL = new NOOPDataModel();\n","import { SyncHook } from \"tapable-ts\";\nimport type { BindingLike, BindingFactory } from \"../binding\";\nimport { BindingInstance, isBinding } from \"../binding\";\nimport { NOOP_MODEL } from \"./noop-model\";\n\nexport const ROOT_BINDING = new BindingInstance([]);\nexport type BatchSetTransaction = [BindingInstance, any][];\n\nexport type Updates = Array<{\n  /** The updated binding */\n  binding: BindingInstance;\n\n  /** The old value */\n  oldValue: any;\n\n  /** The new value */\n  newValue: any;\n\n  /** Force the Update to be included even if no data changed */\n  force?: boolean;\n}>;\n\n/** Options to use when getting or setting data */\nexport interface DataModelOptions {\n  /**\n   * The data (either to set or get) should represent a formatted value\n   * For setting data, the data will be de-formatted before continuing in the pipeline\n   * For getting data, the data will be formatted before returning\n   */\n  formatted?: boolean;\n\n  /**\n   * By default, fetching data will ignore any invalid data.\n   * You can choose to grab the queued invalid data if you'd like\n   * This is usually the case for user-inputs\n   */\n  includeInvalid?: boolean;\n\n  /**\n   * A flag to set to ignore any default value in the schema, and just use the raw value\n   */\n  ignoreDefaultValue?: boolean;\n\n  /**\n   * A flag to indicate that this update should happen silently\n   */\n  silent?: boolean;\n\n  /** Other context associated with this request */\n  context?: {\n    /** The data model to use when getting other data from the context of this request */\n    model: DataModelWithParser;\n  };\n}\n\nexport interface DataModelWithParser<Options = DataModelOptions> {\n  get(binding: BindingLike, options?: Options): any;\n  set(transaction: [BindingLike, any][], options?: Options): Updates;\n  delete(binding: BindingLike, options?: Options): void;\n}\n\nexport interface DataModelImpl<Options = DataModelOptions> {\n  get(binding: BindingInstance, options?: Options): any;\n  set(transaction: BatchSetTransaction, options?: Options): Updates;\n  delete(binding: BindingInstance, options?: Options): void;\n}\n\nexport interface DataModelMiddleware {\n  /** The name of the middleware */\n  name?: string;\n\n  set(\n    transaction: BatchSetTransaction,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ): Updates;\n\n  get(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ): any;\n\n  delete?(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ): void;\n\n  reset?(): void;\n}\n\n/** Wrap the inputs of the DataModel with calls to parse raw binding inputs */\nexport function withParser<Options = unknown>(\n  model: DataModelImpl<Options>,\n  parseBinding: BindingFactory,\n): DataModelWithParser<Options> {\n  /** Parse something into a binding if it requires it */\n  function maybeParse(\n    binding: BindingLike,\n    readOnly: boolean,\n  ): BindingInstance {\n    const parsed = isBinding(binding)\n      ? binding\n      : parseBinding(binding, {\n          get: model.get,\n          set: model.set,\n          readOnly,\n        });\n\n    if (!parsed) {\n      throw new Error(\"Unable to parse binding\");\n    }\n\n    return parsed;\n  }\n\n  return {\n    get(binding, options?: Options) {\n      return model.get(maybeParse(binding, true), options);\n    },\n    set(transaction, options?: Options) {\n      return model.set(\n        transaction.map(([key, val]) => [maybeParse(key, false), val]),\n        options,\n      );\n    },\n    delete(binding, options?: Options) {\n      return model.delete(maybeParse(binding, false), options);\n    },\n  };\n}\n\n/** Wrap a middleware instance in a DataModel compliant API */\nexport function toModel(\n  middleware: DataModelMiddleware,\n  defaultOptions?: DataModelOptions,\n  next?: DataModelImpl,\n): DataModelImpl {\n  if (!next) {\n    return middleware as DataModelImpl;\n  }\n\n  return {\n    get: (binding: BindingInstance, options?: DataModelOptions) => {\n      const resolvedOptions = options ?? defaultOptions;\n\n      if (middleware.get) {\n        return middleware.get(binding, resolvedOptions, next);\n      }\n\n      return next?.get(binding, resolvedOptions);\n    },\n    set: (transaction: BatchSetTransaction, options?: DataModelOptions) => {\n      const resolvedOptions = options ?? defaultOptions;\n\n      if (middleware.set) {\n        return middleware.set(transaction, resolvedOptions, next);\n      }\n\n      return next?.set(transaction, resolvedOptions);\n    },\n    delete: (binding: BindingInstance, options?: DataModelOptions) => {\n      const resolvedOptions = options ?? defaultOptions;\n\n      if (middleware.delete) {\n        return middleware.delete(binding, resolvedOptions, next);\n      }\n\n      return next?.delete(binding, resolvedOptions);\n    },\n  };\n}\n\nexport type DataPipeline = Array<DataModelMiddleware | DataModelImpl>;\n\n/**\n * Given a set of steps in a pipeline, create the effective data-model\n */\nexport function constructModelForPipeline(\n  pipeline: DataPipeline,\n): DataModelImpl {\n  if (pipeline.length === 0) {\n    return NOOP_MODEL;\n  }\n\n  if (pipeline.length === 1) {\n    return toModel(pipeline[0]);\n  }\n\n  /** Default and propagate the options into the nested calls */\n  function createModelWithOptions(options?: DataModelOptions) {\n    const model: DataModelImpl =\n      pipeline.reduce<DataModelImpl | undefined>(\n        (nextModel, middleware) => toModel(middleware, options, nextModel),\n        undefined,\n      ) ?? NOOP_MODEL;\n\n    return model;\n  }\n\n  return {\n    get: (binding: BindingInstance, options?: DataModelOptions) => {\n      return createModelWithOptions(options)?.get(binding, options);\n    },\n    set: (transaction, options) => {\n      return createModelWithOptions(options)?.set(transaction, options);\n    },\n    delete: (binding, options) => {\n      return createModelWithOptions(options)?.delete(binding, options);\n    },\n  };\n}\n\n/** A DataModel that manages middleware data handlers  */\nexport class PipelinedDataModel implements DataModelImpl {\n  private pipeline: DataPipeline;\n  private effectiveDataModel: DataModelImpl;\n\n  public readonly hooks = {\n    onSet: new SyncHook<[BatchSetTransaction]>(),\n  };\n\n  constructor(pipeline: DataPipeline = []) {\n    this.pipeline = pipeline;\n    this.effectiveDataModel = constructModelForPipeline(this.pipeline);\n  }\n\n  public setMiddleware(handlers: DataPipeline) {\n    this.pipeline = handlers;\n    this.effectiveDataModel = constructModelForPipeline(handlers);\n  }\n\n  public addMiddleware(handler: DataModelMiddleware) {\n    this.pipeline = [...this.pipeline, handler];\n    this.effectiveDataModel = constructModelForPipeline(this.pipeline);\n  }\n\n  public reset(model = {}) {\n    this.pipeline.forEach((middleware) => {\n      if (\"reset\" in middleware) {\n        middleware.reset?.();\n      }\n    });\n\n    this.set([[ROOT_BINDING, model]]);\n  }\n\n  public set(\n    transaction: BatchSetTransaction,\n    options?: DataModelOptions,\n  ): Updates {\n    const appliedTransaction = this.effectiveDataModel.set(\n      transaction,\n      options,\n    );\n    this.hooks.onSet.call(transaction);\n    return appliedTransaction;\n  }\n\n  public get(binding: BindingInstance, options?: DataModelOptions): any {\n    return this.effectiveDataModel.get(binding, options);\n  }\n\n  public delete(binding: BindingInstance, options?: DataModelOptions): void {\n    return this.effectiveDataModel.delete(binding, options);\n  }\n}\n","import type { DataModelWithParser } from \"../data\";\nimport type { Logger } from \"../logger\";\n\nexport type ExpressionObjectType = {\n  /** The expression to eval */\n  value: BasicExpressionTypes;\n};\n\nexport type ExpressionLiteralType =\n  | string\n  | number\n  | boolean\n  | undefined\n  | null;\n\nexport type BasicExpressionTypes =\n  | ExpressionLiteralType\n  | ExpressionObjectType\n  | Array<ExpressionLiteralType | ExpressionObjectType>;\n\nexport type ExpressionType = BasicExpressionTypes | ExpressionNode;\n\nexport interface OperatorProcessingOptions {\n  /**\n   * When set to a falsy value, the arguments passed to the handler will be raw AST Nodes\n   * This enables lazy evaluation of arguments\n   */\n  resolveParams: boolean;\n}\n\nexport type BinaryOperatorBasic = (left: any, right: any) => unknown;\nexport type BinaryOperatorAdvanced = OperatorProcessingOptions &\n  ((ctx: ExpressionContext, left: any, right: any) => unknown);\n\nexport type BinaryOperator = BinaryOperatorAdvanced | BinaryOperatorBasic;\n\nexport type UnaryOperator =\n  | ((arg: any) => unknown)\n  | (((ctx: ExpressionContext, arg: any) => unknown) &\n      OperatorProcessingOptions);\n\nexport interface ExpressionContext {\n  /** A means of executing an expression */\n  evaluate: (expr: ExpressionType) => unknown;\n\n  /** The data model that expression handlers can use when fetching data */\n  model: DataModelWithParser;\n\n  /** A logger to use */\n  logger?: Logger;\n}\n\nexport type ExpressionHandler<\n  T extends readonly unknown[] = unknown[],\n  R = void,\n> = ((context: ExpressionContext, ...args: T) => R) &\n  Partial<OperatorProcessingOptions>;\n\nexport const ExpNodeOpaqueIdentifier = Symbol(\"Expression Node ID\");\n\n/** Checks if the input is an already processed Expression node */\nexport function isExpressionNode(x: any): x is ExpressionNode {\n  return (\n    typeof x === \"object\" &&\n    x !== null &&\n    !Array.isArray(x) &&\n    x.__id === ExpNodeOpaqueIdentifier\n  );\n}\n\nexport interface NodePosition {\n  /** The character location */\n  character: number;\n}\n\nexport interface NodeLocation {\n  // We only care about the character offset, not the line/column for now\n  // But making these objects allows us to add more (like line number) later\n\n  /** The start of the node */\n  start: NodePosition;\n\n  /** The end of the node */\n  end: NodePosition;\n}\n\nexport interface BaseNode<T> {\n  /** The thing to discriminate the AST type on */\n  type: T;\n\n  /** How to tell this apart from other objects */\n  __id: typeof ExpNodeOpaqueIdentifier;\n\n  /** The location of the node in the source expression string */\n  location?: NodeLocation;\n\n  /**\n   * The error that occurred while parsing this node\n   * This is only set if the parsing mode is set to non-strict\n   */\n  error?: Error;\n}\n\n/** A helper interface for nodes that container left and right children */\nexport interface DirectionalNode {\n  /** The left node. Often for the left hand side of an expression */\n  left: ExpressionNode;\n\n  /** The right child. Often for the right hand side of an expression */\n  right: ExpressionNode;\n}\n\nexport interface LiteralNode extends BaseNode<\"Literal\"> {\n  /** A node that holds a literal value */\n  value: string | number;\n\n  /** The unprocessed value */\n  raw?: any;\n}\n\nexport interface BinaryNode\n  extends BaseNode<\"BinaryExpression\">,\n    DirectionalNode {\n  /** The operation to perform on the nodes */\n  operator: string;\n}\n\nexport interface LogicalNode\n  extends BaseNode<\"LogicalExpression\">,\n    DirectionalNode {\n  /** The logical operation to perform on the nodes */\n  operator: string;\n}\n\nexport interface UnaryNode extends BaseNode<\"UnaryExpression\"> {\n  /** The operation to perform on the node */\n  operator: string;\n\n  /** The single argument that the operation should be performed on */\n  argument: ExpressionNode;\n}\n\nexport type ThisNode = BaseNode<\"ThisExpression\">;\n\nexport interface ModelRefNode extends BaseNode<\"ModelRef\"> {\n  /** The binding that the model reference points to */\n  ref: string;\n}\n\nexport interface ObjectNode extends BaseNode<\"Object\"> {\n  /**  */\n  attributes: Array<{\n    /** The property name of the object */\n    key: ExpressionNode;\n\n    /** the associated value */\n    value: ExpressionNode;\n  }>;\n}\n\nexport interface MemberExpressionNode extends BaseNode<\"MemberExpression\"> {\n  /** The object to be introspected */\n  object: ExpressionNode;\n\n  /** If the property uses . or open-bracket */\n  computed: boolean;\n\n  /** The property to access on the object */\n  property: ExpressionNode;\n}\n\nexport interface ConditionalExpressionNode\n  extends BaseNode<\"ConditionalExpression\"> {\n  /** The test for the ternary */\n  test: ExpressionNode;\n\n  /** The truthy case for the ternary */\n  consequent: ExpressionNode;\n\n  /** The falsy case for the ternary */\n  alternate: ExpressionNode;\n}\n\nexport interface CompoundNode extends BaseNode<\"Compound\"> {\n  /** The contents of the compound expression */\n  body: ExpressionNode[];\n}\n\nexport interface CallExpressionNode extends BaseNode<\"CallExpression\"> {\n  /** The arguments to the function */\n  args: ExpressionNode[];\n\n  /** The function name */\n  callTarget: IdentifierNode;\n}\n\nexport interface ArrayExpressionNode extends BaseNode<\"ArrayExpression\"> {\n  /** The items in an array */\n  elements: ExpressionNode[];\n}\n\nexport interface IdentifierNode extends BaseNode<\"Identifier\"> {\n  /** The variable name */\n  name: string;\n}\n\nexport type AssignmentNode = BaseNode<\"Assignment\"> & DirectionalNode;\n\nexport interface ModificationNode\n  extends BaseNode<\"Modification\">,\n    DirectionalNode {\n  /** The operator for the modification */\n  operator: string;\n}\n\nexport type ExpressionNode =\n  | LiteralNode\n  | BinaryNode\n  | LogicalNode\n  | UnaryNode\n  | ThisNode\n  | ModelRefNode\n  | MemberExpressionNode\n  | ConditionalExpressionNode\n  | CompoundNode\n  | CallExpressionNode\n  | ArrayExpressionNode\n  | IdentifierNode\n  | AssignmentNode\n  | ModificationNode\n  | ObjectNode;\n\nexport type ExpressionNodeType = ExpressionNode[\"type\"];\n\nexport interface ErrorWithLocation extends Error {\n  /** The place in the string where the error occurs */\n  index: number;\n\n  /** a helpful description */\n  description: string;\n}\n","/* eslint @typescript-eslint/no-use-before-define: 0 */\n/**\n * An expression to AST parser based on JSEP: http://jsep.from.so/\n */\nimport type {\n  ErrorWithLocation,\n  ExpressionNode,\n  ExpressionNodeType,\n  NodeLocation,\n} from \"./types\";\nimport { ExpNodeOpaqueIdentifier } from \"./types\";\n\nconst PERIOD_CODE = 46; // '.'\nconst COMMA_CODE = 44; // ','\nconst SQUOTE_CODE = 39; // Single quote\nconst DQUOTE_CODE = 34; // Double quotes\nconst OPAREN_CODE = 40; // (\nconst CPAREN_CODE = 41; // )\nconst OBRACK_CODE = 91; // [\nconst CBRACK_CODE = 93; // ]\nconst QUMARK_CODE = 63; // ?\nconst SEMCOL_CODE = 59; // ;\nconst COLON_CODE = 58; // :\nconst OCURL_CODE = 123; // {\nconst CCURL_CODE = 125; // }\n\n// Operations\n// ----------\n\n// Set `t` to `true` to save space (when minified, not gzipped)\nconst t = true;\n\n// Use a quickly-accessible map to store all of the unary operators\n// Values are set to `true` (it really doesn't matter)\nconst unaryOps = { \"-\": t, \"!\": t, \"~\": t, \"+\": t };\n\n// Also use a map for the binary operations but set their values to their\n// binary precedence for quick reference:\n// see [Operator precedence](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\nconst binaryOps: Record<string, number> = {\n  \"=\": 3,\n  \"+=\": 3,\n  \"-=\": 3,\n  \"&=\": 3,\n  \"|=\": 3,\n  // Conditional: 4,\n  \"||\": 5,\n  \"&&\": 6,\n  \"|\": 7,\n  \"^\": 8,\n  \"&\": 9,\n  \"==\": 10,\n  \"!=\": 10,\n  \"===\": 10,\n  \"!==\": 10,\n  \"<\": 11,\n  \">\": 11,\n  \"<=\": 11,\n  \">=\": 11,\n  \"<<\": 12,\n  \">>\": 12,\n  \">>>\": 12,\n  \"+\": 13,\n  \"-\": 13,\n  \"*\": 14,\n  \"/\": 14,\n  \"%\": 14,\n};\n\n/** Wrap the message and index in an error and throw it */\nfunction throwError(message: string, index: number): ErrorWithLocation {\n  const err = new Error(`${message} at character ${index}`);\n\n  (err as ErrorWithLocation).index = index;\n  (err as ErrorWithLocation).description = message;\n\n  throw err;\n}\n\n/** Create a new location marker that spans both nodes */\nfunction createSpanningLocation(start?: NodeLocation, end?: NodeLocation) {\n  if (!start || !end) {\n    return;\n  }\n\n  return {\n    start: start.start,\n    end: end.end,\n  };\n}\n\n/** Get return the longest key length of any object */\nfunction getMaxKeyLen(obj: object): number {\n  let maxLen = 0;\n\n  Object.keys(obj).forEach((key) => {\n    if (key.length > maxLen && Object.prototype.hasOwnProperty.call(obj, key)) {\n      maxLen = key.length;\n    }\n  });\n\n  return maxLen;\n}\n\nconst maxUnopLen = getMaxKeyLen(unaryOps);\nconst maxBinopLen = getMaxKeyLen(binaryOps);\n\n// Literals\n// ----------\n// Store the values to return for the various literals we may encounter\nconst literals = {\n  true: true,\n  false: false,\n  null: null,\n  undefined,\n} as const;\n\n// Except for `this`, which is special. This could be changed to something like `'self'` as well\nconst thisStr = \"this\";\n\n/** Returns the precedence of a binary operator or `0` if it isn't a binary operator */\nfunction binaryPrecedence(opVal: string): number {\n  return binaryOps[opVal] || 0;\n}\n\n/**\n * Utility function (gets called from multiple places)\n * Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions\n */\nfunction createBinaryExpression(\n  operator: string | boolean,\n  left: string,\n  right: string,\n  location?: NodeLocation,\n) {\n  let type: ExpressionNodeType;\n\n  if (operator === \"||\" || operator === \"&&\") {\n    type = \"LogicalExpression\";\n  } else if (operator === \"=\") {\n    type = \"Assignment\";\n  } else if (\n    operator === \"+=\" ||\n    operator === \"-=\" ||\n    operator === \"&=\" ||\n    operator === \"|=\"\n  ) {\n    type = \"Modification\";\n  } else {\n    type = \"BinaryExpression\";\n  }\n\n  return {\n    __id: ExpNodeOpaqueIdentifier,\n    type,\n    operator,\n    left,\n    right,\n    location,\n  };\n}\n\n/** `ch` is a character code in the next three functions */\nfunction isDecimalDigit(ch: number) {\n  return ch >= 48 && ch <= 57; // 0...9\n}\n\n/** Check if the char is the character code for the start of an identifier */\nfunction isIdentifierStart(ch: number) {\n  return (\n    ch === 36 ||\n    ch === 95 || // `$` and `_`\n    (ch >= 65 && ch <= 90) || // A...Z\n    (ch >= 97 && ch <= 122)\n  ); // A...z\n}\n\n/** Check if the char code is still a valid identifier portion */\nfunction isIdentifierPart(ch: number) {\n  return (\n    ch === 36 ||\n    ch === 95 || // `$` and `_`\n    (ch >= 65 && ch <= 90) || // A...Z\n    (ch >= 97 && ch <= 122) || // A...z\n    (ch >= 48 && ch <= 57)\n  ); // 0...9\n}\n\n/** Check if the 2 chars are the start of a model reference */\nfunction isModelRefStart(ch0: number, ch1: number) {\n  return ch0 === OCURL_CODE && ch1 === OCURL_CODE; // '{{'\n}\n\n/** Parse out an expression from the string */\nexport function parseExpression(\n  expr: string,\n  options?: {\n    /** If true (the default), will throw on invalid expressions */\n    strict?: boolean;\n  },\n): ExpressionNode {\n  const strictMode = options?.strict ?? true;\n\n  // `index` stores the character number we are currently at while `length` is a constant\n  // All of the gobbles below will modify `index` as we move along\n  const charAtFunc = expr.charAt;\n  const charCodeAtFunc = expr.charCodeAt;\n  const { length } = expr;\n\n  let index = 0;\n\n  /** Create a location object  */\n  const getLocation = (startChar: number) => {\n    return {\n      start: {\n        character: startChar,\n      },\n      end: {\n        character: index,\n      },\n    };\n  };\n\n  /** Grab the char at the index from the expression */\n  function exprI(i: number) {\n    return charAtFunc.call(expr, i);\n  }\n\n  /** Grab the unicode char at the index in the expression */\n  function exprICode(i: number) {\n    return charCodeAtFunc.call(expr, i);\n  }\n\n  /**\n   * Gobble an object and store the object in an attributes array\n   */\n  function gobbleObjects() {\n    const attributes: Array<{\n      /** The property name of the object */\n      key: any;\n\n      /** the associated value */\n      value: any;\n    }> = [];\n    let closed = false;\n\n    let shouldDefineKey = true;\n    let key;\n    let value;\n    let chCode;\n    const startCharIndex = index;\n\n    // get rid of OCURL_CODE\n    ++index;\n\n    while (index < length) {\n      gobbleSpaces();\n      chCode = exprICode(index);\n      // check for end\n      if (chCode === CCURL_CODE) {\n        // if we are at the end but a key was defined\n        if (key) {\n          throwError(\"A key was defined but a value was not\", index);\n        }\n\n        index++;\n        closed = true;\n        break;\n      } else if (shouldDefineKey) {\n        // check for key\n        if (chCode !== SQUOTE_CODE && chCode !== DQUOTE_CODE) {\n          throwError(\"An object must start wtih a key\", index);\n        }\n\n        // get key\n        key = gobbleStringLiteral();\n        // remove spaces\n        gobbleSpaces();\n        // remove colon\n        if (exprICode(index) === COLON_CODE) {\n          index++;\n          shouldDefineKey = false;\n        } else {\n          throwError(\"A colon must follow an object key\", index);\n        }\n      } else {\n        value = gobbleExpression();\n\n        attributes.push({ key, value });\n        gobbleSpaces();\n        chCode = exprICode(index);\n        if (chCode === COMMA_CODE) {\n          index++;\n        } else if (chCode !== CCURL_CODE) {\n          throwError(\"Please add a comma to add another key\", index);\n        }\n\n        shouldDefineKey = true;\n        key = undefined;\n        value = undefined;\n      }\n\n      chCode = exprICode(index);\n    }\n\n    // throw error if object is not closed\n    if (!closed) {\n      throwError(`Unclosed brace in object`, index);\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Object\",\n      attributes,\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  /**\n   * Push `index` up to the next non-space character\n   */\n  function gobbleSpaces() {\n    let ch = exprICode(index);\n    // Space or tab\n    while (ch === 32 || ch === 9) {\n      ch = exprICode(++index);\n    }\n  }\n\n  /**\n   * The main parsing function. Much of this code is dedicated to ternary expressions\n   */\n  function gobbleExpression(): ExpressionNode {\n    const test = gobbleBinaryExpression();\n    gobbleSpaces();\n    const startCharIndex = index;\n\n    if (index < length && exprICode(index) === QUMARK_CODE) {\n      // Ternary expression: test ? consequent : alternate\n      index++;\n      const consequent = gobbleExpression();\n\n      if (!consequent) {\n        throwError(\"Expected expression\", index);\n      }\n\n      gobbleSpaces();\n\n      if (exprICode(index) === COLON_CODE) {\n        index++;\n        const alternate = gobbleExpression();\n\n        if (!alternate) {\n          throwError(\"Expected expression\", index);\n        }\n\n        return {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"ConditionalExpression\",\n          test,\n          consequent,\n          alternate,\n          location: getLocation(startCharIndex),\n        };\n      }\n\n      throwError(\"Expected :\", index);\n    }\n\n    return test;\n  }\n\n  /**\n   * Search for the operation portion of the string (e.g. `+`, `===`)\n   * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n   * and move down from 3 to 2 to 1 character until a matching binary operation is found\n   * then, return that binary operation\n   */\n  function gobbleBinaryOp() {\n    gobbleSpaces();\n\n    let toCheck = expr.substr(index, maxBinopLen);\n    let tcLen = toCheck.length;\n\n    while (tcLen > 0) {\n      if (Object.prototype.hasOwnProperty.call(binaryOps, toCheck)) {\n        index += tcLen;\n        return toCheck;\n      }\n\n      toCheck = toCheck.substr(0, --tcLen);\n    }\n\n    return false;\n  }\n\n  /**\n   * This function is responsible for gobbling an individual expression,\n   * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n   */\n  function gobbleBinaryExpression() {\n    let node;\n    let prec;\n    let i;\n\n    // First, try to get the leftmost thing\n    // Then, check to see if there's a binary operator operating on that leftmost thing\n    let left = gobbleToken();\n    let biop = gobbleBinaryOp();\n\n    // If there wasn't a binary operator, just return the leftmost node\n    if (!biop) {\n      return left;\n    }\n\n    // Otherwise, we need to start a stack to properly place the binary operations in their\n    // precedence structure\n    let biopInfo = { value: biop, prec: binaryPrecedence(biop) };\n    let right = gobbleToken();\n\n    if (!right) {\n      throwError(`Expected expression after ${biop}`, index);\n    }\n\n    const stack = [left, biopInfo, right];\n\n    // Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n    biop = gobbleBinaryOp();\n    while (biop) {\n      prec = binaryPrecedence(biop);\n\n      if (prec === 0) {\n        break;\n      }\n\n      biopInfo = { value: biop, prec };\n\n      // Reduce: make a binary expression from the three topmost entries.\n      while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n        right = stack.pop();\n        biop = stack.pop().value;\n        left = stack.pop();\n        node = createBinaryExpression(\n          biop,\n          left,\n          right,\n          createSpanningLocation(left.location, right.location),\n        );\n        stack.push(node);\n      }\n\n      node = gobbleToken();\n\n      if (!node) {\n        throwError(`Expected expression after ${biop}`, index);\n      }\n\n      stack.push(biopInfo, node);\n      biop = gobbleBinaryOp();\n    }\n\n    i = stack.length - 1;\n    node = stack[i];\n\n    while (i > 1) {\n      node = createBinaryExpression(\n        stack[i - 1].value,\n        stack[i - 2],\n        node,\n        createSpanningLocation(stack[i - 2].location, node.location),\n      );\n      i -= 2;\n    }\n\n    return node;\n  }\n\n  /**\n   * An individual part of a binary expression:\n   * e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n   */\n  function gobbleToken(): any {\n    gobbleSpaces();\n    const ch = exprICode(index);\n    const startCharIndex = index;\n\n    if (isDecimalDigit(ch) || ch === PERIOD_CODE) {\n      // Char code 46 is a dot `.` which can start off a numeric literal\n      return gobbleNumericLiteral();\n    }\n\n    if (ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\n      // Single or double quotes\n      return gobbleStringLiteral();\n    }\n\n    if (isIdentifierStart(ch) || ch === OPAREN_CODE) {\n      // Open parenthesis\n      // `foo`, `bar.baz`\n      return gobbleVariable();\n    }\n\n    if (ch === OBRACK_CODE) {\n      return gobbleArray();\n    }\n\n    if (isModelRefStart(ch, exprICode(index + 1))) {\n      return gobbleModelRef();\n    }\n\n    // not a double bracket: {{}} but if its a single {}\n    if (ch === OCURL_CODE) {\n      return gobbleObjects();\n    }\n\n    let toCheck = expr.substr(index, maxUnopLen);\n    let tcLen = toCheck.length;\n\n    while (tcLen > 0) {\n      if (Object.prototype.hasOwnProperty.call(unaryOps, toCheck)) {\n        index += tcLen;\n        return {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"UnaryExpression\",\n          operator: toCheck,\n          argument: gobbleToken(),\n          prefix: true,\n          location: getLocation(startCharIndex),\n        };\n      }\n\n      toCheck = toCheck.substr(0, --tcLen);\n    }\n\n    return false;\n  }\n\n  /**\n   * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n   * keep track of everything in the numeric literal and then calling `parseFloat` on that string\n   */\n  function gobbleNumericLiteral() {\n    let num = \"\";\n    const startCharIndex = index;\n\n    while (isDecimalDigit(exprICode(index))) {\n      num += exprI(index++);\n    }\n\n    if (exprICode(index) === PERIOD_CODE) {\n      // Can start with a decimal marker\n      num += exprI(index++);\n\n      while (isDecimalDigit(exprICode(index))) {\n        num += exprI(index++);\n      }\n    }\n\n    let ch = exprI(index);\n    if (ch === \"e\" || ch === \"E\") {\n      // Exponent marker\n      num += exprI(index++);\n      ch = exprI(index);\n\n      if (ch === \"+\" || ch === \"-\") {\n        // Exponent sign\n        num += exprI(index++);\n      }\n\n      while (isDecimalDigit(exprICode(index))) {\n        // Exponent itself\n        num += exprI(index++);\n      }\n\n      if (!isDecimalDigit(exprICode(index - 1))) {\n        throwError(`Expected exponent (${num}${exprI(index)})`, index);\n      }\n    }\n\n    const chCode = exprICode(index);\n    // Check to make sure this isn't a variable name that start with a number (123abc)\n    if (isIdentifierStart(chCode)) {\n      throwError(\n        `Variable names cannot start with a number (${num}${exprI(index)})`,\n        index,\n      );\n    } else if (chCode === PERIOD_CODE) {\n      throwError(\"Unexpected period\", index);\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Literal\",\n      value: parseFloat(num),\n      raw: num,\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  /**\n   * Parses a string literal, staring with single or double quotes with basic support for escape codes\n   * e.g. `\"hello world\"`, `'this is\\nJSEP'`\n   */\n  function gobbleStringLiteral() {\n    const quote = exprI(index++);\n    let str = \"\";\n    let closed = false;\n    const startCharIndex = index;\n\n    while (index < length) {\n      let ch = exprI(index++);\n\n      if (ch === quote) {\n        closed = true;\n        break;\n      }\n\n      if (ch !== \"\\\\\") {\n        str += ch;\n        continue;\n      }\n\n      // Check for all of the common escape codes\n      ch = exprI(index++);\n\n      switch (ch) {\n        case \"n\":\n          str += \"\\n\";\n          break;\n        case \"r\":\n          str += \"\\r\";\n          break;\n        case \"t\":\n          str += \"\\t\";\n          break;\n        case \"b\":\n          str += \"\\b\";\n          break;\n        case \"f\":\n          str += \"\\f\";\n          break;\n        case \"v\":\n          str += \"\\u000B\";\n          break;\n        default:\n      }\n    }\n\n    if (!closed) {\n      throwError(`Unclosed quote after \"${str}\"`, index);\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Literal\",\n      value: str,\n      raw: `${quote}${str}${quote}`,\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  /**\n   * Model refs are bindings wrapped in 2 sets of double curlys\n   * e.g. {{foo.bar.ref}}\n   */\n  function gobbleModelRef() {\n    let str = \"\";\n    let closed = false;\n    let openBraceCount = 1;\n    const startCharIndex = index;\n\n    index += 2; // Skip the {{\n    while (index < length) {\n      const ch = exprI(index++);\n\n      if (ch === \"}\" && exprICode(index) === CCURL_CODE) {\n        index++;\n        openBraceCount--;\n\n        if (openBraceCount === 0) {\n          closed = true;\n          break;\n        }\n\n        str += \"}}\";\n      } else if (ch === \"{\" && exprICode(index) === OCURL_CODE) {\n        openBraceCount++;\n        str += \"{{\";\n        index++;\n      } else {\n        str += ch;\n      }\n    }\n\n    if (!closed) {\n      throwError(`Unclosed brace after \"${str}\"`, index);\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"ModelRef\",\n      ref: str,\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  /**\n   * Gobbles only identifiers\n   * e.g.: `foo`, `_value`, `$x1`\n   * Also, this function checks if that identifier is a literal:\n   * (e.g. `true`, `false`, `null`) or `this`\n   */\n  function gobbleIdentifier() {\n    const start = index;\n    let ch = exprICode(start);\n\n    if (isIdentifierStart(ch)) {\n      index++;\n    } else {\n      throwError(`Unexpected ${exprI(index)}`, index);\n    }\n\n    while (index < length) {\n      ch = exprICode(index);\n      if (isIdentifierPart(ch)) {\n        index++;\n      } else {\n        break;\n      }\n    }\n\n    const identifier = expr.slice(start, index);\n\n    if (Object.prototype.hasOwnProperty.call(literals, identifier)) {\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Literal\",\n        value: (literals as any)[identifier],\n        raw: identifier,\n        location: getLocation(start),\n      };\n    }\n\n    if (identifier === thisStr) {\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"ThisExpression\",\n        location: getLocation(start),\n      };\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Identifier\",\n      name: identifier,\n      location: getLocation(start),\n    };\n  }\n\n  /**\n   * Gobbles a list of arguments within the context of a function call\n   * or array literal. This function also assumes that the opening character\n   * `(` or `[` has already been gobbled, and gobbles expressions and commas\n   * until the terminator character `)` or `]` is encountered.\n   * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n   */\n  function gobbleArguments(termination: number) {\n    const args = [];\n    let charIndex;\n    let node;\n\n    while (index < length) {\n      gobbleSpaces();\n      charIndex = exprICode(index);\n\n      if (charIndex === termination) {\n        // Done parsing\n        index++;\n        break;\n      }\n\n      if (charIndex === COMMA_CODE) {\n        // Between expressions\n        index++;\n        continue;\n      }\n\n      node = gobbleExpression();\n\n      if (!node || node.type === \"Compound\") {\n        throwError(\"Expected comma\", index);\n      }\n\n      args.push(node);\n    }\n\n    if (strictMode && charIndex !== termination) {\n      throwError(`Expected ${String.fromCharCode(termination)}`, index);\n    }\n\n    return args;\n  }\n\n  /**\n   * Gobble a non-literal variable name. This variable name may include properties\n   * e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n   * It also gobbles function calls:\n   * e.g. `Math.acos(obj.angle)`\n   */\n  function gobbleVariable(): ExpressionNode {\n    let charIndex = exprICode(index);\n    let node: any =\n      charIndex === OPAREN_CODE ? gobbleGroup() : gobbleIdentifier();\n    const startCharIndex = index;\n    gobbleSpaces();\n    charIndex = exprICode(index);\n\n    while (\n      charIndex === PERIOD_CODE ||\n      charIndex === OBRACK_CODE ||\n      charIndex === OPAREN_CODE\n    ) {\n      index++;\n\n      if (charIndex === PERIOD_CODE) {\n        gobbleSpaces();\n\n        node = {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"MemberExpression\",\n          computed: false,\n          object: node,\n          property: gobbleIdentifier(),\n          location: getLocation(startCharIndex),\n        };\n      } else if (charIndex === OBRACK_CODE) {\n        node = {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"MemberExpression\",\n          computed: true,\n          object: node,\n          property: gobbleExpression(),\n          location: getLocation(startCharIndex),\n        };\n\n        gobbleSpaces();\n        charIndex = exprICode(index);\n\n        if (charIndex !== CBRACK_CODE) {\n          throwError(\"Unclosed [\", index);\n        }\n\n        index++;\n      } else if (charIndex === OPAREN_CODE) {\n        // A function call is being made; gobble all the arguments\n        node = {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"CallExpression\",\n          args: gobbleArguments(CPAREN_CODE),\n          callTarget: node,\n          location: getLocation(startCharIndex),\n        };\n      }\n\n      gobbleSpaces();\n      charIndex = exprICode(index);\n    }\n\n    return node;\n  }\n\n  /**\n   * Responsible for parsing a group of things within parentheses `()`\n   * This function assumes that it needs to gobble the opening parenthesis\n   * and then tries to gobble everything within that parenthesis, assuming\n   * that the next thing it should see is the close parenthesis. If not,\n   * then the expression probably doesn't have a `)`\n   */\n  function gobbleGroup() {\n    index++;\n    const node = gobbleExpression();\n    gobbleSpaces();\n\n    if (exprICode(index) === CPAREN_CODE) {\n      index++;\n      return node;\n    }\n\n    throwError(\"Unclosed (\", index);\n  }\n\n  /**\n   * Responsible for parsing Array literals `[1, 2, 3]`\n   * This function assumes that it needs to gobble the opening bracket\n   * and then tries to gobble the expressions as arguments.\n   */\n  function gobbleArray() {\n    const startCharIndex = index;\n    index++;\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"ArrayExpression\",\n      elements: gobbleArguments(CBRACK_CODE),\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  const nodes = [];\n\n  try {\n    while (index < length) {\n      const chIndex = exprICode(index);\n\n      // Expressions can be separated by semicolons, commas, or just inferred without any\n      // separators\n      if (chIndex === SEMCOL_CODE || chIndex === COMMA_CODE) {\n        index++; // ignore separators\n        continue;\n      }\n\n      const node = gobbleExpression();\n\n      // Try to gobble each expression individually\n      if (node) {\n        nodes.push(node);\n        // If we weren't able to find a binary expression and are out of room, then\n        // the expression passed in probably has too much\n      } else if (strictMode && index < length) {\n        throwError(`Unexpected \"${exprI(index)}\"`, index);\n      }\n    }\n\n    // If there's only one expression just try returning the expression\n    if (nodes.length === 1) {\n      return nodes[0];\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Compound\",\n      body: nodes,\n      location: getLocation(0),\n    };\n  } catch (e) {\n    if (strictMode || !(e instanceof Error)) {\n      throw e;\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Compound\",\n      body: nodes,\n      location: getLocation(0),\n      error: e,\n    };\n  }\n}\n","import type { Binding } from \"@player-ui/types\";\n\nimport type { BindingLike } from \"../binding\";\nimport type {\n  ExpressionHandler,\n  ExpressionContext,\n  ExpressionNode,\n} from \"./types\";\n\n/** Sets a value to the data-model */\nexport const setDataVal: ExpressionHandler<[Binding, any], any> = (\n  _context: ExpressionContext,\n  binding,\n  value,\n) => {\n  _context.model.set([[binding as BindingLike, value]]);\n};\n\n/** Fetches a valid from the data-model */\nexport const getDataVal: ExpressionHandler<[Binding], unknown> = (\n  _context: ExpressionContext,\n  binding,\n) => {\n  return _context.model.get(binding as BindingLike);\n};\n\n/** Deletes a value from the model */\nexport const deleteDataVal: ExpressionHandler<[Binding], void> = (\n  _context: ExpressionContext,\n  binding,\n) => {\n  return _context.model.delete(binding);\n};\n\n/** Conditional expression handler */\nexport const conditional: ExpressionHandler<\n  [ExpressionNode, ExpressionNode, ExpressionNode?]\n> = (ctx, condition, ifTrue, ifFalse) => {\n  const resolution = ctx.evaluate(condition);\n  if (resolution) {\n    return ctx.evaluate(ifTrue);\n  }\n\n  if (ifFalse) {\n    return ctx.evaluate(ifFalse);\n  }\n\n  return null;\n};\n\nconditional.resolveParams = false;\n","import { isExpressionNode } from \"./types\";\nimport type {\n  ErrorWithLocation,\n  ExpressionHandler,\n  ExpressionNode,\n  ExpressionObjectType,\n  ExpressionType,\n  NodeLocation,\n  NodePosition,\n} from \"./types\";\n\n/** Generates a function by removing the first context argument */\nexport function withoutContext<T extends unknown[], Return>(\n  fn: (...args: T) => Return,\n): ExpressionHandler<T, Return> {\n  return (_context, ...args) => fn(...args);\n}\n\n/** Checks if the location includes the target position  */\nfunction isInRange(position: NodePosition, location: NodeLocation) {\n  return (\n    position.character >= location.start.character &&\n    position.character <= location.end.character\n  );\n}\n\n/** Get the node in the expression that's closest to the desired position */\nexport function findClosestNodeAtPosition(\n  node: ExpressionNode,\n  position: NodePosition,\n): ExpressionNode | undefined {\n  // This is just mapping recursively over nodes in the tree\n\n  // eslint-disable-next-line default-case\n  switch (node.type) {\n    case \"Modification\":\n    case \"Assignment\":\n    case \"LogicalExpression\":\n    case \"BinaryExpression\": {\n      const check =\n        findClosestNodeAtPosition(node.left, position) ??\n        findClosestNodeAtPosition(node.right, position);\n      if (check) {\n        return check;\n      }\n\n      break;\n    }\n\n    case \"UnaryExpression\": {\n      const checkArg = findClosestNodeAtPosition(node.argument, position);\n      if (checkArg) {\n        return checkArg;\n      }\n\n      break;\n    }\n\n    case \"MemberExpression\": {\n      const checkObject =\n        findClosestNodeAtPosition(node.object, position) ??\n        findClosestNodeAtPosition(node.property, position);\n      if (checkObject) {\n        return checkObject;\n      }\n\n      break;\n    }\n\n    case \"ConditionalExpression\": {\n      const checkObject =\n        findClosestNodeAtPosition(node.test, position) ??\n        findClosestNodeAtPosition(node.consequent, position) ??\n        findClosestNodeAtPosition(node.alternate, position);\n      if (checkObject) {\n        return checkObject;\n      }\n\n      break;\n    }\n\n    case \"ArrayExpression\":\n    case \"Compound\": {\n      const elements =\n        node.type === \"ArrayExpression\" ? node.elements : node.body;\n\n      const anyElements = elements.find((e) =>\n        findClosestNodeAtPosition(e, position),\n      );\n\n      if (anyElements) {\n        return anyElements;\n      }\n\n      break;\n    }\n\n    case \"Object\": {\n      const checkObject = node.attributes.reduce<ExpressionNode | undefined>(\n        (found, next) => {\n          return (\n            found ??\n            findClosestNodeAtPosition(next.key, position) ??\n            findClosestNodeAtPosition(next.value, position)\n          );\n        },\n        undefined,\n      );\n\n      if (checkObject) {\n        return checkObject;\n      }\n\n      break;\n    }\n\n    case \"CallExpression\": {\n      const anyArgs =\n        node.args.find((arg) => {\n          return findClosestNodeAtPosition(arg, position);\n        }) ?? findClosestNodeAtPosition(node.callTarget, position);\n\n      if (anyArgs) {\n        return anyArgs;\n      }\n\n      break;\n    }\n  }\n\n  // Lastly check for yourself\n  if (node.location && isInRange(position, node.location)) {\n    return node;\n  }\n}\n\n/** Checks if the expression is a simple type */\nexport function isObjectExpression(\n  expr: ExpressionType,\n): expr is ExpressionObjectType {\n  if (isExpressionNode(expr)) {\n    return false;\n  }\n\n  return (\n    typeof expr === \"object\" &&\n    expr !== null &&\n    !Array.isArray(expr) &&\n    \"value\" in expr\n  );\n}\n\n/**\n * Type guard for ErrorWithLocation\n */\nexport function isErrorWithLocation(error: Error): error is ErrorWithLocation {\n  return (\n    (error as ErrorWithLocation).index !== undefined &&\n    (error as ErrorWithLocation).description !== undefined\n  );\n}\n","import { SyncHook } from \"tapable-ts\";\nimport type { Logger, Severity } from \"./types\";\n\n/** A logger that has a tapable subscriptions to callbacks */\nexport default class TapableLogger implements Logger {\n  public readonly hooks = {\n    trace: new SyncHook<[Array<any>]>(),\n    debug: new SyncHook<[Array<any>]>(),\n    info: new SyncHook<[Array<any>]>(),\n    warn: new SyncHook<[Array<any>]>(),\n    error: new SyncHook<[Array<any>]>(),\n    log: new SyncHook<[Severity, Array<any>]>(),\n  };\n\n  private logHandlers: Set<Logger> = new Set();\n\n  private createHandler(severity: Severity): (...args: any[]) => void {\n    return (...args: any[]) => {\n      this.hooks[severity].call(args);\n      this.hooks.log.call(severity, args);\n      this.logHandlers.forEach((logger) => logger[severity](...args));\n    };\n  }\n\n  public addHandler(logHandler: Logger) {\n    this.logHandlers.add(logHandler);\n  }\n\n  public removeHandler(logHandler: Logger) {\n    this.logHandlers.delete(logHandler);\n  }\n\n  public readonly trace = this.createHandler(\"trace\");\n  public readonly debug = this.createHandler(\"debug\");\n  public readonly info = this.createHandler(\"info\");\n  public readonly warn = this.createHandler(\"warn\");\n  public readonly error = this.createHandler(\"error\");\n}\n","import type { Logger, Severity, LoggerProvider } from \"./types\";\n\n/**\n * The ProxyLogger allows a user to log to another Logger instance that may not exist yet\n */\nexport default class ProxyLogger implements Logger {\n  private proxiedLoggerProvider: LoggerProvider;\n\n  constructor(loggerProvider: LoggerProvider) {\n    this.proxiedLoggerProvider = loggerProvider;\n  }\n\n  private createHandler(severity: Severity): (...args: any[]) => void {\n    return (...args: any[]) => {\n      const logger = this.proxiedLoggerProvider();\n      logger?.[severity](...args);\n    };\n  }\n\n  public readonly trace = this.createHandler(\"trace\");\n  public readonly debug = this.createHandler(\"debug\");\n  public readonly info = this.createHandler(\"info\");\n  public readonly warn = this.createHandler(\"warn\");\n  public readonly error = this.createHandler(\"error\");\n}\n","import { SyncWaterfallHook } from \"tapable-ts\";\nimport type { Schema as SchemaType, Formatting } from \"@player-ui/types\";\n\nimport type { BindingInstance } from \"../binding\";\nimport type { ValidationProvider, ValidationObject } from \"../validator\";\nimport type { FormatDefinition, FormatOptions, FormatType } from \"./types\";\n\n/** A function that returns itself */\nconst identify = (val: any) => val;\n\n/** Expand the authored schema into a set of paths -> DataTypes */\nexport function parse(\n  schema: SchemaType.Schema,\n): Map<string, SchemaType.DataTypes> {\n  const expandedPaths = new Map<string, SchemaType.DataTypes>();\n\n  if (!schema.ROOT) {\n    return expandedPaths;\n  }\n\n  const parseQueue: Array<{\n    /** The node to process */\n    node: SchemaType.Node;\n\n    /** The path in the data-model this node represents */\n    path: Array<string>;\n\n    /** A set of visited DataTypes to prevent loops */\n    visited: Set<string>;\n  }> = [{ node: schema.ROOT, path: [], visited: new Set() }];\n\n  while (parseQueue.length > 0) {\n    const next = parseQueue.shift();\n\n    if (!next) {\n      break;\n    }\n\n    const { node, path, visited } = next;\n\n    Object.entries(node).forEach(([prop, type]) => {\n      const nestedPath = [...path, prop];\n\n      const nestedPathStr = nestedPath.join(\".\");\n\n      if (expandedPaths.has(nestedPathStr)) {\n        // We've gone in a loop. Panic\n        throw new Error(\n          \"Path has already been processed. There's either a loop somewhere or a bug\",\n        );\n      }\n\n      if (visited.has(type.type)) {\n        throw new Error(\n          `Path already contained type: ${type.type}. This likely indicates a loop in the schema`,\n        );\n      }\n\n      expandedPaths.set(nestedPathStr, type);\n\n      if (type.isArray) {\n        nestedPath.push(\"[]\");\n      }\n\n      if (type.isRecord) {\n        nestedPath.push(\"{}\");\n      }\n\n      if (type.type && schema[type.type]) {\n        parseQueue.push({\n          path: nestedPath,\n          node: schema[type.type],\n          visited: new Set([...visited, type.type]),\n        });\n      }\n    });\n  }\n\n  return expandedPaths;\n}\n\n/**\n * The Schema is the central hub for all data invariants, and metaData associated with the data-model itself\n * Outside of the types defined in the JSON payload, it doesn't manage or keep any state.\n * It simply servers as an orchestrator for other modules to interface w/ the schema.\n */\nexport class SchemaController implements ValidationProvider {\n  private formatters: Map<string, FormatType<any, any, FormatOptions>> =\n    new Map();\n\n  private types: Map<string, SchemaType.DataType<any>> = new Map();\n  public readonly schema: Map<string, SchemaType.DataTypes> = new Map();\n\n  private bindingSchemaNormalizedCache: Map<BindingInstance, string> =\n    new Map();\n\n  public readonly hooks = {\n    resolveTypeForBinding: new SyncWaterfallHook<\n      [SchemaType.DataTypes | undefined, BindingInstance]\n    >(),\n  };\n\n  constructor(schema?: SchemaType.Schema) {\n    this.schema = schema ? parse(schema) : new Map();\n  }\n\n  public addFormatters(fns: Array<FormatType<any, any, FormatOptions>>) {\n    fns.forEach((def) => {\n      this.formatters.set(def.name, def);\n    });\n  }\n\n  public addDataTypes(types: Array<SchemaType.DataType<any>>) {\n    types.forEach((t) => {\n      this.types.set(t.type, t);\n    });\n  }\n\n  getValidationsForBinding(\n    binding: BindingInstance,\n  ): Array<ValidationObject> | undefined {\n    const typeDef = this.getApparentType(binding);\n\n    if (!typeDef?.validation?.length) {\n      return undefined;\n    }\n\n    // Set the defaults for schema-level validations\n    return typeDef.validation.map((vRef) => ({\n      severity: \"error\",\n      trigger: \"change\",\n      ...vRef,\n    }));\n  }\n\n  private normalizeBinding(binding: BindingInstance): string {\n    const cached = this.bindingSchemaNormalizedCache.get(binding);\n    if (cached) {\n      return cached;\n    }\n\n    let bindingArray = binding.asArray();\n    let normalized = bindingArray\n      .map((p) => (typeof p === \"number\" ? \"[]\" : p))\n      .join(\".\");\n\n    if (normalized) {\n      this.bindingSchemaNormalizedCache.set(binding, normalized);\n      bindingArray = normalized.split(\".\");\n    }\n\n    bindingArray.forEach((item) => {\n      const recordBinding = bindingArray\n        .map((p) => (p === item ? \"{}\" : p))\n        .join(\".\");\n\n      if (this.schema.get(recordBinding)) {\n        this.bindingSchemaNormalizedCache.set(binding, recordBinding);\n        bindingArray = recordBinding.split(\".\");\n        normalized = recordBinding;\n      }\n    });\n\n    return normalized;\n  }\n\n  public getType(binding: BindingInstance): SchemaType.DataTypes | undefined {\n    return this.hooks.resolveTypeForBinding.call(\n      this.schema.get(this.normalizeBinding(binding)),\n      binding,\n    );\n  }\n\n  public getApparentType(\n    binding: BindingInstance,\n  ): SchemaType.DataTypes | undefined {\n    const schemaType = this.getType(binding);\n\n    if (schemaType === undefined) {\n      return undefined;\n    }\n\n    const baseType = this.getTypeDefinition(schemaType?.type);\n\n    if (baseType === undefined) {\n      return schemaType;\n    }\n\n    return {\n      ...baseType,\n      ...schemaType,\n      validation: [\n        ...(schemaType.validation ?? []),\n        ...(baseType.validation ?? []),\n      ],\n    };\n  }\n\n  public getTypeDefinition(dataType: string) {\n    return this.types.get(dataType);\n  }\n\n  public getFormatterForType(\n    formatReference: Formatting.Reference,\n  ): FormatDefinition<unknown, unknown> | undefined {\n    const { type: formatType, ...options } = formatReference;\n\n    const formatter = this.formatters.get(formatType);\n\n    if (!formatter) {\n      return;\n    }\n\n    return {\n      format: formatter.format\n        ? (val) => formatter.format?.(val, options)\n        : identify,\n      deformat: formatter.deformat\n        ? (val) => formatter.deformat?.(val, options)\n        : identify,\n    };\n  }\n\n  /**\n   * Given a binding, fetch a function that's responsible for formatting, and/or de-formatting the data\n   * If no formatter is registered, it will return undefined\n   */\n  public getFormatter(\n    binding: BindingInstance,\n  ): FormatDefinition<unknown, unknown> | undefined {\n    const type = this.getApparentType(binding);\n\n    if (!type?.format) {\n      return undefined;\n    }\n\n    return this.getFormatterForType(type.format);\n  }\n}\n","import type { BindingInstance } from \"../binding\";\n\n/**\n * Remove a binding, and any children from from the map\n * If the binding is an array-item, then it will be spliced from the array and the others will be shifted down\n *\n * @param sourceMap - A map of bindings to values\n * @param binding - The binding to remove from the map\n */\nexport function removeBindingAndChildrenFromMap<T>(\n  sourceMap: Map<BindingInstance, T>,\n  binding: BindingInstance,\n): Map<BindingInstance, T> {\n  const targetMap = new Map(sourceMap);\n\n  const parentBinding = binding.parent();\n  const property = binding.key();\n\n  // Clear out any that are sub-bindings of this binding\n\n  targetMap.forEach((_value, trackedBinding) => {\n    if (binding === trackedBinding || binding.contains(trackedBinding)) {\n      targetMap.delete(trackedBinding);\n    }\n  });\n\n  if (typeof property === \"number\") {\n    // Splice out this index from the rest\n\n    // Order matters here b/c we are shifting items in the array\n    // Start with the smallest index and work our way down\n    const bindingsToRewrite = Array.from(sourceMap.keys())\n      .filter((b) => {\n        if (parentBinding.contains(b)) {\n          const [childIndex] = b.relative(parentBinding);\n          return typeof childIndex === \"number\" && childIndex > property;\n        }\n\n        return false;\n      })\n      .sort();\n\n    bindingsToRewrite.forEach((trackedBinding) => {\n      // If the tracked binding is a sub-binding of the parent binding, then we need to\n      // update the path to reflect the new index\n\n      const [childIndex, ...childPath] = trackedBinding.relative(parentBinding);\n\n      if (typeof childIndex === \"number\") {\n        const newSegments = [childIndex - 1, ...childPath];\n        const newChildBinding = parentBinding.descendent(newSegments);\n        targetMap.set(newChildBinding, targetMap.get(trackedBinding) as T);\n        targetMap.delete(trackedBinding);\n      }\n    });\n  }\n\n  return targetMap;\n}\n","import type { ValidatorFunction } from \"./types\";\n\n/** A registry that tracks validators  */\nexport class ValidatorRegistry {\n  private registry: Map<string, ValidatorFunction<any>>;\n\n  constructor() {\n    this.registry = new Map();\n  }\n\n  /** Use the given validator name to fetch the handler */\n  public get(name: string): ValidatorFunction | undefined {\n    return this.registry.get(name);\n  }\n\n  /** Register a new validator */\n  public register<T>(name: string, handler: ValidatorFunction<T>) {\n    this.registry.set(name, handler);\n  }\n}\n","import type { Node } from \"./types\";\n\n/**\n * Checks if there are templated values in the object\n *\n * @param obj - The Parsed Object to check to see if we have a template array type for\n * @param localKey - The key being checked\n */\nexport function hasTemplateValues(obj: any, localKey: string) {\n  return (\n    Object.hasOwnProperty.call(obj, \"template\") &&\n    Array.isArray(obj?.template) &&\n    obj.template.length &&\n    obj.template.find((tmpl: any) => tmpl.output === localKey)\n  );\n}\n\n/** Check to see if the string is a valid switch key */\nexport function hasSwitchKey(localKey: string) {\n  return localKey === \"staticSwitch\" || localKey === \"dynamicSwitch\";\n}\n\n/** Check to see if the string is a valid template key */\nexport function hasTemplateKey(localKey: string) {\n  return localKey === \"template\";\n}\n\n/** Get the ID of the Node if there is one */\nexport function getNodeID(node?: Node.Node | null): string | undefined {\n  if (!node) {\n    return;\n  }\n\n  if (\n    \"value\" in node &&\n    typeof node.value === \"object\" &&\n    typeof node.value?.id === \"string\"\n  ) {\n    return node.value.id;\n  }\n}\n","import type { BindingInstance, BindingLike } from \"../../binding\";\nimport { isBinding } from \"../../binding\";\nimport type { ExpressionType } from \"../../expressions\";\nimport type { Resolve } from \"./types\";\n\n/** Check to see if and of the data-changes affect the given dependencies  */\nexport function caresAboutDataChanges(\n  dataChanges?: Set<BindingInstance>,\n  dependencies?: Set<BindingInstance>,\n) {\n  if (!dataChanges || !dependencies) {\n    return true;\n  }\n\n  const depArray = Array.from(dependencies.values());\n  const dataChangeArray = Array.from(dataChanges.values());\n\n  return (\n    depArray.find(\n      (dep) =>\n        !!dataChangeArray.find(\n          (change) =>\n            change === dep || change.contains(dep) || dep.contains(change),\n        ),\n    ) !== undefined\n  );\n}\n\n/** Convert the options object for a resolver to one for a node */\nexport function toNodeResolveOptions(\n  resolverOptions: Resolve.ResolverOptions,\n): Resolve.NodeResolveOptions {\n  return {\n    ...resolverOptions,\n    data: {\n      model: resolverOptions.model,\n      formatValue: (ref, value) => {\n        if (resolverOptions.formatValue) {\n          return resolverOptions.formatValue(ref, value);\n        }\n\n        return value;\n      },\n      format: (bindingLike: BindingLike, value: any) =>\n        resolverOptions.format\n          ? resolverOptions.format(\n              isBinding(bindingLike)\n                ? bindingLike\n                : resolverOptions.parseBinding(bindingLike),\n              value,\n            )\n          : value,\n    },\n    evaluate: (exp: ExpressionType) =>\n      resolverOptions.evaluator.evaluate(exp, resolverOptions),\n  };\n}\n\n/**\n * helper function to flatten a potential nested array and combine with initial array\n */\nexport function unpackAndPush(item: any | any[], initial: any[]) {\n  if (Array.isArray(item)) {\n    item.forEach((i) => {\n      unpackAndPush(i, initial);\n    });\n  } else {\n    initial.push(item);\n  }\n}\n","import { SyncHook } from \"tapable-ts\";\nimport type { View as ViewType } from \"@player-ui/types\";\nimport type { BindingInstance, BindingFactory } from \"../binding\";\nimport type { ValidationProvider, ValidationObject } from \"../validator\";\nimport type { Logger } from \"../logger\";\nimport type { Resolve } from \"./resolver\";\nimport { Resolver } from \"./resolver\";\nimport type { Node } from \"./parser\";\nimport { Parser } from \"./parser\";\nimport { TemplatePlugin } from \"./plugins\";\n\n/**\n * Manages the view level validations\n */\nclass CrossfieldProvider implements ValidationProvider {\n  private allValidations = new Set<ValidationObject>();\n  private byBinding = new Map<BindingInstance, Array<ValidationObject>>();\n  private logger?: Logger;\n\n  constructor(initialView: ViewType, parser: BindingFactory, logger?: Logger) {\n    this.logger = logger;\n    this.parse(initialView, parser);\n  }\n\n  private parse(contentView: ViewType, parser: BindingFactory) {\n    const xfieldRefs = contentView.validation;\n\n    if (xfieldRefs === undefined) {\n      return;\n    }\n\n    if (!Array.isArray(xfieldRefs)) {\n      this.logger?.warn(\n        `Unable to register view validations for id: ${contentView.id}. 'validation' property must be an Array.`,\n      );\n\n      return;\n    }\n\n    // Grab the validations from the view (as authored) and parse out the ones that have a _ref_ (to a binding)\n    // Group them all by binding to make it easier to return than later\n\n    xfieldRefs.forEach((vRef) => {\n      // x-field validations by default are triggered by navigating away from the page\n      // the reference can also override that _or_ the severity\n      const withDefaults: ValidationObject = {\n        trigger: \"navigation\",\n        severity: \"error\",\n        ...vRef,\n      };\n\n      this.allValidations.add(withDefaults);\n\n      // The validation reference contains a _ref_ (a binding)\n      const { ref } = vRef;\n\n      if (ref) {\n        /** Group together validations by binding */\n        const parsed = parser(ref);\n\n        if (this.byBinding.has(parsed)) {\n          this.byBinding.get(parsed)?.push(withDefaults);\n        } else {\n          this.byBinding.set(parsed, [withDefaults]);\n        }\n      }\n    });\n  }\n\n  getValidationsForBinding(binding: BindingInstance) {\n    return this.byBinding.get(binding);\n  }\n}\n\n/** A stateful view instance from an content */\nexport class ViewInstance implements ValidationProvider {\n  public hooks = {\n    onUpdate: new SyncHook<[ViewType]>(),\n    parser: new SyncHook<[Parser]>(),\n    resolver: new SyncHook<[Resolver]>(),\n    onTemplatePluginCreated: new SyncHook<[TemplatePlugin]>(),\n    templatePlugin: new SyncHook<[TemplatePlugin]>(),\n  };\n\n  private resolver?: Resolver;\n  public readonly initialView: ViewType;\n  public readonly resolverOptions: Resolve.ResolverOptions;\n  private rootNode?: Node.Node;\n\n  private validationProvider?: CrossfieldProvider;\n\n  private templatePlugin: TemplatePlugin | undefined;\n\n  // TODO might want to add a version/timestamp to this to compare updates\n  public lastUpdate: Record<string, any> | undefined;\n\n  constructor(initialView: ViewType, resolverOptions: Resolve.ResolverOptions) {\n    this.initialView = initialView;\n    this.resolverOptions = resolverOptions;\n    this.hooks.onTemplatePluginCreated.tap(\"view\", (templatePlugin) => {\n      this.templatePlugin = templatePlugin;\n    });\n  }\n\n  public updateAsync() {\n    const update = this.resolver?.update();\n    this.lastUpdate = update;\n    this.hooks.onUpdate.call(update);\n  }\n\n  public update(changes?: Set<BindingInstance>) {\n    if (this.rootNode === undefined) {\n      /** On initialization of the view, also create a validation parser */\n      this.validationProvider = new CrossfieldProvider(\n        this.initialView,\n        this.resolverOptions.parseBinding,\n        this.resolverOptions.logger,\n      );\n\n      if (this.templatePlugin) {\n        this.hooks.templatePlugin.call(this.templatePlugin);\n      } else {\n        this.resolverOptions.logger?.warn(\n          \"templatePlugin not set for View, legacy templates may not work\",\n        );\n      }\n\n      const parser = new Parser();\n      this.hooks.parser.call(parser);\n      this.rootNode = parser.parseView(this.initialView);\n\n      this.resolver = new Resolver(this.rootNode, {\n        ...this.resolverOptions,\n        parseNode: parser.parseObject.bind(parser),\n      });\n      this.hooks.resolver.call(this.resolver);\n    }\n\n    const update = this.resolver?.update(changes);\n\n    if (this.lastUpdate === update) {\n      return this.lastUpdate;\n    }\n\n    this.lastUpdate = update;\n    this.hooks.onUpdate.call(update);\n\n    return update;\n  }\n\n  getValidationsForBinding(binding: BindingInstance) {\n    return this.validationProvider?.getValidationsForBinding(binding);\n  }\n}\n\n/** A plugin for a view */\nexport interface ViewPlugin {\n  /** Called with a view instance */\n  apply(view: ViewInstance): void;\n}\n","import { SyncWaterfallHook } from \"tapable-ts\";\nimport type { Template } from \"@player-ui/types\";\nimport type {\n  Node,\n  ParseObjectOptions,\n  ParseObjectChildOptions,\n  Parser,\n} from \"../parser\";\nimport { NodeType } from \"../parser\";\nimport { ViewInstance, ViewPlugin } from \"../view\";\nimport type { Options } from \"./options\";\nimport type { Resolver } from \"../resolver\";\nimport { hasTemplateKey } from \"../parser/utils\";\n\nexport interface TemplateItemInfo {\n  /** The index of the data for the current iteration of the template */\n  index: number;\n  /** The data for the current iteration of the template */\n  data: any;\n  /** The depth of the template node */\n  depth: number;\n}\n\nexport interface TemplateSubstitution {\n  /** Regular expression to find and replace. The global flag will be always be added to this expression. */\n  expression: string | RegExp;\n  /** The value to replace matches with. */\n  value: string;\n}\n\nexport type TemplateSubstitutionsFunc = (\n  baseSubstitutions: TemplateSubstitution[],\n  templateItemInfo: TemplateItemInfo,\n) => TemplateSubstitution[];\n\n/** A view plugin to resolve/manage templates */\nexport default class TemplatePlugin implements ViewPlugin {\n  private readonly options: Options;\n\n  hooks = {\n    resolveTemplateSubstitutions: new SyncWaterfallHook<\n      [TemplateSubstitution[], TemplateItemInfo]\n    >(),\n  };\n\n  constructor(options: Options) {\n    this.options = options;\n  }\n\n  private parseTemplate(\n    parseObject: any,\n    node: Node.Template,\n    options: Options,\n  ): Node.Node | null {\n    const { template, depth } = node;\n    const data = options.data.model.get(node.data);\n\n    if (!data) {\n      return null;\n    }\n\n    if (!Array.isArray(data)) {\n      throw new Error(`Template using '${node.data}' but is not an array`);\n    }\n\n    const values: Array<Node.Node> = [];\n\n    data.forEach((dataItem, index) => {\n      const templateSubstitutions =\n        this.hooks.resolveTemplateSubstitutions.call(\n          [\n            {\n              expression: new RegExp(`_index${depth || \"\"}_`),\n              value: String(index),\n            },\n          ],\n          {\n            depth,\n            data: dataItem,\n            index,\n          },\n        );\n      let templateStr = JSON.stringify(template);\n\n      for (const { expression, value } of templateSubstitutions) {\n        let flags = \"g\";\n        if (typeof expression === \"object\") {\n          flags = `${expression.flags}${expression.global ? \"\" : \"g\"}`;\n        }\n\n        templateStr = templateStr.replace(new RegExp(expression, flags), value);\n      }\n\n      const parsed = parseObject(JSON.parse(templateStr), NodeType.Value, {\n        templateDepth: node.depth + 1,\n      });\n\n      if (parsed) {\n        values.push(parsed);\n      }\n    });\n\n    const result: Node.MultiNode = {\n      type: NodeType.MultiNode,\n      override: false,\n      values,\n    };\n\n    return result;\n  }\n\n  applyParser(parser: Parser) {\n    parser.hooks.onCreateASTNode.tap(\"template\", (node) => {\n      if (node && node.type === NodeType.Template && !node.dynamic) {\n        return this.parseTemplate(\n          parser.parseObject.bind(parser),\n          node,\n          this.options,\n        );\n      }\n\n      return node;\n    });\n\n    parser.hooks.parseNode.tap(\n      \"template\",\n      (\n        obj: any,\n        _nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        childOptions?: ParseObjectChildOptions,\n      ) => {\n        if (childOptions && hasTemplateKey(childOptions.key)) {\n          return obj\n            .map((template: Template) => {\n              const templateAST = parser.createASTNode(\n                {\n                  type: NodeType.Template,\n                  depth: options.templateDepth ?? 0,\n                  data: template.data,\n                  template: template.value,\n                  dynamic: template.dynamic ?? false,\n                },\n                template,\n              );\n\n              if (!templateAST) return;\n\n              if (templateAST.type === NodeType.MultiNode) {\n                templateAST.values.forEach((v) => {\n                  v.parent = templateAST;\n                });\n              }\n\n              return {\n                path: [...childOptions.path, template.output],\n                value: templateAST,\n              };\n            })\n            .filter(Boolean);\n        }\n      },\n    );\n  }\n\n  applyResolverHooks(resolver: Resolver) {\n    resolver.hooks.beforeResolve.tap(\"template\", (node, options) => {\n      if (node && node.type === NodeType.Template && node.dynamic) {\n        return this.parseTemplate(options.parseNode, node, options);\n      }\n\n      return node;\n    });\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.parser.tap(\"template\", this.applyParser.bind(this));\n    view.hooks.resolver.tap(\"template\", this.applyResolverHooks.bind(this));\n  }\n}\n","import { ViewInstance, ViewPlugin } from \"../view\";\nimport type { Options } from \"./options\";\nimport type {\n  Parser,\n  Node,\n  ParseObjectOptions,\n  ParseObjectChildOptions,\n} from \"../parser\";\nimport { EMPTY_NODE, NodeType } from \"../parser\";\nimport type { Resolver } from \"../resolver\";\nimport { hasSwitchKey } from \"../parser/utils\";\n\n/** A view plugin to resolve switches */\nexport default class SwitchPlugin implements ViewPlugin {\n  private readonly options: Options;\n\n  constructor(options: Options) {\n    this.options = options;\n  }\n\n  private resolveSwitch(node: Node.Switch, options: Options): Node.Node {\n    for (const switchCase of node.cases) {\n      const isApplicable = options.evaluate(switchCase.case);\n      if (isApplicable) {\n        return switchCase.value;\n      }\n    }\n\n    return EMPTY_NODE;\n  }\n\n  private isSwitch(obj: any) {\n    return (\n      obj &&\n      (Object.prototype.hasOwnProperty.call(obj, \"dynamicSwitch\") ||\n        Object.prototype.hasOwnProperty.call(obj, \"staticSwitch\"))\n    );\n  }\n\n  applyParser(parser: Parser) {\n    /** Switches resolved during the parsing phase are static */\n    parser.hooks.onCreateASTNode.tap(\"switch\", (node) => {\n      if (node && node.type === NodeType.Switch && !node.dynamic) {\n        return this.resolveSwitch(node, this.options);\n      }\n\n      return node;\n    });\n\n    parser.hooks.parseNode.tap(\n      \"switch\",\n      (\n        obj: any,\n        _nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        childOptions?: ParseObjectChildOptions,\n      ) => {\n        if (\n          this.isSwitch(obj) ||\n          (childOptions && hasSwitchKey(childOptions.key))\n        ) {\n          const objToParse =\n            childOptions && hasSwitchKey(childOptions.key)\n              ? { [childOptions.key]: obj }\n              : obj;\n          const dynamic = \"dynamicSwitch\" in objToParse;\n          const switchContent = dynamic\n            ? objToParse.dynamicSwitch\n            : objToParse.staticSwitch;\n\n          const cases: Node.SwitchCase[] = switchContent\n            .map(\n              (switchCase: {\n                [x: string]: any;\n                /**\n                 *\n                 */\n                case: any;\n              }) => {\n                const { case: switchCaseExpr, ...switchBody } = switchCase;\n                const value = parser.parseObject(\n                  switchBody,\n                  NodeType.Value,\n                  options,\n                );\n\n                if (value) {\n                  return {\n                    case: switchCaseExpr,\n                    value: value as Node.Value,\n                  };\n                }\n\n                return;\n              },\n            )\n            .filter(Boolean);\n\n          const switchAST = parser.createASTNode(\n            {\n              type: NodeType.Switch,\n              dynamic,\n              cases,\n            },\n            objToParse,\n          );\n\n          if (!switchAST || switchAST.type === NodeType.Empty) {\n            return childOptions ? [] : null;\n          }\n\n          if (switchAST.type === NodeType.Switch) {\n            switchAST.cases.forEach((sCase) => {\n              sCase.value.parent = switchAST;\n            });\n          }\n\n          if (childOptions) {\n            let path = [...childOptions.path, childOptions.key];\n            let value: any = switchAST;\n\n            if (\n              switchAST.type === NodeType.Value &&\n              switchAST.children?.length === 1 &&\n              switchAST.value === undefined\n            ) {\n              const firstChild = switchAST.children[0];\n              path = [...path, ...firstChild.path];\n              value = firstChild.value;\n            }\n\n            return [{ path, value }];\n          }\n\n          return switchAST;\n        }\n      },\n    );\n  }\n\n  applyResolver(resolver: Resolver) {\n    /** Switches resolved during the parsing phase are dynamic */\n    resolver.hooks.beforeResolve.tap(\"switch\", (node, options) => {\n      if (node && node.type === NodeType.Switch && node.dynamic) {\n        return this.resolveSwitch(node, options);\n      }\n\n      return node;\n    });\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.parser.tap(\"switch\", this.applyParser.bind(this));\n    view.hooks.resolver.tap(\"switch\", this.applyResolver.bind(this));\n  }\n}\n","import { ViewInstance, ViewPlugin } from \"../view\";\nimport type {\n  Parser,\n  Node,\n  ParseObjectOptions,\n  ParseObjectChildOptions,\n} from \"../parser\";\nimport { NodeType } from \"../parser\";\nimport { hasTemplateValues, hasTemplateKey } from \"../parser/utils\";\n\n/** A view plugin to resolve multi nodes */\nexport default class MultiNodePlugin implements ViewPlugin {\n  applyParser(parser: Parser) {\n    parser.hooks.parseNode.tap(\n      \"multi-node\",\n      (\n        obj: any,\n        nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        childOptions?: ParseObjectChildOptions,\n      ) => {\n        if (\n          childOptions &&\n          !hasTemplateKey(childOptions.key) &&\n          Array.isArray(obj)\n        ) {\n          const values = obj\n            .map((childVal) =>\n              parser.parseObject(childVal, NodeType.Value, options),\n            )\n            .filter((child): child is Node.Node => !!child);\n\n          if (!values.length) {\n            return [];\n          }\n\n          const multiNode = parser.createASTNode(\n            {\n              type: NodeType.MultiNode,\n              override: !hasTemplateValues(\n                childOptions.parentObj,\n                childOptions.key,\n              ),\n              values,\n            },\n            obj,\n          );\n\n          if (!multiNode) {\n            return [];\n          }\n\n          if (multiNode.type === NodeType.MultiNode) {\n            multiNode.values.forEach((v) => {\n              v.parent = multiNode;\n            });\n          }\n\n          return [\n            {\n              path: [...childOptions.path, childOptions.key],\n              value: multiNode,\n            },\n          ];\n        }\n      },\n    );\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.parser.tap(\"multi-node\", this.applyParser.bind(this));\n  }\n}\n","import { ViewInstance, ViewPlugin } from \"../view\";\nimport type {\n  Parser,\n  Node,\n  ParseObjectOptions,\n  ParseObjectChildOptions,\n} from \"../parser\";\nimport { NodeType } from \"../parser\";\n\n/** A view plugin to resolve assets */\nexport default class AssetPlugin implements ViewPlugin {\n  applyParser(parser: Parser) {\n    parser.hooks.parseNode.tap(\n      \"asset\",\n      (\n        obj: any,\n        nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        childOptions?: ParseObjectChildOptions,\n      ) => {\n        if (childOptions?.key === \"asset\" && typeof obj === \"object\") {\n          const assetAST = parser.parseObject(obj, NodeType.Asset, options);\n\n          if (!assetAST) {\n            return [];\n          }\n\n          return [\n            {\n              path: [...childOptions.path, childOptions.key],\n              value: assetAST,\n            },\n          ];\n        }\n      },\n    );\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.parser.tap(\"asset\", this.applyParser.bind(this));\n  }\n}\n","import { SyncHook } from \"tapable-ts\";\nimport type { Navigation, NavigationFlowEndState } from \"@player-ui/types\";\nimport type { Logger } from \"../../logger\";\nimport type { TransitionOptions } from \"./flow\";\nimport { FlowInstance } from \"./flow\";\n\n/** A manager for the navigation section of a Content blob */\nexport class FlowController {\n  public readonly hooks = {\n    flow: new SyncHook<[FlowInstance]>(),\n  };\n\n  private readonly log?: Logger;\n  private navigation: Navigation;\n  private navStack: FlowInstance[];\n  public current?: FlowInstance;\n\n  constructor(\n    navigation: Navigation,\n    options?: {\n      /** A logger instance to use */\n      logger?: Logger;\n    },\n  ) {\n    this.navigation = navigation;\n    this.navStack = [];\n    this.log = options?.logger;\n\n    this.start = this.start.bind(this);\n    this.run = this.run.bind(this);\n    this.transition = this.transition.bind(this);\n    this.addNewFlow = this.addNewFlow.bind(this);\n  }\n\n  /** Navigate to another state in the state-machine */\n  public transition(stateTransition: string, options?: TransitionOptions) {\n    if (this.current === undefined) {\n      throw new Error(\"Not currently in a flow. Cannot transition.\");\n    }\n\n    this.current.transition(stateTransition, options);\n  }\n\n  private addNewFlow(flow: FlowInstance) {\n    this.navStack.push(flow);\n    this.current = flow;\n    this.hooks.flow.call(flow);\n  }\n\n  private async run(startState: string): Promise<NavigationFlowEndState> {\n    if (!Object.prototype.hasOwnProperty.call(this.navigation, startState)) {\n      return Promise.reject(new Error(`No flow defined for: ${startState}`));\n    }\n\n    const startFlow = this.navigation[startState];\n\n    if (startFlow === null || typeof startFlow !== \"object\") {\n      return Promise.reject(\n        new Error(`Flow: ${startState} needs to be an object`),\n      );\n    }\n\n    this.log?.debug(`Starting flow: ${startState}`);\n\n    const flow = new FlowInstance(startState, startFlow, { logger: this.log });\n    this.addNewFlow(flow);\n\n    flow.hooks.afterTransition.tap(\"flow-controller\", (flowInstance) => {\n      if (flowInstance.currentState?.value.state_type === \"FLOW\") {\n        const subflowId = flowInstance.currentState?.value.ref;\n        this.log?.debug(`Loading subflow ${subflowId}`);\n        this.run(subflowId).then((subFlowEndState) => {\n          this.log?.debug(\n            `Subflow ended. Using outcome: ${subFlowEndState.outcome}`,\n          );\n          flowInstance.transition(subFlowEndState?.outcome);\n        });\n      }\n    });\n\n    const end = await flow.start();\n    this.navStack.pop();\n\n    if (this.navStack.length > 0) {\n      const firstItem = 0;\n      this.current = this.navStack[firstItem];\n    }\n\n    return end;\n  }\n\n  public async start(): Promise<NavigationFlowEndState> {\n    if (!this.navigation.BEGIN) {\n      return Promise.reject(new Error(\"Must supply a BEGIN state\"));\n    }\n\n    return this.run(this.navigation.BEGIN);\n  }\n}\n","const ANY_CHAR_REGEX = /%([a-zA-Z]+)/g;\n\n/**\n * Replaces %num in message with the provided parameters in order.\n *\n * @param message - Parameterized string like \"This is a %1\"\n * @param params - Parameters to replace in message E.g. ['tax2021.amount']\n * @returns A message with the parameters replaced.\n */\nexport function replaceParams(\n  message: string,\n  params: Record<string, any>,\n): string {\n  return message\n    .slice()\n    .replace(ANY_CHAR_REGEX, (keyExpr) => params[keyExpr.slice(1)] || keyExpr);\n}\n","import type { Validation } from \"@player-ui/types\";\nimport type { ViewPlugin, Resolver, Node, ViewInstance } from \"../../view\";\nimport { NodeType } from \"../../view\";\nimport type {\n  BindingInstance,\n  BindingLike,\n  BindingFactory,\n} from \"../../binding\";\nimport { isBinding } from \"../../binding\";\nimport type { ValidationResponse } from \"../../validator\";\n\nconst CONTEXT = \"validation-binding-tracker\";\n\nexport interface BindingTracker {\n  /** Get the bindings currently being tracked for validation */\n  getBindings(): Set<BindingInstance>;\n\n  /** Add a binding to the tracked set */\n  trackBinding(binding: BindingInstance): void;\n}\ninterface Options {\n  /** Parse a binding from a view */\n  parseBinding: BindingFactory;\n\n  /** Callbacks when events happen */\n  callbacks?: {\n    /** Called when a binding is encountered for the first time in a view */\n    onAdd?: (binding: BindingInstance) => void;\n  };\n}\n\n/** A view plugin that manages bindings tracked across updates */\nexport class ValidationBindingTrackerViewPlugin\n  implements ViewPlugin, BindingTracker\n{\n  private options: Options;\n\n  private trackedBindings = new Set<BindingInstance>();\n\n  constructor(options: Options) {\n    this.options = options;\n  }\n\n  /** Fetch the tracked bindings in the current view */\n  getBindings(): Set<BindingInstance> {\n    return this.trackedBindings;\n  }\n\n  /** Add a binding to the tracked set */\n  trackBinding(binding: BindingInstance) {\n    if (this.trackedBindings.has(binding)) {\n      return;\n    }\n\n    this.trackedBindings.add(binding);\n    this.options.callbacks?.onAdd?.(binding);\n  }\n\n  /** Attach hooks to the given resolver */\n  applyResolver(resolver: Resolver) {\n    this.trackedBindings.clear();\n\n    /** Each node maps to a set of bindings that it directly tracks */\n    const tracked = new Map<Node.Node, Set<BindingInstance>>();\n\n    /** Each Node is a registered section or page that maps to a set of nodes in its section */\n    const sections = new Map<Node.Node, Set<Node.Node>>();\n\n    let lastViewUpdateChangeSet: Set<BindingInstance> | undefined;\n\n    /** Map of node to all bindings in children */\n    const lastComputedBindingTree = new Map<Node.Node, Set<BindingInstance>>();\n    let currentBindingTree = new Map<Node.Node, Set<BindingInstance>>();\n\n    /** Map of registered section nodes to bindings */\n    const lastSectionBindingTree = new Map<Node.Node, Set<BindingInstance>>();\n\n    /** Map of resolved nodes to their original nodes. */\n    const resolvedNodeMap: Map<Node.Node, Node.Node> = new Map();\n\n    resolver.hooks.beforeUpdate.tap(CONTEXT, (changes) => {\n      lastViewUpdateChangeSet = changes;\n    });\n\n    resolver.hooks.skipResolve.tap(CONTEXT, (shouldSkip, node) => {\n      const trackedBindingsForNode = lastComputedBindingTree.get(node);\n\n      if (!shouldSkip || !lastViewUpdateChangeSet || !trackedBindingsForNode) {\n        return shouldSkip;\n      }\n\n      const intersection = new Set(\n        [...lastViewUpdateChangeSet].filter((b) =>\n          trackedBindingsForNode.has(b),\n        ),\n      );\n\n      return intersection.size === 0;\n    });\n\n    resolver.hooks.resolveOptions.tap(CONTEXT, (options, node) => {\n      if (options.validation === undefined) {\n        return options;\n      }\n\n      // Clear out any old tracked bindings for this node since we're re-compiling it\n      tracked.delete(node);\n\n      /** Validation callback to track a binding */\n      const track = (binding: BindingLike) => {\n        const parsed = isBinding(binding)\n          ? binding\n          : this.options.parseBinding(binding);\n\n        if (tracked.has(node)) {\n          tracked.get(node)?.add(parsed);\n        } else {\n          tracked.set(node, new Set([parsed]));\n        }\n\n        /** find first parent registered as section and add self to its list */\n        let { parent } = node;\n\n        while (parent) {\n          if (sections.has(parent)) {\n            sections.get(parent)?.add(node);\n            break;\n          } else {\n            parent = parent.parent;\n          }\n        }\n\n        this.trackedBindings.add(parsed);\n        this.options.callbacks?.onAdd?.(parsed);\n      };\n\n      return {\n        ...options,\n        validation: {\n          ...options.validation,\n          get: (binding, getOptions) => {\n            if (getOptions?.track) {\n              track(binding);\n            }\n\n            const eows = options.validation\n              ?._getValidationForBinding(binding)\n              ?.getAll(getOptions);\n\n            const firstFieldEOW = eows?.find(\n              (eow) =>\n                eow.displayTarget === \"field\" ||\n                eow.displayTarget === undefined,\n            );\n\n            return firstFieldEOW;\n          },\n          getValidationsForBinding(binding, getOptions) {\n            if (getOptions?.track) {\n              track(binding);\n            }\n\n            return (\n              options.validation\n                ?._getValidationForBinding(binding)\n                ?.getAll(getOptions) ?? []\n            );\n          },\n          getChildren: (type?: Validation.DisplayTarget) => {\n            const validations = new Array<ValidationResponse>();\n            lastComputedBindingTree.get(node)?.forEach((binding) => {\n              const eow = options.validation\n                ?._getValidationForBinding(binding)\n                ?.get();\n\n              if (eow && (type === undefined || type === eow.displayTarget)) {\n                validations.push(eow);\n              }\n            });\n\n            return validations;\n          },\n          getValidationsForSection: () => {\n            const validations = new Array<ValidationResponse>();\n            lastSectionBindingTree.get(node)?.forEach((binding) => {\n              const eow = options.validation\n                ?._getValidationForBinding(binding)\n                ?.get();\n\n              if (eow && eow.displayTarget === \"section\") {\n                validations.push(eow);\n              }\n            });\n\n            return validations;\n          },\n          register: (registerOptions) => {\n            if (registerOptions?.type === \"section\") {\n              if (!sections.has(node)) {\n                sections.set(node, new Set());\n              }\n            }\n          },\n          track,\n        },\n      };\n    });\n\n    resolver.hooks.afterNodeUpdate.tap(\n      CONTEXT,\n      (originalNode, parent, update) => {\n        // Compute the new tree for this node\n        // If it's not-updated, use the last known value\n\n        const { updated, node: resolvedNode } = update;\n        resolvedNodeMap.set(resolvedNode, originalNode);\n\n        if (updated) {\n          const newlyComputed = new Set(tracked.get(originalNode));\n          if (resolvedNode.type === NodeType.MultiNode) {\n            resolvedNode.values.forEach((value) =>\n              currentBindingTree\n                .get(value)\n                ?.forEach((b) => newlyComputed.add(b)),\n            );\n          }\n\n          if (\"children\" in resolvedNode && resolvedNode.children) {\n            resolvedNode.children.forEach((child) => {\n              currentBindingTree\n                .get(child.value)\n                ?.forEach((b) => newlyComputed.add(b));\n            });\n          }\n\n          currentBindingTree.set(resolvedNode, newlyComputed);\n        } else {\n          currentBindingTree.set(\n            resolvedNode,\n            lastComputedBindingTree.get(originalNode) ?? new Set(),\n          );\n        }\n\n        if (originalNode === resolver.root) {\n          this.trackedBindings = new Set(currentBindingTree.get(resolvedNode));\n          lastComputedBindingTree.clear();\n          currentBindingTree.forEach((value, key) => {\n            const node = resolvedNodeMap.get(key);\n            if (node) {\n              lastComputedBindingTree.set(node, value);\n            }\n          });\n\n          lastSectionBindingTree.clear();\n          sections.forEach((nodeSet, sectionNode) => {\n            const temp = new Set<BindingInstance>();\n            nodeSet.forEach((n) => {\n              tracked.get(n)?.forEach(temp.add, temp);\n            });\n            lastSectionBindingTree.set(sectionNode, temp);\n          });\n\n          tracked.clear();\n          sections.clear();\n          currentBindingTree = new Map();\n        }\n      },\n    );\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.resolver.tap(CONTEXT, this.applyResolver.bind(this));\n  }\n}\n","export interface Store {\n  useLocalState<T>(initialState: T): readonly [T, (value: T) => void];\n  useSharedState<T>(\n    key: string | symbol,\n  ): (initialState: T) => readonly [T, (value: T) => void];\n}\n\ninterface SharedStore {\n  getLocalStateFunction<T>(\n    key: string | symbol,\n    countKey: symbol,\n  ): (initialState: T) => readonly [T, (value: T) => void];\n  useSharedState<T>(\n    key: string | symbol,\n  ): (initialState: T) => readonly [T, (value: T) => void];\n}\n\n/** A store that holds on to state for a transform */\nexport class LocalStateStore implements SharedStore {\n  private state: Map<string | symbol, any>;\n\n  private updateCallback?: () => void;\n\n  constructor(onUpdate?: () => void) {\n    this.updateCallback = onUpdate;\n\n    this.state = new Map();\n  }\n\n  public removeKey(key: symbol | string) {\n    this.state.delete(key);\n  }\n\n  public reset() {\n    this.state.clear();\n  }\n\n  useSharedState<T>(key: string | symbol) {\n    return (initialState: T) => {\n      if (!this.state.has(key)) {\n        this.state.set(key, initialState);\n      }\n\n      return [\n        this.state.get(key) as T,\n        (newState: T) => {\n          const current = this.state.get(key) as T;\n\n          this.state.set(key, newState);\n\n          if (current !== newState) {\n            this.updateCallback?.();\n          }\n        },\n      ] as const;\n    };\n  }\n\n  getLocalStateFunction<T>(key: symbol, countKey: symbol) {\n    return (initialState: T) => {\n      // initialize if not already created\n      if (!this.state.has(key)) {\n        this.state.set(key, []);\n      }\n\n      if (!this.state.has(countKey)) {\n        this.state.set(countKey, 0);\n      }\n\n      const localState = this.state.get(key);\n      const oldCount = this.state.get(countKey);\n\n      this.state.set(countKey, oldCount + 1);\n\n      if (localState.length <= oldCount) {\n        localState.push(initialState);\n      }\n\n      const value = localState[oldCount] as T;\n\n      return [\n        value,\n        (newState: T) => {\n          const oldValue = localState[oldCount] as T;\n          localState[oldCount] = newState;\n\n          if (oldValue !== newState) {\n            this.updateCallback?.();\n          }\n        },\n      ] as const;\n    };\n  }\n}\n","import type { Node } from \"../../view\";\nimport { NodeType } from \"../../view\";\nimport { LocalStateStore } from \"./store\";\nimport type { TransformRegistry } from \"./types\";\nimport type { ViewController } from \"./controller\";\n\n/** Traverse up the nodes until the target is found */\nfunction findUp(node: Node.Node, target: Node.Node): boolean {\n  if (node === target) {\n    return true;\n  }\n\n  if (node.parent) {\n    return findUp(node.parent, target);\n  }\n\n  return false;\n}\n\n/**\n * A plugin to register custom transforms on certain asset types\n * This allows users to embed stateful data into transforms.\n */\nexport class AssetTransformCorePlugin {\n  public readonly stateStore: Map<Node.Node, LocalStateStore>;\n  private readonly registry: TransformRegistry;\n  private beforeResolveSymbol: symbol;\n  private resolveSymbol: symbol;\n  private beforeResolveCountSymbol: symbol;\n  private resolveCountSymbol: symbol;\n\n  constructor(registry: TransformRegistry) {\n    this.registry = registry;\n    this.stateStore = new Map();\n    this.beforeResolveSymbol = Symbol(\"before resolve\");\n    this.resolveSymbol = Symbol(\"resolve\");\n    this.beforeResolveCountSymbol = Symbol(\"before resolve count\");\n    this.resolveCountSymbol = Symbol(\"resolve count\");\n  }\n\n  apply(viewController: ViewController) {\n    viewController.hooks.view.tap(\"asset-transform\", (view) => {\n      // Clear out everything when we create a new view\n      this.stateStore.clear();\n\n      view.hooks.resolver.tap(\"asset-transform\", (resolver) => {\n        let lastUpdatedNode: Node.Node | undefined;\n\n        /** A function to update the state and trigger a view re-compute */\n        const updateState = (node: Node.Node) => {\n          lastUpdatedNode = node;\n          view.update(new Set());\n        };\n\n        /** Given a node and a transform step, fetch a local store */\n        const getStore = (node: Node.Node, stepKey: symbol) => {\n          let store: LocalStateStore;\n          const countKey =\n            stepKey === this.resolveSymbol\n              ? this.resolveCountSymbol\n              : this.beforeResolveCountSymbol;\n\n          const storedState = this.stateStore.get(node);\n\n          if (storedState) {\n            store = storedState;\n            store.removeKey(countKey);\n          } else {\n            store = new LocalStateStore(() => {\n              updateState(node);\n            });\n            this.stateStore.set(node, store);\n          }\n\n          return {\n            useSharedState: (\n              key: string | symbol,\n            ): (<T>(initialState: T) => readonly [T, (value: T) => void]) => {\n              return store.useSharedState(key);\n            },\n            useLocalState: <T>(initialState: T) => {\n              return store.getLocalStateFunction<T>(\n                stepKey,\n                countKey,\n              )(initialState);\n            },\n          };\n        };\n\n        resolver.hooks.beforeResolve.tap(\"asset-transform\", (node, options) => {\n          if (node && (node.type === \"asset\" || node.type === \"view\")) {\n            const transform = this.registry.get(node.value);\n\n            if (transform?.beforeResolve) {\n              const store = getStore(\n                options.node ?? node,\n                this.beforeResolveSymbol,\n              );\n\n              return transform.beforeResolve(node, options, store);\n            }\n          }\n\n          return node;\n        });\n\n        resolver.hooks.afterUpdate.tap(\"asset-transform\", () => {\n          lastUpdatedNode = undefined;\n        });\n\n        resolver.hooks.skipResolve.tap(\"asset-transform\", (skip, node) => {\n          if (!skip || !lastUpdatedNode) {\n            return skip;\n          }\n\n          const isParentOfUpdated = findUp(lastUpdatedNode, node);\n          const isChildOfUpdated = findUp(node, lastUpdatedNode);\n\n          return !isParentOfUpdated && !isChildOfUpdated;\n        });\n\n        resolver.hooks.afterResolve.tap(\n          \"asset-transform\",\n          (value, node, options) => {\n            if (node.type !== NodeType.Asset && node.type !== NodeType.View) {\n              return value;\n            }\n\n            const originalNode = resolver.getSourceNode(node);\n\n            if (!originalNode) {\n              return value;\n            }\n\n            const transform = this.registry.get(value);\n\n            if (transform?.resolve) {\n              const store = getStore(originalNode, this.resolveSymbol);\n\n              return transform?.resolve(value, options, store);\n            }\n\n            return value;\n          },\n        );\n      });\n    });\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\nimport type { DataController } from \".\";\nimport type { Logger } from \"../../logger\";\nimport type { BindingLike } from \"../../binding\";\nimport type {\n  DataModelWithParser,\n  DataModelOptions,\n  Updates,\n} from \"../../data\";\n\n/** Wrapper for the Data Controller Class that prevents writes */\nexport class ReadOnlyDataController\n  implements DataModelWithParser<DataModelOptions>\n{\n  private controller: DataController;\n  private logger?: Logger;\n\n  constructor(controller: DataController, logger?: Logger) {\n    this.controller = controller;\n    this.logger = logger;\n  }\n\n  get(binding: BindingLike, options?: DataModelOptions | undefined) {\n    return this.controller.get(binding, options);\n  }\n\n  set(\n    transaction: [BindingLike, any][],\n    options?: DataModelOptions | undefined,\n  ): Updates {\n    this.logger?.error(\n      \"Error: Tried to set in a read only instance of the DataController\",\n    );\n    return [];\n  }\n\n  delete(binding: BindingLike, options?: DataModelOptions | undefined): void {\n    this.logger?.error(\n      \"Error: Tried to delete in a read only instance of the DataController\",\n    );\n  }\n}\n","import { SyncHook, SyncWaterfallHook, SyncBailHook } from \"tapable-ts\";\nimport { dequal } from \"dequal\";\nimport type { Logger } from \"../../logger\";\nimport type { BindingParser, BindingLike } from \"../../binding\";\nimport { BindingInstance } from \"../../binding\";\nimport type {\n  BatchSetTransaction,\n  Updates,\n  DataModelOptions,\n  DataModelWithParser,\n  DataPipeline,\n  DataModelMiddleware,\n} from \"../../data\";\nimport { PipelinedDataModel, LocalModel } from \"../../data\";\nimport type { RawSetTransaction } from \"../../types\";\nimport { ReadOnlyDataController } from \"./utils\";\n\n/** The orchestrator for player data */\nexport class DataController implements DataModelWithParser<DataModelOptions> {\n  public hooks = {\n    resolve: new SyncWaterfallHook(),\n    resolveDataStages: new SyncWaterfallHook<[DataPipeline]>(),\n\n    // On any set or get of an undefined value, redirect the value to be the default\n    resolveDefaultValue: new SyncBailHook<[BindingInstance], any>(),\n\n    onDelete: new SyncHook<[any]>(),\n\n    onSet: new SyncHook<[BatchSetTransaction]>(),\n\n    onGet: new SyncHook<[any, any]>(),\n\n    onUpdate: new SyncHook<[Updates, DataModelOptions | undefined]>(),\n\n    format: new SyncWaterfallHook<[any, BindingInstance]>(),\n\n    deformat: new SyncWaterfallHook<[any, BindingInstance]>(),\n\n    serialize: new SyncWaterfallHook<[any]>(),\n  };\n\n  private model?: PipelinedDataModel;\n  private trash: Set<BindingInstance>;\n  private pathResolver: BindingParser;\n  private baseMiddleware: Array<DataModelMiddleware>;\n  private logger?: Logger;\n\n  constructor(\n    model: Record<any, unknown> | undefined,\n    options: {\n      /** A means of parsing a raw binding to a Binding object */\n      pathResolver: BindingParser;\n\n      /** middleware to use. typically for validation */\n      middleware?: Array<DataModelMiddleware>;\n\n      /** A logger to use  */\n      logger?: Logger;\n    },\n  ) {\n    this.logger = options.logger;\n    const middleware = options.middleware || [];\n    this.baseMiddleware = [new LocalModel(model), ...middleware];\n\n    this.trash = new Set();\n    this.pathResolver = options.pathResolver;\n  }\n\n  public getModel(): PipelinedDataModel {\n    if (!this.model) {\n      const stages = this.hooks.resolveDataStages.call(this.baseMiddleware);\n      const model = new PipelinedDataModel();\n      model.setMiddleware(stages);\n      this.model = model;\n    }\n\n    return this.model;\n  }\n\n  private resolveDataValue(\n    binding: BindingInstance,\n    value: any,\n    deformat: boolean,\n  ) {\n    if (deformat) {\n      return this.hooks.deformat.call(value, binding);\n    }\n\n    return value;\n  }\n\n  public set(\n    transaction: RawSetTransaction,\n    options?: DataModelOptions,\n  ): Updates {\n    let normalizedTransaction: BatchSetTransaction = [];\n\n    if (Array.isArray(transaction)) {\n      normalizedTransaction = transaction.map(([binding, value]) => {\n        const parsed = this.pathResolver.parse(binding);\n\n        return [\n          parsed,\n          this.resolveDataValue(parsed, value, Boolean(options?.formatted)),\n        ];\n      }) as BatchSetTransaction;\n    } else {\n      normalizedTransaction = Object.keys(transaction).map(\n        (binding: string) => {\n          const parsed = this.pathResolver.parse(binding);\n          const val = transaction[binding];\n\n          return [\n            parsed,\n            this.resolveDataValue(parsed, val, Boolean(options?.formatted)),\n          ];\n        },\n      ) as BatchSetTransaction;\n    }\n\n    // Figure out what the base changes being applied are\n    const setUpdates = normalizedTransaction.reduce<Updates>(\n      (updates, [binding, newVal]) => {\n        const oldVal = this.get(binding, { includeInvalid: true });\n\n        const update = {\n          binding,\n          newValue: newVal,\n          oldValue: oldVal,\n        };\n\n        if (dequal(oldVal, newVal)) {\n          this.logger?.debug(\n            `Skipping update for path: ${binding.asString()}. Value was unchanged: ${oldVal}`,\n          );\n        } else {\n          updates.push(update);\n\n          this.logger?.debug(\n            `Setting path: ${binding.asString()} from: ${oldVal} to: ${newVal}`,\n          );\n        }\n\n        return updates;\n      },\n      [],\n    );\n\n    // Get the applied update\n    const result = this.getModel().set(normalizedTransaction, options);\n\n    // Add any extra bindings that were effected\n    const setUpdateBindings = new Set(setUpdates.map((su) => su.binding));\n    result.forEach((tr) => {\n      if (\n        !setUpdateBindings.has(tr.binding) &&\n        (tr.force === true || !dequal(tr.oldValue, tr.newValue))\n      ) {\n        this.logger?.debug(\n          `Path: ${tr.binding.asString()} was changed from: ${\n            tr.oldValue\n          } to: ${tr.newValue}`,\n        );\n        setUpdates.push(tr);\n      }\n    });\n\n    this.hooks.onSet.call(normalizedTransaction);\n\n    if (setUpdates.length > 0) {\n      this.hooks.onUpdate.call(setUpdates, options);\n    }\n\n    return result;\n  }\n\n  private resolve(binding: BindingLike, readOnly: boolean): BindingInstance {\n    return Array.isArray(binding) || typeof binding === \"string\"\n      ? this.pathResolver.parse(binding, { readOnly })\n      : binding;\n  }\n\n  public get(binding: BindingLike, options?: DataModelOptions) {\n    const resolved =\n      binding instanceof BindingInstance\n        ? binding\n        : this.resolve(binding, true);\n    let result = this.getModel().get(resolved, options);\n\n    if (result === undefined && !options?.ignoreDefaultValue) {\n      const defaultVal = this.hooks.resolveDefaultValue.call(resolved);\n\n      if (defaultVal !== result) {\n        result = defaultVal;\n      }\n    }\n\n    if (options?.formatted) {\n      result = this.hooks.format.call(result, resolved);\n    } else if (options?.formatted === false) {\n      result = this.hooks.deformat.call(result, resolved);\n    }\n\n    this.hooks.onGet.call(binding, result);\n\n    return result;\n  }\n\n  public delete(binding: BindingLike, options?: DataModelOptions) {\n    if (\n      typeof binding !== \"string\" &&\n      !Array.isArray(binding) &&\n      !(binding instanceof BindingInstance)\n    ) {\n      throw new Error(\"Invalid arguments: delete expects a data path (string)\");\n    }\n\n    const resolved =\n      binding instanceof BindingInstance\n        ? binding\n        : this.resolve(binding, false);\n\n    const parentBinding = resolved.parent();\n    const property = resolved.key();\n    const parentValue = this.get(parentBinding);\n\n    const existedBeforeDelete =\n      typeof parentValue === \"object\" &&\n      parentValue !== null &&\n      Object.prototype.hasOwnProperty.call(parentValue, property);\n\n    this.getModel().delete(resolved, options);\n\n    if (existedBeforeDelete && !this.get(resolved)) {\n      this.trash.add(resolved);\n    }\n\n    this.hooks.onDelete.call(resolved);\n  }\n\n  public serialize(): object {\n    return this.hooks.serialize.call(this.get(\"\"));\n  }\n\n  public makeReadOnly(): ReadOnlyDataController {\n    return new ReadOnlyDataController(this, this.logger);\n  }\n}\n","import { BindingInstance } from \"../../binding\";\n\n/** Recursively flattens a nested object to be an object of depth 1 with keys being the full path in the orginal object */\nexport function flatten(obj: any, roots: [string][] = [], sep = \".\"): any {\n  return (\n    Object\n      // find props of given object\n      .keys(obj)\n      // return an object by iterating props\n      .reduce(\n        (memo, prop) => ({\n          // create a new object\n\n          // include previously returned object\n          ...memo,\n          ...(Object.prototype.toString.call(obj[prop]) === \"[object Object]\"\n            ? // keep working if value is an object\n              flatten(obj[prop], roots.concat([prop]))\n            : // include current prop and value and prefix prop with the roots\n              { [roots.concat([prop]).join(sep)]: obj[prop] }),\n        }),\n        {},\n      )\n  );\n}\n\n/** Converts an object into a list of binding/value tuples to use with a LocalModel object */\nexport function objectToBatchSet(obj: any): [BindingInstance, any][] {\n  const flattenedObj = flatten(obj);\n  const batchTxn: [BindingInstance, any][] = [];\n\n  Object.keys(flattenedObj).forEach((key) => {\n    batchTxn.push([new BindingInstance(key), flattenedObj[key]]);\n  });\n\n  return batchTxn;\n}\n","import { LocalModel } from \"../../data\";\nimport { BindingInstance } from \"../../binding\";\nimport { objectToBatchSet } from \"./utils\";\n\nexport interface ConstantsProvider {\n  /**\n   * Function to add constants to the providers store\n   * - @param data values to add to the constants store\n   */\n  addConstants(data: Record<string, any>, namespace: string): void;\n\n  /**\n   * Function to retrieve constants from the providers store\n   *  - @param key Key used for the store access\n   *  - @param namespace namespace values were loaded under (defined in the plugin)\n   *  - @param fallback Optional - if key doesn't exist in namespace what to return (will return unknown if not provided)\n   */\n  getConstants(key: any, namespace: string, fallback?: any): any;\n\n  /**\n   * Function to set values to temporarily override certain keys in the perminant store\n   * - @param data values to override store with\n   * - @param namespace namespace to override\n   */\n  setTemporaryValues(data: any, namespace: string): void;\n\n  /**\n   * Clears any temporary values that were previously set\n   */\n  clearTemporaryValues(): void;\n}\n\n/**\n * Key/Value store for constants and context for Player\n */\nexport class ConstantsController implements ConstantsProvider {\n  /**\n   * Data store is basically a map of namespaces to DataModels to provide some data isolation\n   */\n  private store: Map<string, LocalModel>;\n\n  /**\n   * Separate store for temporary flow specific overrides.\n   * They are kept in a separate data model to make clearing it easier between flows\n   * and so there is no confusion on what is static and what is temporary\n   */\n  private tempStore: Map<string, LocalModel>;\n\n  constructor() {\n    this.store = new Map();\n    this.tempStore = new Map();\n  }\n\n  addConstants(data: any, namespace: string): void {\n    if (this.store.has(namespace)) {\n      this.store.get(namespace)?.set(objectToBatchSet(data));\n    } else {\n      this.store.set(namespace, new LocalModel(data));\n    }\n  }\n\n  getConstants(key: string, namespace: string, fallback?: any): any {\n    const path = new BindingInstance(key);\n\n    return (\n      this.tempStore.get(namespace)?.get(path) ??\n      this.store.get(namespace)?.get(path) ??\n      fallback\n    );\n  }\n\n  setTemporaryValues(data: any, namespace: string): void {\n    if (this.tempStore.has(namespace)) {\n      this.tempStore.get(namespace)?.set(objectToBatchSet(data));\n    } else {\n      this.tempStore.set(namespace, new LocalModel(data));\n    }\n  }\n\n  clearTemporaryValues(namespace?: string): void {\n    if (namespace) {\n      this.tempStore.get(namespace)?.reset();\n    } else {\n      this.tempStore.forEach((value: LocalModel) => {\n        value.reset();\n      });\n    }\n  }\n}\n","import type {\n  Expression,\n  ExpressionObject,\n  NavigationFlowState,\n} from \"@player-ui/types\";\nimport type { ExpressionEvaluator, ExpressionType } from \"../expressions\";\nimport type { FlowInstance } from \"../controllers\";\nimport type { Player, PlayerPlugin } from \"../player\";\n\n/**\n * A plugin that taps into the flow controller to evaluate available expressions\n * Expressions can be exposed via lifecycle \"hooks\" in flow/state nodes\n * e.g: onStart, onEnd\n */\nexport class FlowExpPlugin implements PlayerPlugin {\n  name = \"flow-exp-plugin\";\n\n  apply(player: Player) {\n    let expressionEvaluator: ExpressionEvaluator | undefined;\n\n    /**\n     * Eval Helper\n     *\n     * @param exp - an expression to be evaluated\n     */\n    const handleEval = (exp: Expression | ExpressionObject) => {\n      if (exp) {\n        if (typeof exp === \"object\" && \"exp\" in exp) {\n          expressionEvaluator?.evaluate(exp.exp);\n        } else {\n          expressionEvaluator?.evaluate(exp as ExpressionType);\n        }\n      }\n    };\n\n    player.hooks.expressionEvaluator.tap(this.name, (evaluator) => {\n      expressionEvaluator = evaluator;\n    });\n\n    player.hooks.flowController.tap(this.name, (fc) => {\n      fc.hooks.flow.tap(this.name, (flow: FlowInstance) => {\n        // Eval flow nodes\n        flow.hooks.onStart.tap(this.name, (exp) => handleEval(exp));\n\n        flow.hooks.onEnd.tap(this.name, (exp) => handleEval(exp));\n        // Eval state nodes\n        flow.hooks.resolveTransitionNode.intercept({\n          call: (nextState: NavigationFlowState) => {\n            if (nextState?.onStart) {\n              handleEval(nextState.onStart);\n            }\n          },\n        });\n      });\n    });\n  }\n}\n","import type { ExpressionHandler, ExpressionType } from \"../expressions\";\nimport type { SchemaController } from \"../schema\";\nimport type { Player, PlayerPlugin } from \"../player\";\n\n/** Gets formatter for given formatName and formats value if found, returns value otherwise */\nconst createFormatFunction = (schema: SchemaController) => {\n  /**\n   * The generated handler for the given schema\n   */\n  const handler: ExpressionHandler<[unknown, string], any> = (\n    ctx,\n    value,\n    formatName,\n  ) => {\n    return (\n      schema.getFormatterForType({ type: formatName })?.format(value) ?? value\n    );\n  };\n\n  return handler;\n};\n\n/**\n * A plugin that provides the out-of-the-box expressions for player\n */\nexport class DefaultExpPlugin implements PlayerPlugin {\n  name = \"flow-exp-plugin\";\n\n  apply(player: Player) {\n    let formatFunction: ExpressionHandler<[unknown, string]> | undefined;\n\n    player.hooks.schema.tap(this.name, (schemaController) => {\n      formatFunction = createFormatFunction(schemaController);\n    });\n\n    player.hooks.expressionEvaluator.tap(this.name, (expEvaluator) => {\n      if (formatFunction) {\n        expEvaluator.addExpressionFunction(\"format\", formatFunction);\n      }\n\n      expEvaluator.addExpressionFunction(\"log\", (ctx, ...args) => {\n        player.logger.info(...args);\n      });\n\n      expEvaluator.addExpressionFunction(\"debug\", (ctx, ...args) => {\n        player.logger.debug(...args);\n      });\n\n      expEvaluator.addExpressionFunction(\n        \"eval\",\n        (ctx, ...args: [ExpressionType]) => {\n          return ctx.evaluate(...args);\n        },\n      );\n    });\n  }\n}\n","import type { Flow, FlowResult } from \"@player-ui/types\";\nimport type { BindingParser, BindingLike } from \"./binding\";\nimport type { SchemaController } from \"./schema\";\nimport type { ExpressionEvaluator } from \"./expressions\";\nimport type { Logger } from \"./logger\";\nimport type {\n  ViewController,\n  DataController,\n  ValidationController,\n  FlowController,\n} from \"./controllers\";\nimport type { ReadOnlyDataController } from \"./controllers/data/utils\";\n\n/** The status for a flow's execution state */\nexport type PlayerFlowStatus =\n  | \"not-started\"\n  | \"in-progress\"\n  | \"completed\"\n  | \"error\";\n\n/** Common interface for the state of Player's flow execution */\nexport interface BaseFlowState<T extends PlayerFlowStatus> {\n  /** A unique reference for the life-cycle of a flow */\n  ref: symbol;\n\n  /** The status of the given flow */\n  status: T;\n}\n\n/** The beginning state of Player, before it's seen a flow  */\nexport type NotStartedState = BaseFlowState<\"not-started\">;\n\nexport const NOT_STARTED_STATE: NotStartedState = {\n  ref: Symbol(\"not-started\"),\n  status: \"not-started\",\n};\n\n/** Shared properties for a flow in any state of execution (in-progress, completed successfully, or errored out) */\nexport interface PlayerFlowExecutionData {\n  /** The currently executing flow */\n  flow: Flow;\n}\n\nexport interface ControllerState {\n  /** The manager for data for a flow */\n  data: DataController;\n\n  /** The view manager for a flow */\n  view: ViewController;\n\n  /** The schema manager for a flow */\n  schema: SchemaController;\n\n  /** The validation manager for a flow */\n  validation: ValidationController;\n\n  /** The expression evaluator for a flow */\n  expression: ExpressionEvaluator;\n\n  /** The manager for parsing and resolving bindings */\n  binding: BindingParser;\n\n  /** the manager for the flow state machine */\n  flow: FlowController;\n}\n\n/** A flow is currently executing */\nexport type InProgressState = BaseFlowState<\"in-progress\"> &\n  PlayerFlowExecutionData & {\n    /** A promise that resolves when the flow is completed */\n    flowResult: Promise<FlowResult>;\n\n    /** The underlying state controllers for the current flow */\n    controllers: ControllerState;\n\n    /** Allow other platforms to abort the current flow with an error  */\n    fail: (error: Error) => void;\n\n    /**\n     * The Logger for the current player instance\n     */\n    logger: Logger;\n  };\n\n/** The flow completed properly */\nexport type CompletedState = BaseFlowState<\"completed\"> &\n  PlayerFlowExecutionData &\n  FlowResult & {\n    /** Readonly Player controllers to provide Player functionality after the flow has ended */\n    controllers: {\n      /** A read only instance of the Data Controller */\n      data: ReadOnlyDataController;\n    };\n  };\n\n/** The flow finished but not successfully */\nexport type ErrorState = BaseFlowState<\"error\"> & {\n  /** The currently executing flow */\n  flow: Flow;\n\n  /** The error associated with the failed flow */\n  error: Error;\n};\n\n/** Any Player state  */\nexport type PlayerFlowState =\n  | NotStartedState\n  | InProgressState\n  | CompletedState\n  | ErrorState;\n\n// Model\n\nexport type RawSetType = [BindingLike, any];\nexport type RawSetTransaction = Record<string, any> | RawSetType[];\n","import type { Player, PlayerPlugin } from \"../player\";\nimport {\n  ApplicabilityPlugin,\n  AssetPlugin,\n  MultiNodePlugin,\n  StringResolverPlugin,\n  SwitchPlugin,\n  TemplatePlugin,\n  toNodeResolveOptions,\n} from \"../view\";\n\n/**\n * A plugin that provides the out-of-the-box expressions for player\n */\nexport class DefaultViewPlugin implements PlayerPlugin {\n  name = \"default-view-plugin\";\n\n  apply(player: Player) {\n    player.hooks.viewController.tap(this.name, (viewController) => {\n      viewController.hooks.view.tap(this.name, (view) => {\n        const pluginOptions = toNodeResolveOptions(view.resolverOptions);\n        new AssetPlugin().apply(view);\n        new SwitchPlugin(pluginOptions).apply(view);\n        new ApplicabilityPlugin().apply(view);\n        new StringResolverPlugin().apply(view);\n        const templatePlugin = new TemplatePlugin(pluginOptions);\n        templatePlugin.apply(view);\n        view.hooks.onTemplatePluginCreated.call(templatePlugin);\n        new MultiNodePlugin().apply(view);\n      });\n    });\n  }\n}\n","import type { Schema } from \"@player-ui/player\";\n\nexport const BooleanType: Schema.DataType<boolean> = {\n  type: \"BooleanType\",\n  default: false,\n  validation: [\n    {\n      type: \"oneOf\",\n      message: \"Value must be true or false\",\n      options: [true, false],\n    },\n  ],\n};\n\nexport const IntegerType: Schema.DataType<number> = {\n  type: \"IntegerType\",\n  validation: [\n    {\n      type: \"integer\",\n    },\n  ],\n  format: {\n    type: \"integer\",\n  },\n};\n\nexport const IntegerPosType: Schema.DataType<number> = {\n  type: \"IntegerPosType\",\n  validation: [\n    {\n      type: \"integer\",\n    },\n    {\n      type: \"min\",\n      value: 1,\n    },\n  ],\n  format: {\n    type: \"integer\",\n  },\n};\n\nexport const IntegerNNType: Schema.DataType<number> = {\n  type: \"IntegerNNType\",\n  validation: [\n    {\n      type: \"integer\",\n    },\n    {\n      type: \"min\",\n      value: 0,\n    },\n  ],\n  format: {\n    type: \"integer\",\n  },\n};\n\nexport const StringType: Schema.DataType<string> = {\n  type: \"StringType\",\n  default: \"\",\n  validation: [\n    {\n      type: \"string\",\n    },\n  ],\n  format: {\n    type: \"string\",\n  },\n};\n\nexport const CollectionType: Schema.DataType<Array<unknown>> = {\n  type: \"CollectionType\",\n  validation: [\n    {\n      type: \"collection\",\n    },\n  ],\n};\n\nexport const DateType: Schema.DataType<string> = {\n  type: \"DateType\",\n  validation: [\n    {\n      type: \"string\",\n    },\n  ],\n  format: {\n    type: \"date\",\n  },\n};\n\nexport const PhoneType: Schema.DataType<string> = {\n  type: \"PhoneType\",\n  validation: [\n    {\n      type: \"phone\",\n    },\n  ],\n  format: {\n    type: \"phone\",\n  },\n};\n","import type { FormatType } from \"@player-ui/player\";\nimport { createMaskedNumericFormatter } from \"./utils\";\n\nconst LENGTH_OF_MAX_INT = String(Number.MAX_SAFE_INTEGER).split(\"\").length;\n\n/**\n * Converts an integer to and from a string for display\n */\nexport const integer: FormatType<number, string> = {\n  name: \"integer\",\n\n  /** Converts any integer to a string */\n  format: (value) => {\n    if (value === \"-\") {\n      return value;\n    }\n\n    const formatted = integer.deformat?.(value) ?? value;\n\n    if (typeof formatted === \"number\") {\n      return String(formatted);\n    }\n\n    return \"\";\n  },\n\n  /** Converts any string or number to an integer */\n  deformat: (value) => {\n    if (typeof value === \"number\") {\n      // Handle different zeros. Math.floor(-0) is still -0\n      return Math.floor(value) + 0;\n    }\n\n    if (typeof value !== \"string\") {\n      return;\n    }\n\n    const isNeg = value.replace(/[^0-9.-]/g, \"\").charAt(0) === \"-\";\n\n    // Remove everything but digits and decimal\n    let digits = value.replace(/[^0-9.]/g, \"\");\n    const decimalPlace = digits.indexOf(\".\");\n\n    if (decimalPlace > -1) {\n      digits = digits.substring(0, decimalPlace);\n    }\n\n    if (digits.length === 0) {\n      return;\n    }\n\n    // Can't be longer than the biggest int\n    digits = digits.substr(0, LENGTH_OF_MAX_INT);\n\n    const num = Number(`${isNeg ? \"-\" : \"\"}${digits}`);\n\n    // Handle different zeros. Math.floor(-0) is still -0\n    return Math.floor(num) + 0;\n  },\n};\n\n/** Converts a number to/from a comma separated version */\nexport const commaNumber: FormatType<\n  number,\n  string,\n  {\n    /** The number of decimal places to show */\n    precision?: number;\n  }\n> = {\n  name: \"commaNumber\",\n\n  /** Go from number to number w/ commas */\n  format: (_value, options) => {\n    if (_value === undefined || _value === \"\") {\n      return _value;\n    }\n\n    if (typeof _value !== \"string\" && typeof _value !== \"number\") {\n      return \"\";\n    }\n\n    const value = String(_value);\n\n    // Check to see if first valid char is a negative\n    const isNeg = value.replace(/[^0-9.-]/g, \"\").charAt(0) === \"-\";\n    // Remove everything but digits and decimal\n    let digitAndDecimal = value.replace(/[^0-9.]/g, \"\");\n    // Remove extra leading zeros\n    digitAndDecimal = digitAndDecimal.replace(/^(0*)((0.)?\\d)/g, \"$2\");\n\n    // Find index of first decimal point, for insertion later\n    const firstDecimal = digitAndDecimal.indexOf(\".\");\n\n    // Remove all non-digits i.e. extra decimal points\n    const digitsOnly = digitAndDecimal.replace(/[^0-9]/g, \"\");\n\n    let preDecDigits = digitsOnly;\n    let postDecDigits = \"\";\n\n    if (firstDecimal >= 0) {\n      preDecDigits = digitsOnly\n        .substring(0, firstDecimal)\n        .substr(0, LENGTH_OF_MAX_INT);\n      postDecDigits = digitsOnly.substring(firstDecimal);\n    } else {\n      preDecDigits = preDecDigits.substr(0, LENGTH_OF_MAX_INT);\n    }\n\n    if (options?.precision !== undefined) {\n      postDecDigits = postDecDigits\n        .substring(0, options.precision)\n        .padEnd(options.precision, \"0\");\n    }\n\n    // Beautify\n    preDecDigits = preDecDigits.replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n    if (preDecDigits === \"\" && firstDecimal === 0) {\n      preDecDigits = \"0\";\n    }\n\n    // Put pieces together\n    let retVal = preDecDigits;\n\n    if (isNeg) {\n      retVal = `-${retVal}`;\n    }\n\n    if (\n      (firstDecimal >= 0 || options?.precision !== undefined) &&\n      postDecDigits !== \"\"\n    ) {\n      retVal += `.${postDecDigits}`;\n    }\n\n    return retVal;\n  },\n\n  /** Go from string with comma's to numbers */\n  deformat: (value) => {\n    if (typeof value !== \"string\") {\n      return value;\n    }\n\n    const strValue = value.replace(/,/g, \"\");\n\n    if (strValue === \"\") {\n      return undefined;\n    }\n\n    const number = Number(strValue);\n\n    return isNaN(number) ||\n      number > Number.MAX_SAFE_INTEGER ||\n      number < Number.MIN_SAFE_INTEGER\n      ? undefined\n      : number;\n  },\n};\n\nexport const date: FormatType<\n  string,\n  string,\n  {\n    /** The mask to use to format the date */\n    mask?: string;\n  }\n> = {\n  name: \"date\",\n\n  format: (_value, options) => {\n    let value = typeof _value === \"number\" ? String(_value) : _value;\n    if (_value === undefined) {\n      return undefined;\n    }\n\n    if (typeof value !== \"string\" || value === \"\") {\n      return \"\";\n    }\n\n    // matching anything in DDDD-DD-DD format, including invalid date like 1111-99-99\n    if (value.match(/^\\d{4}[-]\\d{1,2}[-]\\d{1,2}$/)) {\n      const tempVal = value.split(\"-\");\n      value = `${tempVal[1]}/${tempVal[2]}/${tempVal[0]}`;\n    }\n\n    const dateFormat = options?.mask?.toUpperCase() ?? \"MM/DD/YYYY\";\n\n    const delimiter = dateFormat.replace(/[^/.-]/g, \"\").charAt(0);\n    const formatParts = dateFormat.split(delimiter);\n    const valueParts = value.split(delimiter);\n    const processedValueParts = [];\n    let lastMatchIsFull = true;\n\n    for (let index = 0; index < valueParts.length; index++) {\n      let part = valueParts[index];\n\n      if (lastMatchIsFull && index < formatParts.length) {\n        // Remove all non-digits\n        part = part.replace(/[^0-9]/g, \"\");\n        const isLastExpectedField = formatParts.length - 1 === index;\n        const hasDelimiterAfter = valueParts.length - 1 > index;\n        const curFormat = formatParts[index];\n\n        if (curFormat === \"YYYY\") {\n          if (part.length > 4) {\n            valueParts[index + 1] = [\n              \"*\",\n              part.substring(4),\n              valueParts[index + 1],\n            ].join(\"\");\n            part = part.substring(0, 4);\n          }\n\n          if (part.length === 4) {\n            lastMatchIsFull = true;\n            processedValueParts.push(part);\n          }\n\n          if (part.length === 3) {\n            if (isLastExpectedField || !hasDelimiterAfter) {\n              lastMatchIsFull = false;\n              processedValueParts.push(part);\n            } else {\n              valueParts[index + 1] = `*${part.substring(2)}${\n                valueParts[index + 1]\n              }`;\n              part = part.substring(0, 2);\n            }\n          }\n\n          if (part.length === 2) {\n            // Autocomplete completes 2 digit years based on rule:\n            // If autocompleted year is in this millennium up to this year + 2\n            // Else put it in the last millennium\n            // 19 and 20 aren't autocompleted unless there is a separator after\n            let autocomplete;\n\n            // If user didn't enter 2 digits, don't autocomplete YYYY\n            // Otherwise, 19 and 20 aren't autocompleted unless there is a separator after\n            if (\n              part.length === 2 &&\n              (hasDelimiterAfter ||\n                (isLastExpectedField && part !== \"19\" && part !== \"20\"))\n            ) {\n              autocomplete = `20${part}`;\n\n              if (\n                part > (new Date().getFullYear() + 5).toString().substring(2)\n              ) {\n                autocomplete = `19${part}`;\n              }\n            }\n\n            if (autocomplete) {\n              lastMatchIsFull = true;\n              processedValueParts.push(autocomplete);\n            } else {\n              lastMatchIsFull = false;\n              processedValueParts.push(part);\n            }\n          }\n\n          if (part.length === 1 || part.length === 0) {\n            lastMatchIsFull = false;\n            processedValueParts.push(part);\n          }\n        } else if (curFormat === \"YY\") {\n          if (part.length > 2) {\n            valueParts[index + 1] = [\n              \"*\",\n              part.substring(2),\n              valueParts[index + 1],\n            ].join(\"\");\n            part = part.substring(0, 2);\n          }\n\n          if (part.length === 2) {\n            lastMatchIsFull = true;\n            processedValueParts.push(part);\n          }\n\n          if (part.length === 1 || part.length === 0) {\n            lastMatchIsFull = false;\n            processedValueParts.push(part);\n          }\n        } else {\n          // Only MM and DD left\n          if (part.length > 2) {\n            valueParts[index + 1] = [\n              \"*\",\n              part.substring(2),\n              valueParts[index + 1],\n            ].join(\"\");\n            part = part.substring(0, 2);\n          }\n\n          if (part.length === 2) {\n            // 00 isn't a valid month or day,\n            // but if they typed in a delimiter,\n            // let them deal with it being wrong\n            if (part === \"00\" && !hasDelimiterAfter) {\n              lastMatchIsFull = false;\n              processedValueParts.push(\"0\");\n            } else {\n              lastMatchIsFull = true;\n              processedValueParts.push(part);\n            }\n          }\n\n          if (part.length === 1) {\n            if (hasDelimiterAfter) {\n              lastMatchIsFull = true;\n              processedValueParts.push(`0${part}`);\n            } else {\n              lastMatchIsFull = false;\n              processedValueParts.push(part);\n            }\n          }\n\n          if (part.length === 0) {\n            lastMatchIsFull = false;\n            processedValueParts.push(part);\n          }\n        }\n      }\n    }\n\n    return processedValueParts.join(delimiter);\n  },\n};\n\nexport const currency: FormatType<\n  number,\n  string,\n  {\n    /** The symbol to use for currency */\n    currencySymbol?: string;\n\n    /** Use parenthesis instead of a - sign for negative values */\n    useParensForNeg?: boolean;\n\n    /** The number of decimal places to show */\n    precision?: number;\n  }\n> = {\n  name: \"currency\",\n  format: (_value, options) => {\n    const value = typeof _value === \"number\" ? String(_value) : _value;\n    const {\n      currencySymbol = \"\",\n      useParensForNeg = false,\n      precision = 2,\n    } = options ?? {};\n\n    if (value === undefined || value === \"\") {\n      return value;\n    }\n\n    if (typeof value !== \"string\") {\n      return value;\n    }\n\n    const sign = /^\\s*-/.test(value) ? -1 : 1;\n    const dotIndex = value.indexOf(\".\");\n\n    let preDecimal: string;\n    let postDecimal: string;\n\n    // Strip out non-digits\n    // Check if first non-empty character is a minus sign\n    if (dotIndex >= 0) {\n      preDecimal = value.substr(0, dotIndex).replace(/\\D+/g, \"\");\n      postDecimal = value.substr(dotIndex + 1).replace(/\\D+/g, \"\");\n    } else {\n      preDecimal = value.replace(/\\D+/g, \"\");\n      postDecimal = \"0\";\n    }\n\n    const numericalValue = sign * Number(`${preDecimal}.${postDecimal}`);\n\n    const fixedString = numericalValue.toFixed(precision);\n\n    // Beautify - add commas between groups of 3 digits\n    // Would need to split the string first if we had more than 3 decimal places\n    const prettyString = fixedString.replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n\n    if (prettyString.charAt(0) === \"-\") {\n      if (useParensForNeg) {\n        return `(${currencySymbol}${prettyString.substring(1)})`;\n      }\n\n      return `-${currencySymbol}${prettyString.substring(1)}`;\n    }\n\n    return currencySymbol + prettyString;\n  },\n  deformat: (value, options) => {\n    if (typeof value === \"number\") {\n      return value;\n    }\n\n    if (typeof value !== \"string\") {\n      return undefined;\n    }\n\n    let deformatted = value;\n\n    if (options?.currencySymbol) {\n      deformatted = value.replace(options.currencySymbol, \"\");\n    }\n\n    return commaNumber.deformat?.(deformatted);\n  },\n};\n\nconst basePhoneFormatter = createMaskedNumericFormatter(\n  \"phone\",\n  \"(###) ###-####\",\n);\n\nexport const phone: FormatType<string> = {\n  ...basePhoneFormatter,\n  deformat: (value) => basePhoneFormatter.deformat?.(value),\n  format: (value) =>\n    basePhoneFormatter.format?.(value === \"(\" ? \"\" : value) ?? value,\n};\n","import type { FormatType } from \"@player-ui/player\";\n\nexport const PLACEHOLDER = \"#\";\n\n/**\n * Remove any formatting characters in the 'mask' from 'value'\n *\n * @param value - The string to remove the control characters from\n * @param mask - The mask to use and test against\n * @param reserved - The reserved _slots_ (these are the chars that you expect new values to be subbed into)\n *\n * @example\n * removeFormatCharactersFromMaskedString('123-456', '###-###', ['#']) => '123456'\n */\nexport const removeFormatCharactersFromMaskedString = (\n  value: string,\n  mask: string,\n  reserved: string[] = [PLACEHOLDER],\n): string => {\n  const reservedMatchesLength = mask\n    .split(\"\")\n    .filter((val) => reserved.includes(val)).length;\n  let replacements = 0;\n\n  return value.split(\"\").reduce((newString, nextChar, nextIndex) => {\n    const maskedVal = mask[nextIndex];\n\n    if (maskedVal === undefined) {\n      return newString;\n    }\n\n    if (reservedMatchesLength === replacements) {\n      return newString;\n    }\n\n    if (reserved.includes(maskedVal)) {\n      replacements++;\n      return newString + nextChar;\n    }\n\n    /**\n     * Characters will match when the incoming value is formatted, but in cases\n     * where it's being pulled from the model and deformatted again, ensure we\n     * don't skip over characters.\n     */\n    if (maskedVal !== nextChar) {\n      replacements++;\n      return newString + nextChar;\n    }\n\n    return newString;\n  }, \"\");\n};\n\n/**\n * Format the given string using one of the accepted values\n * Optionally, the value can be choose to ignore case when formatting, or to autocomplete if only 1 option is viable\n * If no such option is viable, undefined is returned\n */\nexport const formatAsEnum = (\n  value: string,\n  acceptedValues: string[],\n  options?: {\n    /** Ignore the case of the provided value when comparing to the acceptedValues */\n    ignoreCase?: boolean;\n\n    /** If only 1 option is viable, autocomplete the value to the accepted one */\n    autocomplete?: boolean;\n  },\n): string | undefined => {\n  const autoCompletionsByOverlapCount = acceptedValues\n    .reduce<\n      Array<{\n        /** The size of the overlap (ranking) */\n        count: number;\n\n        /** One of the acceptedValues */\n        target: string;\n      }>\n    >((validCompletions, validValue) => {\n      let overlap = 0;\n\n      for (\n        let charIndex = 0;\n        charIndex < Math.min(validValue.length, value.length);\n        charIndex++\n      ) {\n        const validChar = options?.ignoreCase\n          ? validValue[charIndex].toLowerCase()\n          : validValue[charIndex];\n        const actualChar = options?.ignoreCase\n          ? value[charIndex].toLowerCase()\n          : value[charIndex];\n\n        if (validChar !== actualChar) {\n          break;\n        }\n\n        overlap += 1;\n      }\n\n      if (overlap === 0) {\n        return validCompletions;\n      }\n\n      validCompletions.push({\n        count: overlap,\n        target: validValue,\n      });\n\n      return validCompletions;\n    }, [])\n    .sort((e) => e.count);\n\n  if (autoCompletionsByOverlapCount.length === 0) {\n    return undefined;\n  }\n\n  if (autoCompletionsByOverlapCount.length === 1 && options?.autocomplete) {\n    return autoCompletionsByOverlapCount[0].target;\n  }\n\n  return autoCompletionsByOverlapCount[0].target.substr(\n    0,\n    autoCompletionsByOverlapCount[0].count,\n  );\n};\n\n/**\n * Format the given value using the mask + match\n *\n * @param value - The string value to format\n * @param valueCharMaskMatch - A regular expression that matches characters to substitute in the match. This is typically `/\\d/g` or `/\\w/g`\n * @param mask - The mask to format against. Use # as a placeholder for\n */\nexport const formatAsMasked = (\n  value: string | number,\n  valueCharMaskMatch: RegExp,\n  mask: string,\n): string => {\n  const valStr = String(value);\n  let withMask = mask;\n\n  if (valStr.trim() === \"\") {\n    return \"\";\n  }\n\n  valStr.replace(valueCharMaskMatch, (match) => {\n    withMask = withMask.replace(PLACEHOLDER, match);\n\n    return match;\n  });\n\n  return withMask.split(PLACEHOLDER)[0];\n};\n\n/**\n * Creates a format definition with the given mask\n * Use the `#` char as a placeholder for a number\n */\nexport const createMaskedNumericFormatter = (\n  name: string,\n  mask: string,\n): FormatType<\n  string,\n  string,\n  {\n    /** An enum of values that are also acceptable, and don't fall under the mask */\n    exceptions?: Array<string>;\n  }\n> => {\n  return {\n    name,\n    format: (value, options) => {\n      if (typeof value !== \"string\") {\n        return value;\n      }\n\n      if (options?.exceptions && options.exceptions.length > 0) {\n        const formattedUsingExceptions = formatAsEnum(\n          value,\n          options.exceptions,\n          {\n            autocomplete: true,\n            ignoreCase: true,\n          },\n        );\n\n        if (formattedUsingExceptions !== undefined) {\n          return formattedUsingExceptions;\n        }\n      }\n\n      return formatAsMasked(value, /\\d/g, mask);\n    },\n    deformat: (value, options) => {\n      if (typeof value !== \"string\") {\n        return value;\n      }\n\n      if (options?.exceptions && options.exceptions.length > 0) {\n        const usingExceptions = formatAsEnum(value, options.exceptions, {\n          autocomplete: false,\n          ignoreCase: false,\n        });\n\n        if (usingExceptions !== undefined) {\n          return usingExceptions;\n        }\n      }\n\n      return formatAsMasked(value, /\\d/g, mask.replace(/[^#]/g, \"\"));\n    },\n  };\n};\n"]}