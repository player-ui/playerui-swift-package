{"version":3,"sources":["/home/circleci/.cache/bazel/_bazel_circleci/e8362d362e14c7d23506d1dfa3aea8b8/sandbox/processwrapper-sandbox/1838/execroot/_main/bazel-out/k8-fastbuild/bin/plugins/computed-properties/core/dist/index.global.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/computed-properties/core/src/index.ts"],"names":["ComputedPropertiesPlugin","__defProp","Object","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__hasOwnProp","prototype","hasOwnProperty","__export","target","all","name","get","enumerable","__copyProps","to","from","except","desc","key","call","__toCommonJS","mod","value","src_exports","apply","player","schemaController","expressionEvaluator","getExpressionType","binding","dataType","getType","type","computedPropertyMiddleware","options","next","expType","exp","result","evaluate","context","default","set","transaction","setOperation","Error","asString","delete","hooks","dataController","tap","resolveDataStages","dataPipeline","schema","evaluator"],"mappings":"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","sourcesContent":["\"use strict\";\nvar ComputedPropertiesPlugin = (() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __export = (target, all) => {\n    for (var name in all)\n      __defProp(target, name, { get: all[name], enumerable: true });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/computed-properties/core/src/index.ts\n  var src_exports = {};\n  __export(src_exports, {\n    ComputedPropertiesPlugin: () => ComputedPropertiesPlugin\n  });\n  var ComputedPropertiesPlugin = class {\n    constructor() {\n      this.name = \"ComputedProperties\";\n    }\n    apply(player) {\n      let schemaController;\n      let expressionEvaluator;\n      const getExpressionType = (binding) => {\n        const dataType = schemaController?.getType(binding);\n        if (dataType?.type === \"Expression\") {\n          return dataType;\n        }\n      };\n      const computedPropertyMiddleware = {\n        name: this.name,\n        get(binding, options, next) {\n          const expType = getExpressionType(binding);\n          if (expType) {\n            const { exp } = expType;\n            const result = exp && expressionEvaluator?.evaluate(exp, options?.context);\n            return result ?? expType.default;\n          }\n          return next?.get(binding, options);\n        },\n        set(transaction, options, next) {\n          for (const setOperation of transaction) {\n            if (getExpressionType(setOperation[0])) {\n              throw new Error(\n                `Invalid 'set' operation on computed property: ${setOperation[0].asString()}`\n              );\n            }\n          }\n          return next?.set(transaction, options) ?? [];\n        },\n        delete(binding, options, next) {\n          if (getExpressionType(binding)) {\n            throw new Error(\n              `Invalid 'delete' operation on computed property: ${binding.asString()}`\n            );\n          }\n          return next?.delete(binding, options);\n        }\n      };\n      player.hooks.dataController.tap(this.name, (dataController) => {\n        dataController.hooks.resolveDataStages.tap(this.name, (dataPipeline) => {\n          return [...dataPipeline, computedPropertyMiddleware];\n        });\n      });\n      player.hooks.schema.tap(this.name, (schema) => {\n        schemaController = schema;\n      });\n      player.hooks.expressionEvaluator.tap(this.name, (evaluator) => {\n        expressionEvaluator = evaluator;\n      });\n    }\n  };\n  return __toCommonJS(src_exports);\n})();\n","import type {\n  Player,\n  PlayerPlugin,\n  ExpressionEvaluator,\n  Schema,\n  Expression,\n  DataModelMiddleware,\n  Updates,\n  SchemaController,\n  BindingInstance,\n} from \"@player-ui/player\";\n\nexport interface ExpressionDataType extends Schema.DataType<\"Expression\"> {\n  /** The expression to evaluate to compute the value of this node */\n  exp?: Expression;\n}\n\n/**\n * A player plugin to manage beacon events.\n * It automatically keeps track of the current user's view, and adds additional metaData to each beacon event.\n */\nexport class ComputedPropertiesPlugin implements PlayerPlugin {\n  name = \"ComputedProperties\";\n\n  apply(player: Player) {\n    // Inject a middleware into the data-model to intercept any calls to an expression type in the schema\n    // Calls to `set` throw an error. Calls to `get` compute the value and return if or default\n\n    let schemaController: SchemaController | undefined;\n    let expressionEvaluator: ExpressionEvaluator | undefined;\n\n    /** Look up the data-type of the binding, and check for an Expression type */\n    const getExpressionType = (\n      binding: BindingInstance,\n    ): ExpressionDataType | undefined => {\n      // Check to see if the data-type of the binding is an `Expression`\n      const dataType = schemaController?.getType(binding);\n\n      if (dataType?.type === \"Expression\") {\n        return dataType as ExpressionDataType;\n      }\n    };\n\n    const computedPropertyMiddleware: DataModelMiddleware = {\n      name: this.name,\n      get(binding, options, next) {\n        const expType = getExpressionType(binding);\n\n        if (expType) {\n          const { exp } = expType;\n          const result =\n            exp && expressionEvaluator?.evaluate(exp, options?.context);\n\n          return result ?? expType.default;\n        }\n\n        return next?.get(binding, options);\n      },\n      set(transaction, options, next): Updates {\n        for (const setOperation of transaction) {\n          if (getExpressionType(setOperation[0])) {\n            throw new Error(\n              `Invalid 'set' operation on computed property: ${setOperation[0].asString()}`,\n            );\n          }\n        }\n\n        return next?.set(transaction, options) ?? [];\n      },\n      delete(binding, options, next) {\n        if (getExpressionType(binding)) {\n          throw new Error(\n            `Invalid 'delete' operation on computed property: ${binding.asString()}`,\n          );\n        }\n\n        return next?.delete(binding, options);\n      },\n    };\n\n    player.hooks.dataController.tap(this.name, (dataController) => {\n      dataController.hooks.resolveDataStages.tap(this.name, (dataPipeline) => {\n        return [...dataPipeline, computedPropertyMiddleware];\n      });\n    });\n\n    player.hooks.schema.tap(this.name, (schema) => {\n      schemaController = schema;\n    });\n\n    player.hooks.expressionEvaluator.tap(this.name, (evaluator) => {\n      expressionEvaluator = evaluator;\n    });\n  }\n}\n"]}