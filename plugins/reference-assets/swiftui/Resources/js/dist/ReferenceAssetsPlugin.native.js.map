{"version":3,"sources":["/home/circleci/.cache/bazel/_bazel_circleci/e8362d362e14c7d23506d1dfa3aea8b8/sandbox/processwrapper-sandbox/2166/execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/dist/index.global.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dlv@1.1.3/node_modules/dlv/index.js","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/partial-match-registry/src/deep-partial-matcher.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/partial-match-registry/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/asset-transform/core/src/utils.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/asset-transform/core/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/action/transform.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/sorted-array@2.0.4/node_modules/sorted-array/sorted-array.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/input/transform.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/info/transform.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/image/transform.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/choice/transform.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/plugin.ts"],"names":["ReferenceAssetsPlugin","dlv_es_default","obj","key","def","p","undef","split","length","createMatcher","partialObj","pairs","traverseObj","matchFunction","searchObj","Array","from","entry","path","value","count","size","createBasicMatcher","seed","matcher","match","composeTransforms","args","reverse","fn","fns","asset","options","store","reduce","prevValue","current","composeBefore","beforeResolve","compose","beforeResolveFns","resolveFns","arg","push","resolve","maybeCompose","maybeFn","cleanupTransformRegistry","maybeRegistry","isArray","wrappedTransforms","map","Registry","registry","forEach","set","isBackAction","action","__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__commonJS","cb","mod","__require","exports","__export","target","all","name","get","enumerable","__copyProps","to","except","desc","call","__toESM","isNodeMode","__esModule","__toCommonJS","require_sorted_array","module","SortedArray","defclass","constructor","array","compare","compareDefault","index","insert","element","high","low","pos","ordering","search","remove","splice","comparing","property","a","b","define","amd","src_exports","actionTransform","choiceTransform","expPropTransform","imageTransform","infoTransform","inputTransform","format","val","binding","data","model","formatted","includeInvalid","validation","track","dataType","type","import_sorted_array","object","Map","keys","nestedPath","createSortedArray","c","initialSet","query","callbackfn","clear","isRegistryEmpty","AssetTransformPlugin","transforms","apply","player","hooks","viewController","tap","vc","transformRegistry","transform","run","exp","evaluate","skipValidation","metaData","transition","force","backIconTransform","role","skipArray","plugins","stringResolver","propertiesToSkip","indexOf","infoAsset","actions","segmentedActions","segmentedActionsArray","next","prev","getImageAlt","props","placeholder","accessibility","altText","newImage","items","rest","assetHasBinding","currentValue","resetValue","transformedChoiceItems","item","id","select","unselect","clearSelection","registerPlugin"],"mappings":"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","sourcesContent":["\"use strict\";\nvar ReferenceAssetsPlugin = (() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __export = (target, all) => {\n    for (var name in all)\n      __defProp(target, name, { get: all[name], enumerable: true });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n  var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/sorted-array@2.0.4/node_modules/sorted-array/sorted-array.js\n  var require_sorted_array = __commonJS({\n    \"../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/sorted-array@2.0.4/node_modules/sorted-array/sorted-array.js\"(exports, module) {\n      \"use strict\";\n      var SortedArray2 = function() {\n        var SortedArray3 = defclass({\n          constructor: function(array, compare) {\n            this.array = [];\n            this.compare = compare || compareDefault;\n            var length = array.length, index = 0;\n            while (index < length)\n              this.insert(array[index++]);\n          },\n          insert: function(element) {\n            var array = this.array, compare = this.compare, high = array.length - 1, low = 0, pos = -1, index, ordering;\n            while (high >= low) {\n              index = (high + low) / 2 >>> 0;\n              ordering = compare(array[index], element);\n              if (ordering < 0)\n                low = index + 1;\n              else if (ordering > 0)\n                high = index - 1;\n              else {\n                pos = index;\n                break;\n              }\n              ;\n            }\n            if (pos === -1) {\n              pos = high;\n            }\n            pos++;\n            high = array.length - 1;\n            while (pos < high && compare(element, array[pos]) === 0) {\n              pos++;\n            }\n            index = array.length;\n            array.push(element);\n            while (index > pos) {\n              array[index] = array[--index];\n            }\n            array[pos] = element;\n            return this;\n          },\n          search: function(element) {\n            var array = this.array, compare = this.compare, high = array.length - 1, low = 0, index, ordering;\n            while (high >= low) {\n              index = (high + low) / 2 >>> 0;\n              ordering = compare(array[index], element);\n              if (ordering < 0)\n                low = index + 1;\n              else if (ordering > 0)\n                high = index - 1;\n              else\n                return index;\n            }\n            return -1;\n          },\n          remove: function(element) {\n            var index = this.search(element);\n            if (index >= 0)\n              this.array.splice(index, 1);\n            return this;\n          }\n        });\n        SortedArray3.comparing = function(property, array) {\n          return new SortedArray3(array, function(a, b) {\n            return compareDefault(a[property], b[property]);\n          });\n        };\n        return SortedArray3;\n        function defclass(prototype) {\n          var constructor = prototype.constructor;\n          constructor.prototype = prototype;\n          return constructor;\n        }\n        function compareDefault(a, b) {\n          if (a < b)\n            return -1;\n          else if (a > b)\n            return 1;\n          else\n            return 0;\n        }\n      }();\n      if (typeof module === \"object\")\n        module.exports = SortedArray2;\n      if (typeof define === \"function\" && define.amd)\n        define(function() {\n          return SortedArray2;\n        });\n    }\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/index.ts\n  var src_exports = {};\n  __export(src_exports, {\n    ReferenceAssetsPlugin: () => ReferenceAssetsPlugin,\n    actionTransform: () => actionTransform,\n    choiceTransform: () => choiceTransform,\n    expPropTransform: () => expPropTransform,\n    imageTransform: () => imageTransform,\n    infoTransform: () => infoTransform,\n    inputTransform: () => inputTransform,\n    isBackAction: () => isBackAction\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/input/transform.ts\n  var inputTransform = (asset, options) => {\n    return {\n      ...asset,\n      format(val) {\n        if (asset.binding === void 0) {\n          return val;\n        }\n        return options.data.format(asset.binding, val);\n      },\n      set(val) {\n        if (asset.binding === void 0) {\n          return;\n        }\n        return options.data.model.set([[asset.binding, val]], {\n          formatted: true\n        });\n      },\n      value: asset.binding === void 0 ? \"\" : options.data.model.get(asset.binding, {\n        includeInvalid: true,\n        formatted: true\n      }),\n      validation: asset.binding === void 0 ? void 0 : options.validation?.get(asset.binding, { track: true }),\n      dataType: asset.binding === void 0 ? void 0 : options.validation?.type(asset.binding)\n    };\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+partial-match-registry@0.0.0/node_modules/@player-ui/partial-match-registry/dist/index.mjs\n  var import_sorted_array = __toESM(require_sorted_array(), 1);\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dlv@1.1.3/node_modules/dlv/dist/dlv.es.js\n  function dlv_es_default(t, e, l, n, r) {\n    for (e = e.split ? e.split(\".\") : e, n = 0; n < e.length; n++)\n      t = t ? t[e[n]] : r;\n    return t === r ? l : t;\n  }\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+partial-match-registry@0.0.0/node_modules/@player-ui/partial-match-registry/dist/index.mjs\n  function traverseObj(object, path = [], pairs = /* @__PURE__ */ new Map()) {\n    for (const key of Object.keys(object)) {\n      const val = object[key];\n      const nestedPath = [...path, key];\n      \"\";\n      if (typeof val === \"object\") {\n        traverseObj(val, nestedPath, pairs);\n      } else {\n        pairs.set(nestedPath, val);\n      }\n    }\n    return pairs;\n  }\n  function createMatcher(partialObj) {\n    const pairs = traverseObj(partialObj);\n    const matchFunction = (searchObj) => {\n      for (const entry of Array.from(pairs)) {\n        const [path, value] = entry;\n        if (dlv_es_default(searchObj, path) !== value) {\n          return false;\n        }\n      }\n      return true;\n    };\n    matchFunction.count = pairs.size;\n    return matchFunction;\n  }\n  function createBasicMatcher(seed) {\n    const matcher = (match) => seed === match;\n    matcher.count = 1;\n    return matcher;\n  }\n  var createSortedArray = () => new import_sorted_array.default([], (c) => c.matcher.count);\n  var Registry = class {\n    constructor(initialSet) {\n      this.store = createSortedArray();\n      initialSet?.forEach(([match, value]) => {\n        this.set(match, value);\n      });\n    }\n    /** Add match -> value mapping to the registry */\n    set(match, value) {\n      const matcher = typeof match === \"object\" ? createMatcher(match) : createBasicMatcher(match);\n      this.store.insert({\n        key: match,\n        value,\n        matcher\n      });\n    }\n    /** Fetch the best match in the registry */\n    get(query) {\n      for (const entry of this.store.array) {\n        if (entry.matcher(query)) {\n          return entry.value;\n        }\n      }\n    }\n    /** Loop over all entries and run callback */\n    forEach(callbackfn) {\n      for (const entry of this.store.array) {\n        callbackfn(entry);\n      }\n    }\n    /** Reset the items in the registry */\n    clear() {\n      this.store = createSortedArray();\n    }\n    /** Check if the registry is empty*/\n    isRegistryEmpty() {\n      return this.store.array.length === 0;\n    }\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+asset-transform-plugin@0.0.0/node_modules/@player-ui/asset-transform-plugin/dist/index.mjs\n  function composeTransforms(...args) {\n    const [fn, ...fns] = args.reverse();\n    return (asset, options, store) => {\n      const value = fn(asset, options, store);\n      if (!fns.length) {\n        return value;\n      }\n      return fns.reduce((prevValue, current) => {\n        return current(prevValue, options, store);\n      }, value);\n    };\n  }\n  function composeBefore(...args) {\n    return {\n      beforeResolve: composeTransforms(...args)\n    };\n  }\n  function compose(...args) {\n    const beforeResolveFns = [];\n    const resolveFns = [];\n    for (const arg of args) {\n      if (typeof arg === \"function\") {\n        resolveFns.push(arg);\n      } else {\n        if (arg?.resolve) {\n          resolveFns.push(arg.resolve);\n        }\n        if (arg?.beforeResolve) {\n          beforeResolveFns.push(arg.beforeResolve);\n        }\n      }\n    }\n    return {\n      beforeResolve: beforeResolveFns.length ? composeTransforms(...beforeResolveFns) : void 0,\n      resolve: resolveFns.length ? composeTransforms(...resolveFns) : void 0\n    };\n  }\n  function maybeCompose(maybeFn) {\n    if (typeof maybeFn === \"object\") {\n      return maybeFn;\n    }\n    return compose(maybeFn);\n  }\n  function cleanupTransformRegistry(maybeRegistry) {\n    if (Array.isArray(maybeRegistry)) {\n      const wrappedTransforms = maybeRegistry.map(([key, value]) => {\n        return [key, maybeCompose(value)];\n      });\n      return new Registry(wrappedTransforms);\n    }\n    const registry = new Registry();\n    maybeRegistry.forEach(({ key, value }) => {\n      registry.set(key, maybeCompose(value));\n    });\n    return registry;\n  }\n  var AssetTransformPlugin = class {\n    constructor(transforms) {\n      this.name = \"asset-transform\";\n      this.registry = cleanupTransformRegistry(transforms);\n    }\n    apply(player) {\n      player.hooks.viewController.tap(this.name, (vc) => {\n        this.registry.forEach(\n          ({ key, value }) => vc.transformRegistry.set(key, maybeCompose(value))\n        );\n      });\n    }\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/action/transform.ts\n  function isBackAction(action) {\n    return action.value === \"Prev\";\n  }\n  var transform = (action, options) => {\n    return {\n      ...action,\n      run() {\n        if (action.exp) {\n          options.evaluate(action.exp);\n        }\n        if (action.value) {\n          const skipValidation = action.metaData?.skipValidation;\n          options.transition?.(action.value, { force: skipValidation });\n        }\n      }\n    };\n  };\n  var backIconTransform = (action) => {\n    if (isBackAction(action) && action?.metaData?.role === void 0) {\n      return {\n        ...action,\n        metaData: {\n          ...action?.metaData,\n          role: \"back\"\n        }\n      };\n    }\n    return action;\n  };\n  var expPropTransform = (asset) => {\n    const skipArray = asset.plugins?.stringResolver?.propertiesToSkip;\n    if (skipArray && skipArray.indexOf(\"exp\") > 1) {\n      return asset;\n    }\n    return {\n      ...asset,\n      plugins: {\n        ...asset.plugins,\n        stringResolver: {\n          ...asset?.plugins?.stringResolver,\n          propertiesToSkip: [\n            ...asset.plugins?.stringResolver?.propertiesToSkip ?? [],\n            \"exp\"\n          ]\n        }\n      }\n    };\n  };\n  var actionTransform = compose(\n    transform,\n    backIconTransform,\n    composeBefore(expPropTransform)\n  );\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/info/transform.ts\n  var infoTransform = (infoAsset) => {\n    const actions = infoAsset?.actions;\n    const segmentedActions = actions?.reduce(\n      (segmentedActionsArray, action) => {\n        segmentedActionsArray[isBackAction(action.asset) ? \"prev\" : \"next\"].push(action);\n        return segmentedActionsArray;\n      },\n      { next: [], prev: [] }\n    );\n    return {\n      ...infoAsset,\n      segmentedActions\n    };\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/image/transform.ts\n  var getImageAlt = (props) => {\n    const { metaData, placeholder } = props;\n    if (metaData.accessibility)\n      return metaData.accessibility;\n    if (placeholder)\n      return placeholder;\n    return \"Image\";\n  };\n  var imageTransform = (props) => {\n    const altText = getImageAlt(props);\n    const newImage = {\n      ...props,\n      altText\n    };\n    return newImage;\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/choice/transform.ts\n  var choiceTransform = (asset, options) => {\n    const { items, binding, ...rest } = asset;\n    const assetHasBinding = binding !== void 0;\n    const currentValue = assetHasBinding ? options.data.model.get(binding, {\n      includeInvalid: true\n    }) : void 0;\n    const resetValue = () => {\n      if (assetHasBinding) {\n        return options.data.model.set([[binding, null]]);\n      }\n    };\n    const transformedChoiceItems = (items || []).map(\n      (item, index) => ({\n        ...item,\n        id: item.id ?? `${asset.id}-choice-${index}`,\n        select() {\n          if (assetHasBinding) {\n            return options.data.model.set([[binding, item.value]]);\n          }\n        },\n        unselect: resetValue\n      })\n    );\n    return {\n      ...rest,\n      binding,\n      clearSelection: resetValue,\n      items: transformedChoiceItems,\n      value: currentValue,\n      validation: assetHasBinding ? options.validation?.get(binding, { track: true }) : void 0,\n      dataType: assetHasBinding ? options.validation?.type(binding) : void 0\n    };\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/plugin.ts\n  var ReferenceAssetsPlugin = class {\n    constructor() {\n      this.name = \"reference-assets-transforms\";\n    }\n    apply(player) {\n      player.registerPlugin(\n        new AssetTransformPlugin([\n          [{ type: \"action\" }, actionTransform],\n          [{ type: \"input\" }, inputTransform],\n          [{ type: \"image\" }, imageTransform],\n          [{ type: \"info\" }, infoTransform],\n          [{ type: \"choice\" }, choiceTransform]\n        ])\n      );\n    }\n  };\n  return __toCommonJS(src_exports);\n})();\n","export default function dlv(obj, key, def, p, undef) {\n\tkey = key.split ? key.split('.') : key;\n\tfor (p = 0; p < key.length; p++) {\n\t\tobj = obj ? obj[key[p]] : undef;\n\t}\n\treturn obj === undef ? def : obj;\n}\n","import dlv from \"dlv\";\n\n/** A function that checks overlapping properties against a reference value */\nexport type Matcher = ((searchObj: object) => boolean) & {\n  /** The count represents the specificity of this matcher */\n  count: number;\n};\n\n/** Traverse an object and collect any key/value pairs including nested keys */\nfunction traverseObj(\n  object: Record<any, any>,\n  path: string[] = [],\n  pairs: Map<string[], any> = new Map(),\n): Map<string[], any> {\n  for (const key of Object.keys(object)) {\n    const val: any = object[key];\n    const nestedPath = [...path, key];\n    (\"\");\n\n    if (typeof val === \"object\") {\n      traverseObj(val, nestedPath, pairs);\n    } else {\n      pairs.set(nestedPath, val);\n    }\n  }\n\n  return pairs;\n}\n\n/** Given an object, create a function that compares any set key/value pairs in the given object against a new value */\nexport default function createMatcher(partialObj: object): Matcher {\n  // Convert the partial object into a list of [key, value] pairs;\n  const pairs = traverseObj(partialObj);\n\n  /** Generate a function to match against all of the properties we care about */\n  const matchFunction = (searchObj: object) => {\n    for (const entry of Array.from(pairs)) {\n      const [path, value] = entry;\n\n      if (dlv(searchObj, path) !== value) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  // Keep track of the specificity of the comparator\n  matchFunction.count = pairs.size;\n\n  return matchFunction;\n}\n","import SortedArray from \"sorted-array\";\nimport type { Matcher } from \"./deep-partial-matcher\";\nimport createObjectMatcher from \"./deep-partial-matcher\";\n\nexport { default as createObjectMatcher } from \"./deep-partial-matcher\";\n\n/** create a matcher function that matches exactly */\nfunction createBasicMatcher(seed: any): Matcher {\n  /** a simple matcher function that only matches itself */\n  const matcher = (match: any) => seed === match;\n  matcher.count = 1;\n\n  return matcher;\n}\n\ninterface RegistryIndex<V> {\n  /** The original object we wanted to match on  */\n  key: object;\n\n  /** The value to return */\n  value: V;\n\n  /** The matcher function for this entry */\n  matcher: Matcher;\n}\n\n/** create an empty sorted array using the matcher count */\nconst createSortedArray = <V>() =>\n  new SortedArray<RegistryIndex<V>>([], (c) => c.matcher.count);\n\n/**\n * A partial match registry is a map that uses an object to \"match\" against keys.\n * More specific matches take precedence over less specific ones.\n */\nexport class Registry<V> {\n  private store = createSortedArray<V>();\n\n  constructor(initialSet?: Array<[any, V]>) {\n    initialSet?.forEach(([match, value]) => {\n      this.set(match, value);\n    });\n  }\n\n  /** Add match -> value mapping to the registry */\n  set(match: any, value: V) {\n    const matcher =\n      typeof match === \"object\"\n        ? createObjectMatcher(match)\n        : createBasicMatcher(match);\n\n    this.store.insert({\n      key: match,\n      value,\n      matcher,\n    });\n  }\n\n  /** Fetch the best match in the registry */\n  get(query: any): V | undefined {\n    for (const entry of this.store.array) {\n      if (entry.matcher(query)) {\n        return entry.value;\n      }\n    }\n  }\n\n  /** Loop over all entries and run callback */\n  forEach(callbackfn: (value: RegistryIndex<V>) => void): void {\n    for (const entry of this.store.array) {\n      callbackfn(entry);\n    }\n  }\n\n  /** Reset the items in the registry */\n  clear() {\n    this.store = createSortedArray<V>();\n  }\n\n  /** Check if the registry is empty*/\n  isRegistryEmpty() {\n    return this.store.array.length === 0;\n  }\n}\n","import type {\n  Resolve,\n  Store,\n  BeforeTransformFunction,\n  TransformFunction,\n  TransformFunctions,\n} from \"@player-ui/player\";\n\nfunction composeTransforms(\n  ...args: TransformFunction<any>[]\n): TransformFunction<any>;\n\nfunction composeTransforms(\n  ...args: BeforeTransformFunction<any>[]\n): BeforeTransformFunction<any>;\n\n/**\n * More closely resembles the `compose` function you may have used. Performs\n * right-to-left function evaluation, but leveraging the common signature for\n * Transform Functions. The `options` and `store` is unchanging for each\n * transform since only `value` is returned, allowing them to safely be passed\n * into each transform.\n */\nfunction composeTransforms(\n  ...args: TransformFunction<any>[] | BeforeTransformFunction<any>[]\n): TransformFunction<any> | BeforeTransformFunction<any> {\n  const [fn, ...fns] = args.reverse();\n\n  return (asset: any, options: Resolve.NodeResolveOptions, store: Store) => {\n    const value = fn(asset, options, store);\n\n    if (!fns.length) {\n      return value;\n    }\n\n    return fns.reduce((prevValue, current) => {\n      return current(prevValue, options, store);\n    }, value);\n  };\n}\n\n/**\n * Helper function to make it easier to create transforms that need to be ran in\n * the `beforeResolve` hook. Just like `compose`, functions are evaluated from\n * right-to-left.\n */\nexport function composeBefore(\n  ...args: BeforeTransformFunction<any>[]\n): TransformFunctions {\n  return {\n    beforeResolve: composeTransforms(...args),\n  };\n}\n\n/**\n * Performs right-to-left function evaluation of each transform function. Unlike\n * other compose functions, this does not require unary arguments for all but the\n * last function. The value returned from each function will be used as the value\n * for the next function.\n */\nexport function compose(\n  ...args: Array<TransformFunction<any> | TransformFunctions>\n): TransformFunctions {\n  const beforeResolveFns: BeforeTransformFunction<any>[] = [];\n  const resolveFns: TransformFunction<any>[] = [];\n\n  for (const arg of args) {\n    if (typeof arg === \"function\") {\n      resolveFns.push(arg);\n    } else {\n      if (arg?.resolve) {\n        resolveFns.push(arg.resolve);\n      }\n\n      if (arg?.beforeResolve) {\n        beforeResolveFns.push(arg.beforeResolve);\n      }\n    }\n  }\n\n  return {\n    beforeResolve: beforeResolveFns.length\n      ? composeTransforms(...beforeResolveFns)\n      : undefined,\n    resolve: resolveFns.length ? composeTransforms(...resolveFns) : undefined,\n  };\n}\n","import type {\n  Player,\n  PlayerPlugin,\n  TransformRegistry,\n  TransformFunction,\n  TransformFunctions,\n} from \"@player-ui/player\";\nimport { Registry } from \"@player-ui/partial-match-registry\";\nimport { compose } from \"./utils\";\n\nexport * from \"./utils\";\nexport * from \"./propertiesToSkip\";\n\nexport type TransformType = TransformFunction<any> | TransformFunctions;\nexport type TransformRegistryEntries = Array<[any, TransformType]>;\nexport type AssetTransformInit =\n  | Registry<TransformType>\n  | TransformRegistryEntries;\n\n/**\n * Normalize asset transform values so that they are all objects that contains\n * the resolve & beforeResolve functions.\n */\nfunction maybeCompose(maybeFn: any): TransformFunctions {\n  if (typeof maybeFn === \"object\") {\n    return maybeFn;\n  }\n\n  return compose(maybeFn);\n}\n\n/**\n * Standardize each variation of Asset Registry input into the same transform\n * registry shape.\n */\nfunction cleanupTransformRegistry(\n  maybeRegistry: AssetTransformInit,\n): TransformRegistry {\n  if (Array.isArray(maybeRegistry)) {\n    const wrappedTransforms = maybeRegistry.map(([key, value]) => {\n      return [key, maybeCompose(value)] as [any, TransformFunctions];\n    });\n\n    return new Registry(wrappedTransforms);\n  }\n\n  const registry = new Registry<TransformFunctions>();\n\n  maybeRegistry.forEach(({ key, value }) => {\n    registry.set(key, maybeCompose(value));\n  });\n\n  return registry;\n}\n\n/**\n * A plugin to register custom transforms on certain asset types\n * This allows users to embed stateful data into transforms.\n */\nexport class AssetTransformPlugin implements PlayerPlugin {\n  name = \"asset-transform\";\n  public readonly registry: TransformRegistry;\n\n  constructor(transforms: AssetTransformInit) {\n    this.registry = cleanupTransformRegistry(transforms);\n  }\n\n  apply(player: Player) {\n    player.hooks.viewController.tap(this.name, (vc) => {\n      this.registry.forEach(({ key, value }) =>\n        vc.transformRegistry.set(key, maybeCompose(value)),\n      );\n    });\n  }\n}\n","import type {\n  Asset,\n  TransformFunction,\n  BeforeTransformFunction,\n} from \"@player-ui/player\";\nimport { compose, composeBefore } from \"@player-ui/asset-transform-plugin\";\nimport type { ActionAsset, TransformedAction } from \"./types\";\n\n/**\n * Function to find prev button\n */\nexport function isBackAction(action: ActionAsset): boolean {\n  return action.value === \"Prev\";\n}\n\n/**\n * Attaches the methods to execute an action to an action\n */\nconst transform: TransformFunction<ActionAsset, TransformedAction> = (\n  action,\n  options,\n) => {\n  return {\n    ...action,\n    run() {\n      if (action.exp) {\n        options.evaluate(action.exp);\n      }\n\n      if (action.value) {\n        const skipValidation = action.metaData?.skipValidation;\n        options.transition?.(action.value, { force: skipValidation });\n      }\n    },\n  };\n};\n\n/**\n * De couples back button from the back icon\n */\nconst backIconTransform: TransformFunction<ActionAsset, ActionAsset> = (\n  action,\n) => {\n  /** For previous versions of player, the back button would already have the back icon.\n   *  This ensures that the old functionality does not break and back button is still visible when they update the player.\n   */\n  if (isBackAction(action) && action?.metaData?.role === undefined) {\n    return {\n      ...action,\n      metaData: {\n        ...action?.metaData,\n        role: \"back\",\n      },\n    };\n  }\n\n  return action;\n};\n\n/**\n * Appends `exp` to the plugins.stringResolver.propertiesToSkip array or creates it if it doesn't exist\n *\n * @param asset - Asset to apply the transform to\n */\nexport const expPropTransform: BeforeTransformFunction<Asset> = (asset) => {\n  const skipArray = asset.plugins?.stringResolver?.propertiesToSkip;\n\n  if (skipArray && skipArray.indexOf(\"exp\") > 1) {\n    return asset;\n  }\n\n  return {\n    ...asset,\n    plugins: {\n      ...asset.plugins,\n      stringResolver: {\n        ...asset?.plugins?.stringResolver,\n        propertiesToSkip: [\n          ...(asset.plugins?.stringResolver?.propertiesToSkip ?? []),\n          \"exp\",\n        ],\n      },\n    },\n  };\n};\n\nexport const actionTransform = compose(\n  transform,\n  backIconTransform,\n  composeBefore(expPropTransform),\n);\n","var SortedArray = (function () {\n    var SortedArray = defclass({\n\n        constructor: function (array, compare) {\n            this.array   = [];\n            this.compare = compare || compareDefault;\n            var length   = array.length,\n                index    = 0;\n            while (index < length) this.insert(array[index++]);\n        },\n        insert: function (element) {\n            var array   = this.array,\n                compare = this.compare,\n                high    = array.length-1,\n                low     = 0,\n                pos = -1,\n                index,\n                ordering;\n\n            // The array is sorted. You must find the position of new element in O(log(n)), not O(n).\n            while (high >= low) {\n                index    = (high + low) / 2 >>> 0;\n                ordering = compare(array[index], element);                \n                if (ordering < 0) low  = index + 1;\n                else if (ordering > 0) high = index - 1;\n                else {\n                    pos = index;\n                    break;\n                };\n            }\n\n            if (pos === -1) {\n                // if element was not found, high < low.\n                pos = high;\n            }\n            // This assures that equal elements inserted after will be in a higher position in array.\n            // They can be equal for comparison purposes, but different objects with different data.\n            // Respecting the chronological order can be important for many applications.\n            pos++;\n            high = array.length-1;\n            while ((pos < high) && (compare(element, array[pos]) === 0)){\n                pos++;\n            }\n            index = array.length;\n            // Just to increase array size.\n            array.push(element);            \n            // Much faster. No need to elements swap.\n            while (index > pos) {\n                array[index] = array[--index];\n            }\n            // Set the new element on its correct position.\n            array[pos] = element;\n\n            return this;\n        },\n        search: function (element) {\n            var array   = this.array,\n                compare = this.compare,\n                high    = array.length-1,\n                low     = 0,\n                // In most languages, inner variable declaration makes the code slower.\n                index,\n                ordering;\n\n            while (high >= low) {\n                index    = (high + low) / 2 >>> 0;\n                ordering = compare(array[index], element);\n\n                     if (ordering < 0) low  = index + 1;\n                else if (ordering > 0) high = index - 1;\n                else return index;\n            }\n\n            return -1;\n        },\n        remove: function (element) {\n            var index = this.search(element);\n            if (index >= 0) this.array.splice(index, 1);\n            return this;\n        }\n    });\n\n    SortedArray.comparing = function (property, array) {\n        return new SortedArray(array, function (a, b) {\n            // This should be faster than calling functions.\n            // Besides, this way it is not needed to create useless function to return property value.\n            return compareDefault(a[property], b[property]);\n        });\n    };\n\n    return SortedArray;\n\n    function defclass(prototype) {\n        var constructor = prototype.constructor;\n        constructor.prototype = prototype;\n        return constructor;\n    }\n\n    function compareDefault(a, b) {\n        // Equality has a very low chance to happen. It should be the last option.\n        if (a < b)\n            return -1;\n        else if (a > b)\n            return 1;\n        else\n            return 0;\n    }\n}());\n\nif (typeof module === \"object\") module.exports = SortedArray;\nif (typeof define === \"function\" && define.amd)\n    define(function () { return SortedArray; });\n","export * from \"./assets\";\nexport * from \"./plugin\";\n","import type { TransformFunction } from \"@player-ui/player\";\nimport type { InputAsset, TransformedInput } from \"./types\";\n\n/**\n * Docs about the asset transform\n */\nexport const inputTransform: TransformFunction<InputAsset, TransformedInput> = (\n  asset,\n  options,\n) => {\n  return {\n    ...asset,\n    format(val) {\n      if (asset.binding === undefined) {\n        return val;\n      }\n\n      return options.data.format(asset.binding, val);\n    },\n    set(val) {\n      if (asset.binding === undefined) {\n        return;\n      }\n\n      return options.data.model.set([[asset.binding, val]], {\n        formatted: true,\n      });\n    },\n    value:\n      asset.binding === undefined\n        ? \"\"\n        : options.data.model.get(asset.binding, {\n            includeInvalid: true,\n            formatted: true,\n          }),\n    validation:\n      asset.binding === undefined\n        ? undefined\n        : options.validation?.get(asset.binding, { track: true }),\n    dataType:\n      asset.binding === undefined\n        ? undefined\n        : options.validation?.type(asset.binding),\n  };\n};\n","import type { TransformFunction } from \"@player-ui/player\";\nimport type { AssetWrapper } from \"@player-ui/player\";\nimport type { InfoAsset, InfoAssetTransform } from \"./types\";\nimport type { ActionAsset } from \"../action/types\";\nimport { isBackAction } from \"../action/transform\";\n\n/**\n * This transform should add segmentedActions to the info asset.\n * Segmented actions display side by side in larger viewports. Segmented Actions is an object of next and prev actions\n */\nexport const infoTransform: TransformFunction<InfoAsset, InfoAssetTransform> = (\n  infoAsset,\n) => {\n  const actions = infoAsset?.actions;\n  const segmentedActions = actions?.reduce(\n    (segmentedActionsArray, action) => {\n      segmentedActionsArray[\n        isBackAction(action.asset as ActionAsset) ? \"prev\" : \"next\"\n      ].push(action as AssetWrapper<ActionAsset>);\n      return segmentedActionsArray;\n    },\n    { next: [], prev: [] } as {\n      /**\n       * next is an array of next actions\n       */\n      next: Array<AssetWrapper<ActionAsset>>;\n      /**\n       * prev is an array of prev actions\n       */\n      prev: Array<AssetWrapper<ActionAsset>>;\n    },\n  );\n\n  return {\n    ...infoAsset,\n    segmentedActions,\n  };\n};\n","import type { TransformFunction } from \"@player-ui/player\";\nimport type { ImageAsset, TransformedImage } from \"./types\";\n\n/**\n * Function to retrieve the desired alt text based on passed in props.\n * @param props Image props\n * @returns The alt text for the image asset\n */\nconst getImageAlt = (props: ImageAsset): string => {\n  const { metaData, placeholder } = props;\n  if (metaData.accessibility) return metaData.accessibility;\n\n  if (placeholder) return placeholder;\n\n  return \"Image\";\n};\n\n/**\n * Sets the Image's placeholder and accessibilty\n */\nexport const imageTransform: TransformFunction<ImageAsset, TransformedImage> = (\n  props,\n) => {\n  const altText = getImageAlt(props);\n\n  const newImage = {\n    ...props,\n    altText,\n  };\n\n  return newImage;\n};\n","import type { TransformFunction } from \"@player-ui/player\";\nimport type {\n  ChoiceAsset,\n  TransformedChoice,\n  TransformedChoiceItem,\n} from \"./types\";\n\n/**\n * Docs about the asset transform\n */\nexport const choiceTransform: TransformFunction<\n  ChoiceAsset,\n  TransformedChoice\n> = (asset, options) => {\n  const { items, binding, ...rest } = asset;\n\n  const assetHasBinding = binding !== undefined;\n\n  const currentValue = assetHasBinding\n    ? options.data.model.get(binding, {\n        includeInvalid: true,\n      })\n    : undefined;\n\n  const resetValue = () => {\n    if (assetHasBinding) {\n      return options.data.model.set([[binding, null]]);\n    }\n  };\n\n  const transformedChoiceItems: TransformedChoiceItem[] = (items || []).map(\n    (item, index) => ({\n      ...item,\n      id: item.id ?? `${asset.id}-choice-${index}`,\n      select() {\n        if (assetHasBinding) {\n          return options.data.model.set([[binding, item.value]]);\n        }\n      },\n      unselect: resetValue,\n    }),\n  );\n\n  return {\n    ...rest,\n    binding,\n    clearSelection: resetValue,\n    items: transformedChoiceItems,\n    value: currentValue,\n    validation: assetHasBinding\n      ? options.validation?.get(binding, { track: true })\n      : undefined,\n    dataType: assetHasBinding ? options.validation?.type(binding) : undefined,\n  };\n};\n","import type { Player, ExtendedPlayerPlugin } from \"@player-ui/player\";\nimport { AssetTransformPlugin } from \"@player-ui/asset-transform-plugin\";\nimport type {\n  ActionAsset,\n  InputAsset,\n  ImageAsset,\n  InfoAsset,\n  TextAsset,\n  CollectionAsset,\n  ChoiceAsset,\n} from \"./assets\";\nimport {\n  inputTransform,\n  actionTransform,\n  imageTransform,\n  infoTransform,\n  choiceTransform,\n} from \"./assets\";\n\n/**\n * A plugin to add transforms for the reference assets\n */\nexport class ReferenceAssetsPlugin\n  implements\n    ExtendedPlayerPlugin<\n      [\n        ActionAsset,\n        InputAsset,\n        ImageAsset,\n        TextAsset,\n        CollectionAsset,\n        ChoiceAsset,\n      ],\n      [InfoAsset]\n    >\n{\n  name = \"reference-assets-transforms\";\n\n  apply(player: Player) {\n    player.registerPlugin(\n      new AssetTransformPlugin([\n        [{ type: \"action\" }, actionTransform],\n        [{ type: \"input\" }, inputTransform],\n        [{ type: \"image\" }, imageTransform],\n        [{ type: \"info\" }, infoTransform],\n        [{ type: \"choice\" }, choiceTransform],\n      ]),\n    );\n  }\n}\n"]}