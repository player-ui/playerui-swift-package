{"version":3,"sources":["/home/circleci/.cache/bazel/_bazel_circleci/e8362d362e14c7d23506d1dfa3aea8b8/sandbox/processwrapper-sandbox/2584/execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/dist/index.global.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dlv@1.1.3/node_modules/dlv/index.js","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/partial-match-registry/src/deep-partial-matcher.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/partial-match-registry/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/asset-transform/core/src/utils.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/asset-transform/core/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/action/transform.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/tapable-ts@0.2.4/node_modules/tapable-ts/src/utils.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/tapable-ts@0.2.4/node_modules/tapable-ts/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dequal@2.0.3/node_modules/dequal/dist/index.mjs","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/utils.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/model.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/types.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/parser.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/async.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/utils.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/evaluator.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/schema/schema.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/string-resolver/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/validator/binding-map-splice.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/parser/utils.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/resolver/utils.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/string-resolver.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/utils/replaceParams.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/validation/controller.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/constants/utils.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/sorted-array@2.0.4/node_modules/sorted-array/sorted-array.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/ts-nested-error@1.2.1/node_modules/ts-nested-error/src/nested-error.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/timm@1.7.1/node_modules/timm/lib/timm.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/p-defer@3.0.0/node_modules/p-defer/index.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/queue-microtask@1.2.3/node_modules/queue-microtask/index.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/input/transform.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/info/transform.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/image/transform.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/choice/transform.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/resolver.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/local-model.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/validator/validation-middleware.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/resolver/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/parser/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/applicability.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/player.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/flow/flow.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/view/controller.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding-grammar/ast.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding-grammar/custom/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/binding.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/dependency-tracker.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/noop-model.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/evaluator-functions.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/logger/tapableLogger.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/logger/proxyLogger.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/validator/registry.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/parser/types.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/view.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/builder/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/template.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/switch.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/multi-node.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/asset.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/view/store.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/asset-transform.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/flow/controller.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/validation/binding-tracker.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/data/utils.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/data/controller.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/constants/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/plugins/flow-exp-plugin.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/plugins/default-exp-plugin.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/types.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/async-node/core/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/async-node/core/src/utils/extractNodeFromPath.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/async-node/core/src/utils/traverseAndReplace.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/async-node/core/src/utils/unwrapAsset.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/async-node/core/src/utils/requiresAssetWrapper.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/async-node/core/src/createAsyncTransform.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/chat-message/transform.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/meta-plugin/core/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/expression/core/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/plugins/chat-ui-demo-plugin.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/plugins/reference-assets-transform-plugin.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/plugin.ts"],"names":["ReferenceAssetsPlugin","dlv_es_default","obj","key","def","p","undef","split","length","createObjectMatcher","partialObj","pairs","traverseObj","matchFunction","searchObj","Array","from","entry","path","value","count","size","createBasicMatcher","seed","matcher","match","composeTransforms","args","reverse","fn","fns","asset","options","store","reduce","prevValue","current","composeBefore","beforeResolve","compose","beforeResolveFns","resolveFns","arg","push","resolve","maybeCompose","maybeFn","cleanupTransformRegistry","maybeRegistry","isArray","wrappedTransforms","map","Registry","registry","forEach","set","isBackAction","action","equalToOrIn","check","includes","callTap","tap","ctx","context","callback","find","iter","tar","keys","dequal","isBinding","binding","maybeConvertToNum","i","asInt","parseInt","isNaN","getBindingSegments","asArray","findInArray","array","findIndex","withParser","model","parseBinding","maybeParse","readOnly","parsed","get","Error","transaction","val","delete","toModel","middleware","defaultOptions","next","resolvedOptions","constructModelForPipeline","pipeline","NOOP_MODEL","createModelWithOptions","nextModel","isExpressionNode","x","__id","ExpNodeOpaqueIdentifier","throwError","message","index","err","description","createSpanningLocation","start","end","getMaxKeyLen","maxLen","Object","prototype","hasOwnProperty","call","binaryPrecedence","opVal","binaryOps","createBinaryExpression","operator","left","right","location","type","isDecimalDigit","ch","isIdentifierStart","isIdentifierPart","isModelRefStart","ch0","ch1","OCURL_CODE","parseExpression","expr","strictMode","strict","charAtFunc","charAt","charCodeAtFunc","charCodeAt","getLocation","startChar","character","exprI","exprICode","gobbleObjects","attributes","closed","shouldDefineKey","chCode","startCharIndex","gobbleSpaces","CCURL_CODE","SQUOTE_CODE","DQUOTE_CODE","gobbleStringLiteral","COLON_CODE","gobbleExpression","COMMA_CODE","test","gobbleBinaryExpression","QUMARK_CODE","consequent","alternate","gobbleBinaryOp","toCheck","substr","maxBinopLen","tcLen","node","prec","gobbleToken","biop","biopInfo","stack","pop","PERIOD_CODE","gobbleNumericLiteral","OPAREN_CODE","gobbleVariable","OBRACK_CODE","gobbleArray","gobbleModelRef","maxUnopLen","unaryOps","argument","prefix","num","parseFloat","raw","quote","str","openBraceCount","ref","gobbleIdentifier","identifier","slice","literals","thisStr","name","gobbleArguments","termination","charIndex","String","fromCharCode","gobbleGroup","computed","object","property","CBRACK_CODE","CPAREN_CODE","callTarget","elements","nodes","chIndex","SEMCOL_CODE","body","e","error","isPromiseLike","then","Promise","catch","finally","isAwaitable","AwaitableSymbol","collateAwaitable","promises","result","all","makeAwaitable","isObjectExpression","makePromiseAwareBinaryOp","operation","a","b","async","awaitableThen","resolvedA","resolvedB","makePromiseAwareUnaryOp","resolved","handleConditionalBranching","testValue","getTrueBranch","getFalseBranch","resolveNode","branch","branchResult","parse","schema","parseQueue","shift","visited","entries","prop","nestedPath","nestedPathStr","join","expandedPaths","has","isRecord","Set","Map","ROOT","findNextExp","expStart","indexOf","DOUBLE_OPEN_CURLY","offset","workingString","substring","nextCloseCurly","DOUBLE_CLOSE_CURLY","nextOpenCurly","resolveExpressionsInString","evaluate","expMatch","newVal","expStrWithBrackets","matchStart","expString","expValue","resolveDataRefsInString","formatted","expLocation","trim","evaledVal","resolveDataRefs","traverseObject","removeBindingAndChildrenFromMap","sourceMap","targetMap","parentBinding","parent","_value","trackedBinding","contains","bindingsToRewrite","filter","relative","childIndex","sort","childPath","newSegments","newChildBinding","descendent","hasTemplateValues","localKey","template","tmpl","output","hasSwitchKey","hasTemplateKey","getNodeID","id","caresAboutDataChanges","dataChanges","dependencies","depArray","values","dataChangeArray","dep","change","toNodeResolveOptions","resolverOptions","data","formatValue","format","bindingLike","exp","evaluator","hasSomethingToResolve","bindingResolveLookup","expressionResolveLookup","resolveString","resolveOptions","replaceParams","params","replace","ANY_CHAR_REGEX","keyExpr","isSubset","subset","containingSet","createStatefulValidationObject","severity","state","isBlockingNavigation","objectToBatchSet","flattenedObj","flatten","batchTxn","BindingInstance","__create","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","__commonJS","cb","mod","__require","exports","__export","target","enumerable","__copyProps","to","except","desc","__toESM","isNodeMode","__esModule","__toCommonJS","require_sorted_array","module","SortedArray","defclass","compare","compareDefault","insert","element","high","low","pos","ordering","search","remove","splice","comparing","constructor","define","amd","require_nested_error","toError","NestedError","_NestedError","innerErrors","thisErrorReport","getErrorReport","innerError","errReport","innerErrorReports","idx","rethrow","errs","require_timm","clone","addLast","addFirst","removeLast","removeFirst","removeAt","replaceAt","getIn","setIn","update","updateIn","merge","mergeDeep","mergeIn","omit","addDefaults","default","INVALID_ARGS","IS_DEV","throwStr","msg","getKeysAndSymbols","getOwnPropertySymbols","concat","obj0","out","isObject","o","newItem","len","ptr","obj2","doSetIn","newValue","nestedObj","fnUpdate","prevVal","nextVal","c","d","f","rest","doMerge","attrs","omitList","fDoSomething","fAddDefaults","fDeep","first","fChanged","j","timm","_default","require_p_defer","pDefer","deferred","promise","reject","require_queue_microtask","queueMicrotask","bind","window","global","setTimeout","src_exports","actionTransform","chatMessageTransform","choiceTransform","expPropTransform","imageTransform","infoTransform","inputTransform","transform","includeInvalid","validation","track","dataType","import_sorted_array","createSortedArray","initialSet","query","callbackfn","clear","isRegistryEmpty","AssetTransformPlugin","transforms","apply","player","hooks","viewController","vc","transformRegistry","run","skipValidation","metaData","transition","force","backIconTransform","role","skipArray","plugins","stringResolver","propertiesToSkip","infoAsset","actions","segmentedActions","segmentedActionsArray","prev","getImageAlt","props","placeholder","accessibility","altText","newImage","items","assetHasBinding","currentValue","resetValue","transformedChoiceItems","item","select","unselect","clearSelection","InterceptionManager","interceptions","interceptionKeySet","isUsed","intercept","int","s","add","_a","_b","loop","asError","r","done","Hook","taps","Symbol","before","insertionIndex","beforeSet","t","untap","SyncHook","SyncBailHook","tapIndex","rtn","SyncWaterfallHook","tapValue","AsyncSeriesBailHook","import_ts_nested_error","import_timm","foo","bar","ctor","tmp","Date","getTime","RegExp","toString","ArrayBuffer","Uint8Array","DataView","byteLength","getInt8","isView","import_p_defer","import_queue_microtask","__defProp2","__export2","toValue","toExpression","toPath","toQuery","toConcatenatedNode","SEGMENT_SEPARATOR","OPEN_CURL","CLOSE_CURL","OPEN_BRACKET","CLOSE_BRACKET","EQUALS","SINGLE_QUOTE","DOUBLE_QUOTE","BACK_TICK","isIdentifierChar","char","charCode","matches","expected","whitespace","allowBoolValue","maybeNumber","Number","expression","regex","modelRef","parsePath","simpleSegment","segment","segments","nextSegment","optionallyQuotedSegment","singleQuote","equals","parseBracket","second","parseSegmentAndBrackets","firstSegment","bracketSegment","parts","status","_BindingInstance","factory","rawBinding","tryNum","freeze","joined","asString","bindingAsArray","descendentSegments","resolveBindingAST","bindingPathNode","updates","getValueForNode","nestedResolvedValue","convertToPath","getValue","import_ts_nested_error2","actualValue","appendPathSegments","_node","resolvedNode","beforeResolveNode","objToQuery","resolvedKey","resolvedValue","BINDING_BRACKETS_REGEX","LAZY_BINDING_REGEX","DEFAULT_OPTIONS","BindingParser","skipOptimization","parserOptions","cache","parseCache","normalizePath","ast","TypeError","getBindingForNormalizedResult","normalized","normalizedStr","created","overrides","normalizeConfig","joinedNormalizedPath","updateKeys","updateTransaction","updatedBinding","DependencyTracker","readDeps","writeDeps","namedDependencySets","namedSet","createSubset","getDependencies","trackSubset","trackDefault","getModified","readsBinding","writesBinding","reset","addReadDep","addWriteDep","addChildReadDep","DependencyModel","rootModel","NOOPDataModel","ROOT_BINDING","PipelinedDataModel","onSet","effectiveDataModel","setMiddleware","handlers","addMiddleware","handler","appliedTransaction","LocalModel","effectiveOperations","oldValue","parentValue","true","false","null","undefined","evaluator_functions_exports","conditional","deleteDataVal","getDataVal","setDataVal","waitFor","_context","condition","ifTrue","ifFalse","testResult","resolvedTest","resolveParams","andandOperator","LogicalOperators","and","ororOperator","or","DEFAULT_BINARY_OPERATORS","DEFAULT_UNARY_OPERATORS","PromiseCollectionHandler","handleArray","hasPromises","some","handleObject","resolvedAttributes","attr","keyPromise","valuePromise","leftNode","rightNode","leftResult","awaitedLeft","rightResult","ExpressionEvaluator","vars","beforeEvaluate","onError","expressionsCache","operators","binary","unary","expressions","defaultHookOptions","_execAST","_resolveNode","resolvedOpts","_nothing","_execString","evaluateAsync","addExpressionFunction","addBinaryOperator","addUnaryOperator","setExpressionVariable","getExpressionVariable","matchedExp","matched","storedAST","throwErrors","_currentValue","isAsync","expressionContext","leftVal","rightVal","argVal","expressionName","n","resolvedArgs","objVal","propVal","logger","warn","results","ele","TapableLogger","trace","debug","info","log","logHandlers","createHandler","addHandler","logHandler","removeHandler","ProxyLogger","loggerProvider","proxiedLoggerProvider","identify","SchemaController","formatters","types","bindingSchemaNormalizedCache","resolveTypeForBinding","addFormatters","addDataTypes","getValidationsForBinding","typeDef","getApparentType","vRef","trigger","normalizeBinding","cached","bindingArray","recordBinding","getType","schemaType","baseType","getTypeDefinition","getFormatterForType","formatReference","formatType","formatter","deformat","getFormatter","ValidationMiddleware","validator","shadowModelPaths","shouldIncludeInvalid","asModel","nextTransaction","includedBindings","invalidBindings","validations","isStrong","validResults","invalidResults","shadowValue","shadowBinding","ValidatorRegistry","register","NodeType","EMPTY_NODE","Parser","onParseObject","onCreateASTNode","parseNode","parseView","viewNode","parseObject","createASTNode","tapped","templateDepth","parsedNode","parseLocalObject","objToParse","children","localObj","objEntries","v","defaultValue","accumulation","localValue","newChildren","parentObj","baseAst","child","withContext","Resolver","root","skipResolve","beforeUpdate","afterUpdate","afterResolve","afterNodeUpdate","resolveCache","ASTMap","idCache","AsyncIdMap","getSourceNode","convertedAST","changes","asyncChanges","prevASTMap","prevAsyncIdMap","nextAsyncIdMap","updated","computeTree","getResolveCache","getPreviousResult","isFirstUpdate","cloneNode","clonedNode","import_timm4","rawParent","cacheUpdate","partiallyResolvedParent","dependencyModel","depModelWithParser","previousResult","previousDeps","dataChanged","shouldUseLastValue","repopulateASTMapFromCache","AST","ASTParent","resolvedASTLocal","resolvedUpdate","asyncNodesResolved","handleChildNode","childNode","originalChildNode","previousChildResult","childAST","resolvedAST","childDependencies","computedChildTree","childTreeDeps","childUpdated","childValue","override","arr","rawParentToPassIn","mValue","mTree","bindingDep","scope","CrossfieldProvider","initialView","parser","allValidations","byBinding","contentView","xfieldRefs","withDefaults","ViewInstance","onUpdate","resolver","templatePlugin","updateAsync","asyncNode","lastUpdate","rootNode","validationProvider","setTemplatePlugin","plugin","Builder","_Builder","assetWrapper","valueNode","addChild","multiNode","m","onValueReceived","newChild","updateChildrenByPath","pathToMatch","updateFn","updatedChildren","templateSymbol","TemplatePlugin","resolveTemplateSubstitutions","parseTemplate","depth","dataItem","templateSubstitutions","templateStr","JSON","stringify","flags","placement","applyParser","dynamic","getTemplateSymbolValue","aPath","bPath","pathsEqual","aPlacement","bPlacement","_nodeType","childOptions","templateAST","Boolean","applyResolverHooks","view","createPatternMatcher","testStr","startLocation","endLocation","resolveAllRefs","newNode","import_timm6","findBasePath","parentNode","original","StringResolverPlugin","propertiesToSkipCache","applyResolver","propsToSkip","nodePath","ApplicabilityPlugin","isApplicability","isApplicable","nodeType","parsedApplicability","applicabilityNode","applicability","SwitchPlugin","resolveSwitch","cases","switchCase","case","isSwitch","switchContent","dynamicSwitch","staticSwitch","switchCaseExpr","switchBody","switchAST","sCase","firstChild","MultiNodePlugin","childVal","AssetPlugin","assetAST","LocalStateStore","updateCallback","removeKey","useSharedState","initialState","newState","getLocalStateFunction","countKey","localState","oldCount","findUp","AssetTransformCorePlugin","stateStore","beforeResolveSymbol","resolveSymbol","beforeResolveCountSymbol","resolveCountSymbol","lastUpdatedNode","updateState","getStore","stepKey","storedState","useLocalState","skip","isParentOfUpdated","isChildOfUpdated","originalNode","FlowInstance","flow","isTransitioning","beforeStart","onStart","onEnd","skipTransition","beforeTransition","resolveTransitionNode","afterTransition","history","_oldState","nextState","flowPromise","state_type","startState","import_p_defer2","defer","pushHistory","transitionValue","currentState","transitions","stateName","prevState","newCurrentState","FlowController","navigation","navStack","addNewFlow","stateTransition","startFlow","firstItem","flowInstance","subflowId","subFlowEndState","outcome","BEGIN","CONTEXT","ValidationBindingTrackerViewPlugin","trackedBindings","getBindings","trackBinding","callbacks","onAdd","tracked","sections","lastViewUpdateChangeSet","lastComputedBindingTree","currentBindingTree","lastSectionBindingTree","resolvedNodeMap","shouldSkip","trackedBindingsForNode","intersection","getOptions","eows","_getValidationForBinding","getAll","firstFieldEOW","eow","displayTarget","getChildren","getValidationsForSection","registerOptions","newlyComputed","nodeSet","sectionNode","temp","SCHEMA_VALIDATION_PROVIDER_NAME","VIEW_VALIDATION_PROVIDER_NAME","VALIDATION_PROVIDER_NAME_SYMBOL","for","ValidatedBinding","possibleValidations","onDismiss","weakBindings","applicableValidations","validationsByState","load","vObj","statefulValidationObject","flat","checkIfBlocking","statefulObj","response","blocking","firstInvalid","runApplicableValidations","runner","canDismiss","phase","originalValue","dismissable","dismiss","newApplicableValidations","currentPhase","ValidationController","createValidatorRegistry","onAddValidation","onRemoveValidation","resolveValidationProviders","onTrackBinding","weakBindingTracker","setOptions","getDataMiddleware","strongValidation","updateValidationsForBinding","getValidationForBinding","newInvalidBindings","weakValidation","strongBinding","weakBinding","getValidationProviders","providers","source","provider","viewValidationProvider","getValidationsForView","tracker","onView","bindingTrackerPlugin","withoutDefault","ignoreDefaultValue","silent","validationContext","vals","valObj","trackedValidations","validationObj","validationRunner","vBinding","getValidator","dataTarget","parameters","updateValidationsForView","isNavigationTrigger","lastActiveBindings","activeBindings","updateValidations","dismissValidations","validatorRegistry","validateView","canTransition","forView","bindings","validationMapping","ViewController","initialViews","resolveView","optimizeUpdates","viewOptions","viewMap","flowController","currentView","queueUpdate","updateOptions","onDelete","viewPlugins","createViewPlugins","pendingUpdate","changedBindings","scheduled","import_queue_microtask2","getViewForRef","viewRef","matchingViewId","possibleViewIdMatch","viewId","applyViewPlugins","pluginOptions","ReadOnlyDataController","controller","DataController","resolveDataStages","resolveDefaultValue","onGet","serialize","baseMiddleware","trash","pathResolver","getModel","stages","resolveDataValue","normalizedTransaction","setUpdates","oldVal","setUpdateBindings","su","tr","defaultVal","existedBeforeDelete","makeReadOnly","roots","sep","memo","ConstantsController","tempStore","addConstants","namespace","getConstants","fallback","setTemporaryValues","clearTemporaryValues","FlowExpPlugin","expressionEvaluator","handleEval","fc","createFormatFunction","formatName","DefaultExpPlugin","formatFunction","schemaController","expEvaluator","NOT_STARTED_STATE","PLAYER_VERSION","COMMIT","_Player","config","constantsController","dataController","validationController","bindingParser","resolveFlowContent","getPlugins","findPlugin","symbol","el","applyTo","registerPlugin","getVersion","version","getCommit","commit","getState","setState","setupFlow","userContent","userFlow","flowResultDeferred","resolveStrings","transitionVal","computedTransitionVal","param","await","constants","views","utils","pluginSymbol","endState","flowResult","controllers","fail","payload","maybeUpdateState","endProps","errorState","getMatchValue","pathA","pathB","matchCount","extractNodeFromPath","matchResult","bestMatch","matchValue","traverseAndReplace","replaceFn","MultiNode","unwrapAsset","Value","requiresAssetWrapper","Asset","Applicability","defaultGetNodeId","createAsyncTransform","transformAssetType","wrapperAssetType","getNestedAsset","getAsyncNodeId","asyncNodePosition","replaceNode","unwrapped","transformed","asyncTransform","replacer","replaceFunction","otherValues","unshift","wrapperAsset","AsyncNodePluginSymbol","_AsyncNodePlugin","asyncHandler","onAsyncNode","onAsyncNodeError","applyPlugin","getPlayerInstance","playerInstance","AsyncNodePlugin","AsyncNodePluginPlugin","parseNodeAndUpdate","handleAsyncUpdate","nodeResolveCache","hasValidMapping","resolveAsyncChildren","inProgressNodes","import_queue_microtask3","runAsyncNode","Async","mappedNode","playerState","basePlugin","isDeterminedAsync","parsedAsync","parsedNodeId","asyncAST","asyncNodePlugin","MetaPlugin","ExpressionPlugin","expressionMap","createContentFromMessage","ChatUiDemoPlugin","deferredPromises","allPromiseKeys","counter","sendMessage","nodeId","content","resolveFunction","View","startsWith","res","_","expressionPlugin","ReferenceAssetsTransformPlugin","metaPlugin"],"mappings":"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","sourcesContent":["\"use strict\";\nvar ReferenceAssetsPlugin = (() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __export = (target, all) => {\n    for (var name in all)\n      __defProp(target, name, { get: all[name], enumerable: true });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n  var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/sorted-array@2.0.4/node_modules/sorted-array/sorted-array.js\n  var require_sorted_array = __commonJS({\n    \"../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/sorted-array@2.0.4/node_modules/sorted-array/sorted-array.js\"(exports, module) {\n      \"use strict\";\n      var SortedArray2 = function() {\n        var SortedArray3 = defclass({\n          constructor: function(array, compare) {\n            this.array = [];\n            this.compare = compare || compareDefault;\n            var length = array.length, index = 0;\n            while (index < length)\n              this.insert(array[index++]);\n          },\n          insert: function(element) {\n            var array = this.array, compare = this.compare, high = array.length - 1, low = 0, pos = -1, index, ordering;\n            while (high >= low) {\n              index = (high + low) / 2 >>> 0;\n              ordering = compare(array[index], element);\n              if (ordering < 0)\n                low = index + 1;\n              else if (ordering > 0)\n                high = index - 1;\n              else {\n                pos = index;\n                break;\n              }\n              ;\n            }\n            if (pos === -1) {\n              pos = high;\n            }\n            pos++;\n            high = array.length - 1;\n            while (pos < high && compare(element, array[pos]) === 0) {\n              pos++;\n            }\n            index = array.length;\n            array.push(element);\n            while (index > pos) {\n              array[index] = array[--index];\n            }\n            array[pos] = element;\n            return this;\n          },\n          search: function(element) {\n            var array = this.array, compare = this.compare, high = array.length - 1, low = 0, index, ordering;\n            while (high >= low) {\n              index = (high + low) / 2 >>> 0;\n              ordering = compare(array[index], element);\n              if (ordering < 0)\n                low = index + 1;\n              else if (ordering > 0)\n                high = index - 1;\n              else\n                return index;\n            }\n            return -1;\n          },\n          remove: function(element) {\n            var index = this.search(element);\n            if (index >= 0)\n              this.array.splice(index, 1);\n            return this;\n          }\n        });\n        SortedArray3.comparing = function(property, array) {\n          return new SortedArray3(array, function(a, b) {\n            return compareDefault(a[property], b[property]);\n          });\n        };\n        return SortedArray3;\n        function defclass(prototype) {\n          var constructor = prototype.constructor;\n          constructor.prototype = prototype;\n          return constructor;\n        }\n        function compareDefault(a, b) {\n          if (a < b)\n            return -1;\n          else if (a > b)\n            return 1;\n          else\n            return 0;\n        }\n      }();\n      if (typeof module === \"object\")\n        module.exports = SortedArray2;\n      if (typeof define === \"function\" && define.amd)\n        define(function() {\n          return SortedArray2;\n        });\n    }\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/ts-nested-error@1.2.1/node_modules/ts-nested-error/build/nested-error.js\n  var require_nested_error = __commonJS({\n    \"../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/ts-nested-error@1.2.1/node_modules/ts-nested-error/build/nested-error.js\"(exports) {\n      \"use strict\";\n      Object.defineProperty(exports, \"__esModule\", { value: true });\n      exports.toError = exports.NestedError = void 0;\n      var NestedError4 = class _NestedError extends Error {\n        /**\n         * Allocates an instance of `NestedError` with the given error `message` and\n         * optional `innerError` (which will be automatically coerced using `toError()`).\n         *\n         * @param message     Laconic error message to attach to the created `NestedError`.\n         * @param innerErrors Optional errors that will be wrapped by this higher level\n         *                    error. This value will be automatically coerced using `toError()`.\n         */\n        constructor(message, ...innerErrors) {\n          super(message);\n          const thisErrorReport = _NestedError.getErrorReport(this);\n          if (innerErrors.length === 1) {\n            const innerError = toError(innerErrors[0]);\n            this.innerErrors = [innerError];\n            const errReport = _NestedError.getErrorReport(innerError);\n            this.stack = `${thisErrorReport}\n\n======= INNER ERROR =======\n\n${errReport}`;\n            return;\n          }\n          this.innerErrors = innerErrors.map((err) => toError(err));\n          const innerErrorReports = this.innerErrors.map((error, idx) => {\n            const errReport = _NestedError.getErrorReport(error);\n            return `======= INNER ERROR (${idx + 1} of ${innerErrors.length}) =======\n\n${errReport}`;\n          }).join(\"\\n\\n\");\n          this.stack = `${thisErrorReport}\n\n${innerErrorReports}`;\n        }\n        /**\n         * Provides the first `Error` of the `innerErrors` (if it exists);\n         * otherwise, `null`.\n         *\n         * @deprecated Please shift to using the `innerErrors` (with an 's') property.\n         */\n        get innerError() {\n          return this.innerErrors.length === 0 ? null : this.innerErrors[0];\n        }\n        /**\n         * Returns the function that accepts any value that was thrown as the first argument and\n         * throws it wrapped into `NestedError` or class derived from `NestedError` (provided\n         * this method was called directly in the context of that dervied class constructor)\n         * with the given `message`.\n         * Returned function will pass accepted `Error` object directly to `NestedError`\n         * as `innerErrors` by invoking `toError(err)` on it.\n         *\n         * You'll most likely want to use this method with promises:\n         *\n         * ```ts\n         * userService.getPage().then(\n         *     data => console.log(`Hooray! data: ${data}`),\n         *     NestedError.rethrow('failed to fetch users page')\n         * );\n         * ```\n         *\n         * @param message Message to attach `NestedError` created by the returned function.\n         */\n        static rethrow(message) {\n          return (...errs) => {\n            throw new this(message, ...errs);\n          };\n        }\n      };\n      exports.NestedError = NestedError4;\n      NestedError4.getErrorReport = typeof new Error().stack === \"string\" ? (err) => err.stack : (err) => `${err.name}: ${err.message}`;\n      NestedError4.prototype.name = \"NestedError\";\n      function toError(err) {\n        try {\n          return err instanceof Error ? err : new Error(`Value that is not an instance of Error was thrown: ${err}`);\n        } catch {\n          return new Error(\"Failed to stringify non-instance of Error that was thrown.This is possibly due to the fact that toString() method of the valuedoesn't return a primitive value.\");\n        }\n      }\n      exports.toError = toError;\n    }\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/timm@1.7.1/node_modules/timm/lib/timm.js\n  var require_timm = __commonJS({\n    \"../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/timm@1.7.1/node_modules/timm/lib/timm.js\"(exports) {\n      \"use strict\";\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.clone = clone2;\n      exports.addLast = addLast2;\n      exports.addFirst = addFirst;\n      exports.removeLast = removeLast;\n      exports.removeFirst = removeFirst;\n      exports.insert = insert;\n      exports.removeAt = removeAt2;\n      exports.replaceAt = replaceAt;\n      exports.getIn = getIn;\n      exports.set = set2;\n      exports.setIn = setIn8;\n      exports.update = update;\n      exports.updateIn = updateIn;\n      exports.merge = merge;\n      exports.mergeDeep = mergeDeep;\n      exports.mergeIn = mergeIn;\n      exports.omit = omit3;\n      exports.addDefaults = addDefaults;\n      exports.default = void 0;\n      var INVALID_ARGS = \"INVALID_ARGS\";\n      var IS_DEV = false;\n      function throwStr(msg) {\n        throw new Error(msg);\n      }\n      function getKeysAndSymbols(obj) {\n        const keys = Object.keys(obj);\n        if (Object.getOwnPropertySymbols) {\n          return keys.concat(Object.getOwnPropertySymbols(obj));\n        }\n        return keys;\n      }\n      var hasOwnProperty = {}.hasOwnProperty;\n      function clone2(obj0) {\n        if (Array.isArray(obj0))\n          return obj0.slice();\n        const obj = obj0;\n        const keys = getKeysAndSymbols(obj);\n        const out = {};\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          out[key] = obj[key];\n        }\n        return out;\n      }\n      function isObject(o) {\n        return o != null && typeof o === \"object\";\n      }\n      function addLast2(array, val) {\n        if (Array.isArray(val))\n          return array.concat(val);\n        return array.concat([val]);\n      }\n      function addFirst(array, val) {\n        if (Array.isArray(val))\n          return val.concat(array);\n        return [val].concat(array);\n      }\n      function removeLast(array) {\n        if (!array.length)\n          return array;\n        return array.slice(0, array.length - 1);\n      }\n      function removeFirst(array) {\n        if (!array.length)\n          return array;\n        return array.slice(1);\n      }\n      function insert(array, idx, val) {\n        return array.slice(0, idx).concat(Array.isArray(val) ? val : [val]).concat(array.slice(idx));\n      }\n      function removeAt2(array, idx) {\n        if (idx >= array.length || idx < 0)\n          return array;\n        return array.slice(0, idx).concat(array.slice(idx + 1));\n      }\n      function replaceAt(array, idx, newItem) {\n        if (array[idx] === newItem)\n          return array;\n        const len = array.length;\n        const result = Array(len);\n        for (let i = 0; i < len; i++) {\n          result[i] = array[i];\n        }\n        result[idx] = newItem;\n        return result;\n      }\n      function getIn(obj, path) {\n        if (!Array.isArray(path)) {\n          throwStr(IS_DEV ? \"A path array should be provided when calling getIn()\" : INVALID_ARGS);\n        }\n        if (obj == null)\n          return void 0;\n        let ptr = obj;\n        for (let i = 0; i < path.length; i++) {\n          const key = path[i];\n          ptr = ptr != null ? ptr[key] : void 0;\n          if (ptr === void 0)\n            return ptr;\n        }\n        return ptr;\n      }\n      function set2(obj0, key, val) {\n        let obj = obj0;\n        if (obj == null)\n          obj = typeof key === \"number\" ? [] : {};\n        if (obj[key] === val)\n          return obj;\n        const obj2 = clone2(obj);\n        obj2[key] = val;\n        return obj2;\n      }\n      function setIn8(obj, path, val) {\n        if (!path.length)\n          return val;\n        return doSetIn(obj, path, val, 0);\n      }\n      function doSetIn(obj, path, val, idx) {\n        let newValue;\n        const key = path[idx];\n        if (idx === path.length - 1) {\n          newValue = val;\n        } else {\n          const nestedObj = isObject(obj) && isObject(obj[key]) ? obj[key] : typeof path[idx + 1] === \"number\" ? [] : {};\n          newValue = doSetIn(nestedObj, path, val, idx + 1);\n        }\n        return set2(obj, key, newValue);\n      }\n      function update(obj, key, fnUpdate) {\n        const prevVal = obj == null ? void 0 : obj[key];\n        const nextVal = fnUpdate(prevVal);\n        return set2(obj, key, nextVal);\n      }\n      function updateIn(obj, path, fnUpdate) {\n        const prevVal = getIn(obj, path);\n        const nextVal = fnUpdate(prevVal);\n        return setIn8(obj, path, nextVal);\n      }\n      function merge(a, b, c, d, e, f, ...rest) {\n        return rest.length ? doMerge.call(null, false, false, a, b, c, d, e, f, ...rest) : doMerge(false, false, a, b, c, d, e, f);\n      }\n      function mergeDeep(a, b, c, d, e, f, ...rest) {\n        return rest.length ? doMerge.call(null, false, true, a, b, c, d, e, f, ...rest) : doMerge(false, true, a, b, c, d, e, f);\n      }\n      function mergeIn(a, path, b, c, d, e, f, ...rest) {\n        let prevVal = getIn(a, path);\n        if (prevVal == null)\n          prevVal = {};\n        let nextVal;\n        if (rest.length) {\n          nextVal = doMerge.call(null, false, false, prevVal, b, c, d, e, f, ...rest);\n        } else {\n          nextVal = doMerge(false, false, prevVal, b, c, d, e, f);\n        }\n        return setIn8(a, path, nextVal);\n      }\n      function omit3(obj, attrs) {\n        const omitList = Array.isArray(attrs) ? attrs : [attrs];\n        let fDoSomething = false;\n        for (let i = 0; i < omitList.length; i++) {\n          if (hasOwnProperty.call(obj, omitList[i])) {\n            fDoSomething = true;\n            break;\n          }\n        }\n        if (!fDoSomething)\n          return obj;\n        const out = {};\n        const keys = getKeysAndSymbols(obj);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          if (omitList.indexOf(key) >= 0)\n            continue;\n          out[key] = obj[key];\n        }\n        return out;\n      }\n      function addDefaults(a, b, c, d, e, f, ...rest) {\n        return rest.length ? doMerge.call(null, true, false, a, b, c, d, e, f, ...rest) : doMerge(true, false, a, b, c, d, e, f);\n      }\n      function doMerge(fAddDefaults, fDeep, first, ...rest) {\n        let out = first;\n        if (!(out != null)) {\n          throwStr(IS_DEV ? \"At least one object should be provided to merge()\" : INVALID_ARGS);\n        }\n        let fChanged = false;\n        for (let idx = 0; idx < rest.length; idx++) {\n          const obj = rest[idx];\n          if (obj == null)\n            continue;\n          const keys = getKeysAndSymbols(obj);\n          if (!keys.length)\n            continue;\n          for (let j = 0; j <= keys.length; j++) {\n            const key = keys[j];\n            if (fAddDefaults && out[key] !== void 0)\n              continue;\n            let nextVal = obj[key];\n            if (fDeep && isObject(out[key]) && isObject(nextVal)) {\n              nextVal = doMerge(fAddDefaults, fDeep, out[key], nextVal);\n            }\n            if (nextVal === void 0 || nextVal === out[key])\n              continue;\n            if (!fChanged) {\n              fChanged = true;\n              out = clone2(out);\n            }\n            out[key] = nextVal;\n          }\n        }\n        return out;\n      }\n      var timm = {\n        clone: clone2,\n        addLast: addLast2,\n        addFirst,\n        removeLast,\n        removeFirst,\n        insert,\n        removeAt: removeAt2,\n        replaceAt,\n        getIn,\n        set: set2,\n        setIn: setIn8,\n        update,\n        updateIn,\n        merge,\n        mergeDeep,\n        mergeIn,\n        omit: omit3,\n        addDefaults\n      };\n      var _default = timm;\n      exports.default = _default;\n    }\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/p-defer@3.0.0/node_modules/p-defer/index.js\n  var require_p_defer = __commonJS({\n    \"../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/p-defer@3.0.0/node_modules/p-defer/index.js\"(exports, module) {\n      \"use strict\";\n      var pDefer = () => {\n        const deferred2 = {};\n        deferred2.promise = new Promise((resolve, reject) => {\n          deferred2.resolve = resolve;\n          deferred2.reject = reject;\n        });\n        return deferred2;\n      };\n      module.exports = pDefer;\n    }\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/queue-microtask@1.2.3/node_modules/queue-microtask/index.js\n  var require_queue_microtask = __commonJS({\n    \"../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/queue-microtask@1.2.3/node_modules/queue-microtask/index.js\"(exports, module) {\n      \"use strict\";\n      var promise;\n      module.exports = typeof queueMicrotask === \"function\" ? queueMicrotask.bind(typeof window !== \"undefined\" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {\n        throw err;\n      }, 0));\n    }\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/index.ts\n  var src_exports = {};\n  __export(src_exports, {\n    ReferenceAssetsPlugin: () => ReferenceAssetsPlugin,\n    actionTransform: () => actionTransform,\n    chatMessageTransform: () => chatMessageTransform,\n    choiceTransform: () => choiceTransform,\n    expPropTransform: () => expPropTransform,\n    imageTransform: () => imageTransform,\n    infoTransform: () => infoTransform,\n    inputTransform: () => inputTransform,\n    isBackAction: () => isBackAction,\n    transform: () => transform2\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/input/transform.ts\n  var inputTransform = (asset, options) => {\n    return {\n      ...asset,\n      format(val) {\n        if (asset.binding === void 0) {\n          return val;\n        }\n        return options.data.format(asset.binding, val);\n      },\n      set(val) {\n        if (asset.binding === void 0) {\n          return;\n        }\n        return options.data.model.set([[asset.binding, val]], {\n          formatted: true\n        });\n      },\n      value: asset.binding === void 0 ? \"\" : options.data.model.get(asset.binding, {\n        includeInvalid: true,\n        formatted: true\n      }),\n      validation: asset.binding === void 0 ? void 0 : options.validation?.get(asset.binding, { track: true }),\n      dataType: asset.binding === void 0 ? void 0 : options.validation?.type(asset.binding)\n    };\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+partial-match-registry@0.0.0/node_modules/@player-ui/partial-match-registry/dist/index.mjs\n  var import_sorted_array = __toESM(require_sorted_array(), 1);\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dlv@1.1.3/node_modules/dlv/dist/dlv.es.js\n  function dlv_es_default(t2, e, l, n, r) {\n    for (e = e.split ? e.split(\".\") : e, n = 0; n < e.length; n++)\n      t2 = t2 ? t2[e[n]] : r;\n    return t2 === r ? l : t2;\n  }\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+partial-match-registry@0.0.0/node_modules/@player-ui/partial-match-registry/dist/index.mjs\n  function traverseObj(object, path = [], pairs = /* @__PURE__ */ new Map()) {\n    for (const key of Object.keys(object)) {\n      const val = object[key];\n      const nestedPath = [...path, key];\n      if (typeof val === \"object\") {\n        traverseObj(val, nestedPath, pairs);\n      } else {\n        pairs.set(nestedPath, val);\n      }\n    }\n    return pairs;\n  }\n  function createObjectMatcher(partialObj) {\n    const pairs = traverseObj(partialObj);\n    const matchFunction = (searchObj) => {\n      for (const entry of Array.from(pairs)) {\n        const [path, value] = entry;\n        if (dlv_es_default(searchObj, path) !== value) {\n          return false;\n        }\n      }\n      return true;\n    };\n    matchFunction.count = pairs.size;\n    return matchFunction;\n  }\n  function createBasicMatcher(seed) {\n    const matcher = (match) => seed === match;\n    matcher.count = 1;\n    return matcher;\n  }\n  var createSortedArray = () => new import_sorted_array.default([], (c) => c.matcher.count);\n  var Registry = class {\n    constructor(initialSet) {\n      this.store = createSortedArray();\n      initialSet?.forEach(([match, value]) => {\n        this.set(match, value);\n      });\n    }\n    /** Add match -> value mapping to the registry */\n    set(match, value) {\n      const matcher = typeof match === \"object\" ? createObjectMatcher(match) : createBasicMatcher(match);\n      this.store.insert({\n        key: match,\n        value,\n        matcher\n      });\n    }\n    /** Fetch the best match in the registry */\n    get(query) {\n      for (const entry of this.store.array) {\n        if (entry.matcher(query)) {\n          return entry.value;\n        }\n      }\n    }\n    /** Loop over all entries and run callback */\n    forEach(callbackfn) {\n      for (const entry of this.store.array) {\n        callbackfn(entry);\n      }\n    }\n    /** Reset the items in the registry */\n    clear() {\n      this.store = createSortedArray();\n    }\n    /** Check if the registry is empty*/\n    isRegistryEmpty() {\n      return this.store.array.length === 0;\n    }\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+asset-transform-plugin@0.0.0/node_modules/@player-ui/asset-transform-plugin/dist/index.mjs\n  function composeTransforms(...args) {\n    const [fn, ...fns] = args.reverse();\n    return (asset, options, store) => {\n      const value = fn(asset, options, store);\n      if (!fns.length) {\n        return value;\n      }\n      return fns.reduce((prevValue, current) => {\n        return current(prevValue, options, store);\n      }, value);\n    };\n  }\n  function composeBefore(...args) {\n    return {\n      beforeResolve: composeTransforms(...args)\n    };\n  }\n  function compose(...args) {\n    const beforeResolveFns = [];\n    const resolveFns = [];\n    for (const arg of args) {\n      if (typeof arg === \"function\") {\n        resolveFns.push(arg);\n      } else {\n        if (arg?.resolve) {\n          resolveFns.push(arg.resolve);\n        }\n        if (arg?.beforeResolve) {\n          beforeResolveFns.push(arg.beforeResolve);\n        }\n      }\n    }\n    return {\n      beforeResolve: beforeResolveFns.length ? composeTransforms(...beforeResolveFns) : void 0,\n      resolve: resolveFns.length ? composeTransforms(...resolveFns) : void 0\n    };\n  }\n  function maybeCompose(maybeFn) {\n    if (typeof maybeFn === \"object\") {\n      return maybeFn;\n    }\n    return compose(maybeFn);\n  }\n  function cleanupTransformRegistry(maybeRegistry) {\n    if (Array.isArray(maybeRegistry)) {\n      const wrappedTransforms = maybeRegistry.map(([key, value]) => {\n        return [key, maybeCompose(value)];\n      });\n      return new Registry(wrappedTransforms);\n    }\n    const registry = new Registry();\n    maybeRegistry.forEach(({ key, value }) => {\n      registry.set(key, maybeCompose(value));\n    });\n    return registry;\n  }\n  var AssetTransformPlugin = class {\n    constructor(transforms) {\n      this.name = \"asset-transform\";\n      this.registry = cleanupTransformRegistry(transforms);\n    }\n    apply(player) {\n      player.hooks.viewController.tap(this.name, (vc) => {\n        this.registry.forEach(\n          ({ key, value }) => vc.transformRegistry.set(key, maybeCompose(value))\n        );\n      });\n    }\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/action/transform.ts\n  function isBackAction(action) {\n    return action.value === \"Prev\";\n  }\n  var transform = (action, options) => {\n    return {\n      ...action,\n      run() {\n        if (action.exp) {\n          options.evaluate(action.exp);\n        }\n        if (action.value) {\n          const skipValidation = action.metaData?.skipValidation;\n          options.transition?.(action.value, { force: skipValidation });\n        }\n      }\n    };\n  };\n  var backIconTransform = (action) => {\n    if (isBackAction(action) && action?.metaData?.role === void 0) {\n      return {\n        ...action,\n        metaData: {\n          ...action?.metaData,\n          role: \"back\"\n        }\n      };\n    }\n    return action;\n  };\n  var expPropTransform = (asset) => {\n    const skipArray = asset.plugins?.stringResolver?.propertiesToSkip;\n    if (skipArray && skipArray.indexOf(\"exp\") > 1) {\n      return asset;\n    }\n    return {\n      ...asset,\n      plugins: {\n        ...asset.plugins,\n        stringResolver: {\n          ...asset?.plugins?.stringResolver,\n          propertiesToSkip: [\n            ...asset.plugins?.stringResolver?.propertiesToSkip ?? [],\n            \"exp\"\n          ]\n        }\n      }\n    };\n  };\n  var actionTransform = compose(\n    transform,\n    backIconTransform,\n    composeBefore(expPropTransform)\n  );\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/info/transform.ts\n  var infoTransform = (infoAsset) => {\n    const actions = infoAsset?.actions;\n    const segmentedActions = actions?.reduce(\n      (segmentedActionsArray, action) => {\n        segmentedActionsArray[isBackAction(action.asset) ? \"prev\" : \"next\"].push(action);\n        return segmentedActionsArray;\n      },\n      { next: [], prev: [] }\n    );\n    return {\n      ...infoAsset,\n      segmentedActions\n    };\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/image/transform.ts\n  var getImageAlt = (props) => {\n    const { metaData, placeholder } = props;\n    if (metaData.accessibility)\n      return metaData.accessibility;\n    if (placeholder)\n      return placeholder;\n    return \"Image\";\n  };\n  var imageTransform = (props) => {\n    const altText = getImageAlt(props);\n    const newImage = {\n      ...props,\n      altText\n    };\n    return newImage;\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/choice/transform.ts\n  var choiceTransform = (asset, options) => {\n    const { items, binding, ...rest } = asset;\n    const assetHasBinding = binding !== void 0;\n    const currentValue = assetHasBinding ? options.data.model.get(binding, {\n      includeInvalid: true\n    }) : void 0;\n    const resetValue = () => {\n      if (assetHasBinding) {\n        return options.data.model.set([[binding, null]]);\n      }\n    };\n    const transformedChoiceItems = (items || []).map(\n      (item, index) => ({\n        ...item,\n        id: item.id ?? `${asset.id}-choice-${index}`,\n        select() {\n          if (assetHasBinding) {\n            return options.data.model.set([[binding, item.value]]);\n          }\n        },\n        unselect: resetValue\n      })\n    );\n    return {\n      ...rest,\n      binding,\n      clearSelection: resetValue,\n      items: transformedChoiceItems,\n      value: currentValue,\n      validation: assetHasBinding ? options.validation?.get(binding, { track: true }) : void 0,\n      dataType: assetHasBinding ? options.validation?.type(binding) : void 0\n    };\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/tapable-ts@0.2.4/node_modules/tapable-ts/dist/hooks.mjs\n  function equalToOrIn(value, check) {\n    if (Array.isArray(check)) {\n      return check.includes(value);\n    }\n    return check === value;\n  }\n  function callTap(tap, args, ctx) {\n    if (tap.context) {\n      return tap.callback(ctx, ...args);\n    }\n    return tap.callback(...args);\n  }\n  var InterceptionManager = class {\n    constructor() {\n      this.interceptions = [];\n      this.interceptionKeySet = /* @__PURE__ */ new Set();\n    }\n    isUsed() {\n      return this.interceptions.length > 0;\n    }\n    intercept(int) {\n      this.interceptions.push(int);\n      Object.keys(int).forEach((s) => {\n        this.interceptionKeySet.add(s);\n      });\n    }\n    tap(tap) {\n      if (this.interceptionKeySet.has(\"tap\")) {\n        this.interceptions.forEach((i) => {\n          var _a;\n          (_a = i.tap) == null ? void 0 : _a.call(i, tap);\n        });\n      }\n    }\n    call(ctx, ...args) {\n      if (this.interceptionKeySet.has(\"call\")) {\n        this.interceptions.forEach((i) => {\n          var _a, _b;\n          if (i.context) {\n            (_a = i.call) == null ? void 0 : _a.call(i, ctx, ...args);\n          } else {\n            (_b = i.call) == null ? void 0 : _b.call(i, ...args);\n          }\n        });\n      }\n    }\n    loop(...args) {\n      if (this.interceptionKeySet.has(\"loop\")) {\n        this.interceptions.forEach((i) => {\n          var _a;\n          (_a = i.loop) == null ? void 0 : _a.call(i, ...args);\n        });\n      }\n    }\n    error(err) {\n      if (this.interceptionKeySet.has(\"error\")) {\n        if (err instanceof Error) {\n          const asError = err;\n          this.interceptions.forEach((i) => {\n            var _a;\n            (_a = i.error) == null ? void 0 : _a.call(i, asError);\n          });\n        }\n      }\n    }\n    result(r) {\n      if (this.interceptionKeySet.has(\"result\")) {\n        this.interceptions.forEach((i) => {\n          var _a;\n          (_a = i.result) == null ? void 0 : _a.call(i, r);\n        });\n      }\n    }\n    done() {\n      if (this.interceptionKeySet.has(\"done\")) {\n        this.interceptions.forEach((i) => {\n          var _a;\n          (_a = i.done) == null ? void 0 : _a.call(i);\n        });\n      }\n    }\n  };\n  var Hook = class {\n    constructor() {\n      this.taps = [];\n      this.interceptions = new InterceptionManager();\n    }\n    tap(options, callback) {\n      const resolvedOptions = typeof options === \"string\" ? {\n        name: options,\n        context: false\n      } : {\n        context: false,\n        ...options\n      };\n      const key = Symbol(resolvedOptions.name);\n      const tap = {\n        key,\n        ...resolvedOptions,\n        callback\n      };\n      if (tap.before) {\n        let insertionIndex = this.taps.length;\n        const beforeSet = new Set(Array.isArray(tap.before) ? tap.before : [tap.before]);\n        for (insertionIndex; insertionIndex > 0 && beforeSet.size > 0; insertionIndex--) {\n          const t2 = this.taps[insertionIndex - 1];\n          if (beforeSet.has(t2.name)) {\n            beforeSet.delete(t2.name);\n          }\n          if (t2.before && equalToOrIn(tap.name, t2.before)) {\n            break;\n          }\n        }\n        this.taps.splice(insertionIndex, 0, tap);\n      } else {\n        this.taps.push(tap);\n      }\n      this.interceptions.tap(tap);\n      return tap;\n    }\n    untap(tap) {\n      this.taps = this.taps.filter((t2) => t2.key !== tap.key);\n    }\n    isUsed() {\n      return this.taps.length > 0 || this.interceptions.isUsed();\n    }\n    intercept(int) {\n      this.interceptions.intercept(int);\n    }\n  };\n  var SyncHook = class extends Hook {\n    call(...args) {\n      if (!this.isUsed()) {\n        return;\n      }\n      const ctx = {};\n      this.interceptions.call(ctx, ...args);\n      try {\n        this.taps.forEach((t2) => {\n          callTap(t2, args, ctx);\n        });\n      } catch (err) {\n        this.interceptions.error(err);\n        throw err;\n      }\n      this.interceptions.done();\n    }\n  };\n  var SyncBailHook = class extends Hook {\n    call(...args) {\n      if (!this.isUsed()) {\n        return;\n      }\n      const ctx = {};\n      this.interceptions.call(ctx, ...args);\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        const rtn = callTap(this.taps[tapIndex], args, ctx);\n        if (rtn !== void 0) {\n          this.interceptions.result(rtn);\n          return rtn;\n        }\n      }\n      this.interceptions.done();\n    }\n  };\n  var SyncWaterfallHook = class extends Hook {\n    call(...args) {\n      const ctx = {};\n      this.interceptions.call(ctx, ...args);\n      let [rtn, ...rest] = args;\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        const tapValue = callTap(this.taps[tapIndex], [rtn, ...rest], ctx);\n        if (tapValue !== void 0) {\n          rtn = tapValue;\n        }\n      }\n      this.interceptions.result(rtn);\n      return rtn;\n    }\n  };\n  var AsyncSeriesBailHook = class extends Hook {\n    async call(...args) {\n      const ctx = {};\n      this.interceptions.call(ctx, ...args);\n      try {\n        for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n          const rtn = await callTap(this.taps[tapIndex], args, ctx);\n          if (rtn !== void 0) {\n            this.interceptions.result(rtn);\n            return rtn;\n          }\n        }\n      } catch (e) {\n        this.interceptions.error(e);\n        throw e;\n      }\n      this.interceptions.done();\n    }\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+player@0.0.0/node_modules/@player-ui/player/dist/index.mjs\n  var import_ts_nested_error = __toESM(require_nested_error(), 1);\n  var import_ts_nested_error2 = __toESM(require_nested_error(), 1);\n  var import_timm = __toESM(require_timm(), 1);\n  var import_ts_nested_error3 = __toESM(require_nested_error(), 1);\n  var import_timm2 = __toESM(require_timm(), 1);\n  var import_timm3 = __toESM(require_timm(), 1);\n  var import_timm4 = __toESM(require_timm(), 1);\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dequal@2.0.3/node_modules/dequal/dist/index.mjs\n  var has = Object.prototype.hasOwnProperty;\n  function find(iter, tar, key) {\n    for (key of iter.keys()) {\n      if (dequal(key, tar))\n        return key;\n    }\n  }\n  function dequal(foo, bar) {\n    var ctor, len, tmp;\n    if (foo === bar)\n      return true;\n    if (foo && bar && (ctor = foo.constructor) === bar.constructor) {\n      if (ctor === Date)\n        return foo.getTime() === bar.getTime();\n      if (ctor === RegExp)\n        return foo.toString() === bar.toString();\n      if (ctor === Array) {\n        if ((len = foo.length) === bar.length) {\n          while (len-- && dequal(foo[len], bar[len]))\n            ;\n        }\n        return len === -1;\n      }\n      if (ctor === Set) {\n        if (foo.size !== bar.size) {\n          return false;\n        }\n        for (len of foo) {\n          tmp = len;\n          if (tmp && typeof tmp === \"object\") {\n            tmp = find(bar, tmp);\n            if (!tmp)\n              return false;\n          }\n          if (!bar.has(tmp))\n            return false;\n        }\n        return true;\n      }\n      if (ctor === Map) {\n        if (foo.size !== bar.size) {\n          return false;\n        }\n        for (len of foo) {\n          tmp = len[0];\n          if (tmp && typeof tmp === \"object\") {\n            tmp = find(bar, tmp);\n            if (!tmp)\n              return false;\n          }\n          if (!dequal(len[1], bar.get(tmp))) {\n            return false;\n          }\n        }\n        return true;\n      }\n      if (ctor === ArrayBuffer) {\n        foo = new Uint8Array(foo);\n        bar = new Uint8Array(bar);\n      } else if (ctor === DataView) {\n        if ((len = foo.byteLength) === bar.byteLength) {\n          while (len-- && foo.getInt8(len) === bar.getInt8(len))\n            ;\n        }\n        return len === -1;\n      }\n      if (ArrayBuffer.isView(foo)) {\n        if ((len = foo.byteLength) === bar.byteLength) {\n          while (len-- && foo[len] === bar[len])\n            ;\n        }\n        return len === -1;\n      }\n      if (!ctor || typeof foo === \"object\") {\n        len = 0;\n        for (ctor in foo) {\n          if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))\n            return false;\n          if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))\n            return false;\n        }\n        return Object.keys(bar).length === len;\n      }\n    }\n    return foo !== foo && bar !== bar;\n  }\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+player@0.0.0/node_modules/@player-ui/player/dist/index.mjs\n  var import_timm5 = __toESM(require_timm(), 1);\n  var import_timm6 = __toESM(require_timm(), 1);\n  var import_timm7 = __toESM(require_timm(), 1);\n  var import_timm8 = __toESM(require_timm(), 1);\n  var import_p_defer = __toESM(require_p_defer(), 1);\n  var import_queue_microtask = __toESM(require_queue_microtask(), 1);\n  var import_p_defer2 = __toESM(require_p_defer(), 1);\n  var import_timm9 = __toESM(require_timm(), 1);\n  var import_queue_microtask2 = __toESM(require_queue_microtask(), 1);\n  var __defProp2 = Object.defineProperty;\n  var __export2 = (target, all) => {\n    for (var name in all)\n      __defProp2(target, name, { get: all[name], enumerable: true });\n  };\n  var toValue = (value) => ({\n    name: \"Value\",\n    value\n  });\n  var toExpression = (value) => ({\n    name: \"Expression\",\n    value\n  });\n  var toPath = (path) => ({\n    name: \"PathNode\",\n    path\n  });\n  var toQuery = (key, value) => ({\n    name: \"Query\",\n    key,\n    value\n  });\n  var toConcatenatedNode = (values) => {\n    if (values.length === 1) {\n      return values[0];\n    }\n    return {\n      name: \"Concatenated\",\n      value: values\n    };\n  };\n  var SEGMENT_SEPARATOR = \".\";\n  var OPEN_CURL = \"{\";\n  var CLOSE_CURL = \"}\";\n  var OPEN_BRACKET = \"[\";\n  var CLOSE_BRACKET = \"]\";\n  var EQUALS = \"=\";\n  var SINGLE_QUOTE = \"'\";\n  var DOUBLE_QUOTE = '\"';\n  var BACK_TICK = \"`\";\n  var isIdentifierChar = (char) => {\n    if (!char) {\n      return false;\n    }\n    const charCode = char.charCodeAt(0);\n    const matches = charCode === 32 || // ' '\n    charCode === 34 || // \"\n    charCode === 39 || // '\n    charCode === 40 || // (\n    charCode === 41 || // )\n    charCode === 42 || // *\n    charCode === 46 || // .\n    charCode === 61 || // =\n    charCode === 91 || // [\n    charCode === 93 || // ]\n    charCode === 96 || // `\n    charCode === 123 || // {\n    charCode === 125;\n    return !matches;\n  };\n  var parse = (path) => {\n    let index = 1;\n    let ch = path.charAt(0);\n    const next = (expected) => {\n      if (expected && ch !== expected) {\n        throw new Error(`Expected char: ${expected} but got: ${ch}`);\n      }\n      ch = path.charAt(index);\n      index += 1;\n      return ch;\n    };\n    const whitespace = () => {\n      while (ch === \" \") {\n        next();\n      }\n    };\n    const identifier = (allowBoolValue = false) => {\n      if (!isIdentifierChar(ch)) {\n        return;\n      }\n      let value = ch;\n      while (next()) {\n        if (!isIdentifierChar(ch)) {\n          break;\n        }\n        value += ch;\n      }\n      if (allowBoolValue) {\n        if (value === \"true\") {\n          return toValue(true);\n        }\n        if (value === \"false\") {\n          return toValue(false);\n        }\n      }\n      if (value) {\n        const maybeNumber = Number(value);\n        value = isNaN(maybeNumber) ? value : maybeNumber;\n        return toValue(value);\n      }\n    };\n    const expression = () => {\n      if (ch === BACK_TICK) {\n        next(BACK_TICK);\n        let exp = ch;\n        while (next()) {\n          if (ch === BACK_TICK) {\n            break;\n          }\n          exp += ch;\n        }\n        next(BACK_TICK);\n        if (exp) {\n          return toExpression(exp);\n        }\n      }\n    };\n    const regex = (match) => {\n      if (!ch?.match(match)) {\n        return;\n      }\n      let value = ch;\n      while (next()) {\n        if (!ch?.match(match)) {\n          break;\n        }\n        value += ch;\n      }\n      if (value) {\n        return toValue(value);\n      }\n    };\n    const nestedPath = () => {\n      if (ch === OPEN_CURL) {\n        next(OPEN_CURL);\n        next(OPEN_CURL);\n        const modelRef = parsePath();\n        next(CLOSE_CURL);\n        next(CLOSE_CURL);\n        return modelRef;\n      }\n    };\n    const simpleSegment = (allowBoolValue = false) => nestedPath() ?? expression() ?? identifier(allowBoolValue);\n    const segment = () => {\n      const segments = [];\n      let nextSegment = simpleSegment();\n      while (nextSegment !== void 0) {\n        segments.push(nextSegment);\n        nextSegment = simpleSegment();\n      }\n      if (segments.length === 0) {\n        return void 0;\n      }\n      return toConcatenatedNode(segments);\n    };\n    const optionallyQuotedSegment = (allowBoolValue = false) => {\n      whitespace();\n      if (ch === SINGLE_QUOTE || ch === DOUBLE_QUOTE) {\n        const singleQuote = ch === SINGLE_QUOTE;\n        next(singleQuote ? SINGLE_QUOTE : DOUBLE_QUOTE);\n        const id = regex(/[^'\"]+/);\n        next(singleQuote ? SINGLE_QUOTE : DOUBLE_QUOTE);\n        return id;\n      }\n      return simpleSegment(allowBoolValue);\n    };\n    const equals = () => {\n      if (ch !== EQUALS) {\n        return false;\n      }\n      while (ch === EQUALS) {\n        next();\n      }\n      return true;\n    };\n    const parseBracket = () => {\n      if (ch === OPEN_BRACKET) {\n        next(OPEN_BRACKET);\n        whitespace();\n        let value = optionallyQuotedSegment();\n        if (value) {\n          whitespace();\n          if (equals()) {\n            whitespace();\n            const second = optionallyQuotedSegment(true);\n            value = toQuery(value, second);\n            whitespace();\n          }\n        } else {\n          throw new Error(`Expected identifier`);\n        }\n        if (value) {\n          next(CLOSE_BRACKET);\n        }\n        return value;\n      }\n    };\n    const parseSegmentAndBrackets = () => {\n      const parsed = [];\n      const firstSegment = segment();\n      if (firstSegment) {\n        parsed.push(firstSegment);\n        let bracketSegment = parseBracket();\n        if (bracketSegment?.name === \"Value\") {\n          const maybeNumber = Number(bracketSegment.value);\n          bracketSegment.value = isNaN(maybeNumber) || String(maybeNumber) !== bracketSegment.value ? bracketSegment.value : maybeNumber;\n        }\n        while (bracketSegment !== void 0) {\n          parsed.push(bracketSegment);\n          bracketSegment = parseBracket();\n        }\n      }\n      return parsed;\n    };\n    const parsePath = () => {\n      const parts = [];\n      let nextSegment = parseSegmentAndBrackets();\n      while (nextSegment !== void 0) {\n        parts.push(...nextSegment);\n        if (!ch || ch === CLOSE_CURL) {\n          break;\n        }\n        if (nextSegment.length === 0 && ch) {\n          throw new Error(`Unexpected character: ${ch}`);\n        }\n        next(SEGMENT_SEPARATOR);\n        nextSegment = parseSegmentAndBrackets();\n      }\n      return toPath(parts);\n    };\n    try {\n      const result = parsePath();\n      return {\n        status: true,\n        path: result\n      };\n    } catch (e) {\n      return {\n        status: false,\n        error: e.message\n      };\n    }\n  };\n  function isBinding(binding) {\n    return !(typeof binding === \"string\" || Array.isArray(binding));\n  }\n  function maybeConvertToNum(i) {\n    const asInt = parseInt(i, 10);\n    if (isNaN(asInt)) {\n      return i;\n    }\n    return asInt;\n  }\n  function getBindingSegments(binding) {\n    if (Array.isArray(binding)) {\n      return binding;\n    }\n    if (typeof binding === \"string\") {\n      return binding.split(\".\");\n    }\n    return binding.asArray();\n  }\n  function findInArray(array, key, value) {\n    return array.findIndex((obj) => {\n      if (obj && typeof obj === \"object\") {\n        return obj[key] == value;\n      }\n      return false;\n    });\n  }\n  var BindingInstance = class _BindingInstance {\n    constructor(raw, factory = (rawBinding) => new _BindingInstance(rawBinding)) {\n      const split = Array.isArray(raw) ? raw : raw.split(\".\");\n      this.split = split.map((segment) => {\n        if (typeof segment === \"number\") {\n          return segment;\n        }\n        const tryNum = Number(segment);\n        return isNaN(tryNum) || String(tryNum) !== segment ? segment : tryNum;\n      });\n      Object.freeze(this.split);\n      this.joined = this.split.join(\".\");\n      this.factory = factory;\n    }\n    asArray() {\n      return this.split;\n    }\n    asString() {\n      return this.joined;\n    }\n    /**\n     * Check to see if the given binding is a sub-path of the current one\n     */\n    contains(binding) {\n      const bindingAsArray = binding.asArray();\n      if (bindingAsArray.length < this.split.length) {\n        return false;\n      }\n      for (let i = 0; i < this.split.length; i++) {\n        if (this.split[i] !== bindingAsArray[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    relative(binding) {\n      return this.asArray().slice(binding.asArray().length);\n    }\n    parent() {\n      return this.factory(this.split.slice(0, -1));\n    }\n    key() {\n      return this.split[this.split.length - 1];\n    }\n    /**\n     * This is a utility method to get a binding that is a descendent of this binding\n     *\n     * @param relative - The relative path to descend to\n     */\n    descendent(relative) {\n      const descendentSegments = getBindingSegments(relative);\n      return this.factory(this.split.concat(descendentSegments));\n    }\n  };\n  function resolveBindingAST(bindingPathNode, options, hooks) {\n    const context = {\n      updates: {},\n      path: []\n    };\n    function getValueForNode(node) {\n      if (node.name === \"Value\") {\n        return node.value;\n      }\n      if (node.name === \"PathNode\") {\n        const nestedResolvedValue = resolveBindingAST(node, options);\n        if (nestedResolvedValue.updates) {\n          context.updates = {\n            ...context.updates,\n            ...nestedResolvedValue.updates\n          };\n        }\n        try {\n          return options.convertToPath(\n            options.getValue(nestedResolvedValue.path)\n          );\n        } catch (e) {\n          throw new import_ts_nested_error2.NestedError(\n            `Unable to resolve path segment: ${nestedResolvedValue.path}`,\n            e\n          );\n        }\n      }\n      if (node.name === \"Expression\") {\n        try {\n          const actualValue = options.evaluate(node.value);\n          return options.convertToPath(actualValue);\n        } catch (e) {\n          throw new import_ts_nested_error2.NestedError(`Unable to resolve path: ${node.value}`, e);\n        }\n      }\n      throw new Error(`Unable to resolve value for node: ${node.name}`);\n    }\n    function appendPathSegments(segment) {\n      if (typeof segment === \"string\" && segment.indexOf(\".\") > -1) {\n        segment.split(\".\").forEach((i) => {\n          context.path.push(maybeConvertToNum(i));\n        });\n      } else {\n        context.path.push(segment);\n      }\n    }\n    function resolveNode(_node) {\n      const resolvedNode = hooks?.beforeResolveNode.call(_node, { ...context, ...options }) ?? _node;\n      switch (resolvedNode.name) {\n        case \"Expression\":\n        case \"PathNode\":\n          appendPathSegments(getValueForNode(resolvedNode));\n          break;\n        case \"Value\":\n          appendPathSegments(\n            typeof resolvedNode.value === \"boolean\" ? String(resolvedNode.value) : resolvedNode.value\n          );\n          break;\n        case \"Query\": {\n          const objToQuery = options.getValue(context.path) ?? [];\n          const { key, value } = resolvedNode;\n          const resolvedKey = getValueForNode(key);\n          const resolvedValue = value && getValueForNode(value);\n          const index = findInArray(objToQuery, resolvedKey, resolvedValue);\n          if (index === void 0 || index === -1) {\n            context.updates[[...context.path, objToQuery.length, resolvedKey].join(\".\")] = resolvedValue;\n            context.path.push(objToQuery.length);\n          } else {\n            context.path.push(index);\n          }\n          break;\n        }\n        case \"Concatenated\":\n          context.path.push(resolvedNode.value.map(getValueForNode).join(\"\"));\n          break;\n        default:\n          throw new Error(`Unsupported node type: ${resolvedNode.name}`);\n      }\n    }\n    bindingPathNode.path.forEach(resolveNode);\n    return {\n      path: context.path,\n      updates: Object.keys(context.updates ?? {}).length > 0 ? context.updates : void 0\n    };\n  }\n  var BINDING_BRACKETS_REGEX = /[\\s()*=`{}'\"[\\]]/;\n  var LAZY_BINDING_REGEX = /^[^.]+(\\..+)*$/;\n  var DEFAULT_OPTIONS = {\n    get: () => {\n      throw new Error(\"Not Implemented\");\n    },\n    set: () => {\n      throw new Error(\"Not Implemented\");\n    },\n    evaluate: () => {\n      throw new Error(\"Not Implemented\");\n    }\n  };\n  var BindingParser = class {\n    constructor(options) {\n      this.hooks = {\n        skipOptimization: new SyncBailHook(),\n        beforeResolveNode: new SyncWaterfallHook()\n      };\n      this.parserOptions = { ...DEFAULT_OPTIONS, ...options };\n      this.cache = {};\n      this.parseCache = {};\n      this.parse = this.parse.bind(this);\n    }\n    /**\n     * Takes a binding path, parses it, and returns an equivalent, normalized\n     * representation of that path.\n     */\n    normalizePath(path, resolveOptions) {\n      if (!BINDING_BRACKETS_REGEX.test(path) && LAZY_BINDING_REGEX.test(path) && this.hooks.skipOptimization.call(path) !== true) {\n        return { path: path.split(\".\"), updates: void 0 };\n      }\n      const ast = this.parseCache[path] ?? parse(path);\n      this.parseCache[path] = ast;\n      if (typeof ast !== \"object\" || !ast?.status) {\n        throw new TypeError(\n          `Cannot normalize path \"${path}\": ${ast?.error ?? \"Unknown Error.\"}`\n        );\n      }\n      try {\n        return resolveBindingAST(ast.path, resolveOptions, this.hooks);\n      } catch (e) {\n        throw new import_ts_nested_error.NestedError(`Cannot resolve binding: ${path}`, e);\n      }\n    }\n    getBindingForNormalizedResult(normalized) {\n      const normalizedStr = normalized.path.join(\".\");\n      if (this.cache[normalizedStr]) {\n        return this.cache[normalizedStr];\n      }\n      const created = new BindingInstance(\n        normalizedStr === \"\" ? [] : normalized.path,\n        this.parse\n      );\n      this.cache[normalizedStr] = created;\n      return created;\n    }\n    parse(rawBinding, overrides = {}) {\n      if (isBinding(rawBinding)) {\n        return rawBinding;\n      }\n      const options = {\n        ...this.parserOptions,\n        ...overrides\n      };\n      let updates = {};\n      const joined = Array.isArray(rawBinding) ? rawBinding.join(\".\") : String(rawBinding);\n      const normalizeConfig = {\n        getValue: (path) => {\n          const normalized2 = this.normalizePath(path.join(\".\"), normalizeConfig);\n          return options.get(this.getBindingForNormalizedResult(normalized2));\n        },\n        evaluate: (exp) => {\n          return options.evaluate(exp);\n        },\n        convertToPath: (path) => {\n          if (path === void 0) {\n            throw new Error(\n              \"Attempted to convert undefined value to binding path\"\n            );\n          }\n          if (typeof path !== \"string\" && typeof path !== \"number\" && typeof path !== \"boolean\") {\n            throw new Error(\n              `Attempting to convert ${typeof path} to a binding path.`\n            );\n          }\n          const normalized2 = this.normalizePath(String(path), normalizeConfig);\n          if (normalized2.updates) {\n            updates = {\n              ...updates,\n              ...normalized2.updates\n            };\n          }\n          const joinedNormalizedPath = normalized2.path.join(\".\");\n          if (joinedNormalizedPath === \"\") {\n            throw new Error(\"Nested path resolved to an empty path\");\n          }\n          return joinedNormalizedPath;\n        }\n      };\n      const normalized = this.normalizePath(joined, normalizeConfig);\n      if (normalized.updates) {\n        updates = {\n          ...updates,\n          ...normalized.updates\n        };\n      }\n      const updateKeys = Object.keys(updates);\n      if (!options.readOnly && updateKeys.length > 0) {\n        const updateTransaction = updateKeys.map(\n          (updatedBinding) => [\n            this.parse(updatedBinding),\n            updates[updatedBinding]\n          ]\n        );\n        options.set(updateTransaction);\n      }\n      return this.getBindingForNormalizedResult(normalized);\n    }\n  };\n  var DependencyTracker = class {\n    constructor() {\n      this.readDeps = /* @__PURE__ */ new Set();\n      this.writeDeps = /* @__PURE__ */ new Set();\n      this.namedDependencySets = {};\n      this.namedSet = \"core\";\n      this.createSubset(\"core\");\n      this.createSubset(\"children\");\n    }\n    createSubset(name, force = false) {\n      if (force || !this.namedDependencySets[name]) {\n        this.namedDependencySets[name] = {\n          readDeps: /* @__PURE__ */ new Set(),\n          writeDeps: /* @__PURE__ */ new Set()\n        };\n      }\n    }\n    /** Grab all of the bindings that this depended on */\n    getDependencies(name) {\n      if (name !== void 0) {\n        return this.namedDependencySets?.[name]?.readDeps ?? /* @__PURE__ */ new Set();\n      }\n      return this.readDeps;\n    }\n    trackSubset(name) {\n      this.createSubset(name);\n      this.namedSet = name;\n    }\n    trackDefault() {\n      this.namedSet = \"core\";\n    }\n    /** Grab all of the bindings this wrote to */\n    getModified(name) {\n      if (name !== void 0) {\n        return this.namedDependencySets?.[name]?.writeDeps ?? /* @__PURE__ */ new Set();\n      }\n      return this.writeDeps;\n    }\n    /**\n     * Check to see if the dataModel has read the value at the given binding\n     *\n     * @param binding - The binding you want to check for\n     */\n    readsBinding(binding) {\n      return this.readDeps.has(binding);\n    }\n    /**\n     * Check to see if the dataModel has written to the binding\n     */\n    writesBinding(binding) {\n      return this.writeDeps.has(binding);\n    }\n    /** Reset all tracking of dependencies */\n    reset() {\n      this.readDeps = /* @__PURE__ */ new Set();\n      this.writeDeps = /* @__PURE__ */ new Set();\n      this.namedDependencySets = {};\n      this.namedSet = \"core\";\n      this.createSubset(\"core\", true);\n      this.createSubset(\"children\", true);\n    }\n    addReadDep(binding, namedSet = this.namedSet) {\n      if (namedSet) {\n        this.namedDependencySets?.[namedSet]?.readDeps.add(binding);\n      }\n      this.readDeps.add(binding);\n    }\n    addWriteDep(binding, namedSet = this.namedSet) {\n      if (namedSet) {\n        this.namedDependencySets?.[namedSet]?.writeDeps.add(binding);\n      }\n      this.writeDeps.add(binding);\n    }\n    addChildReadDep(binding) {\n      this.addReadDep(binding, \"children\");\n    }\n  };\n  var DependencyModel = class extends DependencyTracker {\n    constructor(rootModel) {\n      super();\n      this.rootModel = rootModel;\n      this.set = this.set.bind(this);\n      this.get = this.get.bind(this);\n    }\n    set(transaction, options) {\n      transaction.forEach(([binding]) => this.addWriteDep(binding));\n      return this.rootModel.set(transaction, options);\n    }\n    get(binding, options) {\n      this.addReadDep(binding);\n      return this.rootModel.get(binding, options);\n    }\n    delete(binding, options) {\n      this.addWriteDep(binding);\n      return this.rootModel.delete(binding, options);\n    }\n  };\n  var NOOPDataModel = class {\n    get() {\n      return void 0;\n    }\n    set() {\n      return [];\n    }\n    delete() {\n    }\n  };\n  var NOOP_MODEL = new NOOPDataModel();\n  var ROOT_BINDING = new BindingInstance([]);\n  function withParser(model, parseBinding) {\n    function maybeParse(binding, readOnly) {\n      const parsed = isBinding(binding) ? binding : parseBinding(binding, {\n        get: model.get,\n        set: model.set,\n        readOnly\n      });\n      if (!parsed) {\n        throw new Error(\"Unable to parse binding\");\n      }\n      return parsed;\n    }\n    return {\n      get(binding, options) {\n        return model.get(maybeParse(binding, true), options);\n      },\n      set(transaction, options) {\n        return model.set(\n          transaction.map(([key, val]) => [maybeParse(key, false), val]),\n          options\n        );\n      },\n      delete(binding, options) {\n        return model.delete(maybeParse(binding, false), options);\n      }\n    };\n  }\n  function toModel(middleware, defaultOptions, next) {\n    if (!next) {\n      return middleware;\n    }\n    return {\n      get: (binding, options) => {\n        const resolvedOptions = options ?? defaultOptions;\n        if (middleware.get) {\n          return middleware.get(binding, resolvedOptions, next);\n        }\n        return next?.get(binding, resolvedOptions);\n      },\n      set: (transaction, options) => {\n        const resolvedOptions = options ?? defaultOptions;\n        if (middleware.set) {\n          return middleware.set(transaction, resolvedOptions, next);\n        }\n        return next?.set(transaction, resolvedOptions);\n      },\n      delete: (binding, options) => {\n        const resolvedOptions = options ?? defaultOptions;\n        if (middleware.delete) {\n          return middleware.delete(binding, resolvedOptions, next);\n        }\n        return next?.delete(binding, resolvedOptions);\n      }\n    };\n  }\n  function constructModelForPipeline(pipeline) {\n    if (pipeline.length === 0) {\n      return NOOP_MODEL;\n    }\n    if (pipeline.length === 1) {\n      return toModel(pipeline[0]);\n    }\n    function createModelWithOptions(options) {\n      const model = pipeline.reduce(\n        (nextModel, middleware) => toModel(middleware, options, nextModel),\n        void 0\n      ) ?? NOOP_MODEL;\n      return model;\n    }\n    return {\n      get: (binding, options) => {\n        return createModelWithOptions(options)?.get(binding, options);\n      },\n      set: (transaction, options) => {\n        return createModelWithOptions(options)?.set(transaction, options);\n      },\n      delete: (binding, options) => {\n        return createModelWithOptions(options)?.delete(binding, options);\n      }\n    };\n  }\n  var PipelinedDataModel = class {\n    constructor(pipeline = []) {\n      this.hooks = {\n        onSet: new SyncHook()\n      };\n      this.pipeline = pipeline;\n      this.effectiveDataModel = constructModelForPipeline(this.pipeline);\n    }\n    setMiddleware(handlers) {\n      this.pipeline = handlers;\n      this.effectiveDataModel = constructModelForPipeline(handlers);\n    }\n    addMiddleware(handler) {\n      this.pipeline = [...this.pipeline, handler];\n      this.effectiveDataModel = constructModelForPipeline(this.pipeline);\n    }\n    reset(model = {}) {\n      this.pipeline.forEach((middleware) => {\n        if (\"reset\" in middleware) {\n          middleware.reset?.();\n        }\n      });\n      this.set([[ROOT_BINDING, model]]);\n    }\n    set(transaction, options) {\n      const appliedTransaction = this.effectiveDataModel.set(\n        transaction,\n        options\n      );\n      this.hooks.onSet.call(transaction);\n      return appliedTransaction;\n    }\n    get(binding, options) {\n      return this.effectiveDataModel.get(binding, options);\n    }\n    delete(binding, options) {\n      return this.effectiveDataModel.delete(binding, options);\n    }\n  };\n  var LocalModel = class {\n    constructor(model = {}) {\n      this.model = model;\n      this.get = this.get.bind(this);\n      this.set = this.set.bind(this);\n    }\n    reset(model = {}) {\n      this.model = model;\n    }\n    get(binding) {\n      if (!binding || !binding.asString()) {\n        return this.model;\n      }\n      return dlv_es_default(this.model, binding.asArray());\n    }\n    set(transaction) {\n      const effectiveOperations = [];\n      transaction.forEach(([binding, value]) => {\n        const oldValue = this.get(binding);\n        this.model = (0, import_timm.setIn)(this.model, binding.asArray(), value);\n        effectiveOperations.push({ binding, oldValue, newValue: value });\n      });\n      return effectiveOperations;\n    }\n    delete(binding) {\n      const parentBinding = binding.parent();\n      if (parentBinding) {\n        const parentValue = this.get(parentBinding);\n        if (parentValue !== void 0) {\n          if (Array.isArray(parentValue)) {\n            this.model = (0, import_timm.setIn)(\n              this.model,\n              parentBinding.asArray(),\n              (0, import_timm.removeAt)(parentValue, binding.key())\n            );\n          } else {\n            this.model = (0, import_timm.setIn)(\n              this.model,\n              parentBinding.asArray(),\n              (0, import_timm.omit)(parentValue, binding.key())\n            );\n          }\n        }\n      }\n    }\n  };\n  var ExpNodeOpaqueIdentifier = Symbol(\"Expression Node ID\");\n  function isExpressionNode(x) {\n    return typeof x === \"object\" && x !== null && !Array.isArray(x) && x.__id === ExpNodeOpaqueIdentifier;\n  }\n  var PERIOD_CODE = 46;\n  var COMMA_CODE = 44;\n  var SQUOTE_CODE = 39;\n  var DQUOTE_CODE = 34;\n  var OPAREN_CODE = 40;\n  var CPAREN_CODE = 41;\n  var OBRACK_CODE = 91;\n  var CBRACK_CODE = 93;\n  var QUMARK_CODE = 63;\n  var SEMCOL_CODE = 59;\n  var COLON_CODE = 58;\n  var OCURL_CODE = 123;\n  var CCURL_CODE = 125;\n  var t = true;\n  var unaryOps = { \"-\": t, \"!\": t, \"~\": t, \"+\": t };\n  var binaryOps = {\n    \"=\": 3,\n    \"+=\": 3,\n    \"-=\": 3,\n    \"&=\": 3,\n    \"|=\": 3,\n    // Conditional: 4,\n    \"||\": 5,\n    \"&&\": 6,\n    \"|\": 7,\n    \"^\": 8,\n    \"&\": 9,\n    \"==\": 10,\n    \"!=\": 10,\n    \"===\": 10,\n    \"!==\": 10,\n    \"<\": 11,\n    \">\": 11,\n    \"<=\": 11,\n    \">=\": 11,\n    \"<<\": 12,\n    \">>\": 12,\n    \">>>\": 12,\n    \"+\": 13,\n    \"-\": 13,\n    \"*\": 14,\n    \"/\": 14,\n    \"%\": 14\n  };\n  function throwError(message, index) {\n    const err = new Error(`${message} at character ${index}`);\n    err.index = index;\n    err.description = message;\n    throw err;\n  }\n  function createSpanningLocation(start, end) {\n    if (!start || !end) {\n      return;\n    }\n    return {\n      start: start.start,\n      end: end.end\n    };\n  }\n  function getMaxKeyLen(obj) {\n    let maxLen = 0;\n    Object.keys(obj).forEach((key) => {\n      if (key.length > maxLen && Object.prototype.hasOwnProperty.call(obj, key)) {\n        maxLen = key.length;\n      }\n    });\n    return maxLen;\n  }\n  var maxUnopLen = getMaxKeyLen(unaryOps);\n  var maxBinopLen = getMaxKeyLen(binaryOps);\n  var literals = {\n    true: true,\n    false: false,\n    null: null,\n    undefined: void 0\n  };\n  var thisStr = \"this\";\n  function binaryPrecedence(opVal) {\n    return binaryOps[opVal] || 0;\n  }\n  function createBinaryExpression(operator, left, right, location) {\n    let type;\n    if (operator === \"||\" || operator === \"&&\") {\n      type = \"LogicalExpression\";\n    } else if (operator === \"=\") {\n      type = \"Assignment\";\n    } else if (operator === \"+=\" || operator === \"-=\" || operator === \"&=\" || operator === \"|=\") {\n      type = \"Modification\";\n    } else {\n      type = \"BinaryExpression\";\n    }\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type,\n      operator,\n      left,\n      right,\n      location\n    };\n  }\n  function isDecimalDigit(ch) {\n    return ch >= 48 && ch <= 57;\n  }\n  function isIdentifierStart(ch) {\n    return ch === 36 || ch === 95 || // `$` and `_`\n    ch >= 65 && ch <= 90 || // A...Z\n    ch >= 97 && ch <= 122;\n  }\n  function isIdentifierPart(ch) {\n    return ch === 36 || ch === 95 || // `$` and `_`\n    ch >= 65 && ch <= 90 || // A...Z\n    ch >= 97 && ch <= 122 || // A...z\n    ch >= 48 && ch <= 57;\n  }\n  function isModelRefStart(ch0, ch1) {\n    return ch0 === OCURL_CODE && ch1 === OCURL_CODE;\n  }\n  function parseExpression(expr, options) {\n    const strictMode = options?.strict ?? true;\n    const charAtFunc = expr.charAt;\n    const charCodeAtFunc = expr.charCodeAt;\n    const { length } = expr;\n    let index = 0;\n    const getLocation = (startChar) => {\n      return {\n        start: {\n          character: startChar\n        },\n        end: {\n          character: index\n        }\n      };\n    };\n    function exprI(i) {\n      return charAtFunc.call(expr, i);\n    }\n    function exprICode(i) {\n      return charCodeAtFunc.call(expr, i);\n    }\n    function gobbleObjects() {\n      const attributes = [];\n      let closed = false;\n      let shouldDefineKey = true;\n      let key;\n      let value;\n      let chCode;\n      const startCharIndex = index;\n      ++index;\n      while (index < length) {\n        gobbleSpaces();\n        chCode = exprICode(index);\n        if (chCode === CCURL_CODE) {\n          if (key) {\n            throwError(\"A key was defined but a value was not\", index);\n          }\n          index++;\n          closed = true;\n          break;\n        } else if (shouldDefineKey) {\n          if (chCode !== SQUOTE_CODE && chCode !== DQUOTE_CODE) {\n            throwError(\"An object must start wtih a key\", index);\n          }\n          key = gobbleStringLiteral();\n          gobbleSpaces();\n          if (exprICode(index) === COLON_CODE) {\n            index++;\n            shouldDefineKey = false;\n          } else {\n            throwError(\"A colon must follow an object key\", index);\n          }\n        } else {\n          value = gobbleExpression();\n          attributes.push({ key, value });\n          gobbleSpaces();\n          chCode = exprICode(index);\n          if (chCode === COMMA_CODE) {\n            index++;\n          } else if (chCode !== CCURL_CODE) {\n            throwError(\"Please add a comma to add another key\", index);\n          }\n          shouldDefineKey = true;\n          key = void 0;\n          value = void 0;\n        }\n        chCode = exprICode(index);\n      }\n      if (!closed) {\n        throwError(`Unclosed brace in object`, index);\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Object\",\n        attributes,\n        location: getLocation(startCharIndex)\n      };\n    }\n    function gobbleSpaces() {\n      let ch = exprICode(index);\n      while (ch === 32 || ch === 9) {\n        ch = exprICode(++index);\n      }\n    }\n    function gobbleExpression() {\n      const test = gobbleBinaryExpression();\n      gobbleSpaces();\n      const startCharIndex = index;\n      if (index < length && exprICode(index) === QUMARK_CODE) {\n        index++;\n        const consequent = gobbleExpression();\n        if (!consequent) {\n          throwError(\"Expected expression\", index);\n        }\n        gobbleSpaces();\n        if (exprICode(index) === COLON_CODE) {\n          index++;\n          const alternate = gobbleExpression();\n          if (!alternate) {\n            throwError(\"Expected expression\", index);\n          }\n          return {\n            __id: ExpNodeOpaqueIdentifier,\n            type: \"ConditionalExpression\",\n            test,\n            consequent,\n            alternate,\n            location: getLocation(startCharIndex)\n          };\n        }\n        throwError(\"Expected :\", index);\n      }\n      return test;\n    }\n    function gobbleBinaryOp() {\n      gobbleSpaces();\n      let toCheck = expr.substr(index, maxBinopLen);\n      let tcLen = toCheck.length;\n      while (tcLen > 0) {\n        if (Object.prototype.hasOwnProperty.call(binaryOps, toCheck)) {\n          index += tcLen;\n          return toCheck;\n        }\n        toCheck = toCheck.substr(0, --tcLen);\n      }\n      return false;\n    }\n    function gobbleBinaryExpression() {\n      let node;\n      let prec;\n      let i;\n      let left = gobbleToken();\n      let biop = gobbleBinaryOp();\n      if (!biop) {\n        return left;\n      }\n      let biopInfo = { value: biop, prec: binaryPrecedence(biop) };\n      let right = gobbleToken();\n      if (!right) {\n        throwError(`Expected expression after ${biop}`, index);\n      }\n      const stack = [left, biopInfo, right];\n      biop = gobbleBinaryOp();\n      while (biop) {\n        prec = binaryPrecedence(biop);\n        if (prec === 0) {\n          break;\n        }\n        biopInfo = { value: biop, prec };\n        while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n          right = stack.pop();\n          biop = stack.pop().value;\n          left = stack.pop();\n          node = createBinaryExpression(\n            biop,\n            left,\n            right,\n            createSpanningLocation(left.location, right.location)\n          );\n          stack.push(node);\n        }\n        node = gobbleToken();\n        if (!node) {\n          throwError(`Expected expression after ${biop}`, index);\n        }\n        stack.push(biopInfo, node);\n        biop = gobbleBinaryOp();\n      }\n      i = stack.length - 1;\n      node = stack[i];\n      while (i > 1) {\n        node = createBinaryExpression(\n          stack[i - 1].value,\n          stack[i - 2],\n          node,\n          createSpanningLocation(stack[i - 2].location, node.location)\n        );\n        i -= 2;\n      }\n      return node;\n    }\n    function gobbleToken() {\n      gobbleSpaces();\n      const ch = exprICode(index);\n      const startCharIndex = index;\n      if (isDecimalDigit(ch) || ch === PERIOD_CODE) {\n        return gobbleNumericLiteral();\n      }\n      if (ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\n        return gobbleStringLiteral();\n      }\n      if (isIdentifierStart(ch) || ch === OPAREN_CODE) {\n        return gobbleVariable();\n      }\n      if (ch === OBRACK_CODE) {\n        return gobbleArray();\n      }\n      if (isModelRefStart(ch, exprICode(index + 1))) {\n        return gobbleModelRef();\n      }\n      if (ch === OCURL_CODE) {\n        return gobbleObjects();\n      }\n      let toCheck = expr.substr(index, maxUnopLen);\n      let tcLen = toCheck.length;\n      while (tcLen > 0) {\n        if (Object.prototype.hasOwnProperty.call(unaryOps, toCheck)) {\n          index += tcLen;\n          return {\n            __id: ExpNodeOpaqueIdentifier,\n            type: \"UnaryExpression\",\n            operator: toCheck,\n            argument: gobbleToken(),\n            prefix: true,\n            location: getLocation(startCharIndex)\n          };\n        }\n        toCheck = toCheck.substr(0, --tcLen);\n      }\n      return false;\n    }\n    function gobbleNumericLiteral() {\n      let num = \"\";\n      const startCharIndex = index;\n      while (isDecimalDigit(exprICode(index))) {\n        num += exprI(index++);\n      }\n      if (exprICode(index) === PERIOD_CODE) {\n        num += exprI(index++);\n        while (isDecimalDigit(exprICode(index))) {\n          num += exprI(index++);\n        }\n      }\n      let ch = exprI(index);\n      if (ch === \"e\" || ch === \"E\") {\n        num += exprI(index++);\n        ch = exprI(index);\n        if (ch === \"+\" || ch === \"-\") {\n          num += exprI(index++);\n        }\n        while (isDecimalDigit(exprICode(index))) {\n          num += exprI(index++);\n        }\n        if (!isDecimalDigit(exprICode(index - 1))) {\n          throwError(`Expected exponent (${num}${exprI(index)})`, index);\n        }\n      }\n      const chCode = exprICode(index);\n      if (isIdentifierStart(chCode)) {\n        throwError(\n          `Variable names cannot start with a number (${num}${exprI(index)})`,\n          index\n        );\n      } else if (chCode === PERIOD_CODE) {\n        throwError(\"Unexpected period\", index);\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Literal\",\n        value: parseFloat(num),\n        raw: num,\n        location: getLocation(startCharIndex)\n      };\n    }\n    function gobbleStringLiteral() {\n      const quote = exprI(index++);\n      let str = \"\";\n      let closed = false;\n      const startCharIndex = index;\n      while (index < length) {\n        let ch = exprI(index++);\n        if (ch === quote) {\n          closed = true;\n          break;\n        }\n        if (ch !== \"\\\\\") {\n          str += ch;\n          continue;\n        }\n        ch = exprI(index++);\n        switch (ch) {\n          case \"n\":\n            str += \"\\n\";\n            break;\n          case \"r\":\n            str += \"\\r\";\n            break;\n          case \"t\":\n            str += \"\t\";\n            break;\n          case \"b\":\n            str += \"\\b\";\n            break;\n          case \"f\":\n            str += \"\\f\";\n            break;\n          case \"v\":\n            str += \"\\v\";\n            break;\n          default:\n        }\n      }\n      if (!closed) {\n        throwError(`Unclosed quote after \"${str}\"`, index);\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Literal\",\n        value: str,\n        raw: `${quote}${str}${quote}`,\n        location: getLocation(startCharIndex)\n      };\n    }\n    function gobbleModelRef() {\n      let str = \"\";\n      let closed = false;\n      let openBraceCount = 1;\n      const startCharIndex = index;\n      index += 2;\n      while (index < length) {\n        const ch = exprI(index++);\n        if (ch === \"}\" && exprICode(index) === CCURL_CODE) {\n          index++;\n          openBraceCount--;\n          if (openBraceCount === 0) {\n            closed = true;\n            break;\n          }\n          str += \"}}\";\n        } else if (ch === \"{\" && exprICode(index) === OCURL_CODE) {\n          openBraceCount++;\n          str += \"{{\";\n          index++;\n        } else {\n          str += ch;\n        }\n      }\n      if (!closed) {\n        throwError(`Unclosed brace after \"${str}\"`, index);\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"ModelRef\",\n        ref: str,\n        location: getLocation(startCharIndex)\n      };\n    }\n    function gobbleIdentifier() {\n      const start = index;\n      let ch = exprICode(start);\n      if (isIdentifierStart(ch)) {\n        index++;\n      } else {\n        throwError(`Unexpected ${exprI(index)}`, index);\n      }\n      while (index < length) {\n        ch = exprICode(index);\n        if (isIdentifierPart(ch)) {\n          index++;\n        } else {\n          break;\n        }\n      }\n      const identifier = expr.slice(start, index);\n      if (Object.prototype.hasOwnProperty.call(literals, identifier)) {\n        return {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"Literal\",\n          value: literals[identifier],\n          raw: identifier,\n          location: getLocation(start)\n        };\n      }\n      if (identifier === thisStr) {\n        return {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"ThisExpression\",\n          location: getLocation(start)\n        };\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Identifier\",\n        name: identifier,\n        location: getLocation(start)\n      };\n    }\n    function gobbleArguments(termination) {\n      const args = [];\n      let charIndex;\n      let node;\n      while (index < length) {\n        gobbleSpaces();\n        charIndex = exprICode(index);\n        if (charIndex === termination) {\n          index++;\n          break;\n        }\n        if (charIndex === COMMA_CODE) {\n          index++;\n          continue;\n        }\n        node = gobbleExpression();\n        if (!node || node.type === \"Compound\") {\n          throwError(\"Expected comma\", index);\n        }\n        args.push(node);\n      }\n      if (strictMode && charIndex !== termination) {\n        throwError(`Expected ${String.fromCharCode(termination)}`, index);\n      }\n      return args;\n    }\n    function gobbleVariable() {\n      let charIndex = exprICode(index);\n      let node = charIndex === OPAREN_CODE ? gobbleGroup() : gobbleIdentifier();\n      const startCharIndex = index;\n      gobbleSpaces();\n      charIndex = exprICode(index);\n      while (charIndex === PERIOD_CODE || charIndex === OBRACK_CODE || charIndex === OPAREN_CODE) {\n        index++;\n        if (charIndex === PERIOD_CODE) {\n          gobbleSpaces();\n          node = {\n            __id: ExpNodeOpaqueIdentifier,\n            type: \"MemberExpression\",\n            computed: false,\n            object: node,\n            property: gobbleIdentifier(),\n            location: getLocation(startCharIndex)\n          };\n        } else if (charIndex === OBRACK_CODE) {\n          node = {\n            __id: ExpNodeOpaqueIdentifier,\n            type: \"MemberExpression\",\n            computed: true,\n            object: node,\n            property: gobbleExpression(),\n            location: getLocation(startCharIndex)\n          };\n          gobbleSpaces();\n          charIndex = exprICode(index);\n          if (charIndex !== CBRACK_CODE) {\n            throwError(\"Unclosed [\", index);\n          }\n          index++;\n        } else if (charIndex === OPAREN_CODE) {\n          node = {\n            __id: ExpNodeOpaqueIdentifier,\n            type: \"CallExpression\",\n            args: gobbleArguments(CPAREN_CODE),\n            callTarget: node,\n            location: getLocation(startCharIndex)\n          };\n        }\n        gobbleSpaces();\n        charIndex = exprICode(index);\n      }\n      return node;\n    }\n    function gobbleGroup() {\n      index++;\n      const node = gobbleExpression();\n      gobbleSpaces();\n      if (exprICode(index) === CPAREN_CODE) {\n        index++;\n        return node;\n      }\n      throwError(\"Unclosed (\", index);\n    }\n    function gobbleArray() {\n      const startCharIndex = index;\n      index++;\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"ArrayExpression\",\n        elements: gobbleArguments(CBRACK_CODE),\n        location: getLocation(startCharIndex)\n      };\n    }\n    const nodes = [];\n    try {\n      while (index < length) {\n        const chIndex = exprICode(index);\n        if (chIndex === SEMCOL_CODE || chIndex === COMMA_CODE) {\n          index++;\n          continue;\n        }\n        const node = gobbleExpression();\n        if (node) {\n          nodes.push(node);\n        } else if (strictMode && index < length) {\n          throwError(`Unexpected \"${exprI(index)}\"`, index);\n        }\n      }\n      if (nodes.length === 1) {\n        return nodes[0];\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Compound\",\n        body: nodes,\n        location: getLocation(0)\n      };\n    } catch (e) {\n      if (strictMode || !(e instanceof Error)) {\n        throw e;\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Compound\",\n        body: nodes,\n        location: getLocation(0),\n        error: e\n      };\n    }\n  }\n  var evaluator_functions_exports = {};\n  __export2(evaluator_functions_exports, {\n    conditional: () => conditional,\n    deleteDataVal: () => deleteDataVal,\n    getDataVal: () => getDataVal,\n    setDataVal: () => setDataVal,\n    waitFor: () => waitFor\n  });\n  function isPromiseLike(value) {\n    return value != null && typeof value === \"object\" && typeof value.then === \"function\" && // Additional safeguards against false positives\n    (value instanceof Promise || // Check for standard Promise constructor name\n    value.constructor?.name === \"Promise\" || // Verify it has other Promise-like methods to reduce false positives\n    typeof value.catch === \"function\" && typeof value.finally === \"function\");\n  }\n  var AwaitableSymbol = Symbol(\"Awaitable\");\n  function isAwaitable(val) {\n    return isPromiseLike(val) && val[AwaitableSymbol] !== void 0;\n  }\n  function collateAwaitable(promises) {\n    const result = Promise.all(promises);\n    return makeAwaitable(result);\n  }\n  function makeAwaitable(promise) {\n    promise[AwaitableSymbol] = AwaitableSymbol;\n    promise.awaitableThen = (arg) => {\n      return makeAwaitable(promise.then(arg));\n    };\n    return promise;\n  }\n  var setDataVal = (_context, binding, value) => {\n    _context.model.set([[binding, value]]);\n  };\n  var getDataVal = (_context, binding) => {\n    return _context.model.get(binding);\n  };\n  var deleteDataVal = (_context, binding) => {\n    return _context.model.delete(binding);\n  };\n  var conditional = (ctx, condition, ifTrue, ifFalse) => {\n    const testResult = ctx.evaluate(condition);\n    if (isAwaitable(testResult)) {\n      return testResult.awaitableThen((resolvedTest) => {\n        if (resolvedTest) {\n          return ctx.evaluate(ifTrue);\n        }\n        if (ifFalse) {\n          return ctx.evaluate(ifFalse);\n        }\n        return null;\n      });\n    }\n    if (testResult) {\n      return ctx.evaluate(ifTrue);\n    }\n    if (ifFalse) {\n      return ctx.evaluate(ifFalse);\n    }\n    return null;\n  };\n  conditional.resolveParams = false;\n  var waitFor = (ctx, promise) => {\n    return makeAwaitable(promise);\n  };\n  function isObjectExpression(expr) {\n    if (isExpressionNode(expr)) {\n      return false;\n    }\n    return typeof expr === \"object\" && expr !== null && !Array.isArray(expr) && \"value\" in expr;\n  }\n  var andandOperator = (ctx, a, b, async) => {\n    return LogicalOperators.and(ctx, a, b, async);\n  };\n  andandOperator.resolveParams = false;\n  var ororOperator = (ctx, a, b, async) => {\n    return LogicalOperators.or(ctx, a, b, async);\n  };\n  ororOperator.resolveParams = false;\n  var DEFAULT_BINARY_OPERATORS = {\n    // TODO: A lot of these functions used to do type coercion. Not sure if we want to keep that behavior or not.\n    \"+\": (a, b) => a + b,\n    \"-\": (a, b) => a - b,\n    \"*\": (a, b) => a * b,\n    \"/\": (a, b) => a / b,\n    \"%\": (a, b) => a % b,\n    // Promise-aware comparison operators\n    // eslint-disable-next-line\n    \"==\": makePromiseAwareBinaryOp((a, b) => a == b),\n    // eslint-disable-next-line\n    \"!=\": makePromiseAwareBinaryOp((a, b) => a != b),\n    \">\": makePromiseAwareBinaryOp((a, b) => a > b),\n    \">=\": makePromiseAwareBinaryOp((a, b) => a >= b),\n    \"<\": makePromiseAwareBinaryOp((a, b) => a < b),\n    \"<=\": makePromiseAwareBinaryOp((a, b) => a <= b),\n    \"!==\": makePromiseAwareBinaryOp((a, b) => a !== b),\n    \"===\": makePromiseAwareBinaryOp((a, b) => a === b),\n    \"&&\": andandOperator,\n    \"||\": ororOperator,\n    // eslint-disable-next-line\n    \"|\": (a, b) => a | b,\n    // eslint-disable-next-line\n    \"&\": (a, b) => a & b,\n    \"+=\": (a, b) => a + b,\n    \"-=\": (a, b) => a - b,\n    // eslint-disable-next-line\n    \"&=\": (a, b) => a & b,\n    // eslint-disable-next-line\n    \"|=\": (a, b) => a | b\n  };\n  var DEFAULT_UNARY_OPERATORS = {\n    \"-\": (a) => -a,\n    \"+\": (a) => Number(a),\n    \"!\": makePromiseAwareUnaryOp((a) => !a)\n  };\n  function makePromiseAwareBinaryOp(operation) {\n    return (a, b, async) => {\n      if (async && (isAwaitable(a) || isAwaitable(b))) {\n        return collateAwaitable([\n          Promise.resolve(a),\n          Promise.resolve(b)\n        ]).awaitableThen(\n          ([resolvedA, resolvedB]) => operation(resolvedA, resolvedB)\n        );\n      }\n      return operation(a, b);\n    };\n  }\n  function makePromiseAwareUnaryOp(operation) {\n    return (a, async) => {\n      if (async && isAwaitable(a)) {\n        return a.awaitableThen((resolved) => operation(resolved));\n      }\n      return operation(a);\n    };\n  }\n  function handleConditionalBranching(testValue, getTrueBranch, getFalseBranch, resolveNode, async) {\n    if (async && isAwaitable(testValue)) {\n      return testValue.awaitableThen((resolved) => {\n        const branch2 = resolved ? getTrueBranch() : getFalseBranch();\n        const branchResult = resolveNode(branch2);\n        return isAwaitable(branchResult) ? Promise.resolve(branchResult) : branchResult;\n      });\n    }\n    const branch = testValue ? getTrueBranch() : getFalseBranch();\n    return resolveNode(branch);\n  }\n  var PromiseCollectionHandler = {\n    /**\n     * Handle array with potential Promise elements\n     */\n    handleArray(items, async) {\n      if (!async) {\n        return items;\n      }\n      const hasPromises = items.some((item) => isAwaitable(item));\n      return hasPromises ? collateAwaitable(items) : items;\n    },\n    /**\n     * Handle object with potential Promise keys/values\n     */\n    handleObject(attributes, resolveNode, async) {\n      const resolvedAttributes = {};\n      const promises = [];\n      let hasPromises = false;\n      attributes.forEach((attr) => {\n        const key = resolveNode(attr.key);\n        const value = resolveNode(attr.value);\n        if (async && (isAwaitable(key) || isAwaitable(value))) {\n          hasPromises = true;\n          const keyPromise = Promise.resolve(key);\n          const valuePromise = Promise.resolve(value);\n          promises.push(\n            collateAwaitable([keyPromise, valuePromise]).awaitableThen(\n              ([resolvedKey, resolvedValue]) => {\n                resolvedAttributes[resolvedKey] = resolvedValue;\n              }\n            )\n          );\n        } else {\n          resolvedAttributes[key] = value;\n        }\n      });\n      return hasPromises ? collateAwaitable(promises).awaitableThen(() => resolvedAttributes) : resolvedAttributes;\n    }\n  };\n  var LogicalOperators = {\n    and: (ctx, leftNode, rightNode, async) => {\n      const leftResult = ctx.evaluate(leftNode);\n      if (async && isAwaitable(leftResult)) {\n        return leftResult.awaitableThen((awaitedLeft) => {\n          if (!awaitedLeft)\n            return awaitedLeft;\n          const rightResult = ctx.evaluate(rightNode);\n          return isAwaitable(rightResult) ? rightResult : Promise.resolve(rightResult);\n        });\n      }\n      return leftResult && ctx.evaluate(rightNode);\n    },\n    or: (ctx, leftNode, rightNode, async) => {\n      const leftResult = ctx.evaluate(leftNode);\n      if (async && isAwaitable(leftResult)) {\n        return leftResult.awaitableThen((awaitedLeft) => {\n          if (awaitedLeft)\n            return awaitedLeft;\n          const rightResult = ctx.evaluate(rightNode);\n          return isAwaitable(rightResult) ? rightResult : Promise.resolve(rightResult);\n        });\n      }\n      return leftResult || ctx.evaluate(rightNode);\n    }\n  };\n  var ExpressionEvaluator = class {\n    constructor(defaultOptions) {\n      this.vars = {};\n      this.hooks = {\n        /** Resolve an AST node for an expression to a value */\n        resolve: new SyncWaterfallHook(),\n        /** Gets the options that will be passed in calls to the resolve hook */\n        resolveOptions: new SyncWaterfallHook(),\n        /** Allows users to change the expression to be evaluated before processing */\n        beforeEvaluate: new SyncWaterfallHook(),\n        /**\n         * An optional means of handling an error in the expression execution\n         * Return true if handled, to stop propagation of the error\n         */\n        onError: new SyncBailHook()\n      };\n      this.expressionsCache = /* @__PURE__ */ new Map();\n      this.operators = {\n        binary: new Map(\n          Object.entries(DEFAULT_BINARY_OPERATORS)\n        ),\n        unary: new Map(\n          Object.entries(DEFAULT_UNARY_OPERATORS)\n        ),\n        expressions: new Map([\n          ...Object.entries(evaluator_functions_exports),\n          [\"await\", waitFor]\n        ])\n      };\n      this.defaultHookOptions = {\n        ...defaultOptions,\n        evaluate: (expr) => this.evaluate(expr, this.defaultHookOptions),\n        resolveNode: (node) => this._execAST(node, this.defaultHookOptions)\n      };\n      this.hooks.resolve.tap(\"ExpressionEvaluator\", (result, node, options) => {\n        return this._resolveNode(result, node, options);\n      });\n      this.evaluate = this.evaluate.bind(this);\n    }\n    reset() {\n      this.expressionsCache.clear();\n    }\n    evaluate(expr, options) {\n      const resolvedOpts = this.hooks.resolveOptions.call({\n        ...this.defaultHookOptions,\n        ...options,\n        resolveNode: (node) => this._execAST(node, resolvedOpts)\n      });\n      let expression = this.hooks.beforeEvaluate.call(expr, resolvedOpts) ?? expr;\n      while (isObjectExpression(expression)) {\n        expression = expression.value;\n      }\n      if (typeof expression === \"number\" || typeof expression === \"boolean\" || expression === void 0 || expression === null) {\n        return expression;\n      }\n      if (isExpressionNode(expression)) {\n        return this._execAST(expression, resolvedOpts);\n      }\n      if (Array.isArray(expression)) {\n        return expression.reduce(\n          (_nothing, exp) => this.evaluate(exp, options),\n          null\n        );\n      }\n      return this._execString(String(expression), resolvedOpts);\n    }\n    /**\n     * Evaluate functions in an async context\n     * @experimental These Player APIs are in active development and may change. Use with caution\n     */\n    evaluateAsync(expr, options) {\n      if (Array.isArray(expr)) {\n        return collateAwaitable(\n          expr.map(\n            async (exp) => this.evaluate(exp, { ...options, async: true })\n          )\n        ).awaitableThen((values) => {\n          return values.pop();\n        });\n      } else {\n        return this.evaluate(expr, { ...options, async: true });\n      }\n    }\n    addExpressionFunction(name, handler) {\n      this.operators.expressions.set(name, handler);\n    }\n    addBinaryOperator(operator, handler) {\n      this.operators.binary.set(operator, handler);\n    }\n    addUnaryOperator(operator, handler) {\n      this.operators.unary.set(operator, handler);\n    }\n    setExpressionVariable(name, value) {\n      this.vars[name] = value;\n    }\n    getExpressionVariable(name) {\n      return this.vars[name];\n    }\n    _execAST(node, options) {\n      return this.hooks.resolve.call(void 0, node, options);\n    }\n    _execString(exp, options) {\n      if (exp === \"\") {\n        return exp;\n      }\n      const matches = exp.match(/^@\\[(.*)\\]@$/);\n      let matchedExp = exp;\n      if (matches) {\n        const [, matched] = Array.from(matches);\n        if (matched) {\n          matchedExp = matched;\n        }\n      }\n      let storedAST;\n      try {\n        storedAST = this.expressionsCache.get(matchedExp) ?? parseExpression(matchedExp, { strict: options.strict });\n        this.expressionsCache.set(matchedExp, storedAST);\n      } catch (e) {\n        if (options.throwErrors || !this.hooks.onError.call(e)) {\n          throw new import_ts_nested_error3.NestedError(`Error parsing expression: ${exp}`, e);\n        }\n        return;\n      }\n      try {\n        return this._execAST(storedAST, options);\n      } catch (e) {\n        if (options.throwErrors || !this.hooks.onError.call(e)) {\n          throw new import_ts_nested_error3.NestedError(`Error evaluating expression: ${exp}`, e);\n        }\n      }\n    }\n    _resolveNode(_currentValue, node, options) {\n      const { resolveNode, model } = options;\n      const isAsync = options.async ?? false;\n      const expressionContext = {\n        ...options,\n        evaluate: (expr) => this.evaluate(expr, options)\n      };\n      if (node.type === \"Literal\") {\n        return node.value;\n      }\n      if (node.type === \"Identifier\") {\n        return this.vars[node.name];\n      }\n      if (node.type === \"Compound\" || node.type === \"ThisExpression\") {\n        throw new Error(`Expression type: ${node.type} is not supported`);\n      }\n      if (node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\") {\n        const operator = this.operators.binary.get(node.operator);\n        if (operator) {\n          if (\"resolveParams\" in operator) {\n            if (operator.resolveParams === false) {\n              return operator(expressionContext, node.left, node.right, isAsync);\n            }\n            const left2 = resolveNode(node.left);\n            const right2 = resolveNode(node.right);\n            if (options.async && (isAwaitable(left2) || isAwaitable(right2))) {\n              return collateAwaitable([left2, right2]).awaitableThen(\n                ([leftVal, rightVal]) => operator(expressionContext, leftVal, rightVal, isAsync)\n              );\n            }\n            return operator(expressionContext, left2, right2, isAsync);\n          }\n          const left = resolveNode(node.left);\n          const right = resolveNode(node.right);\n          if (options.async && (isAwaitable(left) || isAwaitable(right))) {\n            return collateAwaitable([left, right]).awaitableThen(\n              ([leftVal, rightVal]) => operator(leftVal, rightVal, isAsync)\n            );\n          }\n          return operator(left, right, isAsync);\n        }\n        return;\n      }\n      if (node.type === \"UnaryExpression\") {\n        const operator = this.operators.unary.get(node.operator);\n        if (operator) {\n          if (\"resolveParams\" in operator) {\n            if (operator.resolveParams === false) {\n              return operator(expressionContext, node.argument, isAsync);\n            }\n            const arg2 = resolveNode(node.argument);\n            if (options.async && isAwaitable(arg2)) {\n              return arg2.awaitableThen(\n                (argVal) => operator(expressionContext, argVal, isAsync)\n              );\n            }\n            return operator(expressionContext, arg2, isAsync);\n          }\n          const arg = resolveNode(node.argument);\n          if (options.async && isAwaitable(arg)) {\n            return arg.awaitableThen((argVal) => operator(argVal, isAsync));\n          }\n          return operator(arg, isAsync);\n        }\n        return;\n      }\n      if (node.type === \"Object\") {\n        return PromiseCollectionHandler.handleObject(\n          node.attributes,\n          resolveNode,\n          options.async || false\n        );\n      }\n      if (node.type === \"CallExpression\") {\n        const expressionName = node.callTarget.name;\n        const operator = this.operators.expressions.get(expressionName);\n        if (!operator) {\n          throw new Error(`Unknown expression function: ${expressionName}`);\n        }\n        if (operator.name === waitFor.name && !options.async) {\n          throw new Error(\"Usage of await outside of async context\");\n        }\n        if (\"resolveParams\" in operator && operator.resolveParams === false) {\n          return operator(expressionContext, ...node.args);\n        }\n        const args = node.args.map((n) => resolveNode(n));\n        if (options.async) {\n          const hasPromises = args.some(isAwaitable);\n          if (hasPromises) {\n            return collateAwaitable(args).awaitableThen(\n              (resolvedArgs) => operator(expressionContext, ...resolvedArgs)\n            );\n          }\n        }\n        return operator(expressionContext, ...args);\n      }\n      if (node.type === \"ModelRef\") {\n        return model.get(node.ref, { context: { model: options.model } });\n      }\n      if (node.type === \"MemberExpression\") {\n        const obj = resolveNode(node.object);\n        const prop = resolveNode(node.property);\n        if (options.async && (isAwaitable(obj) || isAwaitable(prop))) {\n          return collateAwaitable([obj, prop]).awaitableThen(\n            ([objVal, propVal]) => objVal[propVal]\n          );\n        }\n        return obj[prop];\n      }\n      if (node.type === \"Assignment\") {\n        if (node.left.type === \"ModelRef\") {\n          const value = resolveNode(node.right);\n          if (isPromiseLike(value)) {\n            if (options.async && isAwaitable(value)) {\n              return value.awaitableThen((resolvedValue) => {\n                model.set([[node.left.ref, resolvedValue]]);\n                return resolvedValue;\n              });\n            } else {\n              options.logger?.warn(\n                \"Unawaited promise written to mode, this behavior is undefined and may change in future releases\"\n              );\n            }\n          }\n          model.set([[node.left.ref, value]]);\n          return value;\n        }\n        if (node.left.type === \"Identifier\") {\n          const value = resolveNode(node.right);\n          if (options.async && isAwaitable(value)) {\n            return value.awaitableThen((resolvedValue) => {\n              this.vars[node.left.name] = resolvedValue;\n              return resolvedValue;\n            });\n          }\n          this.vars[node.left.name] = value;\n          return value;\n        }\n        return;\n      }\n      if (node.type === \"ConditionalExpression\") {\n        const testResult = resolveNode(node.test);\n        return handleConditionalBranching(\n          testResult,\n          () => node.consequent,\n          () => node.alternate,\n          resolveNode,\n          isAsync\n        );\n      }\n      if (node.type === \"ArrayExpression\") {\n        const results = node.elements.map((ele) => resolveNode(ele));\n        return PromiseCollectionHandler.handleArray(results, isAsync);\n      }\n      if (node.type === \"Modification\") {\n        const operation = this.operators.binary.get(node.operator);\n        if (operation) {\n          let newValue;\n          if (\"resolveParams\" in operation) {\n            if (operation.resolveParams === false) {\n              newValue = operation(\n                expressionContext,\n                node.left,\n                node.right,\n                isAsync\n              );\n            } else {\n              const left = resolveNode(node.left);\n              const right = resolveNode(node.right);\n              if (options.async && (isAwaitable(left) || isAwaitable(right))) {\n                newValue = collateAwaitable([left, right]).awaitableThen(\n                  ([leftVal, rightVal]) => operation(expressionContext, leftVal, rightVal, isAsync)\n                );\n              } else {\n                newValue = operation(expressionContext, left, right, isAsync);\n              }\n            }\n          } else {\n            const left = resolveNode(node.left);\n            const right = resolveNode(node.right);\n            if (options.async && (isAwaitable(left) || isAwaitable(right))) {\n              newValue = collateAwaitable([left, right]).awaitableThen(\n                ([leftVal, rightVal]) => operation(leftVal, rightVal, isAsync)\n              );\n            } else {\n              newValue = operation(left, right, isAsync);\n            }\n          }\n          if (node.left.type === \"ModelRef\") {\n            if (options.async && isAwaitable(newValue)) {\n              return newValue.awaitableThen((resolvedValue) => {\n                model.set([[node.left.ref, resolvedValue]]);\n                return resolvedValue;\n              });\n            }\n            model.set([[node.left.ref, newValue]]);\n          } else if (node.left.type === \"Identifier\") {\n            if (options.async && isAwaitable(newValue)) {\n              return newValue.awaitableThen((resolvedValue) => {\n                this.vars[node.left.name] = resolvedValue;\n                return resolvedValue;\n              });\n            }\n            this.vars[node.left.name] = newValue;\n          }\n          return newValue;\n        }\n        return resolveNode(node.left);\n      }\n    }\n  };\n  var TapableLogger = class {\n    constructor() {\n      this.hooks = {\n        trace: new SyncHook(),\n        debug: new SyncHook(),\n        info: new SyncHook(),\n        warn: new SyncHook(),\n        error: new SyncHook(),\n        log: new SyncHook()\n      };\n      this.logHandlers = /* @__PURE__ */ new Set();\n      this.trace = this.createHandler(\"trace\");\n      this.debug = this.createHandler(\"debug\");\n      this.info = this.createHandler(\"info\");\n      this.warn = this.createHandler(\"warn\");\n      this.error = this.createHandler(\"error\");\n    }\n    createHandler(severity) {\n      return (...args) => {\n        this.hooks[severity].call(args);\n        this.hooks.log.call(severity, args);\n        this.logHandlers.forEach((logger) => logger[severity](...args));\n      };\n    }\n    addHandler(logHandler) {\n      this.logHandlers.add(logHandler);\n    }\n    removeHandler(logHandler) {\n      this.logHandlers.delete(logHandler);\n    }\n  };\n  var ProxyLogger = class {\n    constructor(loggerProvider) {\n      this.trace = this.createHandler(\"trace\");\n      this.debug = this.createHandler(\"debug\");\n      this.info = this.createHandler(\"info\");\n      this.warn = this.createHandler(\"warn\");\n      this.error = this.createHandler(\"error\");\n      this.proxiedLoggerProvider = loggerProvider;\n    }\n    createHandler(severity) {\n      return (...args) => {\n        const logger = this.proxiedLoggerProvider();\n        logger?.[severity](...args);\n      };\n    }\n  };\n  var identify = (val) => val;\n  function parse2(schema) {\n    const expandedPaths = /* @__PURE__ */ new Map();\n    if (!schema.ROOT) {\n      return expandedPaths;\n    }\n    const parseQueue = [{ node: schema.ROOT, path: [], visited: /* @__PURE__ */ new Set() }];\n    while (parseQueue.length > 0) {\n      const next = parseQueue.shift();\n      if (!next) {\n        break;\n      }\n      const { node, path, visited } = next;\n      Object.entries(node).forEach(([prop, type]) => {\n        const nestedPath = [...path, prop];\n        const nestedPathStr = nestedPath.join(\".\");\n        if (expandedPaths.has(nestedPathStr)) {\n          throw new Error(\n            \"Path has already been processed. There's either a loop somewhere or a bug\"\n          );\n        }\n        if (visited.has(type.type)) {\n          throw new Error(\n            `Path already contained type: ${type.type}. This likely indicates a loop in the schema`\n          );\n        }\n        expandedPaths.set(nestedPathStr, type);\n        if (type.isArray) {\n          nestedPath.push(\"[]\");\n        }\n        if (type.isRecord) {\n          nestedPath.push(\"{}\");\n        }\n        if (type.type && schema[type.type]) {\n          parseQueue.push({\n            path: nestedPath,\n            node: schema[type.type],\n            visited: /* @__PURE__ */ new Set([...visited, type.type])\n          });\n        }\n      });\n    }\n    return expandedPaths;\n  }\n  var SchemaController = class {\n    constructor(schema) {\n      this.formatters = /* @__PURE__ */ new Map();\n      this.types = /* @__PURE__ */ new Map();\n      this.schema = /* @__PURE__ */ new Map();\n      this.bindingSchemaNormalizedCache = /* @__PURE__ */ new Map();\n      this.hooks = {\n        resolveTypeForBinding: new SyncWaterfallHook()\n      };\n      this.schema = schema ? parse2(schema) : /* @__PURE__ */ new Map();\n    }\n    addFormatters(fns) {\n      fns.forEach((def) => {\n        this.formatters.set(def.name, def);\n      });\n    }\n    addDataTypes(types) {\n      types.forEach((t2) => {\n        this.types.set(t2.type, t2);\n      });\n    }\n    getValidationsForBinding(binding) {\n      const typeDef = this.getApparentType(binding);\n      if (!typeDef?.validation?.length) {\n        return void 0;\n      }\n      return typeDef.validation.map((vRef) => ({\n        severity: \"error\",\n        trigger: \"change\",\n        ...vRef\n      }));\n    }\n    normalizeBinding(binding) {\n      const cached = this.bindingSchemaNormalizedCache.get(binding);\n      if (cached) {\n        return cached;\n      }\n      let bindingArray = binding.asArray();\n      let normalized = bindingArray.map((p) => typeof p === \"number\" ? \"[]\" : p).join(\".\");\n      if (normalized) {\n        this.bindingSchemaNormalizedCache.set(binding, normalized);\n        bindingArray = normalized.split(\".\");\n      }\n      bindingArray.forEach((item) => {\n        const recordBinding = bindingArray.map((p) => p === item ? \"{}\" : p).join(\".\");\n        if (this.schema.get(recordBinding)) {\n          this.bindingSchemaNormalizedCache.set(binding, recordBinding);\n          bindingArray = recordBinding.split(\".\");\n          normalized = recordBinding;\n        }\n      });\n      return normalized;\n    }\n    getType(binding) {\n      return this.hooks.resolveTypeForBinding.call(\n        this.schema.get(this.normalizeBinding(binding)),\n        binding\n      );\n    }\n    getApparentType(binding) {\n      const schemaType = this.getType(binding);\n      if (schemaType === void 0) {\n        return void 0;\n      }\n      const baseType = this.getTypeDefinition(schemaType?.type);\n      if (baseType === void 0) {\n        return schemaType;\n      }\n      return {\n        ...baseType,\n        ...schemaType,\n        validation: [\n          ...schemaType.validation ?? [],\n          ...baseType.validation ?? []\n        ]\n      };\n    }\n    getTypeDefinition(dataType) {\n      return this.types.get(dataType);\n    }\n    getFormatterForType(formatReference) {\n      const { type: formatType, ...options } = formatReference;\n      const formatter = this.formatters.get(formatType);\n      if (!formatter) {\n        return;\n      }\n      return {\n        format: formatter.format ? (val) => formatter.format?.(val, options) : identify,\n        deformat: formatter.deformat ? (val) => formatter.deformat?.(val, options) : identify\n      };\n    }\n    /**\n     * Given a binding, fetch a function that's responsible for formatting, and/or de-formatting the data\n     * If no formatter is registered, it will return undefined\n     */\n    getFormatter(binding) {\n      const type = this.getApparentType(binding);\n      if (!type?.format) {\n        return void 0;\n      }\n      return this.getFormatterForType(type.format);\n    }\n  };\n  var DOUBLE_OPEN_CURLY = \"{{\";\n  var DOUBLE_CLOSE_CURLY = \"}}\";\n  function findNextExp(str) {\n    const expStart = str.indexOf(DOUBLE_OPEN_CURLY);\n    if (expStart === -1) {\n      return void 0;\n    }\n    let count = 1;\n    let offset = expStart + DOUBLE_OPEN_CURLY.length;\n    let workingString = str.substring(expStart + DOUBLE_OPEN_CURLY.length);\n    while (count > 0 && workingString.length > 0) {\n      const nextCloseCurly = workingString.indexOf(DOUBLE_CLOSE_CURLY);\n      if (nextCloseCurly === -1) {\n        break;\n      }\n      const nextOpenCurly = workingString.indexOf(DOUBLE_OPEN_CURLY);\n      if (nextOpenCurly !== -1 && nextOpenCurly < nextCloseCurly) {\n        count++;\n        workingString = workingString.substring(\n          nextOpenCurly + DOUBLE_OPEN_CURLY.length\n        );\n        offset += nextOpenCurly + DOUBLE_OPEN_CURLY.length;\n      } else {\n        count--;\n        workingString = workingString.substring(\n          nextCloseCurly + DOUBLE_CLOSE_CURLY.length\n        );\n        offset += nextCloseCurly + DOUBLE_CLOSE_CURLY.length;\n      }\n    }\n    if (count !== 0) {\n      throw new Error(`Unbalanced {{ and }} in exp: ${str}`);\n    }\n    return {\n      start: expStart,\n      end: offset\n    };\n  }\n  function resolveExpressionsInString(val, { evaluate }) {\n    if (!evaluate) {\n      return val;\n    }\n    const expMatch = /@\\[.*?\\]@/;\n    let newVal = val;\n    let match = newVal.match(expMatch);\n    while (match !== null) {\n      const expStrWithBrackets = match[0];\n      const matchStart = newVal.indexOf(expStrWithBrackets);\n      const expString = expStrWithBrackets.substr(\n        \"@[\".length,\n        expStrWithBrackets.length - \"@[\".length - \"]@\".length\n      );\n      const expValue = evaluate(expString);\n      if (matchStart === 0 && expStrWithBrackets === val && typeof expValue !== \"string\") {\n        return expValue;\n      }\n      newVal = newVal.substr(0, matchStart) + expValue + newVal.substr(matchStart + expStrWithBrackets.length);\n      match = newVal.match(expMatch);\n    }\n    return newVal;\n  }\n  function resolveDataRefsInString(val, options) {\n    const { model, formatted = true } = options;\n    let workingString = resolveExpressionsInString(val, options);\n    if (!model || typeof workingString !== \"string\" || workingString.indexOf(DOUBLE_OPEN_CURLY) === -1) {\n      return workingString;\n    }\n    while (workingString.indexOf(DOUBLE_OPEN_CURLY) !== -1) {\n      const expLocation = findNextExp(workingString);\n      if (!expLocation) {\n        return workingString;\n      }\n      const { start, end } = expLocation;\n      const binding = workingString.substring(\n        start + DOUBLE_OPEN_CURLY.length,\n        end - DOUBLE_OPEN_CURLY.length\n      ).trim();\n      const evaledVal = model.get(binding, { formatted });\n      if (start === 0 && end === workingString.length && typeof evaledVal !== \"string\") {\n        return evaledVal;\n      }\n      workingString = workingString.substr(0, start) + evaledVal + workingString.substr(end);\n    }\n    return workingString;\n  }\n  function traverseObject(val, options) {\n    switch (typeof val) {\n      case \"string\": {\n        return resolveDataRefsInString(val, options);\n      }\n      case \"object\": {\n        if (!val)\n          return val;\n        const keys = Object.keys(val);\n        let newVal = val;\n        if (keys.length > 0) {\n          keys.forEach((key) => {\n            newVal = (0, import_timm2.setIn)(\n              newVal,\n              [key],\n              traverseObject(val[key], options)\n            );\n          });\n        }\n        return newVal;\n      }\n      default:\n        return val;\n    }\n  }\n  function resolveDataRefs(val, options) {\n    return traverseObject(val, options);\n  }\n  function removeBindingAndChildrenFromMap(sourceMap, binding) {\n    const targetMap = new Map(sourceMap);\n    const parentBinding = binding.parent();\n    const property = binding.key();\n    targetMap.forEach((_value, trackedBinding) => {\n      if (binding === trackedBinding || binding.contains(trackedBinding)) {\n        targetMap.delete(trackedBinding);\n      }\n    });\n    if (typeof property === \"number\") {\n      const bindingsToRewrite = Array.from(sourceMap.keys()).filter((b) => {\n        if (parentBinding.contains(b)) {\n          const [childIndex] = b.relative(parentBinding);\n          return typeof childIndex === \"number\" && childIndex > property;\n        }\n        return false;\n      }).sort();\n      bindingsToRewrite.forEach((trackedBinding) => {\n        const [childIndex, ...childPath] = trackedBinding.relative(parentBinding);\n        if (typeof childIndex === \"number\") {\n          const newSegments = [childIndex - 1, ...childPath];\n          const newChildBinding = parentBinding.descendent(newSegments);\n          targetMap.set(newChildBinding, targetMap.get(trackedBinding));\n          targetMap.delete(trackedBinding);\n        }\n      });\n    }\n    return targetMap;\n  }\n  var ValidationMiddleware = class {\n    constructor(validator, options) {\n      this.validator = validator;\n      this.shadowModelPaths = /* @__PURE__ */ new Map();\n      this.logger = options?.logger;\n      this.shouldIncludeInvalid = options?.shouldIncludeInvalid;\n    }\n    set(transaction, options, next) {\n      const asModel = toModel(this, { ...options, includeInvalid: true }, next);\n      const nextTransaction = [];\n      const includedBindings = /* @__PURE__ */ new Set();\n      transaction.forEach(([binding, value]) => {\n        this.shadowModelPaths.set(binding, value);\n        includedBindings.add(binding);\n      });\n      const invalidBindings = [];\n      this.shadowModelPaths.forEach((value, binding) => {\n        const validations = this.validator(binding, asModel);\n        if (validations === void 0) {\n          nextTransaction.push([binding, value]);\n        } else if (validations instanceof Set) {\n          validations.forEach((validation) => {\n            invalidBindings.push(validation.binding);\n            if (!validation.isStrong && validation.binding.asString() === binding.asString()) {\n              nextTransaction.push([validation.binding, value]);\n            }\n          });\n        } else if (includedBindings.has(binding)) {\n          invalidBindings.push(binding);\n          this.logger?.debug(\n            `Invalid value for path: ${binding.asString()} - ${validations.severity} - ${validations.message}`\n          );\n        }\n      });\n      let validResults = [];\n      if (next && nextTransaction.length > 0) {\n        nextTransaction.forEach(\n          ([binding]) => this.shadowModelPaths.delete(binding)\n        );\n        const result = next.set(nextTransaction, options);\n        if (invalidBindings.length === 0) {\n          return result;\n        }\n        validResults = result;\n      }\n      const invalidResults = invalidBindings.map((binding) => {\n        return {\n          binding,\n          oldValue: asModel.get(binding),\n          newValue: asModel.get(binding),\n          force: true\n        };\n      });\n      return [...validResults, ...invalidResults];\n    }\n    get(binding, options, next) {\n      let val = next?.get(binding, options);\n      if (this.shouldIncludeInvalid?.(options) ?? options?.includeInvalid === true) {\n        this.shadowModelPaths.forEach((shadowValue, shadowBinding) => {\n          if (shadowBinding === binding) {\n            val = shadowValue;\n            return;\n          }\n          if (binding.contains(shadowBinding)) {\n            val = (0, import_timm3.setIn)(val, shadowBinding.relative(binding), shadowValue);\n          }\n        });\n      }\n      return val;\n    }\n    delete(binding, options, next) {\n      this.shadowModelPaths = removeBindingAndChildrenFromMap(\n        this.shadowModelPaths,\n        binding\n      );\n      return next?.delete(binding, options);\n    }\n  };\n  var ValidatorRegistry = class {\n    constructor() {\n      this.registry = /* @__PURE__ */ new Map();\n    }\n    /** Use the given validator name to fetch the handler */\n    get(name) {\n      return this.registry.get(name);\n    }\n    /** Register a new validator */\n    register(name, handler) {\n      this.registry.set(name, handler);\n    }\n  };\n  var NodeType = /* @__PURE__ */ ((NodeType2) => {\n    NodeType2[\"Asset\"] = \"asset\";\n    NodeType2[\"View\"] = \"view\";\n    NodeType2[\"Applicability\"] = \"applicability\";\n    NodeType2[\"Template\"] = \"template\";\n    NodeType2[\"Value\"] = \"value\";\n    NodeType2[\"MultiNode\"] = \"multi-node\";\n    NodeType2[\"Switch\"] = \"switch\";\n    NodeType2[\"Async\"] = \"async\";\n    NodeType2[\"Unknown\"] = \"unknown\";\n    NodeType2[\"Empty\"] = \"empty\";\n    return NodeType2;\n  })(NodeType || {});\n  function hasTemplateValues(obj, localKey) {\n    return Object.hasOwnProperty.call(obj, \"template\") && Array.isArray(obj?.template) && obj.template.length && obj.template.find((tmpl) => tmpl.output === localKey);\n  }\n  function hasSwitchKey(localKey) {\n    return localKey === \"staticSwitch\" || localKey === \"dynamicSwitch\";\n  }\n  function hasTemplateKey(localKey) {\n    return localKey === \"template\";\n  }\n  function getNodeID(node) {\n    if (!node) {\n      return;\n    }\n    if (\"value\" in node && typeof node.value === \"object\" && typeof node.value?.id === \"string\") {\n      return node.value.id;\n    }\n  }\n  var EMPTY_NODE = {\n    type: \"empty\"\n    /* Empty */\n  };\n  var Parser = class {\n    constructor() {\n      this.hooks = {\n        onParseObject: new SyncWaterfallHook(),\n        onCreateASTNode: new SyncWaterfallHook(),\n        parseNode: new SyncBailHook()\n      };\n    }\n    parseView(value) {\n      const viewNode = this.parseObject(\n        value,\n        \"view\"\n        /* View */\n      );\n      if (!viewNode) {\n        throw new Error(\"Unable to parse object into a view\");\n      }\n      return viewNode;\n    }\n    createASTNode(node, value) {\n      const tapped = this.hooks.onCreateASTNode.call(node, value);\n      if (tapped === void 0) {\n        return node;\n      }\n      return tapped;\n    }\n    parseObject(obj, type = \"value\", options = { templateDepth: 0 }) {\n      const parsedNode = this.hooks.parseNode.call(\n        obj,\n        type,\n        options\n      );\n      if (parsedNode || parsedNode === null) {\n        return parsedNode;\n      }\n      const parseLocalObject = (currentValue, objToParse, path = []) => {\n        if (typeof objToParse !== \"object\" || objToParse === null) {\n          return { value: objToParse, children: [] };\n        }\n        const localObj = this.hooks.onParseObject.call(objToParse, type);\n        if (!localObj) {\n          return currentValue;\n        }\n        const objEntries = Array.isArray(localObj) ? localObj.map((v, i) => [i, v]) : [\n          ...Object.entries(localObj),\n          ...Object.getOwnPropertySymbols(localObj).map((s) => [\n            s,\n            localObj[s]\n          ])\n        ];\n        const defaultValue = {\n          children: [],\n          value: currentValue\n        };\n        const newValue = objEntries.reduce((accumulation, current) => {\n          let { value: value2 } = accumulation;\n          const { children: children2 } = accumulation;\n          const [localKey, localValue] = current;\n          const newChildren = this.hooks.parseNode.call(\n            localValue,\n            \"value\",\n            options,\n            {\n              path,\n              key: localKey,\n              parentObj: localObj\n            }\n          );\n          if (newChildren) {\n            children2.push(...newChildren);\n          } else if (localValue && typeof localValue === \"object\") {\n            const result = parseLocalObject(accumulation.value, localValue, [\n              ...path,\n              localKey\n            ]);\n            value2 = result.value;\n            children2.push(...result.children);\n          } else {\n            value2 = (0, import_timm5.setIn)(accumulation.value, [...path, localKey], localValue);\n          }\n          return {\n            value: value2,\n            children: children2\n          };\n        }, defaultValue);\n        return newValue;\n      };\n      const { value, children } = parseLocalObject(void 0, obj);\n      const baseAst = value === void 0 && !children.length ? void 0 : {\n        type,\n        value\n      };\n      if (baseAst && children.length) {\n        const parent = baseAst;\n        parent.children = children;\n        children.forEach((child) => {\n          child.value.parent = parent;\n        });\n      }\n      return this.hooks.onCreateASTNode.call(baseAst, obj) ?? null;\n    }\n  };\n  function caresAboutDataChanges(dataChanges, dependencies) {\n    if (!dataChanges || !dependencies) {\n      return true;\n    }\n    const depArray = Array.from(dependencies.values());\n    const dataChangeArray = Array.from(dataChanges.values());\n    return depArray.find(\n      (dep) => !!dataChangeArray.find(\n        (change) => change === dep || change.contains(dep) || dep.contains(change)\n      )\n    ) !== void 0;\n  }\n  function toNodeResolveOptions(resolverOptions) {\n    return {\n      ...resolverOptions,\n      data: {\n        model: resolverOptions.model,\n        formatValue: (ref, value) => {\n          if (resolverOptions.formatValue) {\n            return resolverOptions.formatValue(ref, value);\n          }\n          return value;\n        },\n        format: (bindingLike, value) => resolverOptions.format ? resolverOptions.format(\n          isBinding(bindingLike) ? bindingLike : resolverOptions.parseBinding(bindingLike),\n          value\n        ) : value\n      },\n      evaluate: (exp) => resolverOptions.evaluator.evaluate(exp, resolverOptions)\n    };\n  }\n  var withContext = (model) => {\n    return {\n      get: (binding, options) => {\n        return model.get(binding, {\n          context: { model },\n          ...options\n        });\n      },\n      set: (transaction, options) => {\n        return model.set(transaction, {\n          context: { model },\n          ...options\n        });\n      },\n      delete: (binding, options) => {\n        return model.delete(binding, {\n          context: { model },\n          ...options\n        });\n      }\n    };\n  };\n  var Resolver = class {\n    constructor(root, options) {\n      this.hooks = {\n        skipResolve: new SyncWaterfallHook(),\n        beforeUpdate: new SyncHook(),\n        afterUpdate: new SyncHook(),\n        resolveOptions: new SyncWaterfallHook(),\n        beforeResolve: new SyncWaterfallHook(),\n        resolve: new SyncWaterfallHook(),\n        afterResolve: new SyncWaterfallHook(),\n        afterNodeUpdate: new SyncHook()\n      };\n      this.root = root;\n      this.options = options;\n      this.resolveCache = /* @__PURE__ */ new Map();\n      this.ASTMap = /* @__PURE__ */ new Map();\n      this.logger = options.logger;\n      this.idCache = /* @__PURE__ */ new Set();\n      this.AsyncIdMap = /* @__PURE__ */ new Map();\n    }\n    getSourceNode(convertedAST) {\n      return this.ASTMap.get(convertedAST);\n    }\n    update(changes, asyncChanges) {\n      this.hooks.beforeUpdate.call(changes);\n      const resolveCache = /* @__PURE__ */ new Map();\n      this.idCache.clear();\n      const prevASTMap = new Map(this.ASTMap);\n      this.ASTMap.clear();\n      const prevAsyncIdMap = new Map(this.AsyncIdMap);\n      const nextAsyncIdMap = /* @__PURE__ */ new Map();\n      asyncChanges?.forEach((id) => {\n        let current = prevAsyncIdMap.get(id);\n        while (current && prevASTMap.has(current)) {\n          const next = prevASTMap.get(current);\n          if (next && this.resolveCache.has(next)) {\n            this.resolveCache.delete(next);\n          }\n          current = current.parent;\n        }\n      });\n      const updated = this.computeTree(\n        this.root,\n        void 0,\n        changes,\n        resolveCache,\n        toNodeResolveOptions(this.options),\n        void 0,\n        prevASTMap,\n        nextAsyncIdMap\n      );\n      this.AsyncIdMap = nextAsyncIdMap;\n      this.resolveCache = resolveCache;\n      this.hooks.afterUpdate.call(updated.value);\n      return updated.value;\n    }\n    getResolveCache() {\n      return new Map(this.resolveCache);\n    }\n    getPreviousResult(node) {\n      if (!node) {\n        return;\n      }\n      const isFirstUpdate = this.resolveCache.size === 0;\n      const id = getNodeID(node);\n      if (id) {\n        if (this.idCache.has(id)) {\n          if (isFirstUpdate) {\n            if (node.type === \"asset\" || node.type === \"view\") {\n              this.logger?.error(\n                `Cache conflict: Found Asset/View nodes that have conflicting ids: ${id}, may cause cache issues.`\n              );\n            } else if (node.type === \"value\") {\n              this.logger?.info(\n                `Cache conflict: Found Value nodes that have conflicting ids: ${id}, may cause cache issues. To improve performance make value node IDs globally unique.`\n              );\n            }\n          }\n          return;\n        }\n        this.idCache.add(id);\n      }\n      return this.resolveCache.get(node);\n    }\n    cloneNode(node) {\n      const clonedNode = (0, import_timm4.clone)(node);\n      Object.keys(clonedNode).forEach((key) => {\n        if (key === \"parent\")\n          return;\n        const value = clonedNode[key];\n        if (typeof value === \"object\" && value !== null) {\n          clonedNode[key] = Array.isArray(value) ? [...value] : { ...value };\n        }\n      });\n      return clonedNode;\n    }\n    computeTree(node, rawParent, dataChanges, cacheUpdate, options, partiallyResolvedParent, prevASTMap, nextAsyncIdMap) {\n      const dependencyModel = new DependencyModel(options.data.model);\n      dependencyModel.trackSubset(\"core\");\n      const depModelWithParser = withContext(\n        withParser(dependencyModel, this.options.parseBinding)\n      );\n      const resolveOptions = this.hooks.resolveOptions.call(\n        {\n          ...options,\n          data: {\n            ...options.data,\n            model: depModelWithParser\n          },\n          evaluate: (exp) => this.options.evaluator.evaluate(exp, { model: depModelWithParser }),\n          node\n        },\n        node\n      );\n      const previousResult = this.getPreviousResult(node);\n      const previousDeps = previousResult?.dependencies;\n      const dataChanged = caresAboutDataChanges(dataChanges, previousDeps);\n      const shouldUseLastValue = this.hooks.skipResolve.call(\n        !dataChanged,\n        node,\n        resolveOptions\n      );\n      if (previousResult && shouldUseLastValue) {\n        const update2 = {\n          ...previousResult,\n          updated: false\n        };\n        const repopulateASTMapFromCache = (resolvedNode, AST, ASTParent) => {\n          const { node: resolvedASTLocal } = resolvedNode;\n          this.ASTMap.set(resolvedASTLocal, AST);\n          const resolvedUpdate = {\n            ...resolvedNode,\n            updated: false\n          };\n          cacheUpdate.set(AST, resolvedUpdate);\n          if (resolvedUpdate.node.type === \"async\") {\n            nextAsyncIdMap.set(resolvedUpdate.node.id, resolvedUpdate.node);\n          }\n          for (const key of resolvedUpdate.node.asyncNodesResolved ?? []) {\n            nextAsyncIdMap.set(key, resolvedUpdate.node);\n          }\n          const handleChildNode = (childNode) => {\n            const originalChildNode = prevASTMap.get(childNode) ?? childNode;\n            const previousChildResult = this.getPreviousResult(originalChildNode);\n            if (!previousChildResult)\n              return;\n            repopulateASTMapFromCache(\n              previousChildResult,\n              originalChildNode,\n              AST\n            );\n          };\n          if (\"children\" in resolvedASTLocal) {\n            resolvedASTLocal.children?.forEach(\n              ({ value: childAST }) => handleChildNode(childAST)\n            );\n          } else if (resolvedASTLocal.type === \"multi-node\") {\n            resolvedASTLocal.values.forEach(handleChildNode);\n          }\n          this.hooks.afterNodeUpdate.call(AST, ASTParent, resolvedUpdate);\n        };\n        previousResult.node.parent = partiallyResolvedParent;\n        repopulateASTMapFromCache(previousResult, node, rawParent);\n        return update2;\n      }\n      const clonedNode = {\n        ...this.cloneNode(node),\n        parent: partiallyResolvedParent\n      };\n      const resolvedAST = this.hooks.beforeResolve.call(\n        clonedNode,\n        resolveOptions\n      ) ?? {\n        type: \"empty\"\n        /* Empty */\n      };\n      resolvedAST.parent = partiallyResolvedParent;\n      if (resolvedAST.type === \"async\") {\n        nextAsyncIdMap.set(resolvedAST.id, resolvedAST);\n      }\n      for (const id of resolvedAST.asyncNodesResolved ?? []) {\n        nextAsyncIdMap.set(id, resolvedAST);\n      }\n      resolveOptions.node = resolvedAST;\n      this.ASTMap.set(resolvedAST, node);\n      let resolved = this.hooks.resolve.call(\n        void 0,\n        resolvedAST,\n        resolveOptions\n      );\n      let updated = !dequal(previousResult?.value, resolved);\n      if (previousResult && !updated) {\n        resolved = previousResult?.value;\n      }\n      const childDependencies = /* @__PURE__ */ new Set();\n      dependencyModel.trackSubset(\"children\");\n      if (\"children\" in resolvedAST) {\n        const newChildren = resolvedAST.children?.map((child) => {\n          const computedChildTree = this.computeTree(\n            child.value,\n            node,\n            dataChanges,\n            cacheUpdate,\n            resolveOptions,\n            resolvedAST,\n            prevASTMap,\n            nextAsyncIdMap\n          );\n          const {\n            dependencies: childTreeDeps,\n            node: childNode,\n            updated: childUpdated,\n            value: childValue\n          } = computedChildTree;\n          childTreeDeps.forEach((binding) => childDependencies.add(binding));\n          if (childValue) {\n            if (childNode.type === \"multi-node\" && !childNode.override) {\n              const arr = (0, import_timm4.addLast)(\n                dlv_es_default(resolved, child.path, []),\n                childValue\n              );\n              resolved = (0, import_timm4.setIn)(resolved, child.path, arr);\n            } else {\n              resolved = (0, import_timm4.setIn)(resolved, child.path, childValue);\n            }\n          }\n          updated = updated || childUpdated;\n          return { ...child, value: childNode };\n        });\n        resolvedAST.children = newChildren;\n      } else if (resolvedAST.type === \"multi-node\") {\n        const childValue = [];\n        const rawParentToPassIn = node;\n        resolvedAST.values = resolvedAST.values.map((mValue) => {\n          const mTree = this.computeTree(\n            mValue,\n            rawParentToPassIn,\n            dataChanges,\n            cacheUpdate,\n            resolveOptions,\n            resolvedAST,\n            prevASTMap,\n            nextAsyncIdMap\n          );\n          if (mTree.value !== void 0 && mTree.value !== null) {\n            mTree.dependencies.forEach(\n              (bindingDep) => childDependencies.add(bindingDep)\n            );\n            updated = updated || mTree.updated;\n            childValue.push(mTree.value);\n          }\n          return mTree.node;\n        });\n        resolved = childValue;\n      }\n      childDependencies.forEach(\n        (bindingDep) => dependencyModel.addChildReadDep(bindingDep)\n      );\n      dependencyModel.trackSubset(\"core\");\n      if (previousResult && !updated) {\n        resolved = previousResult?.value;\n      }\n      resolved = this.hooks.afterResolve.call(resolved, resolvedAST, {\n        ...resolveOptions,\n        getDependencies: (scope) => dependencyModel.getDependencies(scope)\n      });\n      const update = {\n        node: resolvedAST,\n        updated,\n        value: resolved,\n        dependencies: /* @__PURE__ */ new Set([\n          ...dependencyModel.getDependencies(),\n          ...childDependencies\n        ])\n      };\n      this.hooks.afterNodeUpdate.call(node, rawParent, update);\n      cacheUpdate.set(node, update);\n      return update;\n    }\n  };\n  var CrossfieldProvider = class {\n    constructor(initialView, parser, logger) {\n      this.allValidations = /* @__PURE__ */ new Set();\n      this.byBinding = /* @__PURE__ */ new Map();\n      this.logger = logger;\n      this.parse(initialView, parser);\n    }\n    parse(contentView, parser) {\n      const xfieldRefs = contentView.validation;\n      if (xfieldRefs === void 0) {\n        return;\n      }\n      if (!Array.isArray(xfieldRefs)) {\n        this.logger?.warn(\n          `Unable to register view validations for id: ${contentView.id}. 'validation' property must be an Array.`\n        );\n        return;\n      }\n      xfieldRefs.forEach((vRef) => {\n        const withDefaults = {\n          trigger: \"navigation\",\n          severity: \"error\",\n          ...vRef\n        };\n        this.allValidations.add(withDefaults);\n        const { ref } = vRef;\n        if (ref) {\n          const parsed = parser(ref);\n          if (this.byBinding.has(parsed)) {\n            this.byBinding.get(parsed)?.push(withDefaults);\n          } else {\n            this.byBinding.set(parsed, [withDefaults]);\n          }\n        }\n      });\n    }\n    getValidationsForBinding(binding) {\n      return this.byBinding.get(binding);\n    }\n  };\n  var ViewInstance = class {\n    constructor(initialView, resolverOptions) {\n      this.hooks = {\n        onUpdate: new SyncHook(),\n        parser: new SyncHook(),\n        resolver: new SyncHook(),\n        templatePlugin: new SyncHook()\n      };\n      this.initialView = initialView;\n      this.resolverOptions = resolverOptions;\n    }\n    updateAsync(asyncNode) {\n      const update = this.resolver?.update(/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set([asyncNode]));\n      this.lastUpdate = update;\n      this.hooks.onUpdate.call(update);\n    }\n    update(changes) {\n      if (this.rootNode === void 0) {\n        this.validationProvider = new CrossfieldProvider(\n          this.initialView,\n          this.resolverOptions.parseBinding,\n          this.resolverOptions.logger\n        );\n        if (this.templatePlugin) {\n          this.hooks.templatePlugin.call(this.templatePlugin);\n        } else {\n          this.resolverOptions.logger?.warn(\n            \"templatePlugin not set for View, legacy templates may not work\"\n          );\n        }\n        const parser = new Parser();\n        this.hooks.parser.call(parser);\n        this.rootNode = parser.parseView(this.initialView);\n        this.resolver = new Resolver(this.rootNode, {\n          ...this.resolverOptions,\n          parseNode: parser.parseObject.bind(parser)\n        });\n        this.hooks.resolver.call(this.resolver);\n      }\n      const update = this.resolver?.update(changes);\n      if (this.lastUpdate === update) {\n        return this.lastUpdate;\n      }\n      this.lastUpdate = update;\n      this.hooks.onUpdate.call(update);\n      return update;\n    }\n    getValidationsForBinding(binding) {\n      return this.validationProvider?.getValidationsForBinding(binding);\n    }\n    setTemplatePlugin(plugin) {\n      this.templatePlugin = plugin;\n    }\n  };\n  var Builder = class _Builder {\n    /**\n     * Creates an asset node\n     *\n     * @param value - the value to put in the asset node\n     */\n    static asset(value) {\n      return {\n        type: \"asset\",\n        value\n      };\n    }\n    static assetWrapper(value) {\n      const valueNode = _Builder.value();\n      _Builder.addChild(valueNode, \"asset\", value);\n      return valueNode;\n    }\n    /**\n     * Creates a value node\n     *\n     * @param v - The object to put in the value node\n     */\n    static value(v) {\n      return {\n        type: \"value\",\n        value: v\n      };\n    }\n    /**\n     * Creates a multiNode and associates the multiNode as the parent\n     * of all the value nodes\n     *\n     * @param values - the value, applicability or async nodes to put in the multinode\n     */\n    static multiNode(...values) {\n      const m = {\n        type: \"multi-node\",\n        override: true,\n        values\n      };\n      values.forEach((v) => {\n        v.parent = m;\n      });\n      return m;\n    }\n    /**\n     * Creates an async node\n     *\n     * @param id - the id of async node. It should be identical for each async node\n     */\n    static asyncNode(id, flatten2 = true, onValueReceived) {\n      return {\n        id,\n        type: \"async\",\n        flatten: flatten2,\n        onValueReceived,\n        value: {\n          type: \"value\",\n          value: {\n            id\n          }\n        }\n      };\n    }\n    /**\n     * Adds a child node to a node\n     *\n     * @param node - The node to add a child to\n     * @param path - The path at which to add the child\n     * @param child - The child node\n     */\n    static addChild(node, path, child) {\n      child.parent = node;\n      const newChild = {\n        path: Array.isArray(path) ? path : [path],\n        value: child\n      };\n      node.children = node.children || [];\n      node.children.push(newChild);\n      return node;\n    }\n    /**\n     * Updates children of a node of the same path and preserves order\n     *\n     * @param node - The node to update children for\n     * @param pathToMatch - The path to match against child paths\n     * @param mapFn - Function to transform matching children\n     */\n    static updateChildrenByPath(node, pathToMatch, updateFn) {\n      if (!node.children)\n        return node;\n      const updatedChildren = node.children.map(\n        (child) => (\n          // Check if paths match exactly\n          child.path.join() === pathToMatch.join() ? { ...child, value: updateFn(child) } : child\n        )\n      );\n      return {\n        ...node,\n        children: updatedChildren\n      };\n    }\n  };\n  var templateSymbol = Symbol(\"template\");\n  var TemplatePlugin = class {\n    constructor(options) {\n      this.hooks = {\n        resolveTemplateSubstitutions: new SyncWaterfallHook()\n      };\n      this.options = options;\n    }\n    parseTemplate(parseObject, node, options) {\n      const { template, depth } = node;\n      const data = options.data.model.get(node.data);\n      if (!data) {\n        return null;\n      }\n      if (!Array.isArray(data)) {\n        throw new Error(`Template using '${node.data}' but is not an array`);\n      }\n      const values = [];\n      data.forEach((dataItem, index) => {\n        const templateSubstitutions = this.hooks.resolveTemplateSubstitutions.call(\n          [\n            {\n              expression: new RegExp(`_index${depth || \"\"}_`),\n              value: String(index)\n            }\n          ],\n          {\n            depth,\n            data: dataItem,\n            index\n          }\n        );\n        let templateStr = JSON.stringify(template);\n        for (const { expression, value } of templateSubstitutions) {\n          let flags = \"g\";\n          if (typeof expression === \"object\") {\n            flags = `${expression.flags}${expression.global ? \"\" : \"g\"}`;\n          }\n          templateStr = templateStr.replace(new RegExp(expression, flags), value);\n        }\n        const parsed = parseObject(JSON.parse(templateStr), \"value\", {\n          templateDepth: node.depth + 1\n        });\n        if (parsed) {\n          values.push(parsed);\n        }\n      });\n      const result = {\n        type: \"multi-node\",\n        override: false,\n        values\n      };\n      if (node.placement !== void 0) {\n        result[templateSymbol] = node.placement;\n      }\n      return result;\n    }\n    applyParser(parser) {\n      parser.hooks.onCreateASTNode.tap(\"template\", (node) => {\n        if (node && node.type === \"template\" && !node.dynamic) {\n          return this.parseTemplate(\n            parser.parseObject.bind(parser),\n            node,\n            this.options\n          );\n        }\n        return node;\n      });\n      parser.hooks.onCreateASTNode.tap(\"template\", (node) => {\n        function getTemplateSymbolValue(node2) {\n          if (node2.type === \"multi-node\") {\n            return node2[templateSymbol];\n          } else if (node2.type === \"template\") {\n            return node2.placement;\n          }\n          return void 0;\n        }\n        if (node && (node.type === \"view\" || node.type === \"asset\") && Array.isArray(node.children)) {\n          node.children = node.children.sort((a, b) => {\n            const aPath = a.path.join();\n            const bPath = b.path.join();\n            const pathsEqual = aPath === bPath;\n            if (pathsEqual) {\n              const aPlacement = getTemplateSymbolValue(a.value);\n              const bPlacement = getTemplateSymbolValue(b.value);\n              if (aPlacement !== void 0 && bPlacement === void 0) {\n                return aPlacement === \"prepend\" ? -1 : 1;\n              } else if (bPlacement !== void 0 && aPlacement === void 0) {\n                return bPlacement === \"prepend\" ? 1 : -1;\n              } else if (aPlacement !== void 0 && bPlacement !== void 0) {\n                if (aPlacement === bPlacement) {\n                  return 0;\n                }\n                return aPlacement === \"prepend\" ? -1 : 1;\n              }\n              return 0;\n            }\n            return aPath > bPath ? 1 : -1;\n          });\n        }\n        return node;\n      });\n      parser.hooks.parseNode.tap(\n        \"template\",\n        (obj, _nodeType, options, childOptions) => {\n          if (childOptions && hasTemplateKey(childOptions.key)) {\n            return obj.map((template) => {\n              const templateAST = parser.createASTNode(\n                {\n                  type: \"template\",\n                  depth: options.templateDepth ?? 0,\n                  data: template.data,\n                  template: template.value,\n                  dynamic: template.dynamic ?? false,\n                  placement: template.placement\n                },\n                template\n              );\n              if (!templateAST)\n                return;\n              if (templateAST.type === \"multi-node\") {\n                templateAST.values.forEach((v) => {\n                  v.parent = templateAST;\n                });\n              }\n              return {\n                path: [...childOptions.path, template.output],\n                value: templateAST\n              };\n            }).filter(Boolean);\n          }\n        }\n      );\n    }\n    applyResolverHooks(resolver) {\n      resolver.hooks.beforeResolve.tap(\"template\", (node, options) => {\n        if (node && node.type === \"template\" && node.dynamic) {\n          return this.parseTemplate(options.parseNode, node, options);\n        }\n        return node;\n      });\n    }\n    apply(view) {\n      view.hooks.parser.tap(\"template\", this.applyParser.bind(this));\n      view.hooks.resolver.tap(\"template\", this.applyResolverHooks.bind(this));\n      view.setTemplatePlugin(this);\n    }\n  };\n  var createPatternMatcher = (start, end) => {\n    return (testStr) => {\n      const startLocation = testStr.indexOf(start);\n      if (startLocation === -1) {\n        return false;\n      }\n      const endLocation = testStr.indexOf(end);\n      if (endLocation === -1) {\n        return false;\n      }\n      return startLocation < endLocation;\n    };\n  };\n  var bindingResolveLookup = createPatternMatcher(\"{{\", \"}}\");\n  var expressionResolveLookup = createPatternMatcher(\"@[\", \"]@\");\n  function hasSomethingToResolve(str) {\n    return bindingResolveLookup(str) || expressionResolveLookup(str);\n  }\n  function resolveString(str, resolveOptions) {\n    return hasSomethingToResolve(str) ? resolveDataRefs(str, {\n      model: resolveOptions.data.model,\n      evaluate: resolveOptions.evaluate\n    }) : str;\n  }\n  function resolveAllRefs(node, resolveOptions, propertiesToSkip) {\n    if (node === null || node === void 0 || typeof node !== \"object\" && typeof node !== \"string\") {\n      return node;\n    }\n    if (typeof node === \"string\") {\n      return resolveString(node, resolveOptions);\n    }\n    let newNode = node;\n    Object.keys(node).forEach((key) => {\n      if (propertiesToSkip.has(key)) {\n        return;\n      }\n      const val = node[key];\n      let newVal = val;\n      if (typeof val === \"object\") {\n        newVal = resolveAllRefs(val, resolveOptions, propertiesToSkip);\n      } else if (typeof val === \"string\") {\n        newVal = resolveString(val, resolveOptions);\n      }\n      if (newVal !== val) {\n        newNode = (0, import_timm6.set)(newNode, key, newVal);\n      }\n    });\n    return newNode;\n  }\n  var findBasePath = (node, resolver) => {\n    const parentNode = node.parent;\n    if (!parentNode) {\n      return [];\n    }\n    if (\"children\" in parentNode) {\n      const original = resolver.getSourceNode(node);\n      return parentNode.children?.find((child) => child.value === original)?.path ?? [];\n    }\n    if (parentNode.type !== \"multi-node\") {\n      return [];\n    }\n    return findBasePath(parentNode, resolver);\n  };\n  var StringResolverPlugin = class {\n    constructor() {\n      this.propertiesToSkipCache = /* @__PURE__ */ new Map();\n    }\n    applyResolver(resolver) {\n      resolver.hooks.resolve.tap(\"string-resolver\", (value, node, options) => {\n        if (node.type === \"empty\" || node.type === \"unknown\") {\n          return null;\n        }\n        if (node.type === \"value\" || node.type === \"asset\" || node.type === \"view\") {\n          let propsToSkip;\n          if (node.type === \"asset\" || node.type === \"view\") {\n            propsToSkip = new Set(\n              node.plugins?.stringResolver?.propertiesToSkip ?? [\"exp\"]\n            );\n            if (node.value?.id) {\n              this.propertiesToSkipCache.set(node.value.id, propsToSkip);\n            }\n          } else if (node.parent?.type === \"multi-node\" && (node.parent?.parent?.type === \"asset\" || node.parent?.parent?.type === \"view\") && node.parent.parent.value?.id && this.propertiesToSkipCache.has(node.parent.parent.value.id)) {\n            propsToSkip = this.propertiesToSkipCache.get(\n              node.parent.parent.value.id\n            );\n          } else {\n            propsToSkip = /* @__PURE__ */ new Set([\"exp\"]);\n          }\n          const nodePath = findBasePath(node, resolver);\n          if (nodePath.length > 0 && nodePath.some((segment) => propsToSkip.has(segment.toString()))) {\n            return node.value;\n          }\n          return resolveAllRefs(node.value, options, propsToSkip);\n        }\n        return value;\n      });\n    }\n    apply(view) {\n      view.hooks.resolver.tap(\"string-resolver\", this.applyResolver.bind(this));\n    }\n  };\n  var ApplicabilityPlugin = class {\n    isApplicability(obj) {\n      return obj && Object.prototype.hasOwnProperty.call(obj, \"applicability\");\n    }\n    applyResolver(resolver) {\n      resolver.hooks.beforeResolve.tap(\n        \"applicability\",\n        (node, options) => {\n          let newNode = node;\n          if (node?.type === \"applicability\") {\n            const isApplicable = options.evaluate(node.expression);\n            if (isApplicable === false) {\n              return null;\n            }\n            newNode = node.value;\n          }\n          return newNode;\n        }\n      );\n    }\n    applyParser(parser) {\n      parser.hooks.parseNode.tap(\n        \"applicability\",\n        (obj, nodeType, options, childOptions) => {\n          if (this.isApplicability(obj)) {\n            const parsedApplicability = parser.parseObject(\n              (0, import_timm7.omit)(obj, \"applicability\"),\n              nodeType,\n              options\n            );\n            if (!parsedApplicability) {\n              return childOptions ? [] : null;\n            }\n            const applicabilityNode = parser.createASTNode(\n              {\n                type: \"applicability\",\n                expression: obj.applicability,\n                value: parsedApplicability\n              },\n              obj\n            );\n            if (!applicabilityNode) {\n              return childOptions ? [] : null;\n            }\n            if (applicabilityNode.type === \"applicability\") {\n              applicabilityNode.value.parent = applicabilityNode;\n            }\n            return childOptions ? [\n              {\n                path: [...childOptions.path, childOptions.key],\n                value: applicabilityNode\n              }\n            ] : applicabilityNode;\n          }\n        }\n      );\n    }\n    apply(view) {\n      view.hooks.resolver.tap(\"applicability\", this.applyResolver.bind(this));\n      view.hooks.parser.tap(\"applicability\", this.applyParser.bind(this));\n    }\n  };\n  var SwitchPlugin = class {\n    constructor(options) {\n      this.options = options;\n    }\n    resolveSwitch(node, options) {\n      for (const switchCase of node.cases) {\n        const isApplicable = options.evaluate(switchCase.case);\n        if (isApplicable) {\n          return switchCase.value;\n        }\n      }\n      return EMPTY_NODE;\n    }\n    isSwitch(obj) {\n      return obj && (Object.prototype.hasOwnProperty.call(obj, \"dynamicSwitch\") || Object.prototype.hasOwnProperty.call(obj, \"staticSwitch\"));\n    }\n    applyParser(parser) {\n      parser.hooks.onCreateASTNode.tap(\"switch\", (node) => {\n        if (node && node.type === \"switch\" && !node.dynamic) {\n          return this.resolveSwitch(node, this.options);\n        }\n        return node;\n      });\n      parser.hooks.parseNode.tap(\n        \"switch\",\n        (obj, _nodeType, options, childOptions) => {\n          if (this.isSwitch(obj) || childOptions && hasSwitchKey(childOptions.key)) {\n            const objToParse = childOptions && hasSwitchKey(childOptions.key) ? { [childOptions.key]: obj } : obj;\n            const dynamic = \"dynamicSwitch\" in objToParse;\n            const switchContent = dynamic ? objToParse.dynamicSwitch : objToParse.staticSwitch;\n            const cases = switchContent.map(\n              (switchCase) => {\n                const { case: switchCaseExpr, ...switchBody } = switchCase;\n                const value = parser.parseObject(\n                  switchBody,\n                  \"value\",\n                  options\n                );\n                if (value) {\n                  return {\n                    case: switchCaseExpr,\n                    value\n                  };\n                }\n                return;\n              }\n            ).filter(Boolean);\n            const switchAST = parser.createASTNode(\n              {\n                type: \"switch\",\n                dynamic,\n                cases\n              },\n              objToParse\n            );\n            if (!switchAST || switchAST.type === \"empty\") {\n              return childOptions ? [] : null;\n            }\n            if (switchAST.type === \"switch\") {\n              switchAST.cases.forEach((sCase) => {\n                sCase.value.parent = switchAST;\n              });\n            }\n            if (childOptions) {\n              let path = [...childOptions.path, childOptions.key];\n              let value = switchAST;\n              if (switchAST.type === \"value\" && switchAST.children?.length === 1 && switchAST.value === void 0) {\n                const firstChild = switchAST.children[0];\n                path = [...path, ...firstChild.path];\n                value = firstChild.value;\n              }\n              return [{ path, value }];\n            }\n            return switchAST;\n          }\n        }\n      );\n    }\n    applyResolver(resolver) {\n      resolver.hooks.beforeResolve.tap(\"switch\", (node, options) => {\n        if (node && node.type === \"switch\" && node.dynamic) {\n          return this.resolveSwitch(node, options);\n        }\n        return node;\n      });\n    }\n    apply(view) {\n      view.hooks.parser.tap(\"switch\", this.applyParser.bind(this));\n      view.hooks.resolver.tap(\"switch\", this.applyResolver.bind(this));\n    }\n  };\n  var MultiNodePlugin = class {\n    applyParser(parser) {\n      parser.hooks.parseNode.tap(\n        \"multi-node\",\n        (obj, nodeType, options, childOptions) => {\n          if ((childOptions === void 0 || !hasTemplateKey(childOptions.key)) && Array.isArray(obj)) {\n            const values = obj.map(\n              (childVal) => parser.parseObject(childVal, \"value\", options)\n            ).filter((child) => !!child);\n            if (!values.length) {\n              return [];\n            }\n            const multiNode = parser.createASTNode(\n              {\n                type: \"multi-node\",\n                override: childOptions !== void 0 && !hasTemplateValues(childOptions.parentObj, childOptions.key),\n                values\n              },\n              obj\n            );\n            if (!multiNode) {\n              return [];\n            }\n            if (multiNode.type === \"multi-node\") {\n              multiNode.values.forEach((v) => {\n                v.parent = multiNode;\n              });\n            }\n            return childOptions === void 0 ? multiNode : [\n              {\n                path: [...childOptions.path, childOptions.key],\n                value: multiNode\n              }\n            ];\n          }\n        }\n      );\n    }\n    apply(view) {\n      view.hooks.parser.tap(\"multi-node\", this.applyParser.bind(this));\n    }\n  };\n  var AssetPlugin = class {\n    applyParser(parser) {\n      parser.hooks.parseNode.tap(\n        \"asset\",\n        (obj, nodeType, options, childOptions) => {\n          if (childOptions?.key === \"asset\" && typeof obj === \"object\") {\n            const assetAST = parser.parseObject(obj, \"asset\", options);\n            if (!assetAST) {\n              return [];\n            }\n            return [\n              {\n                path: [...childOptions.path, childOptions.key],\n                value: assetAST\n              }\n            ];\n          }\n        }\n      );\n    }\n    apply(view) {\n      view.hooks.parser.tap(\"asset\", this.applyParser.bind(this));\n    }\n  };\n  var LocalStateStore = class {\n    constructor(onUpdate) {\n      this.updateCallback = onUpdate;\n      this.state = /* @__PURE__ */ new Map();\n    }\n    removeKey(key) {\n      this.state.delete(key);\n    }\n    reset() {\n      this.state.clear();\n    }\n    useSharedState(key) {\n      return (initialState) => {\n        if (!this.state.has(key)) {\n          this.state.set(key, initialState);\n        }\n        return [\n          this.state.get(key),\n          (newState) => {\n            const current = this.state.get(key);\n            this.state.set(key, newState);\n            if (current !== newState) {\n              this.updateCallback?.();\n            }\n          }\n        ];\n      };\n    }\n    getLocalStateFunction(key, countKey) {\n      return (initialState) => {\n        if (!this.state.has(key)) {\n          this.state.set(key, []);\n        }\n        if (!this.state.has(countKey)) {\n          this.state.set(countKey, 0);\n        }\n        const localState = this.state.get(key);\n        const oldCount = this.state.get(countKey);\n        this.state.set(countKey, oldCount + 1);\n        if (localState.length <= oldCount) {\n          localState.push(initialState);\n        }\n        const value = localState[oldCount];\n        return [\n          value,\n          (newState) => {\n            const oldValue = localState[oldCount];\n            localState[oldCount] = newState;\n            if (oldValue !== newState) {\n              this.updateCallback?.();\n            }\n          }\n        ];\n      };\n    }\n  };\n  function findUp(node, target) {\n    if (node === target) {\n      return true;\n    }\n    if (node.parent) {\n      return findUp(node.parent, target);\n    }\n    return false;\n  }\n  var AssetTransformCorePlugin = class {\n    constructor(registry) {\n      this.registry = registry;\n      this.stateStore = /* @__PURE__ */ new Map();\n      this.beforeResolveSymbol = Symbol(\"before resolve\");\n      this.resolveSymbol = Symbol(\"resolve\");\n      this.beforeResolveCountSymbol = Symbol(\"before resolve count\");\n      this.resolveCountSymbol = Symbol(\"resolve count\");\n    }\n    apply(view) {\n      this.stateStore.clear();\n      view.hooks.resolver.tap(\"asset-transform\", (resolver) => {\n        let lastUpdatedNode;\n        const updateState = (node) => {\n          lastUpdatedNode = node;\n          view.update(/* @__PURE__ */ new Set());\n        };\n        const getStore = (node, stepKey) => {\n          let store;\n          const countKey = stepKey === this.resolveSymbol ? this.resolveCountSymbol : this.beforeResolveCountSymbol;\n          const storedState = this.stateStore.get(node);\n          if (storedState) {\n            store = storedState;\n            store.removeKey(countKey);\n          } else {\n            store = new LocalStateStore(() => {\n              updateState(node);\n            });\n            this.stateStore.set(node, store);\n          }\n          return {\n            useSharedState: (key) => {\n              return store.useSharedState(key);\n            },\n            useLocalState: (initialState) => {\n              return store.getLocalStateFunction(\n                stepKey,\n                countKey\n              )(initialState);\n            }\n          };\n        };\n        resolver.hooks.beforeResolve.tap(\"asset-transform\", (node, options) => {\n          if (node && (node.type === \"asset\" || node.type === \"view\")) {\n            const transform3 = this.registry.get(node.value);\n            if (transform3?.beforeResolve) {\n              const store = getStore(\n                options.node ?? node,\n                this.beforeResolveSymbol\n              );\n              return transform3.beforeResolve(node, options, store);\n            }\n          }\n          return node;\n        });\n        resolver.hooks.afterUpdate.tap(\"asset-transform\", () => {\n          lastUpdatedNode = void 0;\n        });\n        resolver.hooks.skipResolve.tap(\"asset-transform\", (skip, node) => {\n          if (!skip || !lastUpdatedNode) {\n            return skip;\n          }\n          const isParentOfUpdated = findUp(lastUpdatedNode, node);\n          const isChildOfUpdated = findUp(node, lastUpdatedNode);\n          return !isParentOfUpdated && !isChildOfUpdated;\n        });\n        resolver.hooks.afterResolve.tap(\n          \"asset-transform\",\n          (value, node, options) => {\n            if (node.type !== \"asset\" && node.type !== \"view\") {\n              return value;\n            }\n            const originalNode = resolver.getSourceNode(node);\n            if (!originalNode) {\n              return value;\n            }\n            const transform3 = this.registry.get(value);\n            if (transform3?.resolve) {\n              const store = getStore(originalNode, this.resolveSymbol);\n              return transform3?.resolve(value, options, store);\n            }\n            return value;\n          }\n        );\n      });\n    }\n  };\n  var FlowInstance = class {\n    constructor(id, flow, options) {\n      this.isTransitioning = false;\n      this.hooks = {\n        beforeStart: new SyncBailHook(),\n        onStart: new SyncHook(),\n        onEnd: new SyncHook(),\n        skipTransition: new SyncBailHook(),\n        beforeTransition: new SyncWaterfallHook(),\n        resolveTransitionNode: new SyncWaterfallHook(),\n        transition: new SyncHook(),\n        afterTransition: new SyncHook()\n      };\n      this.id = id;\n      this.flow = flow;\n      this.log = options?.logger;\n      this.history = [];\n      this.hooks.transition.tap(\n        \"startPromise\",\n        async (_oldState, nextState) => {\n          const newState = nextState.value;\n          if (this.flowPromise && newState.state_type === \"END\") {\n            this.flowPromise.resolve(newState);\n          }\n        }\n      );\n    }\n    /** Start the state machine */\n    async start() {\n      if (this.flowPromise) {\n        this.log?.warn(\"Already called start for flow\");\n        return this.flowPromise.promise;\n      }\n      this.flow = this.hooks.beforeStart.call(this.flow) || this.flow;\n      if (this.flow.onStart) {\n        this.hooks.onStart.call(this.flow.onStart);\n      }\n      const initialState = this.flow.startState;\n      if (!initialState) {\n        return Promise.reject(new Error(\"No 'startState' defined for flow\"));\n      }\n      this.flowPromise = (0, import_p_defer2.default)();\n      this.pushHistory(initialState);\n      return this.flowPromise.promise;\n    }\n    transition(transitionValue, options) {\n      if (this.isTransitioning) {\n        throw new Error(\n          `Transitioning while ongoing transition from ${this.currentState?.name} is in progress is not supported`\n        );\n      }\n      if (this.currentState?.value.state_type === \"END\") {\n        this.log?.warn(\n          `Skipping transition using ${transitionValue}. Already at and END state`\n        );\n        return;\n      }\n      if (this.currentState === void 0) {\n        throw new Error(\"Cannot transition when there's no current state\");\n      }\n      if (options?.force) {\n        this.log?.debug(`Forced transition. Skipping validation checks`);\n      } else {\n        const skipTransition = this.hooks.skipTransition.call(this.currentState);\n        if (skipTransition) {\n          this.log?.debug(\n            `Skipping transition from ${this.currentState.name} b/c hook told us to`\n          );\n          return;\n        }\n      }\n      const state = this.hooks.beforeTransition.call(\n        this.currentState.value,\n        transitionValue\n      );\n      if (!(\"transitions\" in state)) {\n        throw new Error(`No transitions defined for ${this.currentState.value}`);\n      }\n      const { transitions } = state;\n      const nextState = transitions[transitionValue] || transitions[\"*\"];\n      if (nextState === void 0) {\n        this.log?.warn(\n          `No transition from ${this.currentState.name} using ${transitionValue} or *`\n        );\n        return;\n      }\n      this.log?.debug(\n        `Transitioning from ${this.currentState.name} to ${nextState} using ${transitionValue} `\n      );\n      return this.pushHistory(nextState, options);\n    }\n    pushHistory(stateName, options) {\n      if (!Object.prototype.hasOwnProperty.call(this.flow, stateName)) {\n        throw new Error(`No flow definition for: ${stateName} was found.`);\n      }\n      let nextState = this.flow[stateName];\n      if (!this.flow[stateName] || typeof nextState !== \"object\" || !(\"state_type\" in nextState)) {\n        this.log?.error(`Flow doesn't contain any states named: ${stateName}`);\n        return;\n      }\n      const prevState = this.currentState;\n      this.isTransitioning = true;\n      nextState = this.hooks.resolveTransitionNode.call(nextState);\n      const newCurrentState = {\n        name: stateName,\n        value: nextState\n      };\n      this.currentState = newCurrentState;\n      this.history.push(stateName);\n      if (newCurrentState.value.state_type === \"END\" && this.flow.onEnd) {\n        this.hooks.onEnd.call(this.flow.onEnd);\n      }\n      this.hooks.transition.call(prevState, {\n        ...newCurrentState\n      });\n      this.isTransitioning = false;\n      this.hooks.afterTransition.call(this);\n    }\n  };\n  var FlowController = class {\n    constructor(navigation, options) {\n      this.hooks = {\n        flow: new SyncHook()\n      };\n      this.navigation = navigation;\n      this.navStack = [];\n      this.log = options?.logger;\n      this.start = this.start.bind(this);\n      this.run = this.run.bind(this);\n      this.transition = this.transition.bind(this);\n      this.addNewFlow = this.addNewFlow.bind(this);\n    }\n    /** Navigate to another state in the state-machine */\n    transition(stateTransition, options) {\n      if (this.current === void 0) {\n        throw new Error(\"Not currently in a flow. Cannot transition.\");\n      }\n      this.current.transition(stateTransition, options);\n    }\n    addNewFlow(flow) {\n      this.navStack.push(flow);\n      this.current = flow;\n      this.hooks.flow.call(flow);\n    }\n    async run(startState) {\n      if (!Object.prototype.hasOwnProperty.call(this.navigation, startState)) {\n        return Promise.reject(new Error(`No flow defined for: ${startState}`));\n      }\n      const startFlow = this.navigation[startState];\n      if (startFlow === null || typeof startFlow !== \"object\") {\n        return Promise.reject(\n          new Error(`Flow: ${startState} needs to be an object`)\n        );\n      }\n      this.log?.debug(`Starting flow: ${startState}`);\n      const flow = new FlowInstance(startState, startFlow, { logger: this.log });\n      this.addNewFlow(flow);\n      flow.hooks.afterTransition.tap(\"flow-controller\", (flowInstance) => {\n        if (flowInstance.currentState?.value.state_type === \"FLOW\") {\n          const subflowId = flowInstance.currentState?.value.ref;\n          this.log?.debug(`Loading subflow ${subflowId}`);\n          this.run(subflowId).then((subFlowEndState) => {\n            this.log?.debug(\n              `Subflow ended. Using outcome: ${subFlowEndState.outcome}`\n            );\n            flowInstance.transition(subFlowEndState?.outcome);\n          });\n        }\n      });\n      const end = await flow.start();\n      this.navStack.pop();\n      if (this.navStack.length > 0) {\n        const firstItem = 0;\n        this.current = this.navStack[firstItem];\n      }\n      return end;\n    }\n    async start() {\n      if (!this.navigation.BEGIN) {\n        return Promise.reject(new Error(\"Must supply a BEGIN state\"));\n      }\n      return this.run(this.navigation.BEGIN);\n    }\n  };\n  var ANY_CHAR_REGEX = /%([a-zA-Z]+)/g;\n  function replaceParams(message, params) {\n    return message.slice().replace(ANY_CHAR_REGEX, (keyExpr) => params[keyExpr.slice(1)] || keyExpr);\n  }\n  var CONTEXT = \"validation-binding-tracker\";\n  var ValidationBindingTrackerViewPlugin = class {\n    constructor(options) {\n      this.trackedBindings = /* @__PURE__ */ new Set();\n      this.options = options;\n    }\n    /** Fetch the tracked bindings in the current view */\n    getBindings() {\n      return this.trackedBindings;\n    }\n    /** Add a binding to the tracked set */\n    trackBinding(binding) {\n      if (this.trackedBindings.has(binding)) {\n        return;\n      }\n      this.trackedBindings.add(binding);\n      this.options.callbacks?.onAdd?.(binding);\n    }\n    /** Attach hooks to the given resolver */\n    applyResolver(resolver) {\n      this.trackedBindings.clear();\n      const tracked = /* @__PURE__ */ new Map();\n      const sections = /* @__PURE__ */ new Map();\n      let lastViewUpdateChangeSet;\n      const lastComputedBindingTree = /* @__PURE__ */ new Map();\n      let currentBindingTree = /* @__PURE__ */ new Map();\n      const lastSectionBindingTree = /* @__PURE__ */ new Map();\n      const resolvedNodeMap = /* @__PURE__ */ new Map();\n      resolver.hooks.beforeUpdate.tap(CONTEXT, (changes) => {\n        lastViewUpdateChangeSet = changes;\n      });\n      resolver.hooks.skipResolve.tap(CONTEXT, (shouldSkip, node) => {\n        const trackedBindingsForNode = lastComputedBindingTree.get(node);\n        if (!shouldSkip || !lastViewUpdateChangeSet || !trackedBindingsForNode) {\n          return shouldSkip;\n        }\n        const intersection = new Set(\n          [...lastViewUpdateChangeSet].filter(\n            (b) => trackedBindingsForNode.has(b)\n          )\n        );\n        return intersection.size === 0;\n      });\n      resolver.hooks.resolveOptions.tap(CONTEXT, (options, node) => {\n        if (options.validation === void 0) {\n          return options;\n        }\n        tracked.delete(node);\n        const track = (binding) => {\n          const parsed = isBinding(binding) ? binding : this.options.parseBinding(binding);\n          if (tracked.has(node)) {\n            tracked.get(node)?.add(parsed);\n          } else {\n            tracked.set(node, /* @__PURE__ */ new Set([parsed]));\n          }\n          let { parent } = node;\n          while (parent) {\n            if (sections.has(parent)) {\n              sections.get(parent)?.add(node);\n              break;\n            } else {\n              parent = parent.parent;\n            }\n          }\n          this.trackedBindings.add(parsed);\n          this.options.callbacks?.onAdd?.(parsed);\n        };\n        return {\n          ...options,\n          validation: {\n            ...options.validation,\n            get: (binding, getOptions) => {\n              if (getOptions?.track) {\n                track(binding);\n              }\n              const eows = options.validation?._getValidationForBinding(binding)?.getAll(getOptions);\n              const firstFieldEOW = eows?.find(\n                (eow) => eow.displayTarget === \"field\" || eow.displayTarget === void 0\n              );\n              return firstFieldEOW;\n            },\n            getValidationsForBinding(binding, getOptions) {\n              if (getOptions?.track) {\n                track(binding);\n              }\n              return options.validation?._getValidationForBinding(binding)?.getAll(getOptions) ?? [];\n            },\n            getChildren: (type) => {\n              const validations = new Array();\n              lastComputedBindingTree.get(node)?.forEach((binding) => {\n                const eow = options.validation?._getValidationForBinding(binding)?.get();\n                if (eow && (type === void 0 || type === eow.displayTarget)) {\n                  validations.push(eow);\n                }\n              });\n              return validations;\n            },\n            getValidationsForSection: () => {\n              const validations = new Array();\n              lastSectionBindingTree.get(node)?.forEach((binding) => {\n                const eow = options.validation?._getValidationForBinding(binding)?.get();\n                if (eow && eow.displayTarget === \"section\") {\n                  validations.push(eow);\n                }\n              });\n              return validations;\n            },\n            register: (registerOptions) => {\n              if (registerOptions?.type === \"section\") {\n                if (!sections.has(node)) {\n                  sections.set(node, /* @__PURE__ */ new Set());\n                }\n              }\n            },\n            track\n          }\n        };\n      });\n      resolver.hooks.afterNodeUpdate.tap(\n        CONTEXT,\n        (originalNode, parent, update) => {\n          const { updated, node: resolvedNode } = update;\n          resolvedNodeMap.set(resolvedNode, originalNode);\n          if (updated) {\n            const newlyComputed = new Set(tracked.get(originalNode));\n            if (resolvedNode.type === \"multi-node\") {\n              resolvedNode.values.forEach(\n                (value) => currentBindingTree.get(value)?.forEach((b) => newlyComputed.add(b))\n              );\n            }\n            if (\"children\" in resolvedNode && resolvedNode.children) {\n              resolvedNode.children.forEach((child) => {\n                currentBindingTree.get(child.value)?.forEach((b) => newlyComputed.add(b));\n              });\n            }\n            currentBindingTree.set(resolvedNode, newlyComputed);\n          } else {\n            currentBindingTree.set(\n              resolvedNode,\n              lastComputedBindingTree.get(originalNode) ?? /* @__PURE__ */ new Set()\n            );\n          }\n          if (originalNode === resolver.root) {\n            this.trackedBindings = new Set(currentBindingTree.get(resolvedNode));\n            lastComputedBindingTree.clear();\n            currentBindingTree.forEach((value, key) => {\n              const node = resolvedNodeMap.get(key);\n              if (node) {\n                lastComputedBindingTree.set(node, value);\n              }\n            });\n            lastSectionBindingTree.clear();\n            sections.forEach((nodeSet, sectionNode) => {\n              const temp = /* @__PURE__ */ new Set();\n              nodeSet.forEach((n) => {\n                tracked.get(n)?.forEach(temp.add, temp);\n              });\n              lastSectionBindingTree.set(sectionNode, temp);\n            });\n            tracked.clear();\n            sections.clear();\n            currentBindingTree = /* @__PURE__ */ new Map();\n          }\n        }\n      );\n    }\n    apply(view) {\n      view.hooks.resolver.tap(CONTEXT, this.applyResolver.bind(this));\n    }\n  };\n  var SCHEMA_VALIDATION_PROVIDER_NAME = \"schema\";\n  var VIEW_VALIDATION_PROVIDER_NAME = \"view\";\n  var VALIDATION_PROVIDER_NAME_SYMBOL = Symbol.for(\n    \"validation-provider-name\"\n  );\n  function isSubset(subset, containingSet) {\n    if (subset.size > containingSet.size)\n      return false;\n    for (const entry of subset)\n      if (!containingSet.has(entry))\n        return false;\n    return true;\n  }\n  function createStatefulValidationObject(obj) {\n    return {\n      value: obj,\n      type: obj.severity,\n      state: \"none\",\n      isBlockingNavigation: false\n    };\n  }\n  var ValidatedBinding = class {\n    constructor(possibleValidations, onDismiss, log, weakBindings) {\n      this.applicableValidations = [];\n      this.validationsByState = {\n        load: [],\n        change: [],\n        navigation: []\n      };\n      this.onDismiss = onDismiss;\n      possibleValidations.forEach((vObj) => {\n        const { trigger } = vObj;\n        if (this.validationsByState[trigger]) {\n          const statefulValidationObject = createStatefulValidationObject(vObj);\n          this.validationsByState[trigger].push(statefulValidationObject);\n        } else {\n          log?.warn(`Unknown validation trigger: ${trigger}`);\n        }\n      });\n      this.weakBindings = weakBindings ?? /* @__PURE__ */ new Set();\n    }\n    get allValidations() {\n      return Object.values(this.validationsByState).flat();\n    }\n    checkIfBlocking(statefulObj) {\n      if (statefulObj.state === \"active\") {\n        const { isBlockingNavigation } = statefulObj;\n        return isBlockingNavigation;\n      }\n      return false;\n    }\n    getAll() {\n      return this.applicableValidations.reduce((all, statefulObj) => {\n        if (statefulObj.state === \"active\" && statefulObj.response) {\n          all.push({\n            ...statefulObj.response,\n            blocking: this.checkIfBlocking(statefulObj)\n          });\n        }\n        return all;\n      }, []);\n    }\n    get() {\n      const firstInvalid = this.applicableValidations.find((statefulObj) => {\n        return statefulObj.state === \"active\" && statefulObj.response;\n      });\n      if (firstInvalid?.state === \"active\") {\n        return {\n          ...firstInvalid.response,\n          blocking: this.checkIfBlocking(firstInvalid)\n        };\n      }\n    }\n    runApplicableValidations(runner, canDismiss, phase) {\n      this.applicableValidations = this.applicableValidations.map(\n        (originalValue) => {\n          if (originalValue.state === \"dismissed\") {\n            return originalValue;\n          }\n          const blocking = originalValue.value.blocking ?? (originalValue.value.severity === \"warning\" && \"once\" || true);\n          const obj = (0, import_timm9.setIn)(\n            originalValue,\n            [\"value\", \"blocking\"],\n            blocking\n          );\n          const isBlockingNavigation = blocking === true || blocking === \"once\" && !canDismiss;\n          if (phase === \"navigation\" && obj.state === \"active\" && obj.value.blocking !== true) {\n            if (obj.value.severity === \"warning\") {\n              const warn = obj;\n              if (warn.dismissable && warn.response.dismiss && (warn.response.blocking !== \"once\" || !warn.response.blocking)) {\n                warn.response.dismiss();\n              } else {\n                if (warn?.response.blocking === \"once\") {\n                  warn.response.blocking = false;\n                }\n                warn.dismissable = true;\n              }\n              return warn;\n            }\n          }\n          const response = runner(obj.value);\n          const newState = {\n            type: obj.type,\n            value: obj.value,\n            state: response ? \"active\" : \"none\",\n            isBlockingNavigation,\n            dismissable: obj.value.severity === \"warning\" && phase === \"navigation\",\n            response: response ? {\n              ...obj.value,\n              message: response.message ?? \"Something is broken\",\n              severity: obj.value.severity,\n              displayTarget: obj.value.displayTarget ?? \"field\"\n            } : void 0\n          };\n          if (newState.state === \"active\" && obj.value.severity === \"warning\") {\n            newState.response.dismiss = () => {\n              newState.state = \"dismissed\";\n              this.onDismiss?.();\n            };\n          }\n          return newState;\n        }\n      );\n    }\n    update(phase, canDismiss, runner) {\n      const newApplicableValidations = [];\n      if (phase === \"load\" && this.currentPhase !== void 0) {\n        return;\n      }\n      if (this.currentPhase === \"navigation\" || phase === this.currentPhase) {\n        this.runApplicableValidations(runner, canDismiss, phase);\n        return;\n      }\n      if (phase === \"load\") {\n        this.currentPhase = \"load\";\n        this.applicableValidations = [...this.validationsByState.load];\n      } else if (phase === \"change\" && this.currentPhase === \"load\") {\n        this.currentPhase = \"change\";\n        this.applicableValidations = [\n          ...this.applicableValidations,\n          ...this.validationsByState.change\n        ];\n      } else if (phase === \"navigation\" && (this.currentPhase === \"load\" || this.currentPhase === \"change\")) {\n        this.applicableValidations.forEach((element) => {\n          if (!(element.type === \"error\" && element.state === \"active\" && element.isBlockingNavigation === false)) {\n            newApplicableValidations.push(element);\n          }\n        });\n        this.applicableValidations = [\n          ...newApplicableValidations,\n          ...this.validationsByState.navigation,\n          ...this.currentPhase === \"load\" ? this.validationsByState.change : []\n        ];\n        this.currentPhase = \"navigation\";\n      }\n      this.runApplicableValidations(runner, canDismiss, phase);\n    }\n  };\n  var ValidationController = class {\n    constructor(schema, options) {\n      this.hooks = {\n        /** A hook called to tap into the validator registry for adding more validators */\n        createValidatorRegistry: new SyncHook(),\n        /** A callback/event when a new validation is added to the view */\n        onAddValidation: new SyncWaterfallHook(),\n        /** The inverse of onAddValidation, this is called when a validation is removed from the list */\n        onRemoveValidation: new SyncWaterfallHook(),\n        resolveValidationProviders: new SyncWaterfallHook(),\n        /** A hook called when a binding is added to the tracker */\n        onTrackBinding: new SyncHook()\n      };\n      this.validations = /* @__PURE__ */ new Map();\n      this.weakBindingTracker = /* @__PURE__ */ new Set();\n      this.schema = schema;\n      this.options = options;\n      this.reset();\n    }\n    setOptions(options) {\n      this.options = options;\n    }\n    /** Return the middleware for the data-model to stop propagation of invalid data */\n    getDataMiddleware() {\n      return [\n        {\n          set: (transaction, options, next) => {\n            return next?.set(transaction, options) ?? [];\n          },\n          get: (binding, options, next) => {\n            return next?.get(binding, options);\n          },\n          delete: (binding, options, next) => {\n            this.validations = removeBindingAndChildrenFromMap(\n              this.validations,\n              binding\n            );\n            return next?.delete(binding, options);\n          }\n        },\n        new ValidationMiddleware(\n          (binding) => {\n            if (!this.options) {\n              return;\n            }\n            this.updateValidationsForBinding(binding, \"change\", this.options);\n            const strongValidation = this.getValidationForBinding(binding);\n            if (strongValidation?.get()?.severity === \"error\") {\n              return strongValidation.get();\n            }\n            const newInvalidBindings = /* @__PURE__ */ new Set();\n            this.validations.forEach((weakValidation, strongBinding) => {\n              if (caresAboutDataChanges(\n                /* @__PURE__ */ new Set([binding]),\n                weakValidation.weakBindings\n              ) && weakValidation?.get()?.severity === \"error\") {\n                weakValidation?.weakBindings.forEach((weakBinding) => {\n                  if (weakBinding === strongBinding) {\n                    newInvalidBindings.add({\n                      binding: weakBinding,\n                      isStrong: true\n                    });\n                  } else {\n                    newInvalidBindings.add({\n                      binding: weakBinding,\n                      isStrong: false\n                    });\n                  }\n                });\n              }\n            });\n            if (newInvalidBindings.size > 0) {\n              return newInvalidBindings;\n            }\n          },\n          { logger: new ProxyLogger(() => this.options?.logger) }\n        )\n      ];\n    }\n    getValidationProviders() {\n      if (this.providers) {\n        return this.providers;\n      }\n      this.providers = this.hooks.resolveValidationProviders.call([\n        {\n          source: SCHEMA_VALIDATION_PROVIDER_NAME,\n          provider: this.schema\n        },\n        {\n          source: VIEW_VALIDATION_PROVIDER_NAME,\n          provider: {\n            getValidationsForBinding: (binding) => {\n              return this.viewValidationProvider?.getValidationsForBinding?.(\n                binding\n              );\n            },\n            getValidationsForView: () => {\n              return this.viewValidationProvider?.getValidationsForView?.();\n            }\n          }\n        }\n      ]);\n      return this.providers;\n    }\n    reset() {\n      this.validations.clear();\n      this.tracker = void 0;\n    }\n    onView(view) {\n      this.validations.clear();\n      if (!this.options) {\n        return;\n      }\n      const bindingTrackerPlugin = new ValidationBindingTrackerViewPlugin({\n        ...this.options,\n        callbacks: {\n          onAdd: (binding) => {\n            if (!this.options || this.getValidationForBinding(binding) !== void 0) {\n              return;\n            }\n            const originalValue = this.options.model.get(binding);\n            const withoutDefault = this.options.model.get(binding, {\n              ignoreDefaultValue: true\n            });\n            if (originalValue !== withoutDefault) {\n              this.options.model.set([[binding, originalValue]], {\n                silent: true\n              });\n            }\n            this.updateValidationsForBinding(\n              binding,\n              \"load\",\n              this.options,\n              () => {\n                view.update(/* @__PURE__ */ new Set([binding]));\n              }\n            );\n            this.hooks.onTrackBinding.call(binding);\n          }\n        }\n      });\n      this.tracker = bindingTrackerPlugin;\n      this.viewValidationProvider = view;\n      bindingTrackerPlugin.apply(view);\n    }\n    updateValidationsForBinding(binding, trigger, validationContext, onDismiss) {\n      const context = validationContext ?? this.options;\n      if (!context) {\n        throw new Error(`Context is required for executing validations`);\n      }\n      if (trigger === \"load\") {\n        const possibleValidations = this.getValidationProviders().reduce((vals, provider) => {\n          vals.push(\n            ...provider.provider.getValidationsForBinding?.(binding)?.map((valObj) => ({\n              ...valObj,\n              [VALIDATION_PROVIDER_NAME_SYMBOL]: provider.source\n            })) ?? []\n          );\n          return vals;\n        }, []);\n        if (possibleValidations.length === 0) {\n          return;\n        }\n        this.validations.set(\n          binding,\n          new ValidatedBinding(\n            possibleValidations,\n            onDismiss,\n            this.options?.logger\n          )\n        );\n      }\n      const trackedValidations = this.validations.get(binding);\n      trackedValidations?.update(trigger, true, (validationObj) => {\n        const response = this.validationRunner(validationObj, binding, context);\n        if (this.weakBindingTracker.size > 0) {\n          const t2 = this.validations.get(binding);\n          this.weakBindingTracker.forEach((b) => t2.weakBindings.add(b));\n        }\n        return response ? { message: response.message } : void 0;\n      });\n      if (trigger !== \"load\") {\n        this.validations.forEach((validation, vBinding) => {\n          if (vBinding !== binding && caresAboutDataChanges(/* @__PURE__ */ new Set([binding]), validation.weakBindings)) {\n            validation.update(trigger, true, (validationObj) => {\n              const response = this.validationRunner(\n                validationObj,\n                vBinding,\n                context\n              );\n              return response ? { message: response.message } : void 0;\n            });\n          }\n        });\n      }\n    }\n    validationRunner(validationObj, binding, context = this.options) {\n      if (!context) {\n        throw new Error(\"No context provided to validation runner\");\n      }\n      const handler = validationObj.handler ?? this.getValidator(validationObj.type);\n      const weakBindings = /* @__PURE__ */ new Set();\n      const model = {\n        get(b, options) {\n          weakBindings.add(isBinding(b) ? binding : context.parseBinding(b));\n          return context.model.get(b, { ...options, includeInvalid: true });\n        },\n        set: context.model.set,\n        delete: context.model.delete\n      };\n      const result = handler?.(\n        {\n          ...context,\n          evaluate: (exp, options = { model }) => context.evaluate(exp, options),\n          model,\n          validation: validationObj,\n          schemaType: this.schema.getType(binding)\n        },\n        context.model.get(binding, {\n          includeInvalid: true,\n          formatted: validationObj.dataTarget === \"formatted\"\n        }),\n        validationObj\n      );\n      this.weakBindingTracker = weakBindings;\n      if (result) {\n        let { message } = result;\n        const { parameters } = result;\n        if (validationObj.message) {\n          message = resolveDataRefs(validationObj.message, {\n            model,\n            evaluate: context.evaluate\n          });\n          if (parameters) {\n            message = replaceParams(message, parameters);\n          }\n        }\n        return {\n          message\n        };\n      }\n    }\n    updateValidationsForView(trigger) {\n      const isNavigationTrigger = trigger === \"navigation\";\n      const lastActiveBindings = this.activeBindings;\n      const updateValidations = (dismissValidations) => {\n        this.getBindings().forEach((binding) => {\n          this.validations.get(binding)?.update(trigger, dismissValidations, (obj) => {\n            if (!this.options) {\n              return;\n            }\n            return this.validationRunner(obj, binding, this.options);\n          });\n        });\n      };\n      updateValidations(!isNavigationTrigger);\n      if (isNavigationTrigger) {\n        const { activeBindings } = this;\n        if (isSubset(activeBindings, lastActiveBindings)) {\n          updateValidations(true);\n        }\n      }\n    }\n    get activeBindings() {\n      return new Set(\n        Array.from(this.getBindings()).filter(\n          (b) => this.validations.get(b)?.get() !== void 0\n        )\n      );\n    }\n    getValidator(type) {\n      if (this.validatorRegistry) {\n        return this.validatorRegistry.get(type);\n      }\n      const registry = new ValidatorRegistry();\n      this.hooks.createValidatorRegistry.call(registry);\n      this.validatorRegistry = registry;\n      return registry.get(type);\n    }\n    getBindings() {\n      return this.tracker?.getBindings() ?? /* @__PURE__ */ new Set();\n    }\n    trackBinding(binding) {\n      this.tracker?.trackBinding(binding);\n    }\n    /** Executes all known validations for the tracked bindings using the given model */\n    validateView(trigger = \"navigation\") {\n      this.updateValidationsForView(trigger);\n      const validations = /* @__PURE__ */ new Map();\n      let canTransition = true;\n      this.getBindings().forEach((b) => {\n        const allValidations = this.getValidationForBinding(b)?.getAll();\n        allValidations?.forEach((v) => {\n          if (trigger === \"navigation\" && v.blocking) {\n            this.options?.logger.debug(\n              `Validation on binding: ${b.asString()} is preventing navigation. ${JSON.stringify(\n                v\n              )}`\n            );\n            canTransition = false;\n          }\n          if (!validations.has(b)) {\n            validations.set(b, v);\n          }\n        });\n      });\n      return {\n        canTransition,\n        validations: validations.size ? validations : void 0\n      };\n    }\n    /** Get the current tracked validation for the given binding */\n    getValidationForBinding(binding) {\n      return this.validations.get(binding);\n    }\n    forView(parser) {\n      return {\n        _getValidationForBinding: (binding) => {\n          return this.getValidationForBinding(\n            isBinding(binding) ? binding : parser(binding)\n          );\n        },\n        getAll: () => {\n          const bindings = this.getBindings();\n          if (bindings.size === 0) {\n            return void 0;\n          }\n          const validationMapping = /* @__PURE__ */ new Map();\n          bindings.forEach((b) => {\n            const validation = this.getValidationForBinding(b)?.get();\n            if (validation) {\n              validationMapping.set(b, validation);\n            }\n          });\n          return validationMapping.size === 0 ? void 0 : validationMapping;\n        },\n        get() {\n          throw new Error(\"Error Access be provided by the view plugin\");\n        },\n        getValidationsForBinding() {\n          throw new Error(\"Error rollup should be provided by the view plugin\");\n        },\n        getChildren() {\n          throw new Error(\"Error rollup should be provided by the view plugin\");\n        },\n        getValidationsForSection() {\n          throw new Error(\"Error rollup should be provided by the view plugin\");\n        },\n        track: () => {\n          throw new Error(\"Tracking should be provided by the view plugin\");\n        },\n        register: () => {\n          throw new Error(\n            \"Section functionality should be provided by the view plugin\"\n          );\n        },\n        type: (binding) => this.schema.getType(isBinding(binding) ? binding : parser(binding))\n      };\n    }\n  };\n  var ViewController = class {\n    constructor(initialViews, options) {\n      this.hooks = {\n        resolveView: new SyncWaterfallHook(),\n        view: new SyncHook()\n      };\n      this.transformRegistry = new Registry();\n      this.optimizeUpdates = true;\n      this.viewOptions = options;\n      this.viewMap = initialViews.reduce(\n        (viewMap, view) => {\n          viewMap[view.id] = view;\n          return viewMap;\n        },\n        {}\n      );\n      options.flowController.hooks.flow.tap(\n        \"viewController\",\n        (flow) => {\n          flow.hooks.transition.tap(\"viewController\", (_oldState, newState) => {\n            if (newState.value.state_type === \"VIEW\") {\n              this.onView(newState.value);\n            } else {\n              this.currentView = void 0;\n            }\n          });\n        }\n      );\n      const update = (updates, silent = false) => {\n        if (this.currentView) {\n          if (this.optimizeUpdates) {\n            this.queueUpdate(updates, silent);\n          } else {\n            this.currentView.update();\n          }\n        }\n      };\n      options.model.hooks.onUpdate.tap(\n        \"viewController\",\n        (updates, updateOptions) => {\n          update(\n            new Set(updates.map((t2) => t2.binding)),\n            updateOptions?.silent ?? false\n          );\n        }\n      );\n      options.model.hooks.onDelete.tap(\"viewController\", (binding) => {\n        const parentBinding = binding.parent();\n        const property = binding.key();\n        if (typeof property === \"number\" && parentBinding) {\n          update(/* @__PURE__ */ new Set([parentBinding]));\n        } else {\n          update(/* @__PURE__ */ new Set([binding]));\n        }\n      });\n      this.viewPlugins = this.createViewPlugins();\n    }\n    queueUpdate(bindings, silent = false) {\n      if (this.pendingUpdate?.changedBindings) {\n        this.pendingUpdate.changedBindings = /* @__PURE__ */ new Set([\n          ...this.pendingUpdate.changedBindings,\n          ...bindings\n        ]);\n      } else {\n        this.pendingUpdate = { changedBindings: bindings, scheduled: false };\n      }\n      if (!this.pendingUpdate.scheduled && !silent) {\n        this.pendingUpdate.scheduled = true;\n        (0, import_queue_microtask2.default)(() => {\n          const updates = this.pendingUpdate?.changedBindings;\n          this.pendingUpdate = void 0;\n          this.currentView?.update(updates);\n        });\n      }\n    }\n    getViewForRef(viewRef) {\n      if (this.viewMap[viewRef]) {\n        return this.viewMap[viewRef];\n      }\n      const matchingViewId = Object.keys(this.viewMap).find(\n        (possibleViewIdMatch) => viewRef === resolveDataRefsInString(possibleViewIdMatch, {\n          model: this.viewOptions.model,\n          evaluate: this.viewOptions.evaluator.evaluate\n        })\n      );\n      if (matchingViewId && this.viewMap[matchingViewId]) {\n        return this.viewMap[matchingViewId];\n      }\n    }\n    onView(state) {\n      const viewId = state.ref;\n      const source = this.hooks.resolveView.call(\n        this.getViewForRef(viewId),\n        viewId,\n        state\n      );\n      if (!source) {\n        throw new Error(`No view with id ${viewId}`);\n      }\n      const view = new ViewInstance(source, this.viewOptions);\n      this.currentView = view;\n      this.applyViewPlugins(view);\n      this.hooks.view.call(view);\n      view.update();\n    }\n    applyViewPlugins(view) {\n      for (const plugin of this.viewPlugins) {\n        plugin.apply(view);\n      }\n    }\n    createViewPlugins() {\n      const pluginOptions = toNodeResolveOptions(this.viewOptions);\n      return [\n        new AssetPlugin(),\n        new SwitchPlugin(pluginOptions),\n        new ApplicabilityPlugin(),\n        new AssetTransformCorePlugin(this.transformRegistry),\n        new StringResolverPlugin(),\n        new TemplatePlugin(pluginOptions),\n        new MultiNodePlugin()\n      ];\n    }\n  };\n  var ReadOnlyDataController = class {\n    constructor(controller, logger) {\n      this.controller = controller;\n      this.logger = logger;\n    }\n    get(binding, options) {\n      return this.controller.get(binding, options);\n    }\n    set(transaction, options) {\n      this.logger?.error(\n        \"Error: Tried to set in a read only instance of the DataController\"\n      );\n      return [];\n    }\n    delete(binding, options) {\n      this.logger?.error(\n        \"Error: Tried to delete in a read only instance of the DataController\"\n      );\n    }\n  };\n  var DataController = class {\n    constructor(model, options) {\n      this.hooks = {\n        resolve: new SyncWaterfallHook(),\n        resolveDataStages: new SyncWaterfallHook(),\n        // On any set or get of an undefined value, redirect the value to be the default\n        resolveDefaultValue: new SyncBailHook(),\n        onDelete: new SyncHook(),\n        onSet: new SyncHook(),\n        onGet: new SyncHook(),\n        onUpdate: new SyncHook(),\n        format: new SyncWaterfallHook(),\n        deformat: new SyncWaterfallHook(),\n        serialize: new SyncWaterfallHook()\n      };\n      this.logger = options.logger;\n      const middleware = options.middleware || [];\n      this.baseMiddleware = [new LocalModel(model), ...middleware];\n      this.trash = /* @__PURE__ */ new Set();\n      this.pathResolver = options.pathResolver;\n    }\n    getModel() {\n      if (!this.model) {\n        const stages = this.hooks.resolveDataStages.call(this.baseMiddleware);\n        const model = new PipelinedDataModel();\n        model.setMiddleware(stages);\n        this.model = model;\n      }\n      return this.model;\n    }\n    resolveDataValue(binding, value, deformat) {\n      if (deformat) {\n        return this.hooks.deformat.call(value, binding);\n      }\n      return value;\n    }\n    set(transaction, options) {\n      let normalizedTransaction = [];\n      if (Array.isArray(transaction)) {\n        normalizedTransaction = transaction.map(([binding, value]) => {\n          const parsed = this.pathResolver.parse(binding);\n          return [\n            parsed,\n            this.resolveDataValue(parsed, value, Boolean(options?.formatted))\n          ];\n        });\n      } else {\n        normalizedTransaction = Object.keys(transaction).map(\n          (binding) => {\n            const parsed = this.pathResolver.parse(binding);\n            const val = transaction[binding];\n            return [\n              parsed,\n              this.resolveDataValue(parsed, val, Boolean(options?.formatted))\n            ];\n          }\n        );\n      }\n      const setUpdates = normalizedTransaction.reduce(\n        (updates, [binding, newVal]) => {\n          const oldVal = this.get(binding, { includeInvalid: true });\n          const update = {\n            binding,\n            newValue: newVal,\n            oldValue: oldVal\n          };\n          if (dequal(oldVal, newVal)) {\n            this.logger?.debug(\n              `Skipping update for path: ${binding.asString()}. Value was unchanged: ${oldVal}`\n            );\n          } else {\n            updates.push(update);\n            this.logger?.debug(\n              `Setting path: ${binding.asString()} from: ${oldVal} to: ${newVal}`\n            );\n          }\n          return updates;\n        },\n        []\n      );\n      const result = this.getModel().set(normalizedTransaction, options);\n      const setUpdateBindings = new Set(setUpdates.map((su) => su.binding));\n      result.forEach((tr) => {\n        if (!setUpdateBindings.has(tr.binding) && (tr.force === true || !dequal(tr.oldValue, tr.newValue))) {\n          this.logger?.debug(\n            `Path: ${tr.binding.asString()} was changed from: ${tr.oldValue} to: ${tr.newValue}`\n          );\n          setUpdates.push(tr);\n        }\n      });\n      this.hooks.onSet.call(normalizedTransaction);\n      if (setUpdates.length > 0) {\n        this.hooks.onUpdate.call(setUpdates, options);\n      }\n      return result;\n    }\n    resolve(binding, readOnly) {\n      return Array.isArray(binding) || typeof binding === \"string\" ? this.pathResolver.parse(binding, { readOnly }) : binding;\n    }\n    get(binding, options) {\n      const resolved = binding instanceof BindingInstance ? binding : this.resolve(binding, true);\n      let result = this.getModel().get(resolved, options);\n      if (result === void 0 && !options?.ignoreDefaultValue) {\n        const defaultVal = this.hooks.resolveDefaultValue.call(resolved);\n        if (defaultVal !== result) {\n          result = defaultVal;\n        }\n      }\n      if (options?.formatted) {\n        result = this.hooks.format.call(result, resolved);\n      } else if (options?.formatted === false) {\n        result = this.hooks.deformat.call(result, resolved);\n      }\n      this.hooks.onGet.call(binding, result);\n      return result;\n    }\n    delete(binding, options) {\n      if (typeof binding !== \"string\" && !Array.isArray(binding) && !(binding instanceof BindingInstance)) {\n        throw new Error(\"Invalid arguments: delete expects a data path (string)\");\n      }\n      const resolved = binding instanceof BindingInstance ? binding : this.resolve(binding, false);\n      const parentBinding = resolved.parent();\n      const property = resolved.key();\n      const parentValue = this.get(parentBinding);\n      const existedBeforeDelete = typeof parentValue === \"object\" && parentValue !== null && Object.prototype.hasOwnProperty.call(parentValue, property);\n      this.getModel().delete(resolved, options);\n      if (existedBeforeDelete && !this.get(resolved)) {\n        this.trash.add(resolved);\n      }\n      this.hooks.onDelete.call(resolved);\n    }\n    serialize() {\n      return this.hooks.serialize.call(this.get(\"\"));\n    }\n    makeReadOnly() {\n      return new ReadOnlyDataController(this, this.logger);\n    }\n  };\n  function flatten(obj, roots = [], sep = \".\") {\n    return Object.keys(obj).reduce(\n      (memo, prop) => ({\n        // create a new object\n        // include previously returned object\n        ...memo,\n        ...Object.prototype.toString.call(obj[prop]) === \"[object Object]\" ? (\n          // keep working if value is an object\n          flatten(obj[prop], roots.concat([prop]))\n        ) : (\n          // include current prop and value and prefix prop with the roots\n          { [roots.concat([prop]).join(sep)]: obj[prop] }\n        )\n      }),\n      {}\n    );\n  }\n  function objectToBatchSet(obj) {\n    const flattenedObj = flatten(obj);\n    const batchTxn = [];\n    Object.keys(flattenedObj).forEach((key) => {\n      batchTxn.push([new BindingInstance(key), flattenedObj[key]]);\n    });\n    return batchTxn;\n  }\n  var ConstantsController = class {\n    constructor() {\n      this.store = /* @__PURE__ */ new Map();\n      this.tempStore = /* @__PURE__ */ new Map();\n    }\n    addConstants(data, namespace) {\n      if (this.store.has(namespace)) {\n        this.store.get(namespace)?.set(objectToBatchSet(data));\n      } else {\n        this.store.set(namespace, new LocalModel(data));\n      }\n    }\n    getConstants(key, namespace, fallback) {\n      const path = new BindingInstance(key);\n      return this.tempStore.get(namespace)?.get(path) ?? this.store.get(namespace)?.get(path) ?? fallback;\n    }\n    setTemporaryValues(data, namespace) {\n      if (this.tempStore.has(namespace)) {\n        this.tempStore.get(namespace)?.set(objectToBatchSet(data));\n      } else {\n        this.tempStore.set(namespace, new LocalModel(data));\n      }\n    }\n    clearTemporaryValues(namespace) {\n      if (namespace) {\n        this.tempStore.get(namespace)?.reset();\n      } else {\n        this.tempStore.forEach((value) => {\n          value.reset();\n        });\n      }\n    }\n  };\n  var FlowExpPlugin = class {\n    constructor() {\n      this.name = \"flow-exp-plugin\";\n    }\n    apply(player) {\n      let expressionEvaluator;\n      const handleEval = (exp) => {\n        if (exp) {\n          if (typeof exp === \"object\" && \"exp\" in exp) {\n            expressionEvaluator?.evaluate(exp.exp);\n          } else {\n            expressionEvaluator?.evaluate(exp);\n          }\n        }\n      };\n      player.hooks.expressionEvaluator.tap(this.name, (evaluator) => {\n        expressionEvaluator = evaluator;\n      });\n      player.hooks.flowController.tap(this.name, (fc) => {\n        fc.hooks.flow.tap(this.name, (flow) => {\n          flow.hooks.onStart.tap(this.name, (exp) => handleEval(exp));\n          flow.hooks.onEnd.tap(this.name, (exp) => handleEval(exp));\n          flow.hooks.resolveTransitionNode.intercept({\n            call: (nextState) => {\n              if (nextState?.onStart) {\n                handleEval(nextState.onStart);\n              }\n            }\n          });\n        });\n      });\n    }\n  };\n  var createFormatFunction = (schema) => {\n    const handler = (ctx, value, formatName) => {\n      return schema.getFormatterForType({ type: formatName })?.format(value) ?? value;\n    };\n    return handler;\n  };\n  var DefaultExpPlugin = class {\n    constructor() {\n      this.name = \"flow-exp-plugin\";\n    }\n    apply(player) {\n      let formatFunction;\n      player.hooks.schema.tap(this.name, (schemaController) => {\n        formatFunction = createFormatFunction(schemaController);\n      });\n      player.hooks.expressionEvaluator.tap(this.name, (expEvaluator) => {\n        if (formatFunction) {\n          expEvaluator.addExpressionFunction(\"format\", formatFunction);\n        }\n        expEvaluator.addExpressionFunction(\"log\", (ctx, ...args) => {\n          player.logger.info(...args);\n        });\n        expEvaluator.addExpressionFunction(\"debug\", (ctx, ...args) => {\n          player.logger.debug(...args);\n        });\n        expEvaluator.addExpressionFunction(\n          \"eval\",\n          (ctx, ...args) => {\n            return ctx.evaluate(...args);\n          }\n        );\n      });\n    }\n  };\n  var NOT_STARTED_STATE = {\n    ref: Symbol(\"not-started\"),\n    status: \"not-started\"\n  };\n  var PLAYER_VERSION = true ? \"0.15.0-next.5\" : \"unknown\";\n  var COMMIT = true ? \"b332f0c87e29054ff2a1df91873b9a4ac4c1084f\" : \"unknown\";\n  var _Player = class _Player2 {\n    constructor(config) {\n      this.logger = new TapableLogger();\n      this.constantsController = new ConstantsController();\n      this.state = NOT_STARTED_STATE;\n      this.hooks = {\n        flowController: new SyncHook(),\n        viewController: new SyncHook(),\n        view: new SyncHook(),\n        expressionEvaluator: new SyncHook(),\n        dataController: new SyncHook(),\n        schema: new SyncHook(),\n        validationController: new SyncHook(),\n        bindingParser: new SyncHook(),\n        state: new SyncHook(),\n        onStart: new SyncHook(),\n        onEnd: new SyncHook(),\n        resolveFlowContent: new SyncWaterfallHook()\n      };\n      if (config?.logger) {\n        this.logger.addHandler(config.logger);\n      }\n      this.config = config || {};\n      this.config.plugins = [\n        new DefaultExpPlugin(),\n        ...this.config.plugins || [],\n        new FlowExpPlugin()\n      ];\n      this.config.plugins?.forEach((plugin) => {\n        plugin.apply(this);\n      });\n    }\n    /**  Returns currently registered plugins */\n    getPlugins() {\n      return this.config.plugins ?? [];\n    }\n    /** Find instance of [Plugin] that has been registered to Player */\n    findPlugin(symbol) {\n      return this.config.plugins?.find((el) => el.symbol === symbol);\n    }\n    /** Retrieve an instance of [Plugin] and conditionally invoke [apply] if it exists */\n    applyTo(symbol, apply) {\n      const plugin = this.findPlugin(symbol);\n      if (plugin) {\n        apply(plugin);\n      }\n    }\n    /** Register and apply [Plugin] if one with the same symbol is not already registered. */\n    registerPlugin(plugin) {\n      plugin.apply(this);\n      this.config.plugins?.push(plugin);\n    }\n    /** Returns the current version of the running player */\n    getVersion() {\n      return _Player2.info.version;\n    }\n    /** Returns the git commit used to build Player version */\n    getCommit() {\n      return _Player2.info.commit;\n    }\n    /**\n     * Fetch the current state of Player.\n     * It will return either `not-started`, `in-progress`, `completed`\n     * with some extra data in each\n     */\n    getState() {\n      return this.state;\n    }\n    /**\n     * A private means of setting the state of Player\n     * Calls the hooks for subscribers to listen for this event\n     */\n    setState(state) {\n      this.state = state;\n      this.hooks.state.call(state);\n    }\n    /** Start Player with the given flow */\n    setupFlow(userContent) {\n      const userFlow = this.hooks.resolveFlowContent.call(userContent);\n      const flowController = new FlowController(userFlow.navigation, {\n        logger: this.logger\n      });\n      this.hooks.onStart.call(userFlow);\n      this.hooks.flowController.call(flowController);\n      let expressionEvaluator;\n      let dataController;\n      const pathResolver = new BindingParser({\n        get: (binding) => {\n          return dataController.get(binding);\n        },\n        set: (transaction) => {\n          return dataController.set(transaction);\n        },\n        evaluate: (expression) => {\n          return expressionEvaluator.evaluate(expression);\n        }\n      });\n      this.hooks.bindingParser.call(pathResolver);\n      const parseBinding = pathResolver.parse;\n      const flowResultDeferred = (0, import_p_defer.default)();\n      const schema = new SchemaController(userFlow.schema);\n      this.hooks.schema.call(schema);\n      const validationController = new ValidationController(schema);\n      this.hooks.validationController.call(validationController);\n      dataController = new DataController(userFlow.data, {\n        pathResolver,\n        middleware: validationController.getDataMiddleware(),\n        logger: this.logger\n      });\n      dataController.hooks.format.tap(\"player\", (value, binding) => {\n        const formatter = schema.getFormatter(binding);\n        return formatter ? formatter.format(value) : value;\n      });\n      dataController.hooks.deformat.tap(\"player\", (value, binding) => {\n        const formatter = schema.getFormatter(binding);\n        return formatter ? formatter.deformat(value) : value;\n      });\n      dataController.hooks.resolveDefaultValue.tap(\n        \"player\",\n        (binding) => schema.getApparentType(binding)?.default\n      );\n      let viewController;\n      expressionEvaluator = new ExpressionEvaluator({\n        model: dataController,\n        logger: this.logger\n      });\n      this.hooks.expressionEvaluator.call(expressionEvaluator);\n      expressionEvaluator.hooks.onError.tap(\"player\", (e) => {\n        flowResultDeferred.reject(e);\n        return true;\n      });\n      function resolveStrings(val, formatted) {\n        return resolveDataRefs(val, {\n          model: dataController,\n          evaluate: expressionEvaluator.evaluate,\n          formatted\n        });\n      }\n      flowController.hooks.flow.tap(\"player\", (flow) => {\n        flow.hooks.beforeTransition.tap(\"player\", (state, transitionVal) => {\n          const computedTransitionVal = state.transitions[transitionVal] ? transitionVal : \"*\";\n          if (state.onEnd && state.transitions[computedTransitionVal]) {\n            if (typeof state.onEnd === \"object\" && \"exp\" in state.onEnd) {\n              expressionEvaluator?.evaluate(state.onEnd.exp);\n            } else {\n              expressionEvaluator?.evaluate(state.onEnd);\n            }\n          }\n          if (!(\"transitions\" in state) || !state.transitions[computedTransitionVal]) {\n            return state;\n          }\n          return (0, import_timm8.setIn)(\n            state,\n            [\"transitions\", computedTransitionVal],\n            resolveStrings(state.transitions[computedTransitionVal])\n          );\n        });\n        flow.hooks.skipTransition.tap(\"validation\", (currentState) => {\n          if (currentState?.value.state_type === \"VIEW\") {\n            const { canTransition, validations } = validationController.validateView(\"navigation\");\n            if (!canTransition && validations) {\n              const bindings = new Set(validations.keys());\n              viewController?.currentView?.update(bindings);\n              return true;\n            }\n          }\n          return void 0;\n        });\n        flow.hooks.resolveTransitionNode.tap(\"player\", (state) => {\n          let newState = state;\n          if (\"ref\" in state) {\n            newState = (0, import_timm8.setIn)(state, [\"ref\"], resolveStrings(state.ref));\n          }\n          if (\"param\" in state) {\n            newState = (0, import_timm8.setIn)(\n              state,\n              [\"param\"],\n              resolveStrings(state.param, false)\n            );\n          }\n          return newState;\n        });\n        flow.hooks.transition.tap(\"player\", (_oldState, newState) => {\n          if (newState.value.state_type !== \"VIEW\") {\n            validationController.reset();\n          }\n        });\n        flow.hooks.afterTransition.tap(\"player-action-states\", (flowInstance) => {\n          const value = flowInstance.currentState?.value;\n          if (value && value.state_type === \"ASYNC_ACTION\") {\n            const { exp } = value;\n            try {\n              const result = expressionEvaluator.evaluateAsync(exp);\n              if (isPromiseLike(result)) {\n                if (value.await) {\n                  (0, import_queue_microtask.default)(() => {\n                    result.then((r) => flowController?.transition(String(r))).catch(flowResultDeferred.reject);\n                  });\n                } else {\n                  this.logger.warn(\n                    \"Unawaited promise used as return value in in non-async context, transitioning with '*' value\"\n                  );\n                  flowController?.transition(String(result));\n                }\n              } else {\n                this.logger.warn(\n                  \"Non async expression used in async action node\"\n                );\n                flowController?.transition(String(result));\n              }\n            } catch (e) {\n              flowResultDeferred.reject(e);\n            }\n          } else if (value && value.state_type === \"ACTION\") {\n            const { exp } = value;\n            const result = expressionEvaluator.evaluate(exp);\n            if (isPromiseLike(result)) {\n              this.logger.warn(\n                \"Async expression used as return value in in non-async context, transitioning with '*' value\"\n              );\n            }\n            flowController?.transition(String(result));\n          }\n          expressionEvaluator.reset();\n        });\n      });\n      this.hooks.dataController.call(dataController);\n      validationController.setOptions({\n        parseBinding,\n        model: dataController,\n        logger: this.logger,\n        evaluate: expressionEvaluator.evaluate,\n        constants: this.constantsController\n      });\n      viewController = new ViewController(userFlow.views || [], {\n        evaluator: expressionEvaluator,\n        parseBinding,\n        transition: flowController.transition,\n        model: dataController,\n        utils: {\n          findPlugin: (pluginSymbol) => {\n            return this.findPlugin(pluginSymbol);\n          }\n        },\n        logger: this.logger,\n        flowController,\n        schema,\n        format: (binding, value) => {\n          const formatter = schema.getFormatter(binding);\n          return formatter?.format ? formatter.format(value) : value;\n        },\n        formatValue: (ref, value) => {\n          const formatter = schema.getFormatterForType(ref);\n          return formatter?.format ? formatter.format(value) : value;\n        },\n        validation: {\n          ...validationController.forView(parseBinding),\n          type: (b) => schema.getType(parseBinding(b))\n        },\n        constants: this.constantsController\n      });\n      viewController.hooks.view.tap(\"player\", (view) => {\n        validationController.onView(view);\n        this.hooks.view.call(view);\n      });\n      this.hooks.viewController.call(viewController);\n      return {\n        start: () => {\n          flowController.start().then((endState) => {\n            const flowResult = {\n              endState: resolveStrings(endState, false),\n              data: dataController.serialize()\n            };\n            return flowResult;\n          }).then(flowResultDeferred.resolve).catch((e) => {\n            this.logger.error(`Something went wrong: ${e.message}`);\n            throw e;\n          }).catch(flowResultDeferred.reject).finally(() => this.hooks.onEnd.call());\n        },\n        state: {\n          status: \"in-progress\",\n          flowResult: flowResultDeferred.promise,\n          controllers: {\n            data: dataController,\n            view: viewController,\n            flow: flowController,\n            schema,\n            expression: expressionEvaluator,\n            binding: pathResolver,\n            validation: validationController\n          },\n          fail: flowResultDeferred.reject,\n          flow: userFlow,\n          logger: this.logger\n        }\n      };\n    }\n    async start(payload) {\n      const ref = Symbol(payload?.id ?? \"payload\");\n      const maybeUpdateState = (newState) => {\n        if (this.state.ref !== ref) {\n          this.logger.warn(\n            `Received update for a flow that's not the current one`\n          );\n          return newState;\n        }\n        this.setState(newState);\n        return newState;\n      };\n      this.setState({\n        status: \"not-started\",\n        ref\n      });\n      try {\n        const { state, start } = this.setupFlow(payload);\n        this.setState({\n          ref,\n          ...state\n        });\n        start();\n        const endProps = {\n          ref,\n          status: \"completed\",\n          flow: state.flow,\n          controllers: {\n            data: state.controllers.data.makeReadOnly()\n          }\n        };\n        return maybeUpdateState({\n          ...await state.flowResult,\n          ...endProps\n        });\n      } catch (error) {\n        const errorState = {\n          status: \"error\",\n          ref,\n          flow: payload,\n          error\n        };\n        maybeUpdateState(errorState);\n        throw error;\n      }\n    }\n  };\n  _Player.info = {\n    version: PLAYER_VERSION,\n    commit: COMMIT\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+async-node-plugin@0.0.0/node_modules/@player-ui/async-node-plugin/dist/index.mjs\n  var import_queue_microtask3 = __toESM(require_queue_microtask(), 1);\n  var getMatchValue = (pathA, pathB) => {\n    if (pathA.length > pathB.length) {\n      return 0;\n    }\n    let matchCount = 0;\n    for (let i = 0; i < pathA.length; i++) {\n      if (pathA[i] === pathB[i]) {\n        matchCount++;\n      } else {\n        return 0;\n      }\n    }\n    return matchCount;\n  };\n  var extractNodeFromPath = (node, path) => {\n    if (path === void 0 || path.length === 0) {\n      return node;\n    }\n    if (!(\"children\" in node && node.children)) {\n      return void 0;\n    }\n    let matchResult = 0;\n    let bestMatch;\n    for (const child of node.children) {\n      const matchValue = getMatchValue(child.path, path);\n      if (matchValue > matchResult) {\n        matchResult = matchValue;\n        bestMatch = child;\n      }\n    }\n    if (!bestMatch) {\n      return void 0;\n    }\n    if (matchResult >= path.length) {\n      return bestMatch.value;\n    }\n    return extractNodeFromPath(bestMatch.value, path.slice(matchResult));\n  };\n  var traverseAndReplace = (node, replaceFn) => {\n    if (node.type === NodeType.MultiNode) {\n      let index = 0;\n      while (index < node.values.length) {\n        const child = node.values[index];\n        if (!child) {\n          index++;\n          continue;\n        }\n        const result = replaceFn(child);\n        if (result.type === NodeType.MultiNode) {\n          node.values = [\n            ...node.values.slice(0, index),\n            ...result.values,\n            ...node.values.slice(index + 1)\n          ];\n        } else {\n          node.values[index] = result;\n          index++;\n        }\n      }\n      return node;\n    }\n    return replaceFn(node);\n  };\n  var unwrapAsset = (node) => {\n    if (node.type !== NodeType.Value) {\n      return node;\n    }\n    const child = node.children?.find(\n      (x) => x.path.length === 1 && x.path[0] === \"asset\"\n    );\n    if (!child) {\n      return node;\n    }\n    return child.value;\n  };\n  var requiresAssetWrapper = (node) => {\n    if (node.type === NodeType.Asset) {\n      return true;\n    }\n    if (node.type !== NodeType.Applicability) {\n      return false;\n    }\n    return node.value.type === NodeType.Asset;\n  };\n  var defaultGetNodeId = (node) => {\n    return `async-${node.value.id}`;\n  };\n  var createAsyncTransform = (options) => {\n    const {\n      transformAssetType,\n      wrapperAssetType,\n      getNestedAsset,\n      getAsyncNodeId = defaultGetNodeId,\n      path = [\"values\"],\n      flatten: flatten2 = true,\n      asyncNodePosition = \"append\"\n    } = options;\n    const replaceNode = (node) => {\n      const unwrapped = unwrapAsset(node);\n      if (unwrapped.type !== NodeType.Asset || unwrapped.value.type !== transformAssetType) {\n        return node;\n      }\n      const transformed = asyncTransform2(unwrapped);\n      return extractNodeFromPath(transformed, path) ?? node;\n    };\n    const replacer = (node) => traverseAndReplace(node, replaceNode);\n    const asyncTransform2 = (node) => {\n      const id = getAsyncNodeId(node);\n      const asset = getNestedAsset?.(node);\n      const replaceFunction = flatten2 ? replacer : void 0;\n      const asyncNode = Builder.asyncNode(id, flatten2, replaceFunction);\n      const values = [asyncNode];\n      if (asset) {\n        const otherValues = [];\n        if (requiresAssetWrapper(asset)) {\n          otherValues.push(Builder.assetWrapper(asset));\n        } else if (asset.type === NodeType.MultiNode) {\n          otherValues.push(...asset.values);\n        } else {\n          otherValues.push(asset);\n        }\n        if (asyncNodePosition === \"append\") {\n          values.unshift(...otherValues);\n        } else {\n          values.push(...otherValues);\n        }\n      }\n      const multiNode = Builder.multiNode(...values);\n      const wrapperAsset = Builder.asset({\n        id: wrapperAssetType + \"-\" + id,\n        type: wrapperAssetType\n      });\n      Builder.addChild(wrapperAsset, path, multiNode);\n      return wrapperAsset;\n    };\n    return asyncTransform2;\n  };\n  var AsyncNodePluginSymbol = Symbol.for(\"AsyncNodePlugin\");\n  var _AsyncNodePlugin = class _AsyncNodePlugin2 {\n    constructor(options, asyncHandler) {\n      this.symbol = _AsyncNodePlugin2.Symbol;\n      this.hooks = {\n        onAsyncNode: new AsyncSeriesBailHook(),\n        onAsyncNodeError: new SyncBailHook()\n      };\n      this.name = \"AsyncNode\";\n      if (options?.plugins) {\n        this.plugins = options.plugins;\n        options.plugins.forEach((plugin) => {\n          plugin.applyPlugin(this);\n        });\n      }\n      if (asyncHandler) {\n        this.hooks.onAsyncNode.tap(\n          \"async\",\n          async (node, callback) => {\n            return await asyncHandler(node, callback);\n          }\n        );\n      }\n    }\n    getPlayerInstance() {\n      return this.playerInstance;\n    }\n    apply(player) {\n      this.playerInstance = player;\n      player.hooks.viewController.tap(this.name, (viewController) => {\n        viewController.hooks.view.tap(this.name, (view) => {\n          this.plugins?.forEach((plugin) => {\n            plugin.apply(view);\n          });\n        });\n      });\n    }\n  };\n  _AsyncNodePlugin.Symbol = AsyncNodePluginSymbol;\n  var AsyncNodePlugin = _AsyncNodePlugin;\n  var AsyncNodePluginPlugin = class {\n    constructor() {\n      this.name = \"AsyncNode\";\n    }\n    /**\n     * Parses the node from the result and triggers an asynchronous view update if necessary.\n     * @param node The asynchronous node that might be updated.\n     * @param result The result obtained from resolving the async node. This could be any data structure or value.\n     * @param options Options provided for node resolution, including a potential parseNode function to process the result.\n     * @param view The view instance where the node resides. This can be undefined if the view is not currently active.\n     */\n    parseNodeAndUpdate(node, context, result, options) {\n      let parsedNode = options.parseNode && result ? options.parseNode(result) : void 0;\n      if (parsedNode && node.onValueReceived) {\n        parsedNode = node.onValueReceived(parsedNode);\n      }\n      this.handleAsyncUpdate(node, context, parsedNode);\n    }\n    /**\n     * Updates the node asynchronously based on the result provided.\n     * This method is responsible for handling the update logic of asynchronous nodes.\n     * It checks if the node needs to be updated based on the new result and updates the mapping accordingly.\n     * If an update is necessary, it triggers an asynchronous update on the view.\n     * @param node The asynchronous node that might be updated.\n     * @param newNode The new node to replace the async node.\n     * @param view The view instance where the node resides. This can be undefined if the view is not currently active.\n     */\n    handleAsyncUpdate(node, context, newNode) {\n      const { nodeResolveCache, view } = context;\n      if (nodeResolveCache.get(node.id) !== newNode) {\n        nodeResolveCache.set(node.id, newNode ? newNode : node);\n        view.updateAsync(node.id);\n      }\n    }\n    hasValidMapping(node, context) {\n      const { nodeResolveCache } = context;\n      return nodeResolveCache.has(node.id) && nodeResolveCache.get(node.id) !== node;\n    }\n    /**\n     * Handles the asynchronous API integration for resolving nodes.\n     * This method sets up a hook on the resolver's `beforeResolve` event to process async nodes.\n     * @param resolver The resolver instance to attach the hook to.\n     * @param view\n     */\n    applyResolver(resolver, context) {\n      resolver.hooks.beforeResolve.tap(this.name, (node, options) => {\n        if (!this.isAsync(node)) {\n          return node === null ? node : this.resolveAsyncChildren(node, context);\n        }\n        const resolvedNode = context.nodeResolveCache.get(node.id);\n        if (resolvedNode !== void 0) {\n          if (resolvedNode.asyncNodesResolved === void 0) {\n            resolvedNode.asyncNodesResolved = [];\n          }\n          resolvedNode.asyncNodesResolved.push(node.id);\n          return this.resolveAsyncChildren(resolvedNode, context);\n        }\n        if (context.inProgressNodes.has(node.id)) {\n          return node;\n        }\n        context.inProgressNodes.add(node.id);\n        (0, import_queue_microtask3.default)(() => {\n          this.runAsyncNode(node, context, options).finally();\n        });\n        return node;\n      });\n    }\n    /**\n     * Replaces child async nodes with their resolved content and flattens when necessary. Resolving the children directly helps manage the `parent` reference without needing as much work within the resolver itself.\n     * Handles async node chains as well to make sure all applicable nodes can get flattened.\n     * @param node - The node whose children need to be resolved.\n     * @param context - the async plugin context needed to reach into the cache\n     * @returns The same node but with async node children mapped to their resolved AST.\n     */\n    resolveAsyncChildren(node, context) {\n      const asyncNodesResolved = node.asyncNodesResolved ?? [];\n      node.asyncNodesResolved = asyncNodesResolved;\n      if (node.type === NodeType.MultiNode) {\n        let index = 0;\n        while (index < node.values.length) {\n          const childNode = node.values[index];\n          if (childNode?.type !== NodeType.Async || !this.hasValidMapping(childNode, context)) {\n            index++;\n            continue;\n          }\n          const mappedNode = context.nodeResolveCache.get(childNode.id);\n          asyncNodesResolved.push(childNode.id);\n          if (mappedNode.type === NodeType.MultiNode && childNode.flatten) {\n            mappedNode.values.forEach((v) => v.parent = node);\n            node.values = [\n              ...node.values.slice(0, index),\n              ...mappedNode.values,\n              ...node.values.slice(index + 1)\n            ];\n          } else {\n            node.values[index] = mappedNode;\n            mappedNode.parent = node;\n          }\n        }\n      } else if (\"children\" in node) {\n        node.children?.forEach((c) => {\n          while (c.value.type === NodeType.Async && this.hasValidMapping(c.value, context)) {\n            asyncNodesResolved.push(c.value.id);\n            c.value = context.nodeResolveCache.get(c.value.id);\n            c.value.parent = node;\n          }\n        });\n      }\n      return node;\n    }\n    async runAsyncNode(node, context, options) {\n      try {\n        const result = await this.basePlugin?.hooks.onAsyncNode.call(\n          node,\n          (result2) => {\n            this.parseNodeAndUpdate(node, context, result2, options);\n          }\n        );\n        context.inProgressNodes.delete(node.id);\n        this.parseNodeAndUpdate(node, context, result, options);\n      } catch (e) {\n        const error = e instanceof Error ? e : new Error(String(e));\n        const result = this.basePlugin?.hooks.onAsyncNodeError.call(error, node);\n        if (result === void 0) {\n          const playerState = this.basePlugin?.getPlayerInstance()?.getState();\n          if (playerState?.status === \"in-progress\") {\n            playerState.fail(error);\n          }\n          return;\n        }\n        options.logger?.error(\n          \"Async node handling failed and resolved with a fallback. Error:\",\n          error\n        );\n        context.inProgressNodes.delete(node.id);\n        this.parseNodeAndUpdate(node, context, result, options);\n      }\n    }\n    isAsync(node) {\n      return node?.type === NodeType.Async;\n    }\n    isDeterminedAsync(obj) {\n      return typeof obj === \"object\" && obj !== null && Object.prototype.hasOwnProperty.call(obj, \"async\");\n    }\n    applyParser(parser) {\n      parser.hooks.parseNode.tap(\n        this.name,\n        (obj, nodeType, options, childOptions) => {\n          if (this.isDeterminedAsync(obj)) {\n            const { async, flatten: flatten2, ...rest } = obj;\n            const parsedAsync = parser.parseObject(rest, nodeType, options);\n            const parsedNodeId = getNodeID(parsedAsync);\n            if (parsedAsync === null || !parsedNodeId) {\n              return childOptions ? [] : null;\n            }\n            const asyncAST = parser.createASTNode(\n              {\n                id: parsedNodeId,\n                type: NodeType.Async,\n                value: parsedAsync,\n                flatten: flatten2\n              },\n              obj\n            );\n            if (childOptions) {\n              return asyncAST ? [\n                {\n                  path: [...childOptions.path, childOptions.key],\n                  value: asyncAST\n                }\n              ] : [];\n            }\n            return asyncAST;\n          }\n        }\n      );\n    }\n    apply(view) {\n      const context = {\n        nodeResolveCache: /* @__PURE__ */ new Map(),\n        inProgressNodes: /* @__PURE__ */ new Set(),\n        view\n      };\n      view.hooks.parser.tap(\"async\", this.applyParser.bind(this));\n      view.hooks.resolver.tap(\"async\", (resolver) => {\n        this.applyResolver(resolver, context);\n      });\n    }\n    applyPlugin(asyncNodePlugin) {\n      this.basePlugin = asyncNodePlugin;\n    }\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/chat-message/transform.ts\n  var transform2 = createAsyncTransform({\n    transformAssetType: \"chat-message\",\n    wrapperAssetType: \"collection\",\n    getNestedAsset: (node) => node.children?.[0]?.value\n  });\n  var chatMessageTransform = compose(\n    composeBefore(transform2)\n  );\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+meta-plugin@0.0.0/node_modules/@player-ui/meta-plugin/dist/index.mjs\n  var MetaPlugin = class {\n    constructor(plugins = []) {\n      this.name = \"meta-plugin\";\n      this.plugins = plugins;\n    }\n    apply(player) {\n      this.plugins.forEach((plugin) => player.registerPlugin(plugin));\n    }\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+expression-plugin@0.0.0/node_modules/@player-ui/expression-plugin/dist/index.mjs\n  var ExpressionPlugin = class {\n    constructor(expressionMap) {\n      this.name = \"ExpressionPlugin\";\n      this.expressions = expressionMap;\n    }\n    apply(player) {\n      player.hooks.expressionEvaluator.tap(this.name, (expEvaluator) => {\n        this.expressions.forEach((handler, name) => {\n          expEvaluator.addExpressionFunction(name, handler);\n        });\n      });\n    }\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/plugins/chat-ui-demo-plugin.ts\n  var createContentFromMessage = (message, id) => ({\n    asset: {\n      type: \"chat-message\",\n      id,\n      value: {\n        asset: {\n          type: \"text\",\n          id: `${id}-value`,\n          value: message\n        }\n      }\n    }\n  });\n  var ChatUiDemoPlugin = class {\n    constructor() {\n      this.name = \"chat-ui-demo-plugin\";\n    }\n    apply(player) {\n      const asyncNodePlugin = player.findPlugin(\n        AsyncNodePlugin.Symbol\n      );\n      if (!asyncNodePlugin) {\n        player.logger.warn(\n          `Failed to apply '${this.name}'. Reason: Could not find AsyncNodePlugin.`\n        );\n        return;\n      }\n      let deferredPromises = {};\n      let allPromiseKeys = [];\n      let counter = 0;\n      const sendMessage = (context, message, nodeId) => {\n        if (nodeId && !(nodeId in deferredPromises)) {\n          context.logger?.warn(\n            `'send' expression called with unrecognized id '${nodeId}'`\n          );\n          return;\n        }\n        if (!nodeId && allPromiseKeys.length === 0) {\n          context.logger?.warn(`'send' called with no waiting async nodes`);\n          return;\n        }\n        const keys = nodeId ? [nodeId] : allPromiseKeys;\n        for (const id of keys) {\n          const content = createContentFromMessage(\n            message,\n            `chat-demo-${counter++}`\n          );\n          const resolveFunction = deferredPromises[id];\n          resolveFunction?.(content);\n          delete deferredPromises[id];\n        }\n        if (nodeId) {\n          const index = allPromiseKeys.indexOf(nodeId);\n          allPromiseKeys.splice(index, 1);\n        } else {\n          allPromiseKeys = [];\n        }\n      };\n      asyncNodePlugin.hooks.onAsyncNode.tap(this.name, (node) => {\n        if (node.parent?.parent?.type !== NodeType.Asset && node.parent?.parent?.type !== NodeType.View || !node.parent.parent.value.id.startsWith(\"collection-async-chat-demo\")) {\n          return Promise.resolve(void 0);\n        }\n        return new Promise((res) => {\n          deferredPromises[node.id] = res;\n          allPromiseKeys.push(node.id);\n        });\n      });\n      player.hooks.view.tap(this.name, (_) => {\n        deferredPromises = {};\n        allPromiseKeys = [];\n        counter = 0;\n      });\n      const expressionPlugin = new ExpressionPlugin(\n        /* @__PURE__ */ new Map([[\"send\", sendMessage]])\n      );\n      player.registerPlugin(expressionPlugin);\n    }\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/plugins/reference-assets-transform-plugin.ts\n  var ReferenceAssetsTransformPlugin = class {\n    constructor() {\n      this.name = \"reference-assets-transforms\";\n    }\n    apply(player) {\n      player.registerPlugin(\n        new AssetTransformPlugin([\n          [{ type: \"action\" }, actionTransform],\n          [{ type: \"input\" }, inputTransform],\n          [{ type: \"image\" }, imageTransform],\n          [{ type: \"info\" }, infoTransform],\n          [{ type: \"choice\" }, choiceTransform],\n          [{ type: \"chat-message\" }, chatMessageTransform]\n        ])\n      );\n    }\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/plugin.ts\n  var ReferenceAssetsPlugin = class {\n    constructor() {\n      this.name = \"reference-assets-plugin\";\n      this.metaPlugin = new MetaPlugin([\n        new AsyncNodePlugin({\n          plugins: [new AsyncNodePluginPlugin()]\n        }),\n        new ReferenceAssetsTransformPlugin(),\n        new ChatUiDemoPlugin()\n      ]);\n    }\n    apply(player) {\n      player.registerPlugin(this.metaPlugin);\n    }\n  };\n  return __toCommonJS(src_exports);\n})();\n/*! Bundled license information:\n\ntimm/lib/timm.js:\n  (*!\n   * Timm\n   *\n   * Immutability helpers with fast reads and acceptable writes.\n   *\n   * @copyright Guillermo Grau Panea 2016\n   * @license MIT\n   *)\n\nqueue-microtask/index.js:\n  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n*/\n","export default function dlv(obj, key, def, p, undef) {\n\tkey = key.split ? key.split('.') : key;\n\tfor (p = 0; p < key.length; p++) {\n\t\tobj = obj ? obj[key[p]] : undef;\n\t}\n\treturn obj === undef ? def : obj;\n}\n","import dlv from \"dlv\";\n\n/** A function that checks overlapping properties against a reference value */\nexport type Matcher = ((searchObj: object) => boolean) & {\n  /** The count represents the specificity of this matcher */\n  count: number;\n};\n\n/** Traverse an object and collect any key/value pairs including nested keys */\nfunction traverseObj(\n  object: Record<any, any>,\n  path: string[] = [],\n  pairs: Map<string[], any> = new Map(),\n): Map<string[], any> {\n  for (const key of Object.keys(object)) {\n    const val: any = object[key];\n    const nestedPath = [...path, key];\n\n    if (typeof val === \"object\") {\n      traverseObj(val, nestedPath, pairs);\n    } else {\n      pairs.set(nestedPath, val);\n    }\n  }\n\n  return pairs;\n}\n\n/**\n * Given a partial object, create a matcher function that checks if another object matches the specified properties\n * @param partialObj The partial object to match against\n * @returns A matcher function that checks if an object matches the partial object\n */\nexport function createObjectMatcher(partialObj: object): Matcher {\n  // Convert the partial object into a list of [key, value] pairs;\n  const pairs = traverseObj(partialObj);\n\n  /** Generate a function to match against all of the properties we care about */\n  const matchFunction = (searchObj: object) => {\n    for (const entry of Array.from(pairs)) {\n      const [path, value] = entry;\n\n      if (dlv(searchObj, path) !== value) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  // Keep track of the specificity of the comparator\n  matchFunction.count = pairs.size;\n\n  return matchFunction;\n}\n","import SortedArray from \"sorted-array\";\nimport type { Matcher } from \"./deep-partial-matcher\";\nimport { createObjectMatcher } from \"./deep-partial-matcher\";\n\nexport { createObjectMatcher } from \"./deep-partial-matcher\";\n\n/** create a matcher function that matches exactly */\nfunction createBasicMatcher(seed: any): Matcher {\n  /** a simple matcher function that only matches itself */\n  const matcher = (match: any) => seed === match;\n  matcher.count = 1;\n\n  return matcher;\n}\n\ninterface RegistryIndex<V> {\n  /** The original object we wanted to match on  */\n  key: object;\n\n  /** The value to return */\n  value: V;\n\n  /** The matcher function for this entry */\n  matcher: Matcher;\n}\n\n/** create an empty sorted array using the matcher count */\nconst createSortedArray = <V>() =>\n  new SortedArray<RegistryIndex<V>>([], (c) => c.matcher.count);\n\n/**\n * A partial match registry is a map that uses an object to \"match\" against keys.\n * More specific matches take precedence over less specific ones.\n */\nexport class Registry<V> {\n  private store = createSortedArray<V>();\n\n  constructor(initialSet?: Array<[any, V]>) {\n    initialSet?.forEach(([match, value]) => {\n      this.set(match, value);\n    });\n  }\n\n  /** Add match -> value mapping to the registry */\n  set(match: any, value: V) {\n    const matcher =\n      typeof match === \"object\"\n        ? createObjectMatcher(match)\n        : createBasicMatcher(match);\n\n    this.store.insert({\n      key: match,\n      value,\n      matcher,\n    });\n  }\n\n  /** Fetch the best match in the registry */\n  get(query: any): V | undefined {\n    for (const entry of this.store.array) {\n      if (entry.matcher(query)) {\n        return entry.value;\n      }\n    }\n  }\n\n  /** Loop over all entries and run callback */\n  forEach(callbackfn: (value: RegistryIndex<V>) => void): void {\n    for (const entry of this.store.array) {\n      callbackfn(entry);\n    }\n  }\n\n  /** Reset the items in the registry */\n  clear() {\n    this.store = createSortedArray<V>();\n  }\n\n  /** Check if the registry is empty*/\n  isRegistryEmpty() {\n    return this.store.array.length === 0;\n  }\n}\n","import type {\n  Resolve,\n  Store,\n  BeforeTransformFunction,\n  TransformFunction,\n  TransformFunctions,\n} from \"@player-ui/player\";\n\nfunction composeTransforms(\n  ...args: TransformFunction<any>[]\n): TransformFunction<any>;\n\nfunction composeTransforms(\n  ...args: BeforeTransformFunction<any>[]\n): BeforeTransformFunction<any>;\n\n/**\n * More closely resembles the `compose` function you may have used. Performs\n * right-to-left function evaluation, but leveraging the common signature for\n * Transform Functions. The `options` and `store` is unchanging for each\n * transform since only `value` is returned, allowing them to safely be passed\n * into each transform.\n */\nfunction composeTransforms(\n  ...args: TransformFunction<any>[] | BeforeTransformFunction<any>[]\n): TransformFunction<any> | BeforeTransformFunction<any> {\n  const [fn, ...fns] = args.reverse();\n\n  return (asset: any, options: Resolve.NodeResolveOptions, store: Store) => {\n    const value = fn(asset, options, store);\n\n    if (!fns.length) {\n      return value;\n    }\n\n    return fns.reduce((prevValue, current) => {\n      return current(prevValue, options, store);\n    }, value);\n  };\n}\n\n/**\n * Helper function to make it easier to create transforms that need to be ran in\n * the `beforeResolve` hook. Just like `compose`, functions are evaluated from\n * right-to-left.\n */\nexport function composeBefore(\n  ...args: BeforeTransformFunction<any>[]\n): TransformFunctions {\n  return {\n    beforeResolve: composeTransforms(...args),\n  };\n}\n\n/**\n * Performs right-to-left function evaluation of each transform function. Unlike\n * other compose functions, this does not require unary arguments for all but the\n * last function. The value returned from each function will be used as the value\n * for the next function.\n */\nexport function compose(\n  ...args: Array<TransformFunction<any> | TransformFunctions>\n): TransformFunctions {\n  const beforeResolveFns: BeforeTransformFunction<any>[] = [];\n  const resolveFns: TransformFunction<any>[] = [];\n\n  for (const arg of args) {\n    if (typeof arg === \"function\") {\n      resolveFns.push(arg);\n    } else {\n      if (arg?.resolve) {\n        resolveFns.push(arg.resolve);\n      }\n\n      if (arg?.beforeResolve) {\n        beforeResolveFns.push(arg.beforeResolve);\n      }\n    }\n  }\n\n  return {\n    beforeResolve: beforeResolveFns.length\n      ? composeTransforms(...beforeResolveFns)\n      : undefined,\n    resolve: resolveFns.length ? composeTransforms(...resolveFns) : undefined,\n  };\n}\n","import type {\n  Player,\n  PlayerPlugin,\n  TransformRegistry,\n  TransformFunction,\n  TransformFunctions,\n} from \"@player-ui/player\";\nimport { Registry } from \"@player-ui/partial-match-registry\";\nimport { compose } from \"./utils\";\n\nexport * from \"./utils\";\nexport * from \"./propertiesToSkip\";\n\nexport type TransformType = TransformFunction<any> | TransformFunctions;\nexport type TransformRegistryEntries = Array<[any, TransformType]>;\nexport type AssetTransformInit =\n  | Registry<TransformType>\n  | TransformRegistryEntries;\n\n/**\n * Normalize asset transform values so that they are all objects that contains\n * the resolve & beforeResolve functions.\n */\nfunction maybeCompose(maybeFn: any): TransformFunctions {\n  if (typeof maybeFn === \"object\") {\n    return maybeFn;\n  }\n\n  return compose(maybeFn);\n}\n\n/**\n * Standardize each variation of Asset Registry input into the same transform\n * registry shape.\n */\nfunction cleanupTransformRegistry(\n  maybeRegistry: AssetTransformInit,\n): TransformRegistry {\n  if (Array.isArray(maybeRegistry)) {\n    const wrappedTransforms = maybeRegistry.map(([key, value]) => {\n      return [key, maybeCompose(value)] as [any, TransformFunctions];\n    });\n\n    return new Registry(wrappedTransforms);\n  }\n\n  const registry = new Registry<TransformFunctions>();\n\n  maybeRegistry.forEach(({ key, value }) => {\n    registry.set(key, maybeCompose(value));\n  });\n\n  return registry;\n}\n\n/**\n * A plugin to register custom transforms on certain asset types\n * This allows users to embed stateful data into transforms.\n */\nexport class AssetTransformPlugin implements PlayerPlugin {\n  name = \"asset-transform\";\n  public readonly registry: TransformRegistry;\n\n  constructor(transforms: AssetTransformInit) {\n    this.registry = cleanupTransformRegistry(transforms);\n  }\n\n  apply(player: Player) {\n    player.hooks.viewController.tap(this.name, (vc) => {\n      this.registry.forEach(({ key, value }) =>\n        vc.transformRegistry.set(key, maybeCompose(value)),\n      );\n    });\n  }\n}\n","import type {\n  Asset,\n  TransformFunction,\n  BeforeTransformFunction,\n} from \"@player-ui/player\";\nimport { compose, composeBefore } from \"@player-ui/asset-transform-plugin\";\nimport type { ActionAsset, TransformedAction } from \"./types\";\n\n/**\n * Function to find prev button\n */\nexport function isBackAction(action: ActionAsset): boolean {\n  return action.value === \"Prev\";\n}\n\n/**\n * Attaches the methods to execute an action to an action\n */\nconst transform: TransformFunction<ActionAsset, TransformedAction> = (\n  action,\n  options,\n) => {\n  return {\n    ...action,\n    run() {\n      if (action.exp) {\n        options.evaluate(action.exp);\n      }\n\n      if (action.value) {\n        const skipValidation = action.metaData?.skipValidation;\n        options.transition?.(action.value, { force: skipValidation });\n      }\n    },\n  };\n};\n\n/**\n * De couples back button from the back icon\n */\nconst backIconTransform: TransformFunction<ActionAsset, ActionAsset> = (\n  action,\n) => {\n  /** For previous versions of player, the back button would already have the back icon.\n   *  This ensures that the old functionality does not break and back button is still visible when they update the player.\n   */\n  if (isBackAction(action) && action?.metaData?.role === undefined) {\n    return {\n      ...action,\n      metaData: {\n        ...action?.metaData,\n        role: \"back\",\n      },\n    };\n  }\n\n  return action;\n};\n\n/**\n * Appends `exp` to the plugins.stringResolver.propertiesToSkip array or creates it if it doesn't exist\n *\n * @param asset - Asset to apply the transform to\n */\nexport const expPropTransform: BeforeTransformFunction<Asset> = (asset) => {\n  const skipArray = asset.plugins?.stringResolver?.propertiesToSkip;\n\n  if (skipArray && skipArray.indexOf(\"exp\") > 1) {\n    return asset;\n  }\n\n  return {\n    ...asset,\n    plugins: {\n      ...asset.plugins,\n      stringResolver: {\n        ...asset?.plugins?.stringResolver,\n        propertiesToSkip: [\n          ...(asset.plugins?.stringResolver?.propertiesToSkip ?? []),\n          \"exp\",\n        ],\n      },\n    },\n  };\n};\n\nexport const actionTransform = compose(\n  transform,\n  backIconTransform,\n  composeBefore(expPropTransform),\n);\n","/**\n * Checks if `value` is equal to `check` if `check` is a string or in `check` if check is an Array\n *\n * @param value - the value being searched for\n * @param check - the values to check against\n * @returns `boolean`\n */\nexport function equalToOrIn(value: string, check: string | Array<string>) {\n  if (Array.isArray(check)) {\n    return check.includes(value);\n  }\n\n  return check === value;\n}\n","import { equalToOrIn } from \"./utils\";\n\nexport type Interceptor<Args extends any[], ReturnType, ContextType> = {\n  /** An optional name for the interceptor */\n  name?: string;\n  /** Callback for each loop when used by the hook */\n  loop?: (...args: Args) => void;\n  /** Callback when an error occurs during the hook's call */\n  error?: (err: Error) => void;\n  /** Callback when a result is found for a hook's invocation */\n  result?: (\n    r: ReturnType extends Promise<infer AwaitedValue>\n      ? AwaitedValue\n      : ReturnType\n  ) => void;\n  /** Callback when a hook's call is complete */\n  done?: () => void;\n  /** Callback when a hook is tapped */\n  tap?: (tap: Tap<Args, ReturnType, ContextType>) => void;\n} & (\n  | {\n      /** If context should be omitted from the 'call'. This is the default */\n      context?: false;\n      /** Callback when the hook is tapped without context */\n      call?: (...args: Args) => void;\n    }\n  | {\n      /** If context should be included in the 'call' */\n      context: true;\n      /** Callback when the hook is tapped with context */\n      call?: (context: ContextType, ...args: Args) => void;\n    }\n);\n\nexport type Tap<Args extends any[], ReturnType, ContextType = unknown> = {\n  key: symbol;\n  name: string;\n  before?: string | Array<string>;\n} & (\n  | {\n      context: false;\n      callback: (...args: Args) => ReturnType;\n    }\n  | {\n      context: true;\n      callback: (context: ContextType, ...args: Args) => ReturnType;\n    }\n);\n\ntype BasicTap<Args extends any[], ReturnType, ContextType> = (\n  name: string,\n  callback: (...args: Args) => ReturnType,\n  before?: string | Array<string>\n) => Tap<Args, ReturnType, ContextType>;\n\ntype TapWithContext<Args extends any[], ReturnType, ContextType> =\n  | ((\n      options: {\n        name: string;\n        context?: false;\n        before?: string | Array<string>;\n      },\n      callback: (...args: Args) => ReturnType\n    ) => Tap<Args, ReturnType>)\n  | ((\n      options: {\n        name: string;\n        context: true;\n        before?: string | Array<string>;\n      },\n      callback: (context: ContextType, ...args: Args) => ReturnType\n    ) => Tap<Args, ReturnType>);\n\ninterface SyncBaseHookType<Args extends any[], ReturnType, ContextType> {\n  tap:\n    | BasicTap<Args, ReturnType, ContextType>\n    | TapWithContext<Args, ReturnType, ContextType>;\n  call(...args: Args): void;\n  untap(key: Tap<Args, ReturnType>): void;\n  isUsed(): boolean;\n  intercept(int: Interceptor<Args, ReturnType, ContextType>): void;\n}\n\nfunction callTap<Args extends any[], ReturnType, ContextType>(\n  tap: Tap<Args, ReturnType, ContextType>,\n  args: Args,\n  ctx: ContextType\n) {\n  if (tap.context) {\n    return tap.callback(ctx, ...args);\n  }\n\n  return tap.callback(...args);\n}\n\n/** A manager for all intercepts inside of a tap */\nclass InterceptionManager<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> {\n  protected interceptions: Array<Interceptor<Args, ReturnType, ContextType>>;\n  private interceptionKeySet: Set<\n    keyof Interceptor<Args, ReturnType, ContextType>\n  >;\n\n  constructor() {\n    this.interceptions = [];\n    this.interceptionKeySet = new Set();\n  }\n\n  isUsed() {\n    return this.interceptions.length > 0;\n  }\n\n  intercept(int: Interceptor<Args, ReturnType, ContextType>): void {\n    this.interceptions.push(int);\n    Object.keys(int).forEach((s) => {\n      this.interceptionKeySet.add(s as any);\n    });\n  }\n\n  tap(tap: Tap<Args, ReturnType, ContextType>): void {\n    if (this.interceptionKeySet.has(\"tap\")) {\n      this.interceptions.forEach((i) => {\n        i.tap?.(tap);\n      });\n    }\n  }\n\n  call(ctx: ContextType, ...args: Args): void {\n    if (this.interceptionKeySet.has(\"call\")) {\n      this.interceptions.forEach((i) => {\n        if (i.context) {\n          i.call?.(ctx, ...args);\n        } else {\n          i.call?.(...args);\n        }\n      });\n    }\n  }\n\n  loop(...args: Args): void {\n    if (this.interceptionKeySet.has(\"loop\")) {\n      this.interceptions.forEach((i) => {\n        i.loop?.(...args);\n      });\n    }\n  }\n\n  error(err: unknown): void {\n    if (this.interceptionKeySet.has(\"error\")) {\n      if (err instanceof Error) {\n        const asError: Error = err;\n        this.interceptions.forEach((i) => {\n          i.error?.(asError);\n        });\n      }\n    }\n  }\n\n  result(\n    r: ReturnType extends Promise<infer AwaitedValue>\n      ? AwaitedValue\n      : ReturnType\n  ): void {\n    if (this.interceptionKeySet.has(\"result\")) {\n      this.interceptions.forEach((i) => {\n        i.result?.(r);\n      });\n    }\n  }\n\n  done(): void {\n    if (this.interceptionKeySet.has(\"done\")) {\n      this.interceptions.forEach((i) => {\n        i.done?.();\n      });\n    }\n  }\n}\n\nabstract class Hook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> implements SyncBaseHookType<Args, ReturnType, ContextType>\n{\n  protected taps: Array<Tap<Args, ReturnType, ContextType>>;\n  protected interceptions: InterceptionManager<Args, ReturnType, ContextType>;\n\n  constructor() {\n    this.taps = [];\n    this.interceptions = new InterceptionManager<\n      Args,\n      ReturnType,\n      ContextType\n    >();\n  }\n\n  public tap(\n    options: { name: string; context?: false; before?: string | Array<string> },\n    callback: (...args: Args) => ReturnType\n  ): Tap<Args, ReturnType, ContextType>;\n\n  public tap(\n    options: { name: string; context: true; before?: string | Array<string> },\n    callback: (ctx: ContextType, ...args: Args) => ReturnType\n  ): Tap<Args, ReturnType, ContextType>;\n\n  public tap(\n    name: string,\n    callback: (...args: Args) => ReturnType\n  ): Tap<Args, ReturnType, ContextType>;\n\n  public tap(options: any, callback: any): Tap<Args, ReturnType, ContextType> {\n    const resolvedOptions =\n      typeof options === \"string\"\n        ? {\n            name: options,\n            context: false,\n          }\n        : {\n            context: false,\n            ...options,\n          };\n\n    const key = Symbol(resolvedOptions.name);\n    const tap: Tap<Args, ReturnType, ContextType> = {\n      key,\n      ...resolvedOptions,\n      callback,\n    };\n\n    if (tap.before) {\n      let insertionIndex = this.taps.length;\n      const beforeSet = new Set(\n        Array.isArray(tap.before) ? tap.before : [tap.before]\n      );\n      for (\n        insertionIndex;\n        insertionIndex > 0 && beforeSet.size > 0;\n        insertionIndex--\n      ) {\n        const t = this.taps[insertionIndex - 1];\n        if (beforeSet.has(t.name)) {\n          beforeSet.delete(t.name);\n        }\n\n        if (t.before && equalToOrIn(tap.name, t.before)) {\n          break;\n        }\n      }\n\n      this.taps.splice(insertionIndex, 0, tap);\n    } else {\n      this.taps.push(tap);\n    }\n\n    this.interceptions.tap(tap);\n\n    return tap;\n  }\n\n  abstract call(...args: Args): ReturnType;\n\n  public untap(tap: Tap<Args, ReturnType, ContextType>) {\n    this.taps = this.taps.filter((t) => t.key !== tap.key);\n  }\n\n  public isUsed() {\n    return this.taps.length > 0 || this.interceptions.isUsed();\n  }\n\n  public intercept(int: Interceptor<Args, ReturnType, ContextType>): void {\n    this.interceptions.intercept(int);\n  }\n}\n\nexport class SyncHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, void, ContextType> {\n  public call(...args: Args) {\n    if (!this.isUsed()) {\n      return;\n    }\n\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      this.taps.forEach((t) => {\n        callTap(t, args, ctx);\n      });\n    } catch (err: unknown) {\n      this.interceptions.error(err);\n\n      throw err;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class SyncBailHook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> extends Hook<Args, ReturnType | undefined | null, ContextType> {\n  public call(...args: Args): ReturnType | undefined | null {\n    if (!this.isUsed()) {\n      return;\n    }\n\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n      const rtn = callTap(this.taps[tapIndex], args, ctx);\n      if (rtn !== undefined) {\n        this.interceptions.result(rtn as any);\n        return rtn;\n      }\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class SyncWaterfallHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Args[0], ContextType> {\n  public call(...args: Args): Args[0] {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    // eslint-disable-next-line prefer-const\n    let [rtn, ...rest] = args;\n\n    for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n      const tapValue = callTap(this.taps[tapIndex], [rtn, ...rest] as any, ctx);\n      if (tapValue !== undefined) {\n        rtn = tapValue;\n      }\n    }\n\n    this.interceptions.result(rtn);\n\n    return rtn;\n  }\n}\n\nexport class SyncLoopHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, void, ContextType> {\n  public call(...args: Args) {\n    let finished = false;\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      while (finished !== true) {\n        finished = true;\n        this.interceptions.loop(...args);\n        for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n          const rtn = callTap(this.taps[tapIndex], args, ctx);\n\n          if (rtn !== undefined) {\n            finished = false;\n            break;\n          }\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncParallelHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<void>, ContextType> {\n  public async call(...args: Args): Promise<void> {\n    const ctx: ContextType = {} as any;\n    this.interceptions.call(ctx, ...args);\n\n    await Promise.allSettled(this.taps.map((tap) => callTap(tap, args, ctx)));\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncParallelBailHook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<ReturnType>, ContextType> {\n  public async call(...args: Args): Promise<ReturnType> {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      const rtn = await Promise.race(\n        this.taps.map((tap) => callTap(tap, args, ctx))\n      );\n\n      this.interceptions.result(rtn as any);\n      return rtn;\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n  }\n}\n\nexport class AsyncSeriesHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<void>, ContextType> {\n  public async call(...args: Args): Promise<void> {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        await callTap(this.taps[tapIndex], args, ctx);\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncSeriesBailHook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<ReturnType | undefined | null>, ContextType> {\n  public async call(...args: Args): Promise<ReturnType | undefined | null> {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        const rtn = await callTap(this.taps[tapIndex], args, ctx);\n        if (rtn !== undefined) {\n          this.interceptions.result(rtn);\n          return rtn;\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncSeriesWaterfallHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<Args[0]>, ContextType> {\n  public async call(...args: Args): Promise<Args[0]> {\n    // eslint-disable-next-line prefer-const\n    let [rtn, ...rest] = args;\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        const tapValue = await callTap(\n          this.taps[tapIndex],\n          [rtn, ...rest] as any,\n          ctx\n        );\n        if (tapValue !== undefined) {\n          rtn = tapValue;\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.result(rtn);\n\n    return rtn;\n  }\n}\n\nexport class AsyncSeriesLoopHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<void>, ContextType> {\n  public async call(...args: Args): Promise<void> {\n    let finished = false;\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      while (finished !== true) {\n        finished = true;\n        this.interceptions.loop(...args);\n        for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n          const rtn = await callTap(this.taps[tapIndex], args, ctx);\n\n          if (rtn !== undefined) {\n            finished = false;\n            break;\n          }\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n","var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import type { BindingLike, BindingInstance } from \"./binding\";\n\n/** Check if the parameter representing a binding is already of the Binding class */\nexport function isBinding(binding: BindingLike): binding is BindingInstance {\n  return !(typeof binding === \"string\" || Array.isArray(binding));\n}\n\n/** Convert the string to an int if you can, otherwise just return the original string */\nexport function maybeConvertToNum(i: string): string | number {\n  const asInt = parseInt(i, 10);\n\n  if (isNaN(asInt)) {\n    return i;\n  }\n\n  return asInt;\n}\n\n/**\n * utility to convert binding into binding segments.\n */\nexport function getBindingSegments(\n  binding: BindingLike,\n): Array<string | number> {\n  if (Array.isArray(binding)) {\n    return binding;\n  }\n\n  if (typeof binding === \"string\") {\n    return binding.split(\".\");\n  }\n\n  return binding.asArray();\n}\n\n/** Like _.findIndex, but ignores types */\nexport function findInArray<T extends Record<string | number, object>>(\n  array: Array<T>,\n  key: string | number,\n  value: T,\n): number | undefined {\n  return array.findIndex((obj) => {\n    if (obj && typeof obj === \"object\") {\n      // Intentional double-equals because we want '4' to be coerced to 4\n      return obj[key] == value;\n    }\n\n    return false;\n  });\n}\n","import { SyncHook } from \"tapable-ts\";\nimport type { BindingLike, BindingFactory } from \"../binding\";\nimport { BindingInstance, isBinding } from \"../binding\";\nimport { NOOP_MODEL } from \"./noop-model\";\n\nexport const ROOT_BINDING = new BindingInstance([]);\nexport type BatchSetTransaction = [BindingInstance, any][];\n\nexport type Updates = Array<{\n  /** The updated binding */\n  binding: BindingInstance;\n\n  /** The old value */\n  oldValue: any;\n\n  /** The new value */\n  newValue: any;\n\n  /** Force the Update to be included even if no data changed */\n  force?: boolean;\n}>;\n\n/** Options to use when getting or setting data */\nexport interface DataModelOptions {\n  /**\n   * The data (either to set or get) should represent a formatted value\n   * For setting data, the data will be de-formatted before continuing in the pipeline\n   * For getting data, the data will be formatted before returning\n   */\n  formatted?: boolean;\n\n  /**\n   * By default, fetching data will ignore any invalid data.\n   * You can choose to grab the queued invalid data if you'd like\n   * This is usually the case for user-inputs\n   */\n  includeInvalid?: boolean;\n\n  /**\n   * A flag to set to ignore any default value in the schema, and just use the raw value\n   */\n  ignoreDefaultValue?: boolean;\n\n  /**\n   * A flag to indicate that this update should happen silently\n   */\n  silent?: boolean;\n\n  /** Other context associated with this request */\n  context?: {\n    /** The data model to use when getting other data from the context of this request */\n    model: DataModelWithParser;\n  };\n}\n\nexport interface DataModelWithParser<Options = DataModelOptions> {\n  get(binding: BindingLike, options?: Options): any;\n  set(transaction: [BindingLike, any][], options?: Options): Updates;\n  delete(binding: BindingLike, options?: Options): void;\n}\n\nexport interface DataModelImpl<Options = DataModelOptions> {\n  get(binding: BindingInstance, options?: Options): any;\n  set(transaction: BatchSetTransaction, options?: Options): Updates;\n  delete(binding: BindingInstance, options?: Options): void;\n}\n\nexport interface DataModelMiddleware {\n  /** The name of the middleware */\n  name?: string;\n\n  set(\n    transaction: BatchSetTransaction,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ): Updates;\n\n  get(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ): any;\n\n  delete?(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ): void;\n\n  reset?(): void;\n}\n\n/** Wrap the inputs of the DataModel with calls to parse raw binding inputs */\nexport function withParser<Options = unknown>(\n  model: DataModelImpl<Options>,\n  parseBinding: BindingFactory,\n): DataModelWithParser<Options> {\n  /** Parse something into a binding if it requires it */\n  function maybeParse(\n    binding: BindingLike,\n    readOnly: boolean,\n  ): BindingInstance {\n    const parsed = isBinding(binding)\n      ? binding\n      : parseBinding(binding, {\n          get: model.get,\n          set: model.set,\n          readOnly,\n        });\n\n    if (!parsed) {\n      throw new Error(\"Unable to parse binding\");\n    }\n\n    return parsed;\n  }\n\n  return {\n    get(binding, options?: Options) {\n      return model.get(maybeParse(binding, true), options);\n    },\n    set(transaction, options?: Options) {\n      return model.set(\n        transaction.map(([key, val]) => [maybeParse(key, false), val]),\n        options,\n      );\n    },\n    delete(binding, options?: Options) {\n      return model.delete(maybeParse(binding, false), options);\n    },\n  };\n}\n\n/** Wrap a middleware instance in a DataModel compliant API */\nexport function toModel(\n  middleware: DataModelMiddleware,\n  defaultOptions?: DataModelOptions,\n  next?: DataModelImpl,\n): DataModelImpl {\n  if (!next) {\n    return middleware as DataModelImpl;\n  }\n\n  return {\n    get: (binding: BindingInstance, options?: DataModelOptions) => {\n      const resolvedOptions = options ?? defaultOptions;\n\n      if (middleware.get) {\n        return middleware.get(binding, resolvedOptions, next);\n      }\n\n      return next?.get(binding, resolvedOptions);\n    },\n    set: (transaction: BatchSetTransaction, options?: DataModelOptions) => {\n      const resolvedOptions = options ?? defaultOptions;\n\n      if (middleware.set) {\n        return middleware.set(transaction, resolvedOptions, next);\n      }\n\n      return next?.set(transaction, resolvedOptions);\n    },\n    delete: (binding: BindingInstance, options?: DataModelOptions) => {\n      const resolvedOptions = options ?? defaultOptions;\n\n      if (middleware.delete) {\n        return middleware.delete(binding, resolvedOptions, next);\n      }\n\n      return next?.delete(binding, resolvedOptions);\n    },\n  };\n}\n\nexport type DataPipeline = Array<DataModelMiddleware | DataModelImpl>;\n\n/**\n * Given a set of steps in a pipeline, create the effective data-model\n */\nexport function constructModelForPipeline(\n  pipeline: DataPipeline,\n): DataModelImpl {\n  if (pipeline.length === 0) {\n    return NOOP_MODEL;\n  }\n\n  if (pipeline.length === 1) {\n    return toModel(pipeline[0]);\n  }\n\n  /** Default and propagate the options into the nested calls */\n  function createModelWithOptions(options?: DataModelOptions) {\n    const model: DataModelImpl =\n      pipeline.reduce<DataModelImpl | undefined>(\n        (nextModel, middleware) => toModel(middleware, options, nextModel),\n        undefined,\n      ) ?? NOOP_MODEL;\n\n    return model;\n  }\n\n  return {\n    get: (binding: BindingInstance, options?: DataModelOptions) => {\n      return createModelWithOptions(options)?.get(binding, options);\n    },\n    set: (transaction, options) => {\n      return createModelWithOptions(options)?.set(transaction, options);\n    },\n    delete: (binding, options) => {\n      return createModelWithOptions(options)?.delete(binding, options);\n    },\n  };\n}\n\n/** A DataModel that manages middleware data handlers  */\nexport class PipelinedDataModel implements DataModelImpl {\n  private pipeline: DataPipeline;\n  private effectiveDataModel: DataModelImpl;\n\n  public readonly hooks = {\n    onSet: new SyncHook<[BatchSetTransaction]>(),\n  };\n\n  constructor(pipeline: DataPipeline = []) {\n    this.pipeline = pipeline;\n    this.effectiveDataModel = constructModelForPipeline(this.pipeline);\n  }\n\n  public setMiddleware(handlers: DataPipeline) {\n    this.pipeline = handlers;\n    this.effectiveDataModel = constructModelForPipeline(handlers);\n  }\n\n  public addMiddleware(handler: DataModelMiddleware) {\n    this.pipeline = [...this.pipeline, handler];\n    this.effectiveDataModel = constructModelForPipeline(this.pipeline);\n  }\n\n  public reset(model = {}) {\n    this.pipeline.forEach((middleware) => {\n      if (\"reset\" in middleware) {\n        middleware.reset?.();\n      }\n    });\n\n    this.set([[ROOT_BINDING, model]]);\n  }\n\n  public set(\n    transaction: BatchSetTransaction,\n    options?: DataModelOptions,\n  ): Updates {\n    const appliedTransaction = this.effectiveDataModel.set(\n      transaction,\n      options,\n    );\n    this.hooks.onSet.call(transaction);\n    return appliedTransaction;\n  }\n\n  public get(binding: BindingInstance, options?: DataModelOptions): any {\n    return this.effectiveDataModel.get(binding, options);\n  }\n\n  public delete(binding: BindingInstance, options?: DataModelOptions): void {\n    return this.effectiveDataModel.delete(binding, options);\n  }\n}\n","import type { DataModelWithParser } from \"../data\";\nimport type { Logger } from \"../logger\";\n\nexport type ExpressionObjectType = {\n  /** The expression to eval */\n  value: BasicExpressionTypes;\n};\n\nexport type ExpressionLiteralType =\n  | string\n  | number\n  | boolean\n  | undefined\n  | null;\n\nexport type BasicExpressionTypes =\n  | ExpressionLiteralType\n  | ExpressionObjectType\n  | Array<ExpressionLiteralType | ExpressionObjectType>;\n\nexport type ExpressionType = BasicExpressionTypes | ExpressionNode;\n\nexport interface OperatorProcessingOptions {\n  /**\n   * When set to a falsy value, the arguments passed to the handler will be raw AST Nodes\n   * This enables lazy evaluation of arguments\n   */\n  resolveParams: boolean;\n\n  /**\n   * Whether the expression should be allowed to be evaluated asynchronously\n   */\n  async?: boolean;\n}\n\nexport type BinaryOperatorBasic = (\n  left: any,\n  right: any,\n  async: boolean,\n) => unknown;\nexport type BinaryOperatorAdvanced = OperatorProcessingOptions &\n  ((ctx: ExpressionContext, left: any, right: any, async: boolean) => unknown);\n\nexport type BinaryOperator = BinaryOperatorAdvanced | BinaryOperatorBasic;\n\nexport type UnaryOperator =\n  | ((arg: any, async: boolean) => unknown)\n  | (((ctx: ExpressionContext, arg: any, async: boolean) => unknown) &\n      OperatorProcessingOptions);\n\nexport interface ExpressionContext {\n  /** A means of executing an expression */\n  evaluate: (expr: ExpressionType) => unknown;\n\n  /** The data model that expression handlers can use when fetching data */\n  model: DataModelWithParser;\n\n  /** A logger to use */\n  logger?: Logger;\n}\n\nexport type ExpressionHandler<\n  T extends readonly unknown[] = unknown[],\n  R = void,\n> = ((context: ExpressionContext, ...args: T) => R) &\n  Partial<OperatorProcessingOptions>;\n\nexport const ExpNodeOpaqueIdentifier: unique symbol =\n  Symbol(\"Expression Node ID\");\n\n/** Checks if the input is an already processed Expression node */\nexport function isExpressionNode(x: any): x is ExpressionNode {\n  return (\n    typeof x === \"object\" &&\n    x !== null &&\n    !Array.isArray(x) &&\n    x.__id === ExpNodeOpaqueIdentifier\n  );\n}\n\nexport interface NodePosition {\n  /** The character location */\n  character: number;\n}\n\nexport interface NodeLocation {\n  // We only care about the character offset, not the line/column for now\n  // But making these objects allows us to add more (like line number) later\n\n  /** The start of the node */\n  start: NodePosition;\n\n  /** The end of the node */\n  end: NodePosition;\n}\n\nexport interface BaseNode<T> {\n  /** The thing to discriminate the AST type on */\n  type: T;\n\n  /** How to tell this apart from other objects */\n  __id: typeof ExpNodeOpaqueIdentifier;\n\n  /** The location of the node in the source expression string */\n  location?: NodeLocation;\n\n  /**\n   * The error that occurred while parsing this node\n   * This is only set if the parsing mode is set to non-strict\n   */\n  error?: Error;\n}\n\n/** A helper interface for nodes that container left and right children */\nexport interface DirectionalNode {\n  /** The left node. Often for the left hand side of an expression */\n  left: ExpressionNode;\n\n  /** The right child. Often for the right hand side of an expression */\n  right: ExpressionNode;\n}\n\nexport interface LiteralNode extends BaseNode<\"Literal\"> {\n  /** A node that holds a literal value */\n  value: string | number;\n\n  /** The unprocessed value */\n  raw?: any;\n}\n\nexport interface BinaryNode\n  extends BaseNode<\"BinaryExpression\">,\n    DirectionalNode {\n  /** The operation to perform on the nodes */\n  operator: string;\n}\n\nexport interface LogicalNode\n  extends BaseNode<\"LogicalExpression\">,\n    DirectionalNode {\n  /** The logical operation to perform on the nodes */\n  operator: string;\n}\n\nexport interface UnaryNode extends BaseNode<\"UnaryExpression\"> {\n  /** The operation to perform on the node */\n  operator: string;\n\n  /** The single argument that the operation should be performed on */\n  argument: ExpressionNode;\n}\n\nexport type ThisNode = BaseNode<\"ThisExpression\">;\n\nexport interface ModelRefNode extends BaseNode<\"ModelRef\"> {\n  /** The binding that the model reference points to */\n  ref: string;\n}\n\nexport interface ObjectNode extends BaseNode<\"Object\"> {\n  /**  */\n  attributes: Array<{\n    /** The property name of the object */\n    key: ExpressionNode;\n\n    /** the associated value */\n    value: ExpressionNode;\n  }>;\n}\n\nexport interface MemberExpressionNode extends BaseNode<\"MemberExpression\"> {\n  /** The object to be introspected */\n  object: ExpressionNode;\n\n  /** If the property uses . or open-bracket */\n  computed: boolean;\n\n  /** The property to access on the object */\n  property: ExpressionNode;\n}\n\nexport interface ConditionalExpressionNode\n  extends BaseNode<\"ConditionalExpression\"> {\n  /** The test for the ternary */\n  test: ExpressionNode;\n\n  /** The truthy case for the ternary */\n  consequent: ExpressionNode;\n\n  /** The falsy case for the ternary */\n  alternate: ExpressionNode;\n}\n\nexport interface CompoundNode extends BaseNode<\"Compound\"> {\n  /** The contents of the compound expression */\n  body: ExpressionNode[];\n}\n\nexport interface CallExpressionNode extends BaseNode<\"CallExpression\"> {\n  /** The arguments to the function */\n  args: ExpressionNode[];\n\n  /** The function name */\n  callTarget: IdentifierNode;\n}\n\nexport interface ArrayExpressionNode extends BaseNode<\"ArrayExpression\"> {\n  /** The items in an array */\n  elements: ExpressionNode[];\n}\n\nexport interface IdentifierNode extends BaseNode<\"Identifier\"> {\n  /** The variable name */\n  name: string;\n}\n\nexport type AssignmentNode = BaseNode<\"Assignment\"> & DirectionalNode;\n\nexport interface ModificationNode\n  extends BaseNode<\"Modification\">,\n    DirectionalNode {\n  /** The operator for the modification */\n  operator: string;\n}\n\nexport type ExpressionNode =\n  | LiteralNode\n  | BinaryNode\n  | LogicalNode\n  | UnaryNode\n  | ThisNode\n  | ModelRefNode\n  | MemberExpressionNode\n  | ConditionalExpressionNode\n  | CompoundNode\n  | CallExpressionNode\n  | ArrayExpressionNode\n  | IdentifierNode\n  | AssignmentNode\n  | ModificationNode\n  | ObjectNode;\n\nexport type ExpressionNodeType = ExpressionNode[\"type\"];\n\nexport interface ErrorWithLocation extends Error {\n  /** The place in the string where the error occurs */\n  index: number;\n\n  /** a helpful description */\n  description: string;\n}\n","/**\n * An expression to AST parser based on JSEP: http://jsep.from.so/\n */\nimport type {\n  ErrorWithLocation,\n  ExpressionNode,\n  ExpressionNodeType,\n  NodeLocation,\n} from \"./types\";\nimport { ExpNodeOpaqueIdentifier } from \"./types\";\n\nconst PERIOD_CODE = 46; // '.'\nconst COMMA_CODE = 44; // ','\nconst SQUOTE_CODE = 39; // Single quote\nconst DQUOTE_CODE = 34; // Double quotes\nconst OPAREN_CODE = 40; // (\nconst CPAREN_CODE = 41; // )\nconst OBRACK_CODE = 91; // [\nconst CBRACK_CODE = 93; // ]\nconst QUMARK_CODE = 63; // ?\nconst SEMCOL_CODE = 59; // ;\nconst COLON_CODE = 58; // :\nconst OCURL_CODE = 123; // {\nconst CCURL_CODE = 125; // }\n\n// Operations\n// ----------\n\n// Set `t` to `true` to save space (when minified, not gzipped)\nconst t = true;\n\n// Use a quickly-accessible map to store all of the unary operators\n// Values are set to `true` (it really doesn't matter)\nconst unaryOps = { \"-\": t, \"!\": t, \"~\": t, \"+\": t };\n\n// Also use a map for the binary operations but set their values to their\n// binary precedence for quick reference:\n// see [Operator precedence](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\nconst binaryOps: Record<string, number> = {\n  \"=\": 3,\n  \"+=\": 3,\n  \"-=\": 3,\n  \"&=\": 3,\n  \"|=\": 3,\n  // Conditional: 4,\n  \"||\": 5,\n  \"&&\": 6,\n  \"|\": 7,\n  \"^\": 8,\n  \"&\": 9,\n  \"==\": 10,\n  \"!=\": 10,\n  \"===\": 10,\n  \"!==\": 10,\n  \"<\": 11,\n  \">\": 11,\n  \"<=\": 11,\n  \">=\": 11,\n  \"<<\": 12,\n  \">>\": 12,\n  \">>>\": 12,\n  \"+\": 13,\n  \"-\": 13,\n  \"*\": 14,\n  \"/\": 14,\n  \"%\": 14,\n};\n\n/** Wrap the message and index in an error and throw it */\nfunction throwError(message: string, index: number): ErrorWithLocation {\n  const err = new Error(`${message} at character ${index}`);\n\n  (err as ErrorWithLocation).index = index;\n  (err as ErrorWithLocation).description = message;\n\n  throw err;\n}\n\n/** Create a new location marker that spans both nodes */\nfunction createSpanningLocation(start?: NodeLocation, end?: NodeLocation) {\n  if (!start || !end) {\n    return;\n  }\n\n  return {\n    start: start.start,\n    end: end.end,\n  };\n}\n\n/** Get return the longest key length of any object */\nfunction getMaxKeyLen(obj: object): number {\n  let maxLen = 0;\n\n  Object.keys(obj).forEach((key) => {\n    if (key.length > maxLen && Object.prototype.hasOwnProperty.call(obj, key)) {\n      maxLen = key.length;\n    }\n  });\n\n  return maxLen;\n}\n\nconst maxUnopLen = getMaxKeyLen(unaryOps);\nconst maxBinopLen = getMaxKeyLen(binaryOps);\n\n// Literals\n// ----------\n// Store the values to return for the various literals we may encounter\nconst literals = {\n  true: true,\n  false: false,\n  null: null,\n  undefined,\n} as const;\n\n// Except for `this`, which is special. This could be changed to something like `'self'` as well\nconst thisStr = \"this\";\n\n/** Returns the precedence of a binary operator or `0` if it isn't a binary operator */\nfunction binaryPrecedence(opVal: string): number {\n  return binaryOps[opVal] || 0;\n}\n\n/**\n * Utility function (gets called from multiple places)\n * Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions\n */\nfunction createBinaryExpression(\n  operator: string | boolean,\n  left: string,\n  right: string,\n  location?: NodeLocation,\n) {\n  let type: ExpressionNodeType;\n\n  if (operator === \"||\" || operator === \"&&\") {\n    type = \"LogicalExpression\";\n  } else if (operator === \"=\") {\n    type = \"Assignment\";\n  } else if (\n    operator === \"+=\" ||\n    operator === \"-=\" ||\n    operator === \"&=\" ||\n    operator === \"|=\"\n  ) {\n    type = \"Modification\";\n  } else {\n    type = \"BinaryExpression\";\n  }\n\n  return {\n    __id: ExpNodeOpaqueIdentifier,\n    type,\n    operator,\n    left,\n    right,\n    location,\n  };\n}\n\n/** `ch` is a character code in the next three functions */\nfunction isDecimalDigit(ch: number) {\n  return ch >= 48 && ch <= 57; // 0...9\n}\n\n/** Check if the char is the character code for the start of an identifier */\nfunction isIdentifierStart(ch: number) {\n  return (\n    ch === 36 ||\n    ch === 95 || // `$` and `_`\n    (ch >= 65 && ch <= 90) || // A...Z\n    (ch >= 97 && ch <= 122)\n  ); // A...z\n}\n\n/** Check if the char code is still a valid identifier portion */\nfunction isIdentifierPart(ch: number) {\n  return (\n    ch === 36 ||\n    ch === 95 || // `$` and `_`\n    (ch >= 65 && ch <= 90) || // A...Z\n    (ch >= 97 && ch <= 122) || // A...z\n    (ch >= 48 && ch <= 57)\n  ); // 0...9\n}\n\n/** Check if the 2 chars are the start of a model reference */\nfunction isModelRefStart(ch0: number, ch1: number) {\n  return ch0 === OCURL_CODE && ch1 === OCURL_CODE; // '{{'\n}\n\n/** Parse out an expression from the string */\nexport function parseExpression(\n  expr: string,\n  options?: {\n    /** If true (the default), will throw on invalid expressions */\n    strict?: boolean;\n  },\n): ExpressionNode {\n  const strictMode = options?.strict ?? true;\n\n  // `index` stores the character number we are currently at while `length` is a constant\n  // All of the gobbles below will modify `index` as we move along\n  const charAtFunc = expr.charAt;\n  const charCodeAtFunc = expr.charCodeAt;\n  const { length } = expr;\n\n  let index = 0;\n\n  /** Create a location object  */\n  const getLocation = (startChar: number) => {\n    return {\n      start: {\n        character: startChar,\n      },\n      end: {\n        character: index,\n      },\n    };\n  };\n\n  /** Grab the char at the index from the expression */\n  function exprI(i: number) {\n    return charAtFunc.call(expr, i);\n  }\n\n  /** Grab the unicode char at the index in the expression */\n  function exprICode(i: number) {\n    return charCodeAtFunc.call(expr, i);\n  }\n\n  /**\n   * Gobble an object and store the object in an attributes array\n   */\n  function gobbleObjects() {\n    const attributes: Array<{\n      /** The property name of the object */\n      key: any;\n\n      /** the associated value */\n      value: any;\n    }> = [];\n    let closed = false;\n\n    let shouldDefineKey = true;\n    let key;\n    let value;\n    let chCode;\n    const startCharIndex = index;\n\n    // get rid of OCURL_CODE\n    ++index;\n\n    while (index < length) {\n      gobbleSpaces();\n      chCode = exprICode(index);\n      // check for end\n      if (chCode === CCURL_CODE) {\n        // if we are at the end but a key was defined\n        if (key) {\n          throwError(\"A key was defined but a value was not\", index);\n        }\n\n        index++;\n        closed = true;\n        break;\n      } else if (shouldDefineKey) {\n        // check for key\n        if (chCode !== SQUOTE_CODE && chCode !== DQUOTE_CODE) {\n          throwError(\"An object must start wtih a key\", index);\n        }\n\n        // get key\n        key = gobbleStringLiteral();\n        // remove spaces\n        gobbleSpaces();\n        // remove colon\n        if (exprICode(index) === COLON_CODE) {\n          index++;\n          shouldDefineKey = false;\n        } else {\n          throwError(\"A colon must follow an object key\", index);\n        }\n      } else {\n        value = gobbleExpression();\n\n        attributes.push({ key, value });\n        gobbleSpaces();\n        chCode = exprICode(index);\n        if (chCode === COMMA_CODE) {\n          index++;\n        } else if (chCode !== CCURL_CODE) {\n          throwError(\"Please add a comma to add another key\", index);\n        }\n\n        shouldDefineKey = true;\n        key = undefined;\n        value = undefined;\n      }\n\n      chCode = exprICode(index);\n    }\n\n    // throw error if object is not closed\n    if (!closed) {\n      throwError(`Unclosed brace in object`, index);\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Object\",\n      attributes,\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  /**\n   * Push `index` up to the next non-space character\n   */\n  function gobbleSpaces() {\n    let ch = exprICode(index);\n    // Space or tab\n    while (ch === 32 || ch === 9) {\n      ch = exprICode(++index);\n    }\n  }\n\n  /**\n   * The main parsing function. Much of this code is dedicated to ternary expressions\n   */\n  function gobbleExpression(): ExpressionNode {\n    const test = gobbleBinaryExpression();\n    gobbleSpaces();\n    const startCharIndex = index;\n\n    if (index < length && exprICode(index) === QUMARK_CODE) {\n      // Ternary expression: test ? consequent : alternate\n      index++;\n      const consequent = gobbleExpression();\n\n      if (!consequent) {\n        throwError(\"Expected expression\", index);\n      }\n\n      gobbleSpaces();\n\n      if (exprICode(index) === COLON_CODE) {\n        index++;\n        const alternate = gobbleExpression();\n\n        if (!alternate) {\n          throwError(\"Expected expression\", index);\n        }\n\n        return {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"ConditionalExpression\",\n          test,\n          consequent,\n          alternate,\n          location: getLocation(startCharIndex),\n        };\n      }\n\n      throwError(\"Expected :\", index);\n    }\n\n    return test;\n  }\n\n  /**\n   * Search for the operation portion of the string (e.g. `+`, `===`)\n   * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n   * and move down from 3 to 2 to 1 character until a matching binary operation is found\n   * then, return that binary operation\n   */\n  function gobbleBinaryOp() {\n    gobbleSpaces();\n\n    let toCheck = expr.substr(index, maxBinopLen);\n    let tcLen = toCheck.length;\n\n    while (tcLen > 0) {\n      if (Object.prototype.hasOwnProperty.call(binaryOps, toCheck)) {\n        index += tcLen;\n        return toCheck;\n      }\n\n      toCheck = toCheck.substr(0, --tcLen);\n    }\n\n    return false;\n  }\n\n  /**\n   * This function is responsible for gobbling an individual expression,\n   * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n   */\n  function gobbleBinaryExpression() {\n    let node;\n    let prec;\n    let i;\n\n    // First, try to get the leftmost thing\n    // Then, check to see if there's a binary operator operating on that leftmost thing\n    let left = gobbleToken();\n    let biop = gobbleBinaryOp();\n\n    // If there wasn't a binary operator, just return the leftmost node\n    if (!biop) {\n      return left;\n    }\n\n    // Otherwise, we need to start a stack to properly place the binary operations in their\n    // precedence structure\n    let biopInfo = { value: biop, prec: binaryPrecedence(biop) };\n    let right = gobbleToken();\n\n    if (!right) {\n      throwError(`Expected expression after ${biop}`, index);\n    }\n\n    const stack = [left, biopInfo, right];\n\n    // Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n    biop = gobbleBinaryOp();\n    while (biop) {\n      prec = binaryPrecedence(biop);\n\n      if (prec === 0) {\n        break;\n      }\n\n      biopInfo = { value: biop, prec };\n\n      // Reduce: make a binary expression from the three topmost entries.\n      while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n        right = stack.pop();\n        biop = stack.pop().value;\n        left = stack.pop();\n        node = createBinaryExpression(\n          biop,\n          left,\n          right,\n          createSpanningLocation(left.location, right.location),\n        );\n        stack.push(node);\n      }\n\n      node = gobbleToken();\n\n      if (!node) {\n        throwError(`Expected expression after ${biop}`, index);\n      }\n\n      stack.push(biopInfo, node);\n      biop = gobbleBinaryOp();\n    }\n\n    i = stack.length - 1;\n    node = stack[i];\n\n    while (i > 1) {\n      node = createBinaryExpression(\n        stack[i - 1].value,\n        stack[i - 2],\n        node,\n        createSpanningLocation(stack[i - 2].location, node.location),\n      );\n      i -= 2;\n    }\n\n    return node;\n  }\n\n  /**\n   * An individual part of a binary expression:\n   * e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n   */\n  function gobbleToken(): any {\n    gobbleSpaces();\n    const ch = exprICode(index);\n    const startCharIndex = index;\n\n    if (isDecimalDigit(ch) || ch === PERIOD_CODE) {\n      // Char code 46 is a dot `.` which can start off a numeric literal\n      return gobbleNumericLiteral();\n    }\n\n    if (ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\n      // Single or double quotes\n      return gobbleStringLiteral();\n    }\n\n    if (isIdentifierStart(ch) || ch === OPAREN_CODE) {\n      // Open parenthesis\n      // `foo`, `bar.baz`\n      return gobbleVariable();\n    }\n\n    if (ch === OBRACK_CODE) {\n      return gobbleArray();\n    }\n\n    if (isModelRefStart(ch, exprICode(index + 1))) {\n      return gobbleModelRef();\n    }\n\n    // not a double bracket: {{}} but if its a single {}\n    if (ch === OCURL_CODE) {\n      return gobbleObjects();\n    }\n\n    let toCheck = expr.substr(index, maxUnopLen);\n    let tcLen = toCheck.length;\n\n    while (tcLen > 0) {\n      if (Object.prototype.hasOwnProperty.call(unaryOps, toCheck)) {\n        index += tcLen;\n        return {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"UnaryExpression\",\n          operator: toCheck,\n          argument: gobbleToken(),\n          prefix: true,\n          location: getLocation(startCharIndex),\n        };\n      }\n\n      toCheck = toCheck.substr(0, --tcLen);\n    }\n\n    return false;\n  }\n\n  /**\n   * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n   * keep track of everything in the numeric literal and then calling `parseFloat` on that string\n   */\n  function gobbleNumericLiteral() {\n    let num = \"\";\n    const startCharIndex = index;\n\n    while (isDecimalDigit(exprICode(index))) {\n      num += exprI(index++);\n    }\n\n    if (exprICode(index) === PERIOD_CODE) {\n      // Can start with a decimal marker\n      num += exprI(index++);\n\n      while (isDecimalDigit(exprICode(index))) {\n        num += exprI(index++);\n      }\n    }\n\n    let ch = exprI(index);\n    if (ch === \"e\" || ch === \"E\") {\n      // Exponent marker\n      num += exprI(index++);\n      ch = exprI(index);\n\n      if (ch === \"+\" || ch === \"-\") {\n        // Exponent sign\n        num += exprI(index++);\n      }\n\n      while (isDecimalDigit(exprICode(index))) {\n        // Exponent itself\n        num += exprI(index++);\n      }\n\n      if (!isDecimalDigit(exprICode(index - 1))) {\n        throwError(`Expected exponent (${num}${exprI(index)})`, index);\n      }\n    }\n\n    const chCode = exprICode(index);\n    // Check to make sure this isn't a variable name that start with a number (123abc)\n    if (isIdentifierStart(chCode)) {\n      throwError(\n        `Variable names cannot start with a number (${num}${exprI(index)})`,\n        index,\n      );\n    } else if (chCode === PERIOD_CODE) {\n      throwError(\"Unexpected period\", index);\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Literal\",\n      value: parseFloat(num),\n      raw: num,\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  /**\n   * Parses a string literal, staring with single or double quotes with basic support for escape codes\n   * e.g. `\"hello world\"`, `'this is\\nJSEP'`\n   */\n  function gobbleStringLiteral() {\n    const quote = exprI(index++);\n    let str = \"\";\n    let closed = false;\n    const startCharIndex = index;\n\n    while (index < length) {\n      let ch = exprI(index++);\n\n      if (ch === quote) {\n        closed = true;\n        break;\n      }\n\n      if (ch !== \"\\\\\") {\n        str += ch;\n        continue;\n      }\n\n      // Check for all of the common escape codes\n      ch = exprI(index++);\n\n      switch (ch) {\n        case \"n\":\n          str += \"\\n\";\n          break;\n        case \"r\":\n          str += \"\\r\";\n          break;\n        case \"t\":\n          str += \"\\t\";\n          break;\n        case \"b\":\n          str += \"\\b\";\n          break;\n        case \"f\":\n          str += \"\\f\";\n          break;\n        case \"v\":\n          str += \"\\u000B\";\n          break;\n        default:\n      }\n    }\n\n    if (!closed) {\n      throwError(`Unclosed quote after \"${str}\"`, index);\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Literal\",\n      value: str,\n      raw: `${quote}${str}${quote}`,\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  /**\n   * Model refs are bindings wrapped in 2 sets of double curlys\n   * e.g. {{foo.bar.ref}}\n   */\n  function gobbleModelRef() {\n    let str = \"\";\n    let closed = false;\n    let openBraceCount = 1;\n    const startCharIndex = index;\n\n    index += 2; // Skip the {{\n    while (index < length) {\n      const ch = exprI(index++);\n\n      if (ch === \"}\" && exprICode(index) === CCURL_CODE) {\n        index++;\n        openBraceCount--;\n\n        if (openBraceCount === 0) {\n          closed = true;\n          break;\n        }\n\n        str += \"}}\";\n      } else if (ch === \"{\" && exprICode(index) === OCURL_CODE) {\n        openBraceCount++;\n        str += \"{{\";\n        index++;\n      } else {\n        str += ch;\n      }\n    }\n\n    if (!closed) {\n      throwError(`Unclosed brace after \"${str}\"`, index);\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"ModelRef\",\n      ref: str,\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  /**\n   * Gobbles only identifiers\n   * e.g.: `foo`, `_value`, `$x1`\n   * Also, this function checks if that identifier is a literal:\n   * (e.g. `true`, `false`, `null`) or `this`\n   */\n  function gobbleIdentifier() {\n    const start = index;\n    let ch = exprICode(start);\n\n    if (isIdentifierStart(ch)) {\n      index++;\n    } else {\n      throwError(`Unexpected ${exprI(index)}`, index);\n    }\n\n    while (index < length) {\n      ch = exprICode(index);\n      if (isIdentifierPart(ch)) {\n        index++;\n      } else {\n        break;\n      }\n    }\n\n    const identifier = expr.slice(start, index);\n\n    if (Object.prototype.hasOwnProperty.call(literals, identifier)) {\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Literal\",\n        value: (literals as any)[identifier],\n        raw: identifier,\n        location: getLocation(start),\n      };\n    }\n\n    if (identifier === thisStr) {\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"ThisExpression\",\n        location: getLocation(start),\n      };\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Identifier\",\n      name: identifier,\n      location: getLocation(start),\n    };\n  }\n\n  /**\n   * Gobbles a list of arguments within the context of a function call\n   * or array literal. This function also assumes that the opening character\n   * `(` or `[` has already been gobbled, and gobbles expressions and commas\n   * until the terminator character `)` or `]` is encountered.\n   * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n   */\n  function gobbleArguments(termination: number) {\n    const args = [];\n    let charIndex;\n    let node;\n\n    while (index < length) {\n      gobbleSpaces();\n      charIndex = exprICode(index);\n\n      if (charIndex === termination) {\n        // Done parsing\n        index++;\n        break;\n      }\n\n      if (charIndex === COMMA_CODE) {\n        // Between expressions\n        index++;\n        continue;\n      }\n\n      node = gobbleExpression();\n\n      if (!node || node.type === \"Compound\") {\n        throwError(\"Expected comma\", index);\n      }\n\n      args.push(node);\n    }\n\n    if (strictMode && charIndex !== termination) {\n      throwError(`Expected ${String.fromCharCode(termination)}`, index);\n    }\n\n    return args;\n  }\n\n  /**\n   * Gobble a non-literal variable name. This variable name may include properties\n   * e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n   * It also gobbles function calls:\n   * e.g. `Math.acos(obj.angle)`\n   */\n  function gobbleVariable(): ExpressionNode {\n    let charIndex = exprICode(index);\n    let node: any =\n      charIndex === OPAREN_CODE ? gobbleGroup() : gobbleIdentifier();\n    const startCharIndex = index;\n    gobbleSpaces();\n    charIndex = exprICode(index);\n\n    while (\n      charIndex === PERIOD_CODE ||\n      charIndex === OBRACK_CODE ||\n      charIndex === OPAREN_CODE\n    ) {\n      index++;\n\n      if (charIndex === PERIOD_CODE) {\n        gobbleSpaces();\n\n        node = {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"MemberExpression\",\n          computed: false,\n          object: node,\n          property: gobbleIdentifier(),\n          location: getLocation(startCharIndex),\n        };\n      } else if (charIndex === OBRACK_CODE) {\n        node = {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"MemberExpression\",\n          computed: true,\n          object: node,\n          property: gobbleExpression(),\n          location: getLocation(startCharIndex),\n        };\n\n        gobbleSpaces();\n        charIndex = exprICode(index);\n\n        if (charIndex !== CBRACK_CODE) {\n          throwError(\"Unclosed [\", index);\n        }\n\n        index++;\n      } else if (charIndex === OPAREN_CODE) {\n        // A function call is being made; gobble all the arguments\n        node = {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"CallExpression\",\n          args: gobbleArguments(CPAREN_CODE),\n          callTarget: node,\n          location: getLocation(startCharIndex),\n        };\n      }\n\n      gobbleSpaces();\n      charIndex = exprICode(index);\n    }\n\n    return node;\n  }\n\n  /**\n   * Responsible for parsing a group of things within parentheses `()`\n   * This function assumes that it needs to gobble the opening parenthesis\n   * and then tries to gobble everything within that parenthesis, assuming\n   * that the next thing it should see is the close parenthesis. If not,\n   * then the expression probably doesn't have a `)`\n   */\n  function gobbleGroup() {\n    index++;\n    const node = gobbleExpression();\n    gobbleSpaces();\n\n    if (exprICode(index) === CPAREN_CODE) {\n      index++;\n      return node;\n    }\n\n    throwError(\"Unclosed (\", index);\n  }\n\n  /**\n   * Responsible for parsing Array literals `[1, 2, 3]`\n   * This function assumes that it needs to gobble the opening bracket\n   * and then tries to gobble the expressions as arguments.\n   */\n  function gobbleArray() {\n    const startCharIndex = index;\n    index++;\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"ArrayExpression\",\n      elements: gobbleArguments(CBRACK_CODE),\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  const nodes = [];\n\n  try {\n    while (index < length) {\n      const chIndex = exprICode(index);\n\n      // Expressions can be separated by semicolons, commas, or just inferred without any\n      // separators\n      if (chIndex === SEMCOL_CODE || chIndex === COMMA_CODE) {\n        index++; // ignore separators\n        continue;\n      }\n\n      const node = gobbleExpression();\n\n      // Try to gobble each expression individually\n      if (node) {\n        nodes.push(node);\n        // If we weren't able to find a binary expression and are out of room, then\n        // the expression passed in probably has too much\n      } else if (strictMode && index < length) {\n        throwError(`Unexpected \"${exprI(index)}\"`, index);\n      }\n    }\n\n    // If there's only one expression just try returning the expression\n    if (nodes.length === 1) {\n      return nodes[0];\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Compound\",\n      body: nodes,\n      location: getLocation(0),\n    };\n  } catch (e) {\n    if (strictMode || !(e instanceof Error)) {\n      throw e;\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Compound\",\n      body: nodes,\n      location: getLocation(0),\n      error: e,\n    };\n  }\n}\n","/**\n * Promise detection that handles various Promise implementations\n * and reduces false positives from objects with coincidental 'then' methods\n */\nexport function isPromiseLike(value: any): value is Promise<any> {\n  return (\n    value != null &&\n    typeof value === \"object\" &&\n    typeof value.then === \"function\" &&\n    // Additional safeguards against false positives\n    (value instanceof Promise ||\n      // Check for standard Promise constructor name\n      value.constructor?.name === \"Promise\" ||\n      // Verify it has other Promise-like methods to reduce false positives\n      (typeof value.catch === \"function\" &&\n        typeof value.finally === \"function\"))\n  );\n}\n\n/** Unique private symbol to indicate async functions wrapped in Player's await function */\nexport const AwaitableSymbol: unique symbol = Symbol(\"Awaitable\");\n\n/**\n * Wrapper for Promises that are generated from the `await` function with a unique symbol so we can\n * determine when a promise should be awaited by us (as its returned by await) or a promise thats\n * generated from any async function\n */\nexport interface Awaitable<T> extends Promise<T> {\n  /** Prevent unwrapped then from being exposed from underlying promise */\n  then: never;\n  /** Internalally awaitable wrapper around underlying then function */\n  awaitableThen<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null,\n  ): Promise<TResult1 | TResult2>;\n  /** Symbol to identify this as something returned by await */\n  [AwaitableSymbol]: symbol;\n}\n\n/** Typeguard for AwaitableResult */\nexport function isAwaitable(val: unknown): val is Awaitable<any> {\n  return (\n    isPromiseLike(val) && (val as Awaitable<any>)[AwaitableSymbol] !== undefined\n  );\n}\n\n/**\n * Wraps Promise.all in AwaitableResult wrapper to allow internal functions to await internally produced promises\n */\nexport function collateAwaitable<T extends readonly unknown[] | []>(\n  promises: T,\n): Awaitable<any> {\n  const result = Promise.all(promises) as Promise<any>;\n  return makeAwaitable(result);\n}\n\n/**\n * Add AwaitableSymbol to base promise and promise returned by then() function\n */\nexport function makeAwaitable(promise: Promise<any>): Awaitable<any> {\n  (promise as Awaitable<any>)[AwaitableSymbol] = AwaitableSymbol;\n  (promise as any).awaitableThen = (arg: any) => {\n    return makeAwaitable(promise.then(arg));\n  };\n  return promise as Awaitable<any>;\n}\n","import { isExpressionNode } from \"./types\";\nimport type {\n  ErrorWithLocation,\n  ExpressionHandler,\n  ExpressionNode,\n  ExpressionObjectType,\n  ExpressionType,\n  NodeLocation,\n  NodePosition,\n} from \"./types\";\n\n/** Generates a function by removing the first context argument */\nexport function withoutContext<T extends unknown[], Return>(\n  fn: (...args: T) => Return,\n): ExpressionHandler<T, Return> {\n  return (_context, ...args) => fn(...args);\n}\n\n/** Checks if the location includes the target position  */\nfunction isInRange(position: NodePosition, location: NodeLocation) {\n  return (\n    position.character >= location.start.character &&\n    position.character <= location.end.character\n  );\n}\n\n/** Get the node in the expression that's closest to the desired position */\nexport function findClosestNodeAtPosition(\n  node: ExpressionNode,\n  position: NodePosition,\n): ExpressionNode | undefined {\n  // This is just mapping recursively over nodes in the tree\n\n  switch (node.type) {\n    case \"Modification\":\n    case \"Assignment\":\n    case \"LogicalExpression\":\n    case \"BinaryExpression\": {\n      const check =\n        findClosestNodeAtPosition(node.left, position) ??\n        findClosestNodeAtPosition(node.right, position);\n      if (check) {\n        return check;\n      }\n\n      break;\n    }\n\n    case \"UnaryExpression\": {\n      const checkArg = findClosestNodeAtPosition(node.argument, position);\n      if (checkArg) {\n        return checkArg;\n      }\n\n      break;\n    }\n\n    case \"MemberExpression\": {\n      const checkObject =\n        findClosestNodeAtPosition(node.object, position) ??\n        findClosestNodeAtPosition(node.property, position);\n      if (checkObject) {\n        return checkObject;\n      }\n\n      break;\n    }\n\n    case \"ConditionalExpression\": {\n      const checkObject =\n        findClosestNodeAtPosition(node.test, position) ??\n        findClosestNodeAtPosition(node.consequent, position) ??\n        findClosestNodeAtPosition(node.alternate, position);\n      if (checkObject) {\n        return checkObject;\n      }\n\n      break;\n    }\n\n    case \"ArrayExpression\":\n    case \"Compound\": {\n      const elements =\n        node.type === \"ArrayExpression\" ? node.elements : node.body;\n\n      const anyElements = elements.find((e) =>\n        findClosestNodeAtPosition(e, position),\n      );\n\n      if (anyElements) {\n        return anyElements;\n      }\n\n      break;\n    }\n\n    case \"Object\": {\n      const checkObject = node.attributes.reduce<ExpressionNode | undefined>(\n        (found, next) => {\n          return (\n            found ??\n            findClosestNodeAtPosition(next.key, position) ??\n            findClosestNodeAtPosition(next.value, position)\n          );\n        },\n        undefined,\n      );\n\n      if (checkObject) {\n        return checkObject;\n      }\n\n      break;\n    }\n\n    case \"CallExpression\": {\n      const anyArgs =\n        node.args.find((arg) => {\n          return findClosestNodeAtPosition(arg, position);\n        }) ?? findClosestNodeAtPosition(node.callTarget, position);\n\n      if (anyArgs) {\n        return anyArgs;\n      }\n\n      break;\n    }\n  }\n\n  // Lastly check for yourself\n  if (node.location && isInRange(position, node.location)) {\n    return node;\n  }\n}\n\n/** Checks if the expression is a simple type */\nexport function isObjectExpression(\n  expr: ExpressionType,\n): expr is ExpressionObjectType {\n  if (isExpressionNode(expr)) {\n    return false;\n  }\n\n  return (\n    typeof expr === \"object\" &&\n    expr !== null &&\n    !Array.isArray(expr) &&\n    \"value\" in expr\n  );\n}\n\n/**\n * Type guard for ErrorWithLocation\n */\nexport function isErrorWithLocation(error: Error): error is ErrorWithLocation {\n  return (\n    (error as ErrorWithLocation).index !== undefined &&\n    (error as ErrorWithLocation).description !== undefined\n  );\n}\n","import { SyncWaterfallHook, SyncBailHook } from \"tapable-ts\";\nimport { NestedError } from \"ts-nested-error\";\nimport { parseExpression } from \"./parser\";\nimport * as DEFAULT_EXPRESSION_HANDLERS from \"./evaluator-functions\";\nimport { collateAwaitable, isAwaitable, isPromiseLike } from \"./async\";\nimport { isExpressionNode } from \"./types\";\nimport { isObjectExpression } from \"./utils\";\nimport type {\n  ExpressionNode,\n  BinaryOperator,\n  UnaryOperator,\n  ExpressionType,\n  ExpressionContext,\n  ExpressionHandler,\n} from \"./types\";\n\n/** a && b -- but handles short cutting if the first value is false */\nconst andandOperator: BinaryOperator = (ctx, a, b, async) => {\n  return LogicalOperators.and(ctx, a, b, async);\n};\nandandOperator.resolveParams = false;\n\n/** a || b -- but with short cutting if first value is true */\nconst ororOperator: BinaryOperator = (ctx, a, b, async) => {\n  return LogicalOperators.or(ctx, a, b, async);\n};\nororOperator.resolveParams = false;\n\nconst DEFAULT_BINARY_OPERATORS: Record<string, BinaryOperator> = {\n  // TODO: A lot of these functions used to do type coercion. Not sure if we want to keep that behavior or not.\n  \"+\": (a: any, b: any) => a + b,\n  \"-\": (a: any, b: any) => a - b,\n  \"*\": (a: any, b: any) => a * b,\n  \"/\": (a: any, b: any) => a / b,\n  \"%\": (a: any, b: any) => a % b,\n\n  // Promise-aware comparison operators\n  // eslint-disable-next-line\n  \"==\": makePromiseAwareBinaryOp((a: any, b: any) => a == b),\n  // eslint-disable-next-line\n  \"!=\": makePromiseAwareBinaryOp((a: any, b: any) => a != b),\n  \">\": makePromiseAwareBinaryOp((a: any, b: any) => a > b),\n  \">=\": makePromiseAwareBinaryOp((a: any, b: any) => a >= b),\n  \"<\": makePromiseAwareBinaryOp((a: any, b: any) => a < b),\n  \"<=\": makePromiseAwareBinaryOp((a: any, b: any) => a <= b),\n  \"!==\": makePromiseAwareBinaryOp((a: any, b: any) => a !== b),\n  \"===\": makePromiseAwareBinaryOp((a: any, b: any) => a === b),\n\n  \"&&\": andandOperator,\n  \"||\": ororOperator,\n\n  // eslint-disable-next-line\n  \"|\": (a: any, b: any) => a | b,\n\n  // eslint-disable-next-line\n  \"&\": (a: any, b: any) => a & b,\n  \"+=\": (a: any, b: any) => a + b,\n  \"-=\": (a: any, b: any) => a - b,\n\n  // eslint-disable-next-line\n  \"&=\": (a: any, b: any) => a & b,\n\n  // eslint-disable-next-line\n  \"|=\": (a: any, b: any) => a | b,\n};\n\nconst DEFAULT_UNARY_OPERATORS: Record<string, UnaryOperator> = {\n  \"-\": (a: any) => -a,\n  \"+\": (a: any) => Number(a),\n  \"!\": makePromiseAwareUnaryOp((a: any) => !a),\n};\n\n/**\n * Higher-order function that makes any binary operation Promise-aware\n */\nfunction makePromiseAwareBinaryOp<T>(\n  operation: (a: any, b: any) => T,\n): (a: any, b: any, async: boolean) => T | Promise<T> {\n  return (a: any, b: any, async: boolean) => {\n    //async handler\n    if (async && (isAwaitable(a) || isAwaitable(b))) {\n      return collateAwaitable([\n        Promise.resolve(a),\n        Promise.resolve(b),\n      ]).awaitableThen(([resolvedA, resolvedB]) =>\n        operation(resolvedA, resolvedB),\n      );\n    }\n    //sync handler\n    return operation(a, b);\n  };\n}\n\n/**\n * Higher-order function that makes any unary operation Promise-aware\n */\nfunction makePromiseAwareUnaryOp<T>(\n  operation: (a: any) => T,\n): (a: any, async: boolean) => T | Promise<T> {\n  return (a: any, async: boolean) => {\n    //async handler\n    if (async && isAwaitable(a)) {\n      return a.awaitableThen((resolved: any) => operation(resolved));\n    }\n    //sync handler\n    return operation(a);\n  };\n}\n\n/**\n * Utility for handling conditional branching with Promises\n */\nfunction handleConditionalBranching(\n  testValue: any,\n  getTrueBranch: () => any,\n  getFalseBranch: () => any,\n  resolveNode: (node: any) => any,\n  async: boolean,\n): any {\n  //async handler\n  if (async && isAwaitable(testValue)) {\n    return testValue.awaitableThen((resolved: boolean) => {\n      const branch = resolved ? getTrueBranch() : getFalseBranch();\n      const branchResult = resolveNode(branch);\n      return isAwaitable(branchResult)\n        ? Promise.resolve(branchResult)\n        : branchResult;\n    });\n  }\n\n  // sync handler\n  const branch = testValue ? getTrueBranch() : getFalseBranch();\n  return resolveNode(branch);\n}\n\n/**\n * Utility for handling collections (arrays/objects) with potential Promises\n */\nconst PromiseCollectionHandler = {\n  /**\n   * Handle array with potential Promise elements\n   */\n  handleArray<T>(items: T[], async: boolean): T[] | Promise<T[]> {\n    if (!async) {\n      return items;\n    }\n    const hasPromises = items.some((item) => isAwaitable(item));\n    return hasPromises ? collateAwaitable(items) : items;\n  },\n\n  /**\n   * Handle object with potential Promise keys/values\n   */\n  handleObject(\n    attributes: Array<{ key: any; value: any }>,\n    resolveNode: (node: any) => any,\n    async: boolean,\n  ): Record<string, any> | Promise<Record<string, any>> {\n    const resolvedAttributes: Record<string, any> = {};\n    const promises: Promise<void>[] = [];\n    let hasPromises = false;\n\n    attributes.forEach((attr) => {\n      const key = resolveNode(attr.key);\n      const value = resolveNode(attr.value);\n\n      //async handler\n      if (async && (isAwaitable(key) || isAwaitable(value))) {\n        hasPromises = true;\n        const keyPromise = Promise.resolve(key);\n        const valuePromise = Promise.resolve(value);\n\n        promises.push(\n          collateAwaitable([keyPromise, valuePromise]).awaitableThen(\n            ([resolvedKey, resolvedValue]) => {\n              resolvedAttributes[resolvedKey] = resolvedValue;\n            },\n          ),\n        );\n      } else {\n        resolvedAttributes[key] = value;\n      }\n    });\n\n    return hasPromises\n      ? collateAwaitable(promises).awaitableThen(() => resolvedAttributes)\n      : resolvedAttributes;\n  },\n};\n\n/**\n * Smart logical operators that handle short-circuiting with Promises\n */\nconst LogicalOperators = {\n  and: (ctx: any, leftNode: any, rightNode: any, async: boolean) => {\n    const leftResult = ctx.evaluate(leftNode);\n\n    if (async && isAwaitable(leftResult)) {\n      return leftResult.awaitableThen((awaitedLeft: any) => {\n        if (!awaitedLeft) return awaitedLeft; // Short circuit\n        const rightResult = ctx.evaluate(rightNode);\n        return isAwaitable(rightResult)\n          ? rightResult\n          : Promise.resolve(rightResult);\n      });\n    }\n\n    // Sync short-circuiting\n    return leftResult && ctx.evaluate(rightNode);\n  },\n\n  or: (ctx: any, leftNode: any, rightNode: any, async: boolean) => {\n    const leftResult = ctx.evaluate(leftNode);\n\n    if (async && isAwaitable(leftResult)) {\n      return leftResult.awaitableThen((awaitedLeft: any) => {\n        if (awaitedLeft) return awaitedLeft; // Short circuit\n        const rightResult = ctx.evaluate(rightNode);\n        return isAwaitable(rightResult)\n          ? rightResult\n          : Promise.resolve(rightResult);\n      });\n    }\n\n    // Sync short-circuiting\n    return leftResult || ctx.evaluate(rightNode);\n  },\n};\n\nexport interface HookOptions extends ExpressionContext {\n  /** Given an expression node  */\n  resolveNode: (node: ExpressionNode) => any;\n\n  /** Enabling this flag skips calling the onError hook, and just throws errors back to the caller.\n   * The caller is responsible for handling the error.\n   */\n  throwErrors?: boolean;\n\n  /** Whether expressions should be parsed strictly or not */\n  strict?: boolean;\n\n  /** Whether the expression should be evaluated asynchronously */\n  async?: boolean;\n}\n\nexport type ExpressionEvaluatorOptions = Omit<\n  HookOptions,\n  \"resolveNode\" | \"evaluate\"\n>;\n\nexport type ExpressionEvaluatorFunction = (\n  exp: ExpressionType,\n  options?: ExpressionEvaluatorOptions,\n) => any;\n\n/**\n * The expression evaluator is responsible for parsing and executing anything in the custom expression language\n * */\nexport class ExpressionEvaluator {\n  private readonly vars: Record<string, any> = {};\n  public readonly hooks: {\n    resolve: SyncWaterfallHook<[any, ExpressionNode, HookOptions]>;\n    resolveOptions: SyncWaterfallHook<[HookOptions]>;\n    beforeEvaluate: SyncWaterfallHook<[ExpressionType, HookOptions]>;\n    onError: SyncBailHook<[Error], true>;\n  } = {\n    /** Resolve an AST node for an expression to a value */\n    resolve: new SyncWaterfallHook<[any, ExpressionNode, HookOptions]>(),\n    /** Gets the options that will be passed in calls to the resolve hook */\n    resolveOptions: new SyncWaterfallHook<[HookOptions]>(),\n    /** Allows users to change the expression to be evaluated before processing */\n    beforeEvaluate: new SyncWaterfallHook<[ExpressionType, HookOptions]>(),\n    /**\n     * An optional means of handling an error in the expression execution\n     * Return true if handled, to stop propagation of the error\n     */\n    onError: new SyncBailHook<[Error], true>(),\n  };\n\n  private readonly expressionsCache: Map<string, ExpressionNode> = new Map();\n\n  private readonly defaultHookOptions: HookOptions;\n\n  public readonly operators: {\n    binary: Map<string, BinaryOperator>;\n    unary: Map<string, UnaryOperator>;\n    expressions: Map<string, ExpressionHandler<any, any>>;\n  } = {\n    binary: new Map<string, BinaryOperator>(\n      Object.entries(DEFAULT_BINARY_OPERATORS),\n    ),\n    unary: new Map<string, UnaryOperator>(\n      Object.entries(DEFAULT_UNARY_OPERATORS),\n    ),\n    expressions: new Map<string, ExpressionHandler<any, any>>([\n      ...Object.entries(DEFAULT_EXPRESSION_HANDLERS),\n      [\"await\", DEFAULT_EXPRESSION_HANDLERS.waitFor],\n    ]),\n  };\n\n  public reset(): void {\n    this.expressionsCache.clear();\n  }\n\n  constructor(defaultOptions: ExpressionEvaluatorOptions) {\n    this.defaultHookOptions = {\n      ...defaultOptions,\n      evaluate: (expr) => this.evaluate(expr, this.defaultHookOptions),\n      resolveNode: (node: ExpressionNode) =>\n        this._execAST(node, this.defaultHookOptions),\n    };\n\n    this.hooks.resolve.tap(\"ExpressionEvaluator\", (result, node, options) => {\n      return this._resolveNode(result, node, options);\n    });\n    this.evaluate = this.evaluate.bind(this);\n  }\n\n  public evaluate(\n    expr: ExpressionType,\n    options?: ExpressionEvaluatorOptions,\n  ): any {\n    const resolvedOpts = this.hooks.resolveOptions.call({\n      ...this.defaultHookOptions,\n      ...options,\n      resolveNode: (node: ExpressionNode) => this._execAST(node, resolvedOpts),\n    });\n\n    let expression = this.hooks.beforeEvaluate.call(expr, resolvedOpts) ?? expr;\n\n    // Unwrap any returned expression type\n    // Since this could also be an object type, we need to recurse through it until we find the end\n    while (isObjectExpression(expression)) {\n      expression = expression.value;\n    }\n\n    // Check for literals\n    if (\n      typeof expression === \"number\" ||\n      typeof expression === \"boolean\" ||\n      expression === undefined ||\n      expression === null\n    ) {\n      return expression;\n    }\n\n    // Skip doing anything with objects that are _actually_ just parsed expression nodes\n    if (isExpressionNode(expression)) {\n      return this._execAST(expression, resolvedOpts);\n    }\n\n    if (Array.isArray(expression)) {\n      return expression.reduce(\n        (_nothing, exp) => this.evaluate(exp, options),\n        null,\n      );\n    }\n\n    return this._execString(String(expression), resolvedOpts);\n  }\n\n  /**\n   * Evaluate functions in an async context\n   * @experimental These Player APIs are in active development and may change. Use with caution\n   */\n  public evaluateAsync(\n    expr: ExpressionType,\n    options?: ExpressionEvaluatorOptions,\n  ): Promise<any> {\n    // handle async expression block\n    if (Array.isArray(expr)) {\n      return collateAwaitable(\n        expr.map(async (exp) =>\n          this.evaluate(exp, { ...options, async: true } as any),\n        ),\n      ).awaitableThen((values) => {\n        return values.pop();\n      });\n    } else {\n      return this.evaluate(expr, { ...options, async: true } as any);\n    }\n  }\n\n  public addExpressionFunction<T extends readonly unknown[], R>(\n    name: string,\n    handler: ExpressionHandler<T, R>,\n  ): void {\n    this.operators.expressions.set(name, handler);\n  }\n\n  public addBinaryOperator(operator: string, handler: BinaryOperator): void {\n    this.operators.binary.set(operator, handler);\n  }\n\n  public addUnaryOperator(operator: string, handler: UnaryOperator): void {\n    this.operators.unary.set(operator, handler);\n  }\n\n  public setExpressionVariable(name: string, value: unknown): void {\n    this.vars[name] = value;\n  }\n\n  public getExpressionVariable(name: string): unknown {\n    return this.vars[name];\n  }\n\n  private _execAST(node: ExpressionNode, options: HookOptions): any {\n    return this.hooks.resolve.call(undefined, node, options);\n  }\n\n  private _execString(exp: string, options: HookOptions) {\n    if (exp === \"\") {\n      return exp;\n    }\n\n    const matches = exp.match(/^@\\[(.*)\\]@$/);\n    let matchedExp = exp;\n    if (matches) {\n      const [, matched] = Array.from(matches); // In case the expression was surrounded by @[ ]@\n      if (matched) {\n        matchedExp = matched;\n      }\n    }\n\n    let storedAST: ExpressionNode;\n\n    try {\n      storedAST =\n        this.expressionsCache.get(matchedExp) ??\n        parseExpression(matchedExp, { strict: options.strict });\n      this.expressionsCache.set(matchedExp, storedAST);\n    } catch (e: any) {\n      if (options.throwErrors || !this.hooks.onError.call(e)) {\n        // Only throw the error if it's not handled by the hook, or throwErrors is true\n        throw new NestedError(`Error parsing expression: ${exp}`, e);\n      }\n\n      return;\n    }\n\n    try {\n      return this._execAST(storedAST, options);\n    } catch (e: any) {\n      if (options.throwErrors || !this.hooks.onError.call(e)) {\n        // Only throw the error if it's not handled by the hook, or throwErrors is true\n        throw new NestedError(`Error evaluating expression: ${exp}`, e);\n      }\n    }\n  }\n\n  private _resolveNode(\n    _currentValue: any,\n    node: ExpressionNode,\n    options: HookOptions,\n  ): unknown {\n    const { resolveNode, model } = options;\n    const isAsync = options.async ?? false;\n\n    const expressionContext: ExpressionContext = {\n      ...options,\n      evaluate: (expr) => this.evaluate(expr, options),\n    };\n\n    if (node.type === \"Literal\") {\n      return node.value;\n    }\n\n    if (node.type === \"Identifier\") {\n      return this.vars[node.name];\n    }\n\n    if (node.type === \"Compound\" || node.type === \"ThisExpression\") {\n      throw new Error(`Expression type: ${node.type} is not supported`);\n    }\n\n    if (node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\") {\n      const operator = this.operators.binary.get(node.operator);\n\n      if (operator) {\n        if (\"resolveParams\" in operator) {\n          if (operator.resolveParams === false) {\n            return operator(expressionContext, node.left, node.right, isAsync);\n          }\n\n          const left = resolveNode(node.left);\n          const right = resolveNode(node.right);\n\n          // Handle promises in binary operations\n          if (options.async && (isAwaitable(left) || isAwaitable(right))) {\n            return collateAwaitable([left, right]).awaitableThen(\n              ([leftVal, rightVal]) =>\n                operator(expressionContext, leftVal, rightVal, isAsync),\n            );\n          }\n\n          return operator(expressionContext, left, right, isAsync);\n        }\n\n        const left = resolveNode(node.left);\n        const right = resolveNode(node.right);\n\n        if (options.async && (isAwaitable(left) || isAwaitable(right))) {\n          return collateAwaitable([left, right]).awaitableThen(\n            ([leftVal, rightVal]) => operator(leftVal, rightVal, isAsync),\n          );\n        }\n\n        return operator(left, right, isAsync);\n      }\n\n      return;\n    }\n\n    if (node.type === \"UnaryExpression\") {\n      const operator = this.operators.unary.get(node.operator);\n\n      if (operator) {\n        if (\"resolveParams\" in operator) {\n          if (operator.resolveParams === false) {\n            return operator(expressionContext, node.argument, isAsync);\n          }\n\n          const arg = resolveNode(node.argument);\n\n          if (options.async && isAwaitable(arg)) {\n            return arg.awaitableThen((argVal) =>\n              operator(expressionContext, argVal, isAsync),\n            );\n          }\n\n          return operator(expressionContext, arg, isAsync);\n        }\n\n        const arg = resolveNode(node.argument);\n\n        if (options.async && isAwaitable(arg)) {\n          return arg.awaitableThen((argVal) => operator(argVal, isAsync));\n        }\n\n        return operator(arg, isAsync);\n      }\n\n      return;\n    }\n\n    if (node.type === \"Object\") {\n      return PromiseCollectionHandler.handleObject(\n        node.attributes,\n        resolveNode,\n        options.async || false,\n      );\n    }\n\n    if (node.type === \"CallExpression\") {\n      const expressionName = node.callTarget.name;\n\n      const operator = this.operators.expressions.get(expressionName);\n\n      if (!operator) {\n        throw new Error(`Unknown expression function: ${expressionName}`);\n      }\n\n      if (\n        operator.name === DEFAULT_EXPRESSION_HANDLERS.waitFor.name &&\n        !options.async\n      ) {\n        throw new Error(\"Usage of await outside of async context\");\n      }\n\n      if (\"resolveParams\" in operator && operator.resolveParams === false) {\n        return operator(expressionContext, ...node.args);\n      }\n\n      const args = node.args.map((n) => resolveNode(n));\n\n      // Check if any arguments are promises\n      if (options.async) {\n        const hasPromises = args.some(isAwaitable);\n\n        if (hasPromises) {\n          return collateAwaitable(args).awaitableThen((resolvedArgs) =>\n            operator(expressionContext, ...resolvedArgs),\n          );\n        }\n      }\n\n      return operator(expressionContext, ...args);\n    }\n\n    if (node.type === \"ModelRef\") {\n      return model.get(node.ref, { context: { model: options.model } });\n    }\n\n    if (node.type === \"MemberExpression\") {\n      const obj = resolveNode(node.object);\n      const prop = resolveNode(node.property);\n\n      if (options.async && (isAwaitable(obj) || isAwaitable(prop))) {\n        return collateAwaitable([obj, prop]).awaitableThen(\n          ([objVal, propVal]) => objVal[propVal],\n        );\n      }\n\n      return obj[prop];\n    }\n\n    if (node.type === \"Assignment\") {\n      if (node.left.type === \"ModelRef\") {\n        const value = resolveNode(node.right);\n\n        if (isPromiseLike(value)) {\n          if (options.async && isAwaitable(value)) {\n            return value.awaitableThen((resolvedValue) => {\n              model.set([[(node.left as any).ref, resolvedValue]]);\n              return resolvedValue;\n            });\n          } else {\n            options.logger?.warn(\n              \"Unawaited promise written to mode, this behavior is undefined and may change in future releases\",\n            );\n          }\n        }\n\n        model.set([[(node.left as any).ref, value]]);\n        return value;\n      }\n\n      if (node.left.type === \"Identifier\") {\n        const value = resolveNode(node.right);\n\n        if (options.async && isAwaitable(value)) {\n          return value.awaitableThen((resolvedValue) => {\n            this.vars[(node.left as any).name] = resolvedValue;\n            return resolvedValue;\n          });\n        }\n\n        this.vars[(node.left as any).name] = value;\n        return value;\n      }\n\n      return;\n    }\n\n    if (node.type === \"ConditionalExpression\") {\n      const testResult = resolveNode(node.test);\n\n      return handleConditionalBranching(\n        testResult,\n        () => node.consequent,\n        () => node.alternate,\n        resolveNode,\n        isAsync,\n      );\n    }\n\n    if (node.type === \"ArrayExpression\") {\n      const results = node.elements.map((ele) => resolveNode(ele));\n      return PromiseCollectionHandler.handleArray(results, isAsync);\n    }\n\n    if (node.type === \"Modification\") {\n      const operation = this.operators.binary.get(node.operator);\n\n      if (operation) {\n        let newValue;\n\n        if (\"resolveParams\" in operation) {\n          if (operation.resolveParams === false) {\n            newValue = operation(\n              expressionContext,\n              node.left,\n              node.right,\n              isAsync,\n            );\n          } else {\n            const left = resolveNode(node.left);\n            const right = resolveNode(node.right);\n\n            if (options.async && (isAwaitable(left) || isAwaitable(right))) {\n              newValue = collateAwaitable([left, right]).awaitableThen(\n                ([leftVal, rightVal]) =>\n                  operation(expressionContext, leftVal, rightVal, isAsync),\n              );\n            } else {\n              newValue = operation(expressionContext, left, right, isAsync);\n            }\n          }\n        } else {\n          const left = resolveNode(node.left);\n          const right = resolveNode(node.right);\n\n          if (options.async && (isAwaitable(left) || isAwaitable(right))) {\n            newValue = collateAwaitable([left, right]).awaitableThen(\n              ([leftVal, rightVal]) => operation(leftVal, rightVal, isAsync),\n            );\n          } else {\n            newValue = operation(left, right, isAsync);\n          }\n        }\n\n        if (node.left.type === \"ModelRef\") {\n          if (options.async && isAwaitable(newValue)) {\n            return newValue.awaitableThen((resolvedValue) => {\n              model.set([[(node.left as any).ref, resolvedValue]]);\n              return resolvedValue;\n            });\n          }\n          model.set([[(node.left as any).ref, newValue]]);\n        } else if (node.left.type === \"Identifier\") {\n          if (options.async && isAwaitable(newValue)) {\n            return newValue.awaitableThen((resolvedValue) => {\n              this.vars[(node.left as any).name] = resolvedValue;\n              return resolvedValue;\n            });\n          }\n          this.vars[(node.left as any).name] = newValue;\n        }\n\n        return newValue;\n      }\n\n      return resolveNode(node.left);\n    }\n  }\n}\n","import { SyncWaterfallHook } from \"tapable-ts\";\nimport type { Schema as SchemaType, Formatting } from \"@player-ui/types\";\n\nimport type { BindingInstance } from \"../binding\";\nimport type { ValidationProvider, ValidationObject } from \"../validator\";\nimport type { FormatDefinition, FormatOptions, FormatType } from \"./types\";\n\n/** A function that returns itself */\nconst identify = (val: any) => val;\n\n/** Expand the authored schema into a set of paths -> DataTypes */\nexport function parse(\n  schema: SchemaType.Schema,\n): Map<string, SchemaType.DataTypes> {\n  const expandedPaths = new Map<string, SchemaType.DataTypes>();\n\n  if (!schema.ROOT) {\n    return expandedPaths;\n  }\n\n  const parseQueue: Array<{\n    /** The node to process */\n    node: SchemaType.Node;\n\n    /** The path in the data-model this node represents */\n    path: Array<string>;\n\n    /** A set of visited DataTypes to prevent loops */\n    visited: Set<string>;\n  }> = [{ node: schema.ROOT, path: [], visited: new Set() }];\n\n  while (parseQueue.length > 0) {\n    const next = parseQueue.shift();\n\n    if (!next) {\n      break;\n    }\n\n    const { node, path, visited } = next;\n\n    Object.entries(node).forEach(([prop, type]) => {\n      const nestedPath = [...path, prop];\n\n      const nestedPathStr = nestedPath.join(\".\");\n\n      if (expandedPaths.has(nestedPathStr)) {\n        // We've gone in a loop. Panic\n        throw new Error(\n          \"Path has already been processed. There's either a loop somewhere or a bug\",\n        );\n      }\n\n      if (visited.has(type.type)) {\n        throw new Error(\n          `Path already contained type: ${type.type}. This likely indicates a loop in the schema`,\n        );\n      }\n\n      expandedPaths.set(nestedPathStr, type);\n\n      if (type.isArray) {\n        nestedPath.push(\"[]\");\n      }\n\n      if (type.isRecord) {\n        nestedPath.push(\"{}\");\n      }\n\n      if (type.type && schema[type.type]) {\n        parseQueue.push({\n          path: nestedPath,\n          node: schema[type.type],\n          visited: new Set([...visited, type.type]),\n        });\n      }\n    });\n  }\n\n  return expandedPaths;\n}\n\n/**\n * The Schema is the central hub for all data invariants, and metaData associated with the data-model itself\n * Outside of the types defined in the JSON payload, it doesn't manage or keep any state.\n * It simply servers as an orchestrator for other modules to interface w/ the schema.\n */\nexport class SchemaController implements ValidationProvider {\n  private formatters: Map<string, FormatType<any, any, FormatOptions>> =\n    new Map();\n\n  private types: Map<string, SchemaType.DataType<any>> = new Map();\n  public readonly schema: Map<string, SchemaType.DataTypes> = new Map();\n\n  private bindingSchemaNormalizedCache: Map<BindingInstance, string> =\n    new Map();\n\n  public readonly hooks = {\n    resolveTypeForBinding: new SyncWaterfallHook<\n      [SchemaType.DataTypes | undefined, BindingInstance]\n    >(),\n  };\n\n  constructor(schema?: SchemaType.Schema) {\n    this.schema = schema ? parse(schema) : new Map();\n  }\n\n  public addFormatters(fns: Array<FormatType<any, any, FormatOptions>>) {\n    fns.forEach((def) => {\n      this.formatters.set(def.name, def);\n    });\n  }\n\n  public addDataTypes(types: Array<SchemaType.DataType<any>>) {\n    types.forEach((t) => {\n      this.types.set(t.type, t);\n    });\n  }\n\n  getValidationsForBinding(\n    binding: BindingInstance,\n  ): Array<ValidationObject> | undefined {\n    const typeDef = this.getApparentType(binding);\n\n    if (!typeDef?.validation?.length) {\n      return undefined;\n    }\n\n    // Set the defaults for schema-level validations\n    return typeDef.validation.map((vRef) => ({\n      severity: \"error\",\n      trigger: \"change\",\n      ...vRef,\n    }));\n  }\n\n  private normalizeBinding(binding: BindingInstance): string {\n    const cached = this.bindingSchemaNormalizedCache.get(binding);\n    if (cached) {\n      return cached;\n    }\n\n    let bindingArray = binding.asArray();\n    let normalized = bindingArray\n      .map((p) => (typeof p === \"number\" ? \"[]\" : p))\n      .join(\".\");\n\n    if (normalized) {\n      this.bindingSchemaNormalizedCache.set(binding, normalized);\n      bindingArray = normalized.split(\".\");\n    }\n\n    bindingArray.forEach((item) => {\n      const recordBinding = bindingArray\n        .map((p) => (p === item ? \"{}\" : p))\n        .join(\".\");\n\n      if (this.schema.get(recordBinding)) {\n        this.bindingSchemaNormalizedCache.set(binding, recordBinding);\n        bindingArray = recordBinding.split(\".\");\n        normalized = recordBinding;\n      }\n    });\n\n    return normalized;\n  }\n\n  public getType(binding: BindingInstance): SchemaType.DataTypes | undefined {\n    return this.hooks.resolveTypeForBinding.call(\n      this.schema.get(this.normalizeBinding(binding)),\n      binding,\n    );\n  }\n\n  public getApparentType(\n    binding: BindingInstance,\n  ): SchemaType.DataTypes | undefined {\n    const schemaType = this.getType(binding);\n\n    if (schemaType === undefined) {\n      return undefined;\n    }\n\n    const baseType = this.getTypeDefinition(schemaType?.type);\n\n    if (baseType === undefined) {\n      return schemaType;\n    }\n\n    return {\n      ...baseType,\n      ...schemaType,\n      validation: [\n        ...(schemaType.validation ?? []),\n        ...(baseType.validation ?? []),\n      ],\n    };\n  }\n\n  public getTypeDefinition(dataType: string) {\n    return this.types.get(dataType);\n  }\n\n  public getFormatterForType(\n    formatReference: Formatting.Reference,\n  ): FormatDefinition<unknown, unknown> | undefined {\n    const { type: formatType, ...options } = formatReference;\n\n    const formatter = this.formatters.get(formatType);\n\n    if (!formatter) {\n      return;\n    }\n\n    return {\n      format: formatter.format\n        ? (val) => formatter.format?.(val, options)\n        : identify,\n      deformat: formatter.deformat\n        ? (val) => formatter.deformat?.(val, options)\n        : identify,\n    };\n  }\n\n  /**\n   * Given a binding, fetch a function that's responsible for formatting, and/or de-formatting the data\n   * If no formatter is registered, it will return undefined\n   */\n  public getFormatter(\n    binding: BindingInstance,\n  ): FormatDefinition<unknown, unknown> | undefined {\n    const type = this.getApparentType(binding);\n\n    if (!type?.format) {\n      return undefined;\n    }\n\n    return this.getFormatterForType(type.format);\n  }\n}\n","import { setIn } from \"timm\";\nimport type { Expression } from \"@player-ui/types\";\nimport type { DataModelWithParser } from \"../data\";\n\nconst DOUBLE_OPEN_CURLY = \"{{\";\nconst DOUBLE_CLOSE_CURLY = \"}}\";\n\nexport interface Options {\n  /**\n   * The model to use when resolving refs\n   * Passing `false` will skip trying to resolve any direct model refs ({{foo}})\n   */\n  model: false | DataModelWithParser;\n\n  /**\n   * A function to evaluate an expression\n   * Passing `false` will skip trying to evaluate any expressions (@[ foo() ]@)\n   */\n  evaluate: false | ((exp: Expression) => any);\n\n  /**\n   * Optionaly resolve binding without formatting in case Type format applies\n   */\n  formatted?: boolean;\n}\n\n/** Search the given string for the coordinates of the next expression to resolve */\nexport function findNextExp(str: string) {\n  const expStart = str.indexOf(DOUBLE_OPEN_CURLY);\n\n  if (expStart === -1) {\n    return undefined;\n  }\n\n  let count = 1;\n  let offset = expStart + DOUBLE_OPEN_CURLY.length;\n  let workingString = str.substring(expStart + DOUBLE_OPEN_CURLY.length);\n\n  while (count > 0 && workingString.length > 0) {\n    // Find the next open or close curly\n    const nextCloseCurly = workingString.indexOf(DOUBLE_CLOSE_CURLY);\n\n    // We can't close anything, so there's no point in going on with life.\n    if (nextCloseCurly === -1) {\n      break;\n    }\n\n    const nextOpenCurly = workingString.indexOf(DOUBLE_OPEN_CURLY);\n\n    if (nextOpenCurly !== -1 && nextOpenCurly < nextCloseCurly) {\n      // We've hit another open bracket before closing out the one we want\n      // Move everything over and bump our close count by 1\n      count++;\n      workingString = workingString.substring(\n        nextOpenCurly + DOUBLE_OPEN_CURLY.length,\n      );\n      offset += nextOpenCurly + DOUBLE_OPEN_CURLY.length;\n    } else {\n      // We've hit another closing bracket\n      // Decrement our count and updates offsets\n      count--;\n      workingString = workingString.substring(\n        nextCloseCurly + DOUBLE_CLOSE_CURLY.length,\n      );\n      offset += nextCloseCurly + DOUBLE_CLOSE_CURLY.length;\n    }\n  }\n\n  if (count !== 0) {\n    throw new Error(`Unbalanced {{ and }} in exp: ${str}`);\n  }\n\n  return {\n    start: expStart,\n    end: offset,\n  };\n}\n\n/** Finds any subset of the string wrapped in @[]@ and evaluates it as an expression */\nexport function resolveExpressionsInString(\n  val: string,\n  { evaluate }: Options,\n): string {\n  if (!evaluate) {\n    return val;\n  }\n\n  const expMatch = /@\\[.*?\\]@/;\n  let newVal = val;\n  let match = newVal.match(expMatch);\n\n  while (match !== null) {\n    const expStrWithBrackets = match[0];\n    const matchStart = newVal.indexOf(expStrWithBrackets);\n\n    const expString = expStrWithBrackets.substr(\n      \"@[\".length,\n      expStrWithBrackets.length - \"@[\".length - \"]@\".length,\n    );\n    const expValue = evaluate(expString);\n\n    // The string is only the expression, return the raw value.\n    if (\n      matchStart === 0 &&\n      expStrWithBrackets === val &&\n      typeof expValue !== \"string\"\n    ) {\n      return expValue;\n    }\n\n    newVal =\n      newVal.substr(0, matchStart) +\n      expValue +\n      newVal.substr(matchStart + expStrWithBrackets.length);\n    // remove the surrounding @[]@ to get the expression\n    match = newVal.match(expMatch);\n  }\n\n  return newVal;\n}\n\n/** Return a string with all data model references resolved */\nexport function resolveDataRefsInString(val: string, options: Options): string {\n  const { model, formatted = true } = options;\n  let workingString = resolveExpressionsInString(val, options);\n\n  if (\n    !model ||\n    typeof workingString !== \"string\" ||\n    workingString.indexOf(DOUBLE_OPEN_CURLY) === -1\n  ) {\n    return workingString;\n  }\n\n  while (workingString.indexOf(DOUBLE_OPEN_CURLY) !== -1) {\n    const expLocation = findNextExp(workingString);\n\n    if (!expLocation) {\n      return workingString;\n    }\n\n    const { start, end } = expLocation;\n\n    // Strip out the wrapping curlies from {{binding}} before passing to the model\n    const binding = workingString\n      .substring(\n        start + DOUBLE_OPEN_CURLY.length,\n        end - DOUBLE_OPEN_CURLY.length,\n      )\n      .trim();\n\n    const evaledVal = model.get(binding, { formatted });\n\n    // Exit early if the string is _just_ a model lookup\n    // If the result is a string, we may need further processing for nested bindings\n    if (\n      start === 0 &&\n      end === workingString.length &&\n      typeof evaledVal !== \"string\"\n    ) {\n      return evaledVal;\n    }\n\n    workingString =\n      workingString.substr(0, start) + evaledVal + workingString.substr(end);\n  }\n\n  return workingString;\n}\n\n/** Traverse the thing and replace any model refs */\nfunction traverseObject<T>(val: T, options: Options): T {\n  switch (typeof val) {\n    case \"string\": {\n      return resolveDataRefsInString(val as string, options) as unknown as T;\n    }\n\n    case \"object\": {\n      if (!val) return val;\n      // TODO: Do we care refs in keys?\n      const keys = Object.keys(val);\n      let newVal = val;\n\n      if (keys.length > 0) {\n        keys.forEach((key) => {\n          newVal = setIn(\n            newVal as any,\n            [key],\n            traverseObject((val as any)[key], options),\n          ) as any;\n        });\n      }\n\n      return newVal;\n    }\n\n    default:\n      return val;\n  }\n}\n\n/** Recursively resolve all model refs in whatever you pass in */\nexport function resolveDataRefs<T>(val: T, options: Options): T {\n  return traverseObject(val, options);\n}\n","import type { BindingInstance } from \"../binding\";\n\n/**\n * Remove a binding, and any children from from the map\n * If the binding is an array-item, then it will be spliced from the array and the others will be shifted down\n *\n * @param sourceMap - A map of bindings to values\n * @param binding - The binding to remove from the map\n */\nexport function removeBindingAndChildrenFromMap<T>(\n  sourceMap: Map<BindingInstance, T>,\n  binding: BindingInstance,\n): Map<BindingInstance, T> {\n  const targetMap = new Map(sourceMap);\n\n  const parentBinding = binding.parent();\n  const property = binding.key();\n\n  // Clear out any that are sub-bindings of this binding\n\n  targetMap.forEach((_value, trackedBinding) => {\n    if (binding === trackedBinding || binding.contains(trackedBinding)) {\n      targetMap.delete(trackedBinding);\n    }\n  });\n\n  if (typeof property === \"number\") {\n    // Splice out this index from the rest\n\n    // Order matters here b/c we are shifting items in the array\n    // Start with the smallest index and work our way down\n    const bindingsToRewrite = Array.from(sourceMap.keys())\n      .filter((b) => {\n        if (parentBinding.contains(b)) {\n          const [childIndex] = b.relative(parentBinding);\n          return typeof childIndex === \"number\" && childIndex > property;\n        }\n\n        return false;\n      })\n      .sort();\n\n    bindingsToRewrite.forEach((trackedBinding) => {\n      // If the tracked binding is a sub-binding of the parent binding, then we need to\n      // update the path to reflect the new index\n\n      const [childIndex, ...childPath] = trackedBinding.relative(parentBinding);\n\n      if (typeof childIndex === \"number\") {\n        const newSegments = [childIndex - 1, ...childPath];\n        const newChildBinding = parentBinding.descendent(newSegments);\n        targetMap.set(newChildBinding, targetMap.get(trackedBinding) as T);\n        targetMap.delete(trackedBinding);\n      }\n    });\n  }\n\n  return targetMap;\n}\n","import type { Node } from \"./types\";\n\n/**\n * Checks if there are templated values in the object\n *\n * @param obj - The Parsed Object to check to see if we have a template array type for\n * @param localKey - The key being checked\n */\nexport function hasTemplateValues(obj: any, localKey: string) {\n  return (\n    Object.hasOwnProperty.call(obj, \"template\") &&\n    Array.isArray(obj?.template) &&\n    obj.template.length &&\n    obj.template.find((tmpl: any) => tmpl.output === localKey)\n  );\n}\n\n/** Check to see if the string is a valid switch key */\nexport function hasSwitchKey(localKey: string) {\n  return localKey === \"staticSwitch\" || localKey === \"dynamicSwitch\";\n}\n\n/** Check to see if the string is a valid template key */\nexport function hasTemplateKey(localKey: string) {\n  return localKey === \"template\";\n}\n\n/** Get the ID of the Node if there is one */\nexport function getNodeID(node?: Node.Node | null): string | undefined {\n  if (!node) {\n    return;\n  }\n\n  if (\n    \"value\" in node &&\n    typeof node.value === \"object\" &&\n    typeof node.value?.id === \"string\"\n  ) {\n    return node.value.id;\n  }\n}\n","import type { BindingInstance, BindingLike } from \"../../binding\";\nimport { isBinding } from \"../../binding\";\nimport type { ExpressionType } from \"../../expressions\";\nimport type { Resolve } from \"./types\";\n\n/** Check to see if and of the data-changes affect the given dependencies  */\nexport function caresAboutDataChanges(\n  dataChanges?: Set<BindingInstance>,\n  dependencies?: Set<BindingInstance>,\n) {\n  if (!dataChanges || !dependencies) {\n    return true;\n  }\n\n  const depArray = Array.from(dependencies.values());\n  const dataChangeArray = Array.from(dataChanges.values());\n\n  return (\n    depArray.find(\n      (dep) =>\n        !!dataChangeArray.find(\n          (change) =>\n            change === dep || change.contains(dep) || dep.contains(change),\n        ),\n    ) !== undefined\n  );\n}\n\n/** Convert the options object for a resolver to one for a node */\nexport function toNodeResolveOptions(\n  resolverOptions: Resolve.ResolverOptions,\n): Resolve.NodeResolveOptions {\n  return {\n    ...resolverOptions,\n    data: {\n      model: resolverOptions.model,\n      formatValue: (ref, value) => {\n        if (resolverOptions.formatValue) {\n          return resolverOptions.formatValue(ref, value);\n        }\n\n        return value;\n      },\n      format: (bindingLike: BindingLike, value: any) =>\n        resolverOptions.format\n          ? resolverOptions.format(\n              isBinding(bindingLike)\n                ? bindingLike\n                : resolverOptions.parseBinding(bindingLike),\n              value,\n            )\n          : value,\n    },\n    evaluate: (exp: ExpressionType) =>\n      resolverOptions.evaluator.evaluate(exp, resolverOptions),\n  };\n}\n","import { set } from \"timm\";\nimport { resolveDataRefs } from \"../../string-resolver\";\nimport type { Options } from \"./options\";\nimport type { Node } from \"../parser\";\nimport { NodeType } from \"../parser\";\nimport type { Resolver } from \"../resolver\";\nimport { ViewInstance, ViewPlugin } from \"../view\";\n\n/** Create a function that checks for a start/end sequence in a string */\nconst createPatternMatcher = (start: string, end: string) => {\n  return (testStr: string) => {\n    const startLocation = testStr.indexOf(start);\n\n    if (startLocation === -1) {\n      return false;\n    }\n\n    const endLocation = testStr.indexOf(end);\n\n    if (endLocation === -1) {\n      return false;\n    }\n\n    return startLocation < endLocation;\n  };\n};\n\nconst bindingResolveLookup = createPatternMatcher(\"{{\", \"}}\");\nconst expressionResolveLookup = createPatternMatcher(\"@[\", \"]@\");\n\n/** Check to see if a string contains a reference to dynamic content */\nfunction hasSomethingToResolve(str: string) {\n  return bindingResolveLookup(str) || expressionResolveLookup(str);\n}\n\n/** Resolve data refs in a string if necessary. */\nfunction resolveString(str: string, resolveOptions: Options) {\n  return hasSomethingToResolve(str)\n    ? resolveDataRefs(str, {\n        model: resolveOptions.data.model,\n        evaluate: resolveOptions.evaluate,\n      })\n    : str;\n}\n\n/** Recursively resolve all string references in an object or array */\nexport function resolveAllRefs(\n  node: any,\n  resolveOptions: Options,\n  propertiesToSkip: Set<string | number>,\n): any {\n  if (\n    node === null ||\n    node === undefined ||\n    (typeof node !== \"object\" && typeof node !== \"string\")\n  ) {\n    return node;\n  }\n\n  if (typeof node === \"string\") {\n    return resolveString(node, resolveOptions);\n  }\n\n  let newNode = node;\n\n  Object.keys(node).forEach((key: string | number) => {\n    if (propertiesToSkip.has(key)) {\n      return;\n    }\n\n    const val = node[key];\n\n    let newVal = val;\n\n    if (typeof val === \"object\") {\n      newVal = resolveAllRefs(val, resolveOptions, propertiesToSkip);\n    } else if (typeof val === \"string\") {\n      newVal = resolveString(val, resolveOptions);\n    }\n\n    if (newVal !== val) {\n      newNode = set(newNode, key as any, newVal);\n    }\n  });\n\n  return newNode;\n}\n\n/** Traverse up the node tree finding the first available 'path' */\nconst findBasePath = (\n  node: Node.Node,\n  resolver: Resolver,\n): Node.PathSegment[] => {\n  const parentNode = node.parent;\n  if (!parentNode) {\n    return [];\n  }\n\n  if (\"children\" in parentNode) {\n    const original = resolver.getSourceNode(node);\n    return (\n      parentNode.children?.find((child) => child.value === original)?.path ?? []\n    );\n  }\n\n  if (parentNode.type !== NodeType.MultiNode) {\n    return [];\n  }\n\n  return findBasePath(parentNode, resolver);\n};\n\n/** A plugin that resolves all string references for each node */\nexport class StringResolverPlugin implements ViewPlugin {\n  private propertiesToSkipCache: Map<string, Set<string>>;\n\n  constructor() {\n    this.propertiesToSkipCache = new Map();\n  }\n\n  applyResolver(resolver: Resolver) {\n    resolver.hooks.resolve.tap(\"string-resolver\", (value, node, options) => {\n      if (node.type === NodeType.Empty || node.type === NodeType.Unknown) {\n        return null;\n      }\n\n      if (\n        node.type === NodeType.Value ||\n        node.type === NodeType.Asset ||\n        node.type === NodeType.View\n      ) {\n        /** Use specified properties to skip during string resolution, or default */\n        let propsToSkip: Set<string>;\n        if (node.type === NodeType.Asset || node.type === NodeType.View) {\n          propsToSkip = new Set(\n            node.plugins?.stringResolver?.propertiesToSkip ?? [\"exp\"],\n          );\n          if (node.value?.id) {\n            this.propertiesToSkipCache.set(node.value.id, propsToSkip);\n          }\n        } else if (\n          node.parent?.type === NodeType.MultiNode &&\n          (node.parent?.parent?.type === NodeType.Asset ||\n            node.parent?.parent?.type === NodeType.View) &&\n          node.parent.parent.value?.id &&\n          this.propertiesToSkipCache.has(node.parent.parent.value.id)\n        ) {\n          propsToSkip = this.propertiesToSkipCache.get(\n            node.parent.parent.value.id,\n          ) as Set<string>;\n        } else {\n          propsToSkip = new Set([\"exp\"]);\n        }\n\n        const nodePath = findBasePath(node, resolver);\n\n        /** If the path includes something that is supposed to be skipped, this node should be skipped too. */\n        if (\n          nodePath.length > 0 &&\n          nodePath.some((segment) => propsToSkip.has(segment.toString()))\n        ) {\n          return node.value;\n        }\n\n        return resolveAllRefs(node.value, options, propsToSkip);\n      }\n\n      return value;\n    });\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.resolver.tap(\"string-resolver\", this.applyResolver.bind(this));\n  }\n}\n","const ANY_CHAR_REGEX = /%([a-zA-Z]+)/g;\n\n/**\n * Replaces %num in message with the provided parameters in order.\n *\n * @param message - Parameterized string like \"This is a %1\"\n * @param params - Parameters to replace in message E.g. ['tax2021.amount']\n * @returns A message with the parameters replaced.\n */\nexport function replaceParams(\n  message: string,\n  params: Record<string, any>,\n): string {\n  return message\n    .slice()\n    .replace(ANY_CHAR_REGEX, (keyExpr) => params[keyExpr.slice(1)] || keyExpr);\n}\n","import type { Validation } from \"@player-ui/types\";\nimport { SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport { setIn } from \"timm\";\n\nimport type { BindingInstance, BindingFactory } from \"../../binding\";\nimport { isBinding } from \"../../binding\";\nimport type { DataModelWithParser, DataModelMiddleware } from \"../../data\";\nimport type { SchemaController } from \"../../schema\";\nimport type {\n  ErrorValidationResponse,\n  ValidationObject,\n  ValidationObjectWithHandler,\n  ValidatorContext,\n  ValidationProvider,\n  ValidationResponse,\n  WarningValidationResponse,\n  StrongOrWeakBinding,\n} from \"../../validator\";\nimport {\n  ValidationMiddleware,\n  ValidatorRegistry,\n  removeBindingAndChildrenFromMap,\n} from \"../../validator\";\nimport type { Logger } from \"../../logger\";\nimport { ProxyLogger } from \"../../logger\";\nimport type { Resolve, ViewInstance } from \"../../view\";\nimport { caresAboutDataChanges } from \"../../view\";\nimport { replaceParams } from \"../../utils\";\nimport { resolveDataRefs } from \"../../string-resolver\";\nimport type {\n  ExpressionEvaluatorOptions,\n  ExpressionType,\n} from \"../../expressions\";\nimport type { BindingTracker } from \"./binding-tracker\";\nimport { ValidationBindingTrackerViewPlugin } from \"./binding-tracker\";\n\nexport const SCHEMA_VALIDATION_PROVIDER_NAME = \"schema\";\nexport const VIEW_VALIDATION_PROVIDER_NAME = \"view\";\n\nexport const VALIDATION_PROVIDER_NAME_SYMBOL: unique symbol = Symbol.for(\n  \"validation-provider-name\",\n);\n\nexport type ValidationObjectWithSource = ValidationObjectWithHandler & {\n  /** The name of the validation */\n  [VALIDATION_PROVIDER_NAME_SYMBOL]: string;\n};\n\ntype SimpleValidatorContext = Omit<\n  ValidatorContext,\n  \"validation\" | \"schemaType\"\n>;\n\ninterface BaseActiveValidation<T> {\n  /** The validation is being actively shown */\n  state: \"active\";\n\n  /** The validation response */\n  response: T;\n}\n\ntype ActiveWarning = BaseActiveValidation<WarningValidationResponse> & {\n  /** Warnings track if they can be dismissed automatically (by navigating) */\n  dismissable: boolean;\n};\ntype ActiveError = BaseActiveValidation<ErrorValidationResponse>;\n\n/**\n * warnings that keep track of their active state\n */\ntype StatefulWarning = {\n  /** A common key to differentiate between errors and warnings */\n  type: \"warning\";\n\n  /** The underlying validation this tracks */\n  value: ValidationObjectWithSource;\n\n  /** If this is currently preventing navigation from continuing */\n  isBlockingNavigation: boolean;\n} & (\n  | {\n      /** warnings start with no state, but can active or dismissed */\n      state: \"none\" | \"dismissed\";\n    }\n  | ActiveWarning\n);\n\n/** Errors that keep track of their state */\ntype StatefulError = {\n  /** A common key to differentiate between errors and warnings */\n  type: \"error\";\n\n  /** The underlying validation this tracks */\n  value: ValidationObjectWithSource;\n\n  /** If this is currently preventing navigation from continuing */\n  isBlockingNavigation: boolean;\n} & (\n  | {\n      /** Errors start with no state an can be activated */\n      state: \"none\";\n    }\n  | ActiveError\n);\n\nexport type StatefulValidationObject = StatefulWarning | StatefulError;\n\n/** Helper function to determin if the subset is within the containingSet */\nfunction isSubset<T>(subset: Set<T>, containingSet: Set<T>): boolean {\n  if (subset.size > containingSet.size) return false;\n  for (const entry of subset) if (!containingSet.has(entry)) return false;\n  return true;\n}\n\n/** Helper for initializing a validation object that tracks state */\nfunction createStatefulValidationObject(\n  obj: ValidationObjectWithSource,\n): StatefulValidationObject {\n  return {\n    value: obj,\n    type: obj.severity,\n    state: \"none\",\n    isBlockingNavigation: false,\n  };\n}\n\ntype ValidationRunner = (obj: ValidationObjectWithHandler) =>\n  | {\n      /** A validation message */\n      message: string;\n    }\n  | undefined;\n\n/** A class that manages validating bindings across phases */\nclass ValidatedBinding {\n  public currentPhase?: Validation.Trigger;\n  private applicableValidations: Array<StatefulValidationObject> = [];\n  private validationsByState: Record<\n    Validation.Trigger,\n    Array<StatefulValidationObject>\n  > = {\n    load: [],\n    change: [],\n    navigation: [],\n  };\n\n  public get allValidations(): Array<StatefulValidationObject> {\n    return Object.values(this.validationsByState).flat();\n  }\n\n  public weakBindings: Set<BindingInstance>;\n\n  private onDismiss?: () => void;\n\n  constructor(\n    possibleValidations: Array<ValidationObjectWithSource>,\n    onDismiss?: () => void,\n    log?: Logger,\n    weakBindings?: Set<BindingInstance>,\n  ) {\n    this.onDismiss = onDismiss;\n    possibleValidations.forEach((vObj) => {\n      const { trigger } = vObj;\n\n      if (this.validationsByState[trigger]) {\n        const statefulValidationObject = createStatefulValidationObject(vObj);\n        this.validationsByState[trigger].push(statefulValidationObject);\n      } else {\n        log?.warn(`Unknown validation trigger: ${trigger}`);\n      }\n    });\n    this.weakBindings = weakBindings ?? new Set();\n  }\n\n  private checkIfBlocking(statefulObj: StatefulValidationObject) {\n    if (statefulObj.state === \"active\") {\n      const { isBlockingNavigation } = statefulObj;\n      return isBlockingNavigation;\n    }\n\n    return false;\n  }\n\n  public getAll(): Array<ValidationResponse> {\n    return this.applicableValidations.reduce((all, statefulObj) => {\n      if (statefulObj.state === \"active\" && statefulObj.response) {\n        all.push({\n          ...statefulObj.response,\n          blocking: this.checkIfBlocking(statefulObj),\n        });\n      }\n\n      return all;\n    }, [] as Array<ValidationResponse>);\n  }\n\n  public get(): ValidationResponse | undefined {\n    const firstInvalid = this.applicableValidations.find((statefulObj) => {\n      return statefulObj.state === \"active\" && statefulObj.response;\n    });\n\n    if (firstInvalid?.state === \"active\") {\n      return {\n        ...firstInvalid.response,\n        blocking: this.checkIfBlocking(firstInvalid),\n      };\n    }\n  }\n\n  private runApplicableValidations(\n    runner: ValidationRunner,\n    canDismiss: boolean,\n    phase: Validation.Trigger,\n  ) {\n    // If the currentState is not load, skip those\n    this.applicableValidations = this.applicableValidations.map(\n      (originalValue) => {\n        if (originalValue.state === \"dismissed\") {\n          // Don't rerun any dismissed warnings\n          return originalValue;\n        }\n\n        // treat all warnings the same and block it once (unless blocking is true)\n        const blocking =\n          originalValue.value.blocking ??\n          ((originalValue.value.severity === \"warning\" && \"once\") || true);\n\n        const obj = setIn(\n          originalValue,\n          [\"value\", \"blocking\"],\n          blocking,\n        ) as StatefulValidationObject;\n\n        const isBlockingNavigation =\n          blocking === true || (blocking === \"once\" && !canDismiss);\n\n        if (\n          phase === \"navigation\" &&\n          obj.state === \"active\" &&\n          obj.value.blocking !== true\n        ) {\n          if (obj.value.severity === \"warning\") {\n            const warn = obj as ActiveWarning;\n            if (\n              warn.dismissable &&\n              warn.response.dismiss &&\n              (warn.response.blocking !== \"once\" || !warn.response.blocking)\n            ) {\n              warn.response.dismiss();\n            } else {\n              if (warn?.response.blocking === \"once\") {\n                warn.response.blocking = false;\n              }\n\n              warn.dismissable = true;\n            }\n\n            return warn as StatefulValidationObject;\n          }\n        }\n\n        const response = runner(obj.value);\n\n        const newState = {\n          type: obj.type,\n          value: obj.value,\n          state: response ? \"active\" : \"none\",\n          isBlockingNavigation,\n          dismissable:\n            obj.value.severity === \"warning\" && phase === \"navigation\",\n          response: response\n            ? {\n                ...obj.value,\n                message: response.message ?? \"Something is broken\",\n                severity: obj.value.severity,\n                displayTarget: obj.value.displayTarget ?? \"field\",\n              }\n            : undefined,\n        } as StatefulValidationObject;\n\n        if (newState.state === \"active\" && obj.value.severity === \"warning\") {\n          (newState.response as WarningValidationResponse).dismiss = () => {\n            (newState as StatefulWarning).state = \"dismissed\";\n            this.onDismiss?.();\n          };\n        }\n\n        return newState;\n      },\n    );\n  }\n\n  public update(\n    phase: Validation.Trigger,\n    canDismiss: boolean,\n    runner: ValidationRunner,\n  ) {\n    const newApplicableValidations: StatefulValidationObject[] = [];\n\n    if (phase === \"load\" && this.currentPhase !== undefined) {\n      // Tried to run the 'load' phase twice. Aborting\n      return;\n    }\n\n    if (this.currentPhase === \"navigation\" || phase === this.currentPhase) {\n      // Already added all the types. No need to continue adding new validations\n      this.runApplicableValidations(runner, canDismiss, phase);\n      return;\n    }\n\n    if (phase === \"load\") {\n      this.currentPhase = \"load\";\n      this.applicableValidations = [...this.validationsByState.load];\n    } else if (phase === \"change\" && this.currentPhase === \"load\") {\n      this.currentPhase = \"change\";\n      // The transition to the 'change' type can only come from a 'load' type\n      this.applicableValidations = [\n        ...this.applicableValidations,\n        ...this.validationsByState.change,\n      ];\n    } else if (\n      phase === \"navigation\" &&\n      (this.currentPhase === \"load\" || this.currentPhase === \"change\")\n    ) {\n      // Can transition to a nav state from a change or load\n\n      // if there is an non-blocking error that is active then remove the error from applicable validations so it can no longer be shown\n      // which is needed if there are additional warnings to become active for that binding after the error is shown\n      this.applicableValidations.forEach((element) => {\n        if (\n          !(\n            element.type === \"error\" &&\n            element.state === \"active\" &&\n            element.isBlockingNavigation === false\n          )\n        ) {\n          newApplicableValidations.push(element);\n        }\n      });\n\n      this.applicableValidations = [\n        ...newApplicableValidations,\n        ...this.validationsByState.navigation,\n        ...(this.currentPhase === \"load\" ? this.validationsByState.change : []),\n      ];\n      this.currentPhase = \"navigation\";\n    }\n\n    this.runApplicableValidations(runner, canDismiss, phase);\n  }\n}\n\n/**\n * A controller for orchestrating validation within a running player\n *\n * The current validation flow is as follows:\n *\n *   - When a binding is first seen, gather all of the possible validations for it from the providers\n *     - Schema and Crossfield (view) are both providers of possible validations\n *     - Run all of the applicable validations for that binding for the `load` trigger\n *\n *   - When a change occurs, set the phase of the binding to `change`.\n *     - Run all of the `change` triggered validations for that binding.\n *\n *   - When a navigation event occurs, set the phase of the binding to `navigate`.\n *     - Run all `change` and `navigate` validations for each tracked binding.\n *     - For any warnings, also keep a state of `shown` or `dismissed`.\n *       - Set all non-dismissed warnings to `shown`.\n *       - Set all `shown` warnings to `dismissed`.\n *     - Allow navigation forward if there are no non-dismissed warnings and no valid errors.\n */\nexport class ValidationController implements BindingTracker {\n  public readonly hooks = {\n    /** A hook called to tap into the validator registry for adding more validators */\n    createValidatorRegistry: new SyncHook<[ValidatorRegistry]>(),\n\n    /** A callback/event when a new validation is added to the view */\n    onAddValidation: new SyncWaterfallHook<\n      [ValidationResponse, BindingInstance]\n    >(),\n\n    /** The inverse of onAddValidation, this is called when a validation is removed from the list */\n    onRemoveValidation: new SyncWaterfallHook<\n      [ValidationResponse, BindingInstance]\n    >(),\n\n    resolveValidationProviders: new SyncWaterfallHook<\n      [\n        Array<{\n          /** The name of the provider */\n          source: string;\n          /** The provider itself */\n          provider: ValidationProvider;\n        }>,\n      ],\n      {\n        /** The view this is triggered for  */\n        view?: ViewInstance;\n      }\n    >(),\n\n    /** A hook called when a binding is added to the tracker */\n    onTrackBinding: new SyncHook<[BindingInstance]>(),\n  };\n\n  private tracker: BindingTracker | undefined;\n  private validations = new Map<BindingInstance, ValidatedBinding>();\n  private validatorRegistry?: ValidatorRegistry;\n  private schema: SchemaController;\n\n  private providers:\n    | Array<{\n        /** The name of the provider */\n        source: string;\n        /** The provider itself */\n        provider: ValidationProvider;\n      }>\n    | undefined;\n\n  private viewValidationProvider?: ValidationProvider;\n  private options?: SimpleValidatorContext;\n  private weakBindingTracker = new Set<BindingInstance>();\n\n  constructor(schema: SchemaController, options?: SimpleValidatorContext) {\n    this.schema = schema;\n    this.options = options;\n    this.reset();\n  }\n\n  setOptions(options: SimpleValidatorContext) {\n    this.options = options;\n  }\n\n  /** Return the middleware for the data-model to stop propagation of invalid data */\n  public getDataMiddleware(): Array<DataModelMiddleware> {\n    return [\n      {\n        set: (transaction, options, next) => {\n          return next?.set(transaction, options) ?? [];\n        },\n        get: (binding, options, next) => {\n          return next?.get(binding, options);\n        },\n        delete: (binding, options, next) => {\n          this.validations = removeBindingAndChildrenFromMap(\n            this.validations,\n            binding,\n          );\n\n          return next?.delete(binding, options);\n        },\n      },\n      new ValidationMiddleware(\n        (binding) => {\n          if (!this.options) {\n            return;\n          }\n\n          this.updateValidationsForBinding(binding, \"change\", this.options);\n          const strongValidation = this.getValidationForBinding(binding);\n\n          // return validation issues directly on bindings first\n          if (strongValidation?.get()?.severity === \"error\") {\n            return strongValidation.get();\n          }\n\n          // if none, check to see any validations this binding may be a weak ref of and return\n          const newInvalidBindings: Set<StrongOrWeakBinding> = new Set();\n          this.validations.forEach((weakValidation, strongBinding) => {\n            if (\n              caresAboutDataChanges(\n                new Set([binding]),\n                weakValidation.weakBindings,\n              ) &&\n              weakValidation?.get()?.severity === \"error\"\n            ) {\n              weakValidation?.weakBindings.forEach((weakBinding) => {\n                if (weakBinding === strongBinding) {\n                  newInvalidBindings.add({\n                    binding: weakBinding,\n                    isStrong: true,\n                  });\n                } else {\n                  newInvalidBindings.add({\n                    binding: weakBinding,\n                    isStrong: false,\n                  });\n                }\n              });\n            }\n          });\n\n          if (newInvalidBindings.size > 0) {\n            return newInvalidBindings;\n          }\n        },\n        { logger: new ProxyLogger(() => this.options?.logger) },\n      ),\n    ];\n  }\n\n  private getValidationProviders() {\n    if (this.providers) {\n      return this.providers;\n    }\n\n    this.providers = this.hooks.resolveValidationProviders.call([\n      {\n        source: SCHEMA_VALIDATION_PROVIDER_NAME,\n        provider: this.schema,\n      },\n      {\n        source: VIEW_VALIDATION_PROVIDER_NAME,\n        provider: {\n          getValidationsForBinding: (\n            binding: BindingInstance,\n          ): Array<ValidationObject> | undefined => {\n            return this.viewValidationProvider?.getValidationsForBinding?.(\n              binding,\n            );\n          },\n\n          getValidationsForView: (): Array<ValidationObject> | undefined => {\n            return this.viewValidationProvider?.getValidationsForView?.();\n          },\n        },\n      },\n    ]);\n\n    return this.providers;\n  }\n\n  public reset() {\n    this.validations.clear();\n    this.tracker = undefined;\n  }\n\n  public onView(view: ViewInstance): void {\n    this.validations.clear();\n    if (!this.options) {\n      return;\n    }\n\n    const bindingTrackerPlugin = new ValidationBindingTrackerViewPlugin({\n      ...this.options,\n      callbacks: {\n        onAdd: (binding) => {\n          if (\n            !this.options ||\n            this.getValidationForBinding(binding) !== undefined\n          ) {\n            return;\n          }\n\n          // Set the default value for the binding if we need to\n          const originalValue = this.options.model.get(binding);\n          const withoutDefault = this.options.model.get(binding, {\n            ignoreDefaultValue: true,\n          });\n\n          if (originalValue !== withoutDefault) {\n            // Don't trigger updates when setting the default value\n            this.options.model.set([[binding, originalValue]], {\n              silent: true,\n            });\n          }\n\n          this.updateValidationsForBinding(\n            binding,\n            \"load\",\n            this.options,\n            () => {\n              view.update(new Set([binding]));\n            },\n          );\n\n          this.hooks.onTrackBinding.call(binding);\n        },\n      },\n    });\n\n    this.tracker = bindingTrackerPlugin;\n    this.viewValidationProvider = view;\n\n    bindingTrackerPlugin.apply(view);\n  }\n\n  updateValidationsForBinding(\n    binding: BindingInstance,\n    trigger: Validation.Trigger,\n    validationContext?: SimpleValidatorContext,\n    onDismiss?: () => void,\n  ): void {\n    const context = validationContext ?? this.options;\n\n    if (!context) {\n      throw new Error(`Context is required for executing validations`);\n    }\n\n    if (trigger === \"load\") {\n      // Get all of the validations from each provider\n      const possibleValidations = this.getValidationProviders().reduce<\n        Array<ValidationObjectWithSource>\n      >((vals, provider) => {\n        vals.push(\n          ...(provider.provider\n            .getValidationsForBinding?.(binding)\n            ?.map((valObj) => ({\n              ...valObj,\n              [VALIDATION_PROVIDER_NAME_SYMBOL]: provider.source,\n            })) ?? []),\n        );\n\n        return vals;\n      }, []);\n\n      if (possibleValidations.length === 0) {\n        return;\n      }\n\n      this.validations.set(\n        binding,\n        new ValidatedBinding(\n          possibleValidations,\n          onDismiss,\n          this.options?.logger,\n        ),\n      );\n    }\n\n    const trackedValidations = this.validations.get(binding);\n    trackedValidations?.update(trigger, true, (validationObj) => {\n      const response = this.validationRunner(validationObj, binding, context);\n\n      if (this.weakBindingTracker.size > 0) {\n        const t = this.validations.get(binding) as ValidatedBinding;\n        this.weakBindingTracker.forEach((b) => t.weakBindings.add(b));\n      }\n\n      return response ? { message: response.message } : undefined;\n    });\n\n    // Also run any validations that binding or sub-binding is a weak binding of\n    if (trigger !== \"load\") {\n      this.validations.forEach((validation, vBinding) => {\n        if (\n          vBinding !== binding &&\n          caresAboutDataChanges(new Set([binding]), validation.weakBindings)\n        ) {\n          validation.update(trigger, true, (validationObj) => {\n            const response = this.validationRunner(\n              validationObj,\n              vBinding,\n              context,\n            );\n            return response ? { message: response.message } : undefined;\n          });\n        }\n      });\n    }\n  }\n\n  validationRunner(\n    validationObj: ValidationObjectWithHandler,\n    binding: BindingInstance,\n    context: SimpleValidatorContext | undefined = this.options,\n  ) {\n    if (!context) {\n      throw new Error(\"No context provided to validation runner\");\n    }\n\n    const handler =\n      validationObj.handler ?? this.getValidator(validationObj.type);\n\n    const weakBindings = new Set<BindingInstance>();\n\n    // For any data-gets in the validation runner, default to using the _invalid_ value (since that's what we're testing against)\n    const model: DataModelWithParser = {\n      get(b, options) {\n        weakBindings.add(isBinding(b) ? binding : context.parseBinding(b));\n        return context.model.get(b, { ...options, includeInvalid: true });\n      },\n      set: context.model.set,\n      delete: context.model.delete,\n    };\n\n    const result = handler?.(\n      {\n        ...context,\n        evaluate: (\n          exp: ExpressionType,\n          options: ExpressionEvaluatorOptions = { model },\n        ) => context.evaluate(exp, options),\n        model,\n        validation: validationObj,\n        schemaType: this.schema.getType(binding),\n      },\n      context.model.get(binding, {\n        includeInvalid: true,\n        formatted: validationObj.dataTarget === \"formatted\",\n      }),\n      validationObj,\n    );\n\n    this.weakBindingTracker = weakBindings;\n\n    if (result) {\n      let { message } = result;\n      const { parameters } = result;\n\n      if (validationObj.message) {\n        message = resolveDataRefs(validationObj.message, {\n          model,\n          evaluate: context.evaluate,\n        });\n        if (parameters) {\n          message = replaceParams(message, parameters);\n        }\n      }\n\n      return {\n        message,\n      };\n    }\n  }\n\n  private updateValidationsForView(trigger: Validation.Trigger): void {\n    const isNavigationTrigger = trigger === \"navigation\";\n    const lastActiveBindings = this.activeBindings;\n\n    /** Run validations for all bindings in view */\n    const updateValidations = (dismissValidations: boolean) => {\n      this.getBindings().forEach((binding) => {\n        this.validations\n          .get(binding)\n          ?.update(trigger, dismissValidations, (obj) => {\n            if (!this.options) {\n              return;\n            }\n\n            return this.validationRunner(obj, binding, this.options);\n          });\n      });\n    };\n\n    // Should dismiss for non-navigation triggers.\n    updateValidations(!isNavigationTrigger);\n\n    if (isNavigationTrigger) {\n      // If validations didn't change since last update, dismiss all dismissible validations.\n      const { activeBindings } = this;\n      if (isSubset(activeBindings, lastActiveBindings)) {\n        updateValidations(true);\n      }\n    }\n  }\n\n  private get activeBindings(): Set<BindingInstance> {\n    return new Set(\n      Array.from(this.getBindings()).filter(\n        (b) => this.validations.get(b)?.get() !== undefined,\n      ),\n    );\n  }\n\n  public getValidator(type: string) {\n    if (this.validatorRegistry) {\n      return this.validatorRegistry.get(type);\n    }\n\n    const registry = new ValidatorRegistry();\n    this.hooks.createValidatorRegistry.call(registry);\n    this.validatorRegistry = registry;\n\n    return registry.get(type);\n  }\n\n  getBindings(): Set<BindingInstance> {\n    return this.tracker?.getBindings() ?? new Set();\n  }\n\n  trackBinding(binding: BindingInstance): void {\n    this.tracker?.trackBinding(binding);\n  }\n\n  /** Executes all known validations for the tracked bindings using the given model */\n  validateView(trigger: Validation.Trigger = \"navigation\"): {\n    /** Indicating if the view can proceed without error */\n    canTransition: boolean;\n\n    /** the validations that are preventing the view from continuing */\n    validations?: Map<BindingInstance, ValidationResponse>;\n  } {\n    this.updateValidationsForView(trigger);\n\n    const validations = new Map<BindingInstance, ValidationResponse>();\n\n    let canTransition = true;\n\n    this.getBindings().forEach((b) => {\n      const allValidations = this.getValidationForBinding(b)?.getAll();\n\n      allValidations?.forEach((v) => {\n        if (trigger === \"navigation\" && v.blocking) {\n          this.options?.logger.debug(\n            `Validation on binding: ${b.asString()} is preventing navigation. ${JSON.stringify(\n              v,\n            )}`,\n          );\n\n          canTransition = false;\n        }\n\n        if (!validations.has(b)) {\n          validations.set(b, v);\n        }\n      });\n    });\n\n    return {\n      canTransition,\n      validations: validations.size ? validations : undefined,\n    };\n  }\n\n  /** Get the current tracked validation for the given binding */\n  public getValidationForBinding(\n    binding: BindingInstance,\n  ): ValidatedBinding | undefined {\n    return this.validations.get(binding);\n  }\n\n  forView(parser: BindingFactory): Resolve.Validation {\n    return {\n      _getValidationForBinding: (binding) => {\n        return this.getValidationForBinding(\n          isBinding(binding) ? binding : parser(binding),\n        );\n      },\n      getAll: () => {\n        const bindings = this.getBindings();\n        if (bindings.size === 0) {\n          return undefined;\n        }\n\n        const validationMapping = new Map<\n          BindingInstance,\n          ValidationResponse\n        >();\n\n        bindings.forEach((b) => {\n          const validation = this.getValidationForBinding(b)?.get();\n\n          if (validation) {\n            validationMapping.set(b, validation);\n          }\n        });\n\n        return validationMapping.size === 0 ? undefined : validationMapping;\n      },\n      get() {\n        throw new Error(\"Error Access be provided by the view plugin\");\n      },\n      getValidationsForBinding() {\n        throw new Error(\"Error rollup should be provided by the view plugin\");\n      },\n      getChildren() {\n        throw new Error(\"Error rollup should be provided by the view plugin\");\n      },\n      getValidationsForSection() {\n        throw new Error(\"Error rollup should be provided by the view plugin\");\n      },\n      track: () => {\n        throw new Error(\"Tracking should be provided by the view plugin\");\n      },\n      register: () => {\n        throw new Error(\n          \"Section functionality should be provided by the view plugin\",\n        );\n      },\n      type: (binding) =>\n        this.schema.getType(isBinding(binding) ? binding : parser(binding)),\n    };\n  }\n}\n","import { BindingInstance } from \"../../binding\";\n\n/** Recursively flattens a nested object to be an object of depth 1 with keys being the full path in the orginal object */\nexport function flatten(obj: any, roots: [string][] = [], sep = \".\"): any {\n  return (\n    Object\n      // find props of given object\n      .keys(obj)\n      // return an object by iterating props\n      .reduce(\n        (memo, prop) => ({\n          // create a new object\n\n          // include previously returned object\n          ...memo,\n          ...(Object.prototype.toString.call(obj[prop]) === \"[object Object]\"\n            ? // keep working if value is an object\n              flatten(obj[prop], roots.concat([prop]))\n            : // include current prop and value and prefix prop with the roots\n              { [roots.concat([prop]).join(sep)]: obj[prop] }),\n        }),\n        {},\n      )\n  );\n}\n\n/** Converts an object into a list of binding/value tuples to use with a LocalModel object */\nexport function objectToBatchSet(obj: any): [BindingInstance, any][] {\n  const flattenedObj = flatten(obj);\n  const batchTxn: [BindingInstance, any][] = [];\n\n  Object.keys(flattenedObj).forEach((key) => {\n    batchTxn.push([new BindingInstance(key), flattenedObj[key]]);\n  });\n\n  return batchTxn;\n}\n","var SortedArray = (function () {\n    var SortedArray = defclass({\n\n        constructor: function (array, compare) {\n            this.array   = [];\n            this.compare = compare || compareDefault;\n            var length   = array.length,\n                index    = 0;\n            while (index < length) this.insert(array[index++]);\n        },\n        insert: function (element) {\n            var array   = this.array,\n                compare = this.compare,\n                high    = array.length-1,\n                low     = 0,\n                pos = -1,\n                index,\n                ordering;\n\n            // The array is sorted. You must find the position of new element in O(log(n)), not O(n).\n            while (high >= low) {\n                index    = (high + low) / 2 >>> 0;\n                ordering = compare(array[index], element);                \n                if (ordering < 0) low  = index + 1;\n                else if (ordering > 0) high = index - 1;\n                else {\n                    pos = index;\n                    break;\n                };\n            }\n\n            if (pos === -1) {\n                // if element was not found, high < low.\n                pos = high;\n            }\n            // This assures that equal elements inserted after will be in a higher position in array.\n            // They can be equal for comparison purposes, but different objects with different data.\n            // Respecting the chronological order can be important for many applications.\n            pos++;\n            high = array.length-1;\n            while ((pos < high) && (compare(element, array[pos]) === 0)){\n                pos++;\n            }\n            index = array.length;\n            // Just to increase array size.\n            array.push(element);            \n            // Much faster. No need to elements swap.\n            while (index > pos) {\n                array[index] = array[--index];\n            }\n            // Set the new element on its correct position.\n            array[pos] = element;\n\n            return this;\n        },\n        search: function (element) {\n            var array   = this.array,\n                compare = this.compare,\n                high    = array.length-1,\n                low     = 0,\n                // In most languages, inner variable declaration makes the code slower.\n                index,\n                ordering;\n\n            while (high >= low) {\n                index    = (high + low) / 2 >>> 0;\n                ordering = compare(array[index], element);\n\n                     if (ordering < 0) low  = index + 1;\n                else if (ordering > 0) high = index - 1;\n                else return index;\n            }\n\n            return -1;\n        },\n        remove: function (element) {\n            var index = this.search(element);\n            if (index >= 0) this.array.splice(index, 1);\n            return this;\n        }\n    });\n\n    SortedArray.comparing = function (property, array) {\n        return new SortedArray(array, function (a, b) {\n            // This should be faster than calling functions.\n            // Besides, this way it is not needed to create useless function to return property value.\n            return compareDefault(a[property], b[property]);\n        });\n    };\n\n    return SortedArray;\n\n    function defclass(prototype) {\n        var constructor = prototype.constructor;\n        constructor.prototype = prototype;\n        return constructor;\n    }\n\n    function compareDefault(a, b) {\n        // Equality has a very low chance to happen. It should be the last option.\n        if (a < b)\n            return -1;\n        else if (a > b)\n            return 1;\n        else\n            return 0;\n    }\n}());\n\nif (typeof module === \"object\") module.exports = SortedArray;\nif (typeof define === \"function\" && define.amd)\n    define(function () { return SortedArray; });\n","/**\n * Subclass of standard `Error` that eagerly collects the callstack of the error\n * that caused it. This way you can investigate the core problem that happened\n * by looking at the callstack from up to bottom (from higher level errors to\n * lower level).\n */\nexport class NestedError extends Error {\n    /**\n     * Combined callstack of this error and the errors that it wraps.\n     * If the JavaScript runtime doesn't support `Error::stack` property\n     * this will contain only the concatenated messages.\n     */\n    readonly stack: string;\n\n    /**\n     * The list of lower-level errors wrapped by this error.\n     */\n    readonly innerErrors: Error[];\n\n    /**\n     * Provides the first `Error` of the `innerErrors` (if it exists);\n     * otherwise, `null`.\n     *\n     * @deprecated Please shift to using the `innerErrors` (with an 's') property.\n     */\n    get innerError(): Error | null {\n        return this.innerErrors.length === 0\n            ? null\n            : this.innerErrors[0];\n    }\n\n    private static readonly getErrorReport = typeof new Error().stack === 'string'\n        ? (err: Error) => err.stack!\n        : (err: Error) => `${err.name}: ${err.message}`;\n\n    /**\n     * Returns the function that accepts any value that was thrown as the first argument and\n     * throws it wrapped into `NestedError` or class derived from `NestedError` (provided\n     * this method was called directly in the context of that dervied class constructor)\n     * with the given `message`.\n     * Returned function will pass accepted `Error` object directly to `NestedError`\n     * as `innerErrors` by invoking `toError(err)` on it.\n     *\n     * You'll most likely want to use this method with promises:\n     *\n     * ```ts\n     * userService.getPage().then(\n     *     data => console.log(`Hooray! data: ${data}`),\n     *     NestedError.rethrow('failed to fetch users page')\n     * );\n     * ```\n     *\n     * @param message Message to attach `NestedError` created by the returned function.\n     */\n    static rethrow(message: string) {\n        return (...errs: unknown[]) => { throw new this(message, ...errs); };\n    }\n\n    /**\n     * Allocates an instance of `NestedError` with the given error `message` and\n     * optional `innerError` (which will be automatically coerced using `toError()`).\n     *\n     * @param message     Laconic error message to attach to the created `NestedError`.\n     * @param innerErrors Optional errors that will be wrapped by this higher level\n     *                    error. This value will be automatically coerced using `toError()`.\n     */\n    constructor(message?: string, ...innerErrors: unknown[]) {\n        super(message);\n        const thisErrorReport = NestedError.getErrorReport(this);\n        if (innerErrors.length === 1) {\n            const innerError = toError(innerErrors[0]);\n            this.innerErrors = [innerError];\n            const errReport = NestedError.getErrorReport(innerError);\n            this.stack = `${thisErrorReport}\\n\\n======= INNER ERROR =======\\n\\n${errReport}`;\n            return;\n        }\n        this.innerErrors = innerErrors.map(err => toError(err));\n        const innerErrorReports = this.innerErrors\n            .map((error, idx) => {\n                const errReport = NestedError.getErrorReport(error);\n                return `======= INNER ERROR (${idx + 1} of ${innerErrors.length}) =======\\n\\n${errReport}`;\n            })\n            .join(\"\\n\\n\");\n        this.stack = `${thisErrorReport}\\n\\n${innerErrorReports}`;\n    }\n}\n\nNestedError.prototype.name = nameof(NestedError);\n\n/**\n * @deprecated You should not call this function on an object of statically assumed `Error` type,\n *             because it is intended to be used in a dynamic context where the type of thrown value\n *             is not known ahead of time (during the compile time).\n */\nexport function toError(err: Error): Error;\n\n/**\n * Returns `err` itself if `err instanceof Error === true`, otherwise attemts to\n * stringify it and wrap into `Error` object to be returned.\n *\n * **This function is guaranteed never to throw.**\n *\n * @param err Possbile `instanceof Error` to return or value of any type that will\n *            be wrapped into a fully-fledged `Error` object.\n */\nexport function toError(err: unknown): Error;\n\nexport function toError(err: unknown) {\n    try {\n        return err instanceof Error\n            ? err\n            : new Error(`Value that is not an instance of Error was thrown: ${err}`);\n    } catch {\n        return new Error(\n            \"Failed to stringify non-instance of Error that was thrown.\" +\n            \"This is possibly due to the fact that toString() method of the value\" +\n            \"doesn't return a primitive value.\"\n        );\n    }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clone = clone;\nexports.addLast = addLast;\nexports.addFirst = addFirst;\nexports.removeLast = removeLast;\nexports.removeFirst = removeFirst;\nexports.insert = insert;\nexports.removeAt = removeAt;\nexports.replaceAt = replaceAt;\nexports.getIn = getIn;\nexports.set = set;\nexports.setIn = setIn;\nexports.update = update;\nexports.updateIn = updateIn;\nexports.merge = merge;\nexports.mergeDeep = mergeDeep;\nexports.mergeIn = mergeIn;\nexports.omit = omit;\nexports.addDefaults = addDefaults;\nexports.default = void 0;\n\n/* eslint-disable @typescript-eslint/ban-types */\n\n/*!\n * Timm\n *\n * Immutability helpers with fast reads and acceptable writes.\n *\n * @copyright Guillermo Grau Panea 2016\n * @license MIT\n */\nconst INVALID_ARGS = 'INVALID_ARGS';\nconst IS_DEV = process.env.NODE_ENV !== 'production';\n\n// ===============================================\n// ### Helpers\n// ===============================================\nfunction throwStr(msg) {\n  throw new Error(msg);\n}\n\nfunction getKeysAndSymbols(obj) {\n  const keys = Object.keys(obj);\n\n  if (Object.getOwnPropertySymbols) {\n    // @ts-ignore\n    return keys.concat(Object.getOwnPropertySymbols(obj));\n  }\n\n  return keys;\n}\n\nconst hasOwnProperty = {}.hasOwnProperty;\n\nfunction clone(obj0) {\n  // As array\n  if (Array.isArray(obj0)) return obj0.slice(); // As object\n\n  const obj = obj0;\n  const keys = getKeysAndSymbols(obj);\n  const out = {};\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    out[key] = obj[key];\n  } // @ts-ignore (see type tests)\n\n\n  return out;\n} // Custom guard\n\n\nfunction isObject(o) {\n  return o != null && typeof o === 'object';\n} // _deepFreeze = (obj) ->\n//   Object.freeze obj\n//   for key in Object.getOwnPropertyNames obj\n//     val = obj[key]\n//     if isObject(val) and not Object.isFrozen val\n//       _deepFreeze val\n//   obj\n// ===============================================\n// -- ### Arrays\n// ===============================================\n// -- #### addLast()\n// -- Returns a new array with an appended item or items.\n// --\n// -- Usage: `addLast(array, val)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = addLast(arr, 'c')\n// -- // ['a', 'b', 'c']\n// -- arr2 === arr\n// -- // false\n// -- arr3 = addLast(arr, ['c', 'd'])\n// -- // ['a', 'b', 'c', 'd']\n// -- ```\n// `array.concat(val)` also handles the scalar case,\n// but is apparently very slow\n\n\nfunction addLast(array, val) {\n  if (Array.isArray(val)) return array.concat(val);\n  return array.concat([val]);\n} // -- #### addFirst()\n// -- Returns a new array with a prepended item or items.\n// --\n// -- Usage: `addFirst(array, val)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = addFirst(arr, 'c')\n// -- // ['c', 'a', 'b']\n// -- arr2 === arr\n// -- // false\n// -- arr3 = addFirst(arr, ['c', 'd'])\n// -- // ['c', 'd', 'a', 'b']\n// -- ```\n\n\nfunction addFirst(array, val) {\n  if (Array.isArray(val)) return val.concat(array);\n  return [val].concat(array);\n} // -- #### removeLast()\n// -- Returns a new array removing the last item.\n// --\n// -- Usage: `removeLast(array)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = removeLast(arr)\n// -- // ['a']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- arr3 = []\n// -- removeLast(arr3) === arr3\n// -- // true\n// -- ```\n\n\nfunction removeLast(array) {\n  if (!array.length) return array;\n  return array.slice(0, array.length - 1);\n} // -- #### removeFirst()\n// -- Returns a new array removing the first item.\n// --\n// -- Usage: `removeFirst(array)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = removeFirst(arr)\n// -- // ['b']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- arr3 = []\n// -- removeFirst(arr3) === arr3\n// -- // true\n// -- ```\n\n\nfunction removeFirst(array) {\n  if (!array.length) return array;\n  return array.slice(1);\n} // -- #### insert()\n// -- Returns a new array obtained by inserting an item or items\n// -- at a specified index.\n// --\n// -- Usage: `insert(array, idx, val)`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = insert(arr, 1, 'd')\n// -- // ['a', 'd', 'b', 'c']\n// -- arr2 === arr\n// -- // false\n// -- insert(arr, 1, ['d', 'e'])\n// -- // ['a', 'd', 'e', 'b', 'c']\n// -- ```\n\n\nfunction insert(array, idx, val) {\n  return array.slice(0, idx).concat(Array.isArray(val) ? val : [val]).concat(array.slice(idx));\n} // -- #### removeAt()\n// -- Returns a new array obtained by removing an item at\n// -- a specified index.\n// --\n// -- Usage: `removeAt(array, idx)`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = removeAt(arr, 1)\n// -- // ['a', 'c']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- removeAt(arr, 4) === arr\n// -- // true\n// -- ```\n\n\nfunction removeAt(array, idx) {\n  if (idx >= array.length || idx < 0) return array;\n  return array.slice(0, idx).concat(array.slice(idx + 1));\n} // -- #### replaceAt()\n// -- Returns a new array obtained by replacing an item at\n// -- a specified index. If the provided item is the same as\n// -- (*referentially equal to*) the previous item at that position,\n// -- the original array is returned.\n// --\n// -- Usage: `replaceAt(array, idx, newItem)`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = replaceAt(arr, 1, 'd')\n// -- // ['a', 'd', 'c']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- replaceAt(arr, 1, 'b') === arr\n// -- // true\n// -- ```\n\n\nfunction replaceAt(array, idx, newItem) {\n  if (array[idx] === newItem) return array;\n  const len = array.length;\n  const result = Array(len);\n\n  for (let i = 0; i < len; i++) {\n    result[i] = array[i];\n  }\n\n  result[idx] = newItem;\n  return result;\n} // ===============================================\n// -- ### Collections (objects and arrays)\n// ===============================================\n// -- #### getIn()\n// -- Returns a value from an object at a given path. Works with\n// -- nested arrays and objects. If the path does not exist, it returns\n// -- `undefined`.\n// --\n// -- Usage: `getIn(obj, path)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: ['a', 'b', 'c'] }\n// -- getIn(obj, ['d', 'd1'])\n// -- // 3\n// -- getIn(obj, ['e', 1])\n// -- // 'b'\n// -- ```\n\n\nfunction getIn(obj, path) {\n  if (!Array.isArray(path)) {\n    throwStr(IS_DEV ? 'A path array should be provided when calling getIn()' : INVALID_ARGS);\n  }\n\n  if (obj == null) return undefined;\n  let ptr = obj;\n\n  for (let i = 0; i < path.length; i++) {\n    const key = path[i];\n    ptr = ptr != null ? ptr[key] : undefined;\n    if (ptr === undefined) return ptr;\n  }\n\n  return ptr;\n} // -- #### set()\n// -- Returns a new object with a modified attribute.\n// -- If the provided value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `set(obj, key, val)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3 }\n// -- obj2 = set(obj, 'b', 5)\n// -- // { a: 1, b: 5, c: 3 }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- set(obj, 'b', 2) === obj\n// -- // true\n// -- ```\n// When called with an undefined/null `obj`, `set()` returns either\n// a single-element array, or a single-key object\n\n\n// Implementation\nfunction set(obj0, key, val) {\n  let obj = obj0;\n  if (obj == null) obj = typeof key === 'number' ? [] : {};\n  if (obj[key] === val) return obj;\n  const obj2 = clone(obj);\n  obj2[key] = val;\n  return obj2;\n} // -- #### setIn()\n// -- Returns a new object with a modified **nested** attribute.\n// --\n// -- Notes:\n// --\n// -- * If the provided value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// -- * If the path does not exist, it will be created before setting\n// -- the new value.\n// --\n// -- Usage: `setIn(obj, path, val)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj2 = setIn(obj, ['d', 'd1'], 4)\n// -- // { a: 1, b: 2, d: { d1: 4, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj2 === obj\n// -- // false\n// -- obj2.d === obj.d\n// -- // false\n// -- obj2.e === obj.e\n// -- // true\n// --\n// -- // The same object is returned if there are no changes:\n// -- obj3 = setIn(obj, ['d', 'd1'], 3)\n// -- // { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj3 === obj\n// -- // true\n// -- obj3.d === obj.d\n// -- // true\n// -- obj3.e === obj.e\n// -- // true\n// --\n// -- // ... unknown paths create intermediate keys. Numeric segments are treated as array indices:\n// -- setIn({ a: 3 }, ['unknown', 0, 'path'], 4)\n// -- // { a: 3, unknown: [{ path: 4 }] }\n// -- ```\n\n\nfunction setIn(obj, path, val) {\n  if (!path.length) return val;\n  return doSetIn(obj, path, val, 0);\n}\n\nfunction doSetIn(obj, path, val, idx) {\n  let newValue;\n  const key = path[idx];\n\n  if (idx === path.length - 1) {\n    newValue = val;\n  } else {\n    const nestedObj = isObject(obj) && isObject(obj[key]) ? obj[key] : typeof path[idx + 1] === 'number' ? [] : {};\n    newValue = doSetIn(nestedObj, path, val, idx + 1);\n  }\n\n  return set(obj, key, newValue);\n} // -- #### update()\n// -- Returns a new object with a modified attribute,\n// -- calculated via a user-provided callback based on the current value.\n// -- If the calculated value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `update(obj, key, fnUpdate)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3 }\n// -- obj2 = update(obj, 'b', (val) => val + 1)\n// -- // { a: 1, b: 3, c: 3 }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- update(obj, 'b', (val) => val) === obj\n// -- // true\n// -- ```\n\n\nfunction update(obj, key, fnUpdate) {\n  const prevVal = obj == null ? undefined : obj[key];\n  const nextVal = fnUpdate(prevVal);\n  return set(obj, key, nextVal);\n} // -- #### updateIn()\n// -- Returns a new object with a modified **nested** attribute,\n// -- calculated via a user-provided callback based on the current value.\n// -- If the calculated value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `updateIn<T: ArrayOrObject>(obj: T, path: Array<Key>,\n// -- fnUpdate: (prevValue: any) => any): T`\n// --\n// -- ```js\n// -- obj = { a: 1, d: { d1: 3, d2: 4 } }\n// -- obj2 = updateIn(obj, ['d', 'd1'], (val) => val + 1)\n// -- // { a: 1, d: { d1: 4, d2: 4 } }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- obj3 = updateIn(obj, ['d', 'd1'], (val) => val)\n// -- // { a: 1, d: { d1: 3, d2: 4 } }\n// -- obj3 === obj\n// -- // true\n// -- ```\n\n\nfunction updateIn(obj, path, fnUpdate) {\n  const prevVal = getIn(obj, path);\n  const nextVal = fnUpdate(prevVal);\n  return setIn(obj, path, nextVal);\n} // -- #### merge()\n// -- Returns a new object built as follows: the overlapping keys from the\n// -- second one overwrite the corresponding entries from the first one.\n// -- Similar to `Object.assign()`, but immutable.\n// --\n// -- Usage:\n// --\n// -- * `merge(obj1, obj2)`\n// -- * `merge(obj1, ...objects)`\n// --\n// -- The unmodified `obj1` is returned if `obj2` does not *provide something\n// -- new to* `obj1`, i.e. if either of the following\n// -- conditions are true:\n// --\n// -- * `obj2` is `null` or `undefined`\n// -- * `obj2` is an object, but it is empty\n// -- * All attributes of `obj2` are `undefined`\n// -- * All attributes of `obj2` are referentially equal to the\n// --   corresponding attributes of `obj1`\n// --\n// -- Note that `undefined` attributes in `obj2` do not modify the\n// -- corresponding attributes in `obj1`.\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: 3 }\n// -- obj2 = { c: 4, d: 5 }\n// -- obj3 = merge(obj1, obj2)\n// -- // { a: 1, b: 2, c: 4, d: 5 }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- merge(obj1, { c: 3 }) === obj1\n// -- // true\n// -- ```\n// Signatures:\n// - 1 arg\n\n\n// Implementation\nfunction merge(a, b, c, d, e, f, ...rest) {\n  return rest.length ? doMerge.call(null, false, false, a, b, c, d, e, f, ...rest) : doMerge(false, false, a, b, c, d, e, f);\n} // -- #### mergeDeep()\n// -- Returns a new object built as follows: the overlapping keys from the\n// -- second one overwrite the corresponding entries from the first one.\n// -- If both the first and second entries are objects they are merged recursively.\n// -- Similar to `Object.assign()`, but immutable, and deeply merging.\n// --\n// -- Usage:\n// --\n// -- * `mergeDeep(obj1, obj2)`\n// -- * `mergeDeep(obj1, ...objects)`\n// --\n// -- The unmodified `obj1` is returned if `obj2` does not *provide something\n// -- new to* `obj1`, i.e. if either of the following\n// -- conditions are true:\n// --\n// -- * `obj2` is `null` or `undefined`\n// -- * `obj2` is an object, but it is empty\n// -- * All attributes of `obj2` are `undefined`\n// -- * All attributes of `obj2` are referentially equal to the\n// --   corresponding attributes of `obj1`\n// --\n// -- Note that `undefined` attributes in `obj2` do not modify the\n// -- corresponding attributes in `obj1`.\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: { a: 1 } }\n// -- obj2 = { b: 3, c: { b: 2 } }\n// -- obj3 = mergeDeep(obj1, obj2)\n// -- // { a: 1, b: 3, c: { a: 1, b: 2 }  }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- mergeDeep(obj1, { c: { a: 1 } }) === obj1\n// -- // true\n// -- ```\n\n\nfunction mergeDeep(a, b, c, d, e, f, ...rest) {\n  return rest.length ? doMerge.call(null, false, true, a, b, c, d, e, f, ...rest) : doMerge(false, true, a, b, c, d, e, f);\n} // -- #### mergeIn()\n// -- Similar to `merge()`, but merging the value at a given nested path.\n// --\n// -- Usage examples:\n// --\n// -- * `mergeIn(obj1, path, obj2)`\n// -- * `mergeIn(obj1, path, ...objects)`\n// --\n// -- ```js\n// -- obj1 = { a: 1, d: { b: { d1: 3, d2: 4 } } }\n// -- obj2 = { d3: 5 }\n// -- obj3 = mergeIn(obj1, ['d', 'b'], obj2)\n// -- // { a: 1, d: { b: { d1: 3, d2: 4, d3: 5 } } }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- mergeIn(obj1, ['d', 'b'], { d2: 4 }) === obj1\n// -- // true\n// -- ```\n\n\nfunction mergeIn(a, path, b, c, d, e, f, ...rest) {\n  let prevVal = getIn(a, path);\n  if (prevVal == null) prevVal = {};\n  let nextVal;\n\n  if (rest.length) {\n    nextVal = doMerge.call(null, false, false, prevVal, b, c, d, e, f, ...rest);\n  } else {\n    nextVal = doMerge(false, false, prevVal, b, c, d, e, f);\n  }\n\n  return setIn(a, path, nextVal);\n} // -- #### omit()\n// -- Returns an object excluding one or several attributes.\n// --\n// -- Usage: `omit(obj, attrs)`\n//\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3, d: 4 }\n// -- omit(obj, 'a')\n// -- // { b: 2, c: 3, d: 4 }\n// -- omit(obj, ['b', 'c'])\n// -- // { a: 1, d: 4 }\n// --\n// -- // The same object is returned if there are no changes:\n// -- omit(obj, 'z') === obj1\n// -- // true\n// -- ```\n\n\nfunction omit(obj, attrs) {\n  const omitList = Array.isArray(attrs) ? attrs : [attrs];\n  let fDoSomething = false;\n\n  for (let i = 0; i < omitList.length; i++) {\n    if (hasOwnProperty.call(obj, omitList[i])) {\n      fDoSomething = true;\n      break;\n    }\n  }\n\n  if (!fDoSomething) return obj;\n  const out = {};\n  const keys = getKeysAndSymbols(obj);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (omitList.indexOf(key) >= 0) continue;\n    out[key] = obj[key];\n  }\n\n  return out;\n} // -- #### addDefaults()\n// -- Returns a new object built as follows: `undefined` keys in the first one\n// -- are filled in with the corresponding values from the second one\n// -- (even if they are `null`).\n// --\n// -- Usage:\n// --\n// -- * `addDefaults(obj, defaults)`\n// -- * `addDefaults(obj, ...defaultObjects)`\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: 3 }\n// -- obj2 = { c: 4, d: 5, e: null }\n// -- obj3 = addDefaults(obj1, obj2)\n// -- // { a: 1, b: 2, c: 3, d: 5, e: null }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- addDefaults(obj1, { c: 4 }) === obj1\n// -- // true\n// -- ```\n// Signatures:\n// - 2 args\n\n\n// Implementation and catch-all\nfunction addDefaults(a, b, c, d, e, f, ...rest) {\n  return rest.length ? doMerge.call(null, true, false, a, b, c, d, e, f, ...rest) : doMerge(true, false, a, b, c, d, e, f);\n}\n\nfunction doMerge(fAddDefaults, fDeep, first, ...rest) {\n  let out = first;\n\n  if (!(out != null)) {\n    throwStr(IS_DEV ? 'At least one object should be provided to merge()' : INVALID_ARGS);\n  }\n\n  let fChanged = false;\n\n  for (let idx = 0; idx < rest.length; idx++) {\n    const obj = rest[idx];\n    if (obj == null) continue;\n    const keys = getKeysAndSymbols(obj);\n    if (!keys.length) continue;\n\n    for (let j = 0; j <= keys.length; j++) {\n      const key = keys[j];\n      if (fAddDefaults && out[key] !== undefined) continue;\n      let nextVal = obj[key];\n\n      if (fDeep && isObject(out[key]) && isObject(nextVal)) {\n        nextVal = doMerge(fAddDefaults, fDeep, out[key], nextVal);\n      }\n\n      if (nextVal === undefined || nextVal === out[key]) continue;\n\n      if (!fChanged) {\n        fChanged = true;\n        out = clone(out);\n      }\n\n      out[key] = nextVal;\n    }\n  }\n\n  return out;\n} // ===============================================\n// ### Public API\n// ===============================================\n\n\nconst timm = {\n  clone,\n  addLast,\n  addFirst,\n  removeLast,\n  removeFirst,\n  insert,\n  removeAt,\n  replaceAt,\n  getIn,\n  set,\n  setIn,\n  update,\n  updateIn,\n  merge,\n  mergeDeep,\n  mergeIn,\n  omit,\n  addDefaults\n};\nvar _default = timm;\nexports.default = _default;","'use strict';\n\nconst pDefer = () => {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n};\n\nmodule.exports = pDefer;\n","/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n","export * from \"./assets\";\nexport * from \"./plugin\";\n","import type { TransformFunction } from \"@player-ui/player\";\nimport type { InputAsset, TransformedInput } from \"./types\";\n\n/**\n * Docs about the asset transform\n */\nexport const inputTransform: TransformFunction<InputAsset, TransformedInput> = (\n  asset,\n  options,\n) => {\n  return {\n    ...asset,\n    format(val) {\n      if (asset.binding === undefined) {\n        return val;\n      }\n\n      return options.data.format(asset.binding, val);\n    },\n    set(val) {\n      if (asset.binding === undefined) {\n        return;\n      }\n\n      return options.data.model.set([[asset.binding, val]], {\n        formatted: true,\n      });\n    },\n    value:\n      asset.binding === undefined\n        ? \"\"\n        : options.data.model.get(asset.binding, {\n            includeInvalid: true,\n            formatted: true,\n          }),\n    validation:\n      asset.binding === undefined\n        ? undefined\n        : options.validation?.get(asset.binding, { track: true }),\n    dataType:\n      asset.binding === undefined\n        ? undefined\n        : options.validation?.type(asset.binding),\n  };\n};\n","import type { TransformFunction } from \"@player-ui/player\";\nimport type { AssetWrapper } from \"@player-ui/player\";\nimport type { InfoAsset, InfoAssetTransform } from \"./types\";\nimport type { ActionAsset } from \"../action/types\";\nimport { isBackAction } from \"../action/transform\";\n\n/**\n * This transform should add segmentedActions to the info asset.\n * Segmented actions display side by side in larger viewports. Segmented Actions is an object of next and prev actions\n */\nexport const infoTransform: TransformFunction<InfoAsset, InfoAssetTransform> = (\n  infoAsset,\n) => {\n  const actions = infoAsset?.actions;\n  const segmentedActions = actions?.reduce(\n    (segmentedActionsArray, action) => {\n      segmentedActionsArray[\n        isBackAction(action.asset as ActionAsset) ? \"prev\" : \"next\"\n      ].push(action as AssetWrapper<ActionAsset>);\n      return segmentedActionsArray;\n    },\n    { next: [], prev: [] } as {\n      /**\n       * next is an array of next actions\n       */\n      next: Array<AssetWrapper<ActionAsset>>;\n      /**\n       * prev is an array of prev actions\n       */\n      prev: Array<AssetWrapper<ActionAsset>>;\n    },\n  );\n\n  return {\n    ...infoAsset,\n    segmentedActions,\n  };\n};\n","import type { TransformFunction } from \"@player-ui/player\";\nimport type { ImageAsset, TransformedImage } from \"./types\";\n\n/**\n * Function to retrieve the desired alt text based on passed in props.\n * @param props Image props\n * @returns The alt text for the image asset\n */\nconst getImageAlt = (props: ImageAsset): string => {\n  const { metaData, placeholder } = props;\n  if (metaData.accessibility) return metaData.accessibility;\n\n  if (placeholder) return placeholder;\n\n  return \"Image\";\n};\n\n/**\n * Sets the Image's placeholder and accessibilty\n */\nexport const imageTransform: TransformFunction<ImageAsset, TransformedImage> = (\n  props,\n) => {\n  const altText = getImageAlt(props);\n\n  const newImage = {\n    ...props,\n    altText,\n  };\n\n  return newImage;\n};\n","import type { TransformFunction } from \"@player-ui/player\";\nimport type {\n  ChoiceAsset,\n  TransformedChoice,\n  TransformedChoiceItem,\n} from \"./types\";\n\n/**\n * Docs about the asset transform\n */\nexport const choiceTransform: TransformFunction<\n  ChoiceAsset,\n  TransformedChoice\n> = (asset, options) => {\n  const { items, binding, ...rest } = asset;\n\n  const assetHasBinding = binding !== undefined;\n\n  const currentValue = assetHasBinding\n    ? options.data.model.get(binding, {\n        includeInvalid: true,\n      })\n    : undefined;\n\n  const resetValue = () => {\n    if (assetHasBinding) {\n      return options.data.model.set([[binding, null]]);\n    }\n  };\n\n  const transformedChoiceItems: TransformedChoiceItem[] = (items || []).map(\n    (item, index) => ({\n      ...item,\n      id: item.id ?? `${asset.id}-choice-${index}`,\n      select() {\n        if (assetHasBinding) {\n          return options.data.model.set([[binding, item.value]]);\n        }\n      },\n      unselect: resetValue,\n    }),\n  );\n\n  return {\n    ...rest,\n    binding,\n    clearSelection: resetValue,\n    items: transformedChoiceItems,\n    value: currentValue,\n    validation: assetHasBinding\n      ? options.validation?.get(binding, { track: true })\n      : undefined,\n    dataType: assetHasBinding ? options.validation?.type(binding) : undefined,\n  };\n};\n","import { SyncBailHook, SyncWaterfallHook } from \"tapable-ts\";\nimport { NestedError } from \"ts-nested-error\";\nimport type { ParserResult, AnyNode } from \"../binding-grammar/index\";\nimport {\n  // We can swap this with whichever parser we want to use\n  parseCustom as parseBinding,\n} from \"../binding-grammar\";\nimport type { BindingParserOptions, BindingLike } from \"./binding\";\nimport { BindingInstance } from \"./binding\";\nimport { isBinding } from \"./utils\";\nimport type { NormalizedResult, ResolveBindingASTOptions } from \"./resolver\";\nimport { resolveBindingAST } from \"./resolver\";\n\nexport * from \"./utils\";\nexport * from \"./binding\";\n\nexport const SIMPLE_BINDING_REGEX = /^[\\w\\-@]+(\\.[\\w\\-@]+)*$/;\nexport const BINDING_BRACKETS_REGEX = /[\\s()*=`{}'\"[\\]]/;\nconst LAZY_BINDING_REGEX = /^[^.]+(\\..+)*$/;\n\nconst DEFAULT_OPTIONS: BindingParserOptions = {\n  get: () => {\n    throw new Error(\"Not Implemented\");\n  },\n  set: () => {\n    throw new Error(\"Not Implemented\");\n  },\n  evaluate: () => {\n    throw new Error(\"Not Implemented\");\n  },\n};\n\ntype BeforeResolveNodeContext = Required<NormalizedResult> &\n  ResolveBindingASTOptions;\n\n/** A parser for creating bindings from a string */\nexport class BindingParser {\n  private cache: Record<string, BindingInstance>;\n  private parseCache: Record<string, ParserResult>;\n  private parserOptions: BindingParserOptions;\n\n  public hooks = {\n    skipOptimization: new SyncBailHook<[string], boolean>(),\n    beforeResolveNode: new SyncWaterfallHook<\n      [AnyNode, BeforeResolveNodeContext]\n    >(),\n  };\n\n  constructor(options?: Partial<BindingParserOptions>) {\n    this.parserOptions = { ...DEFAULT_OPTIONS, ...options };\n    this.cache = {};\n    this.parseCache = {};\n    this.parse = this.parse.bind(this);\n  }\n\n  /**\n   * Takes a binding path, parses it, and returns an equivalent, normalized\n   * representation of that path.\n   */\n  private normalizePath(\n    path: string,\n    resolveOptions: ResolveBindingASTOptions,\n  ) {\n    /**\n     * Ensure no binding characters exist in path and the characters remaining\n     * look like a binding format.\n     */\n    if (\n      !BINDING_BRACKETS_REGEX.test(path) &&\n      LAZY_BINDING_REGEX.test(path) &&\n      this.hooks.skipOptimization.call(path) !== true\n    ) {\n      return { path: path.split(\".\"), updates: undefined } as NormalizedResult;\n    }\n\n    const ast = this.parseCache[path] ?? parseBinding(path);\n    this.parseCache[path] = ast;\n\n    if (typeof ast !== \"object\" || !ast?.status) {\n      throw new TypeError(\n        `Cannot normalize path \"${path}\": ${ast?.error ?? \"Unknown Error.\"}`,\n      );\n    }\n\n    try {\n      return resolveBindingAST(ast.path, resolveOptions, this.hooks);\n    } catch (e: any) {\n      throw new NestedError(`Cannot resolve binding: ${path}`, e);\n    }\n  }\n\n  private getBindingForNormalizedResult(\n    normalized: NormalizedResult,\n  ): BindingInstance {\n    const normalizedStr = normalized.path.join(\".\");\n\n    if (this.cache[normalizedStr]) {\n      return this.cache[normalizedStr];\n    }\n\n    const created = new BindingInstance(\n      normalizedStr === \"\" ? [] : normalized.path,\n      this.parse,\n    );\n    this.cache[normalizedStr] = created;\n\n    return created;\n  }\n\n  public parse(\n    rawBinding: BindingLike,\n    overrides: Partial<BindingParserOptions> = {},\n  ): BindingInstance {\n    if (isBinding(rawBinding)) {\n      return rawBinding;\n    }\n\n    const options = {\n      ...this.parserOptions,\n      ...overrides,\n    };\n\n    let updates: Record<string, any> = {};\n\n    const joined = Array.isArray(rawBinding)\n      ? rawBinding.join(\".\")\n      : String(rawBinding);\n\n    const normalizeConfig: ResolveBindingASTOptions = {\n      getValue: (path: Array<string | number>) => {\n        const normalized = this.normalizePath(path.join(\".\"), normalizeConfig);\n\n        return options.get(this.getBindingForNormalizedResult(normalized));\n      },\n      evaluate: (exp) => {\n        return options.evaluate(exp);\n      },\n      convertToPath: (path: any) => {\n        if (path === undefined) {\n          throw new Error(\n            \"Attempted to convert undefined value to binding path\",\n          );\n        }\n\n        if (\n          typeof path !== \"string\" &&\n          typeof path !== \"number\" &&\n          typeof path !== \"boolean\"\n        ) {\n          throw new Error(\n            `Attempting to convert ${typeof path} to a binding path.`,\n          );\n        }\n\n        const normalized = this.normalizePath(String(path), normalizeConfig);\n\n        if (normalized.updates) {\n          updates = {\n            ...updates,\n            ...normalized.updates,\n          };\n        }\n\n        const joinedNormalizedPath = normalized.path.join(\".\");\n\n        if (joinedNormalizedPath === \"\") {\n          throw new Error(\"Nested path resolved to an empty path\");\n        }\n\n        return joinedNormalizedPath;\n      },\n    };\n\n    const normalized = this.normalizePath(joined, normalizeConfig);\n\n    if (normalized.updates) {\n      updates = {\n        ...updates,\n        ...normalized.updates,\n      };\n    }\n\n    const updateKeys = Object.keys(updates);\n\n    if (!options.readOnly && updateKeys.length > 0) {\n      const updateTransaction = updateKeys.map<[BindingInstance, any]>(\n        (updatedBinding) => [\n          this.parse(updatedBinding),\n          updates[updatedBinding],\n        ],\n      );\n\n      options.set(updateTransaction);\n    }\n\n    return this.getBindingForNormalizedResult(normalized);\n  }\n}\n","import { NestedError } from \"ts-nested-error\";\nimport type { SyncWaterfallHook } from \"tapable-ts\";\nimport type { PathNode, AnyNode } from \"../binding-grammar\";\nimport { findInArray, maybeConvertToNum } from \"./utils\";\n\nexport interface NormalizedResult {\n  /** The normalized path */\n  path: Array<string | number>;\n\n  /** Any new updates that need to happen for this binding to be resolved */\n  updates?: Record<string, any>;\n}\n\nexport interface ResolveBindingASTOptions {\n  /** Get the value of the model at the given path */\n  getValue: (path: Array<string | number>) => any;\n\n  /** Convert the value into valid path segments */\n  convertToPath: (value: any) => string;\n\n  /** Convert the value into valid path segments */\n  evaluate: (exp: string) => any;\n}\n\nexport interface ResolveBindingASTHooks {\n  /** A hook for transforming a node before fully resolving it */\n  beforeResolveNode: SyncWaterfallHook<\n    [AnyNode, Required<NormalizedResult> & ResolveBindingASTOptions]\n  >;\n}\n\n/** Given a binding AST, resolve it */\nexport function resolveBindingAST(\n  bindingPathNode: PathNode,\n  options: ResolveBindingASTOptions,\n  hooks?: ResolveBindingASTHooks,\n): NormalizedResult {\n  const context: Required<NormalizedResult> = {\n    updates: {},\n    path: [],\n  };\n\n  // let updates: Record<string, any> = {};\n  // const path: Array<string | number> = [];\n\n  /** Get the value for any child node */\n  function getValueForNode(node: AnyNode): any {\n    if (node.name === \"Value\") {\n      return node.value;\n    }\n\n    if (node.name === \"PathNode\") {\n      const nestedResolvedValue = resolveBindingAST(node, options);\n\n      if (nestedResolvedValue.updates) {\n        context.updates = {\n          ...context.updates,\n          ...nestedResolvedValue.updates,\n        };\n      }\n\n      try {\n        return options.convertToPath(\n          options.getValue(nestedResolvedValue.path),\n        );\n      } catch (e: any) {\n        throw new NestedError(\n          `Unable to resolve path segment: ${nestedResolvedValue.path}`,\n          e,\n        );\n      }\n    }\n\n    if (node.name === \"Expression\") {\n      try {\n        const actualValue = options.evaluate(node.value);\n\n        return options.convertToPath(actualValue);\n      } catch (e: any) {\n        throw new NestedError(`Unable to resolve path: ${node.value}`, e);\n      }\n    }\n\n    throw new Error(`Unable to resolve value for node: ${node.name}`);\n  }\n\n  /** Handle when path segments are binding paths (foo.bar) or single segments (foo) */\n  function appendPathSegments(segment: string | number) {\n    if (typeof segment === \"string\" && segment.indexOf(\".\") > -1) {\n      segment.split(\".\").forEach((i) => {\n        context.path.push(maybeConvertToNum(i));\n      });\n    } else {\n      context.path.push(segment);\n    }\n  }\n\n  /** Compute the _actual_ binding val from the AST */\n  function resolveNode(_node: AnyNode) {\n    const resolvedNode =\n      hooks?.beforeResolveNode.call(_node, { ...context, ...options }) ?? _node;\n\n    switch (resolvedNode.name) {\n      case \"Expression\":\n      case \"PathNode\":\n        appendPathSegments(getValueForNode(resolvedNode));\n        break;\n\n      case \"Value\":\n        appendPathSegments(\n          typeof resolvedNode.value === \"boolean\"\n            ? String(resolvedNode.value)\n            : resolvedNode.value,\n        );\n        break;\n\n      case \"Query\": {\n        // Look for an object at the path with the given key/val criteria\n        const objToQuery: Record<string, any>[] =\n          options.getValue(context.path) ?? [];\n\n        const { key, value } = resolvedNode;\n\n        const resolvedKey = getValueForNode(key);\n        const resolvedValue = value && getValueForNode(value);\n\n        const index = findInArray(objToQuery, resolvedKey, resolvedValue);\n\n        if (index === undefined || index === -1) {\n          context.updates[\n            [...context.path, objToQuery.length, resolvedKey].join(\".\")\n          ] = resolvedValue;\n          context.path.push(objToQuery.length);\n        } else {\n          context.path.push(index);\n        }\n\n        break;\n      }\n\n      case \"Concatenated\":\n        context.path.push(resolvedNode.value.map(getValueForNode).join(\"\"));\n        break;\n\n      default:\n        throw new Error(`Unsupported node type: ${(resolvedNode as any).name}`);\n    }\n  }\n\n  bindingPathNode.path.forEach(resolveNode);\n\n  return {\n    path: context.path,\n    updates:\n      Object.keys(context.updates ?? {}).length > 0\n        ? context.updates\n        : undefined,\n  };\n}\n","import get from \"dlv\";\nimport { setIn, omit, removeAt } from \"timm\";\nimport type { BindingInstance } from \"../binding\";\nimport type { BatchSetTransaction, DataModelImpl, Updates } from \"./model\";\n\n/**\n * A data model that stores data in an in-memory JS object\n */\nexport class LocalModel implements DataModelImpl {\n  public model: {\n    [key: string]: any;\n  };\n\n  constructor(model = {}) {\n    this.model = model;\n    this.get = this.get.bind(this);\n    this.set = this.set.bind(this);\n  }\n\n  public reset(model = {}) {\n    this.model = model;\n  }\n\n  public get(binding?: BindingInstance) {\n    if (!binding || !binding.asString()) {\n      return this.model;\n    }\n\n    return get(this.model, binding.asArray() as string[]);\n  }\n\n  public set(transaction: BatchSetTransaction) {\n    const effectiveOperations: Updates = [];\n    transaction.forEach(([binding, value]) => {\n      const oldValue = this.get(binding);\n      this.model = setIn(this.model, binding.asArray(), value) as any;\n      effectiveOperations.push({ binding, oldValue, newValue: value });\n    });\n    return effectiveOperations;\n  }\n\n  public delete(binding: BindingInstance) {\n    const parentBinding = binding.parent();\n\n    if (parentBinding) {\n      const parentValue = this.get(parentBinding);\n\n      if (parentValue !== undefined) {\n        if (Array.isArray(parentValue)) {\n          this.model = setIn(\n            this.model,\n            parentBinding.asArray(),\n            removeAt(parentValue, binding.key() as number),\n          ) as any;\n        } else {\n          this.model = setIn(\n            this.model,\n            parentBinding.asArray(),\n            omit(parentValue, binding.key() as string),\n          ) as any;\n        }\n      }\n    }\n  }\n}\n","import { setIn } from \"timm\";\nimport type { BindingInstance } from \"../binding\";\nimport type {\n  BatchSetTransaction,\n  DataModelImpl,\n  DataModelOptions,\n  DataModelMiddleware,\n  Updates,\n} from \"../data\";\nimport { toModel } from \"../data\";\nimport type { Logger } from \"../logger\";\n\nimport type { ValidationResponse } from \"./types\";\nimport { removeBindingAndChildrenFromMap } from \"./binding-map-splice\";\n\n/**\n * A BindingInstance with an indicator of whether or not it's a strong binding\n */\nexport type StrongOrWeakBinding = {\n  /** BindingInstance in question */\n  binding: BindingInstance;\n  /** Boolean indicating whether the relevant BindingInstance is a strong binding */\n  isStrong: boolean;\n};\n\n/**\n * Returns a validation object if the data is invalid or an set of BindingsInstances if the binding itself is a weak ref of another invalid validation\n */\nexport type MiddlewareChecker = (\n  binding: BindingInstance,\n  model: DataModelImpl,\n) => ValidationResponse | Set<StrongOrWeakBinding> | undefined;\n\n/**\n * Middleware for the data-model that caches the results of invalid data\n */\nexport class ValidationMiddleware implements DataModelMiddleware {\n  public validator: MiddlewareChecker;\n  public shadowModelPaths: Map<BindingInstance, any>;\n  private logger?: Logger;\n  private shouldIncludeInvalid?: (options?: DataModelOptions) => boolean;\n\n  constructor(\n    validator: MiddlewareChecker,\n    options?: {\n      /** A logger instance */\n      logger?: Logger;\n      /** Optional function to include data staged in shadowModel */\n      shouldIncludeInvalid?: (options?: DataModelOptions) => boolean;\n    },\n  ) {\n    this.validator = validator;\n    this.shadowModelPaths = new Map();\n    this.logger = options?.logger;\n    this.shouldIncludeInvalid = options?.shouldIncludeInvalid;\n  }\n\n  public set(\n    transaction: BatchSetTransaction,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ): Updates {\n    const asModel = toModel(this, { ...options, includeInvalid: true }, next);\n    const nextTransaction: BatchSetTransaction = [];\n\n    const includedBindings = new Set<BindingInstance>();\n\n    transaction.forEach(([binding, value]) => {\n      this.shadowModelPaths.set(binding, value);\n      includedBindings.add(binding);\n    });\n\n    const invalidBindings: Array<BindingInstance> = [];\n\n    this.shadowModelPaths.forEach((value, binding) => {\n      const validations = this.validator(binding, asModel);\n\n      if (validations === undefined) {\n        nextTransaction.push([binding, value]);\n      } else if (validations instanceof Set) {\n        validations.forEach((validation) => {\n          invalidBindings.push(validation.binding);\n          if (\n            !validation.isStrong &&\n            validation.binding.asString() === binding.asString()\n          ) {\n            nextTransaction.push([validation.binding, value]);\n          }\n        });\n      } else if (includedBindings.has(binding)) {\n        invalidBindings.push(binding);\n        this.logger?.debug(\n          `Invalid value for path: ${binding.asString()} - ${\n            validations.severity\n          } - ${validations.message}`,\n        );\n      }\n    });\n\n    let validResults: Updates = [];\n\n    if (next && nextTransaction.length > 0) {\n      // defer clearing the shadow model to prevent validations that are run twice due to weak binding refs still needing the data\n      nextTransaction.forEach(([binding]) =>\n        this.shadowModelPaths.delete(binding),\n      );\n      const result = next.set(nextTransaction, options);\n      if (invalidBindings.length === 0) {\n        return result;\n      }\n\n      validResults = result;\n    }\n\n    const invalidResults = invalidBindings.map((binding) => {\n      return {\n        binding,\n        oldValue: asModel.get(binding),\n        newValue: asModel.get(binding),\n        force: true,\n      };\n    });\n\n    return [...validResults, ...invalidResults];\n  }\n\n  public get(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ) {\n    let val = next?.get(binding, options);\n\n    if (\n      this.shouldIncludeInvalid?.(options) ??\n      options?.includeInvalid === true\n    ) {\n      this.shadowModelPaths.forEach((shadowValue, shadowBinding) => {\n        if (shadowBinding === binding) {\n          val = shadowValue;\n\n          return;\n        }\n\n        if (binding.contains(shadowBinding)) {\n          val = setIn(val, shadowBinding.relative(binding), shadowValue);\n        }\n      });\n    }\n\n    return val;\n  }\n\n  public delete(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ) {\n    this.shadowModelPaths = removeBindingAndChildrenFromMap(\n      this.shadowModelPaths,\n      binding,\n    );\n\n    return next?.delete(binding, options);\n  }\n}\n","import { SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport { addLast, clone, setIn } from \"timm\";\nimport dlv from \"dlv\";\nimport { dequal } from \"dequal\";\nimport type { BindingInstance, BindingLike } from \"../../binding\";\nimport type {\n  DataModelOptions,\n  DataModelWithParser,\n  Updates,\n} from \"../../data\";\nimport { DependencyModel, withParser } from \"../../data\";\nimport type { Logger } from \"../../logger\";\nimport { Node, NodeType } from \"../parser\";\nimport { caresAboutDataChanges, toNodeResolveOptions } from \"./utils\";\nimport type { Resolve } from \"./types\";\nimport { getNodeID } from \"../parser/utils\";\n\nexport * from \"./types\";\nexport * from \"./utils\";\n\ninterface NodeUpdate extends Resolve.ResolvedNode {\n  /** A flag to track if a node has changed since the last resolution */\n  updated: boolean;\n}\n\n/** Add model context to the data model */\nconst withContext = (model: DataModelWithParser): DataModelWithParser => {\n  return {\n    get: (binding: BindingLike, options?: DataModelOptions): any => {\n      return model.get(binding, {\n        context: { model },\n        ...options,\n      });\n    },\n\n    set: (\n      transaction: [BindingLike, any][],\n      options?: DataModelOptions,\n    ): Updates => {\n      return model.set(transaction, {\n        context: { model },\n        ...options,\n      });\n    },\n\n    delete: (binding: BindingLike, options?: DataModelOptions): void => {\n      return model.delete(binding, {\n        context: { model },\n        ...options,\n      });\n    },\n  };\n};\n\nexport type ResolverHooks = {\n  /** A hook to allow skipping of the resolution tree for a specific node */\n  skipResolve: SyncWaterfallHook<\n    [boolean, Node.Node, Resolve.NodeResolveOptions]\n  >;\n\n  /** An event emitted before calculating the next update */\n  beforeUpdate: SyncHook<[Set<BindingInstance> | undefined]>;\n\n  /** An event emitted after calculating the next update */\n  afterUpdate: SyncHook<[any]>;\n\n  /** The options passed to a node to resolve it to an object */\n  resolveOptions: SyncWaterfallHook<[Resolve.NodeResolveOptions, Node.Node]>;\n\n  /** A hook to transform the AST node into a new AST node before resolving it */\n  beforeResolve: SyncWaterfallHook<\n    [Node.Node | null, Resolve.NodeResolveOptions]\n  >;\n\n  /**\n   * A hook to transform an AST node into it's resolved value.\n   * This runs _before_ any children are resolved\n   */\n  resolve: SyncWaterfallHook<[any, Node.Node, Resolve.NodeResolveOptions]>;\n\n  /**\n   * A hook to transform the resolved value of an AST node.\n   * This runs _after_ all children nodes are resolved\n   */\n  afterResolve: SyncWaterfallHook<[any, Node.Node, Resolve.NodeResolveOptions]>;\n\n  /** Called at the very end of a node's tree being updated */\n  afterNodeUpdate: SyncHook<[Node.Node, Node.Node | undefined, NodeUpdate]>;\n};\n\n/**\n * The Resolver is the way to take a parsed AST graph of a view and resolve it to a concrete representation of the current user state\n * It combines the ability to mutate ast nodes before resolving, as well as the mutating the resolved objects while parsing\n */\nexport class Resolver {\n  public readonly hooks: ResolverHooks = {\n    skipResolve: new SyncWaterfallHook(),\n    beforeUpdate: new SyncHook(),\n    afterUpdate: new SyncHook(),\n    resolveOptions: new SyncWaterfallHook(),\n    beforeResolve: new SyncWaterfallHook(),\n    resolve: new SyncWaterfallHook(),\n    afterResolve: new SyncWaterfallHook(),\n    afterNodeUpdate: new SyncHook(),\n  };\n\n  /**\n   * The AST tree after beforeResolve is ran mapped to the AST before beforeResolve is ran\n   */\n  private readonly ASTMap: Map<Node.Node, Node.Node>;\n  /**\n   * The AST tree after beforeResolve is ran mapped to the AST before beforeResolve is ran\n   */\n  private AsyncIdMap: Map<string, Node.Node>;\n  /**\n   * The root node in the AST tree we want to resolve\n   */\n  public readonly root: Node.Node;\n\n  /**\n   * The cache of the last resolved values when walking the tree.\n   * This gets recycled every update to avoid stale data if a node is unused in an update\n   */\n  private resolveCache: Map<Node.Node, Resolve.ResolvedNode>;\n\n  /**\n   * Cache of node IDs that have been processed to track if nodes have duplicate IDs\n   */\n  private idCache: Set<string>;\n\n  /**\n   * The parameters required to resolve AST nodes\n   */\n  private readonly options: Resolve.ResolverOptions;\n\n  /**\n   * Tapable logger for logging errors encountered during view resolution\n   */\n  private logger?: Logger;\n\n  constructor(root: Node.Node, options: Resolve.ResolverOptions) {\n    this.root = root;\n    this.options = options;\n    this.resolveCache = new Map();\n    this.ASTMap = new Map();\n    this.logger = options.logger;\n    this.idCache = new Set();\n    this.AsyncIdMap = new Map();\n  }\n\n  public getSourceNode(convertedAST: Node.Node): Node.Node | undefined {\n    return this.ASTMap.get(convertedAST);\n  }\n\n  public update(\n    changes?: Set<BindingInstance>,\n    asyncChanges?: Set<string>,\n  ): any {\n    this.hooks.beforeUpdate.call(changes);\n    const resolveCache = new Map<Node.Node, Resolve.ResolvedNode>();\n    this.idCache.clear();\n    const prevASTMap = new Map(this.ASTMap);\n    this.ASTMap.clear();\n\n    const prevAsyncIdMap = new Map(this.AsyncIdMap);\n    const nextAsyncIdMap = new Map<string, Node.Node>();\n    asyncChanges?.forEach((id) => {\n      let current: Node.Node | undefined = prevAsyncIdMap.get(id);\n      while (current && prevASTMap.has(current)) {\n        const next = prevASTMap.get(current);\n        if (next && this.resolveCache.has(next)) {\n          this.resolveCache.delete(next);\n        }\n        current = current.parent;\n      }\n    });\n\n    const updated = this.computeTree(\n      this.root,\n      undefined,\n      changes,\n      resolveCache,\n      toNodeResolveOptions(this.options),\n      undefined,\n      prevASTMap,\n      nextAsyncIdMap,\n    );\n    this.AsyncIdMap = nextAsyncIdMap;\n    this.resolveCache = resolveCache;\n    this.hooks.afterUpdate.call(updated.value);\n    return updated.value;\n  }\n\n  public getResolveCache(): Map<Node.Node, Resolve.ResolvedNode> {\n    return new Map(this.resolveCache);\n  }\n\n  private getPreviousResult(node: Node.Node): Resolve.ResolvedNode | undefined {\n    if (!node) {\n      return;\n    }\n\n    const isFirstUpdate = this.resolveCache.size === 0;\n    const id = getNodeID(node);\n\n    if (id) {\n      if (this.idCache.has(id)) {\n        // Only log this conflict once to cut down on noise\n        // May want to swap this to logging when we first see the id -- which may not be the first render\n        if (isFirstUpdate) {\n          if (node.type === NodeType.Asset || node.type === NodeType.View) {\n            this.logger?.error(\n              `Cache conflict: Found Asset/View nodes that have conflicting ids: ${id}, may cause cache issues.`,\n            );\n          } else if (node.type === NodeType.Value) {\n            this.logger?.info(\n              `Cache conflict: Found Value nodes that have conflicting ids: ${id}, may cause cache issues. To improve performance make value node IDs globally unique.`,\n            );\n          }\n        }\n\n        // Don't use anything from a prev result if there's a duplicate id detected\n        return;\n      }\n\n      this.idCache.add(id);\n    }\n\n    return this.resolveCache.get(node);\n  }\n\n  private cloneNode(node: any) {\n    const clonedNode = clone(node);\n\n    Object.keys(clonedNode).forEach((key) => {\n      if (key === \"parent\") return;\n\n      const value = clonedNode[key];\n      if (typeof value === \"object\" && value !== null) {\n        clonedNode[key] = Array.isArray(value) ? [...value] : { ...value };\n      }\n    });\n\n    return clonedNode;\n  }\n\n  private computeTree(\n    node: Node.Node,\n    rawParent: Node.Node | undefined,\n    dataChanges: Set<BindingInstance> | undefined,\n    cacheUpdate: Map<Node.Node, Resolve.ResolvedNode>,\n    options: Resolve.NodeResolveOptions,\n    partiallyResolvedParent: Node.Node | undefined,\n    prevASTMap: Map<Node.Node, Node.Node>,\n    nextAsyncIdMap: Map<string, Node.Node>,\n  ): NodeUpdate {\n    const dependencyModel = new DependencyModel(options.data.model);\n\n    dependencyModel.trackSubset(\"core\");\n    const depModelWithParser = withContext(\n      withParser(dependencyModel, this.options.parseBinding),\n    );\n\n    const resolveOptions = this.hooks.resolveOptions.call(\n      {\n        ...options,\n        data: {\n          ...options.data,\n          model: depModelWithParser,\n        },\n        evaluate: (exp) =>\n          this.options.evaluator.evaluate(exp, { model: depModelWithParser }),\n        node,\n      },\n      node,\n    );\n\n    const previousResult = this.getPreviousResult(node);\n    const previousDeps = previousResult?.dependencies;\n\n    const dataChanged = caresAboutDataChanges(dataChanges, previousDeps);\n    const shouldUseLastValue = this.hooks.skipResolve.call(\n      !dataChanged,\n      node,\n      resolveOptions,\n    );\n\n    if (previousResult && shouldUseLastValue) {\n      const update = {\n        ...previousResult,\n        updated: false,\n      };\n\n      /** Recursively repopulate the AST map given some AST Node and it's resolved AST representation */\n      const repopulateASTMapFromCache = (\n        resolvedNode: Resolve.ResolvedNode,\n        AST: Node.Node,\n        ASTParent: Node.Node | undefined,\n      ) => {\n        const { node: resolvedASTLocal } = resolvedNode;\n        this.ASTMap.set(resolvedASTLocal, AST);\n        const resolvedUpdate = {\n          ...resolvedNode,\n          updated: false,\n        };\n        cacheUpdate.set(AST, resolvedUpdate);\n        if (resolvedUpdate.node.type === NodeType.Async) {\n          nextAsyncIdMap.set(resolvedUpdate.node.id, resolvedUpdate.node);\n        }\n        for (const key of resolvedUpdate.node.asyncNodesResolved ?? []) {\n          nextAsyncIdMap.set(key, resolvedUpdate.node);\n        }\n\n        /** Helper function for recursing over child node */\n        const handleChildNode = (childNode: Node.Node) => {\n          // In order to get the correct results, we need to use the node references from the last update.\n          const originalChildNode = prevASTMap.get(childNode) ?? childNode;\n          const previousChildResult = this.getPreviousResult(originalChildNode);\n          if (!previousChildResult) return;\n\n          repopulateASTMapFromCache(\n            previousChildResult,\n            originalChildNode,\n            AST,\n          );\n        };\n\n        if (\"children\" in resolvedASTLocal) {\n          resolvedASTLocal.children?.forEach(({ value: childAST }) =>\n            handleChildNode(childAST),\n          );\n        } else if (resolvedASTLocal.type === NodeType.MultiNode) {\n          resolvedASTLocal.values.forEach(handleChildNode);\n        }\n\n        this.hooks.afterNodeUpdate.call(AST, ASTParent, resolvedUpdate);\n      };\n\n      // Point the root of the cached node to the new resolved node.\n      previousResult.node.parent = partiallyResolvedParent;\n\n      repopulateASTMapFromCache(previousResult, node, rawParent);\n\n      return update;\n    }\n\n    // Shallow clone the node so that changes to it during the resolve steps don't impact the original.\n    // We are trusting that this becomes a deep clone once the whole node tree has been traversed.\n    const clonedNode: Node.Node = {\n      ...this.cloneNode(node),\n      parent: partiallyResolvedParent,\n    };\n    const resolvedAST = this.hooks.beforeResolve.call(\n      clonedNode,\n      resolveOptions,\n    ) ?? {\n      type: NodeType.Empty,\n    };\n\n    resolvedAST.parent = partiallyResolvedParent;\n\n    if (resolvedAST.type === NodeType.Async) {\n      nextAsyncIdMap.set(resolvedAST.id, resolvedAST);\n    }\n    for (const id of resolvedAST.asyncNodesResolved ?? []) {\n      nextAsyncIdMap.set(id, resolvedAST);\n    }\n\n    resolveOptions.node = resolvedAST;\n\n    this.ASTMap.set(resolvedAST, node);\n\n    let resolved = this.hooks.resolve.call(\n      undefined,\n      resolvedAST,\n      resolveOptions,\n    );\n\n    let updated = !dequal(previousResult?.value, resolved);\n\n    if (previousResult && !updated) {\n      resolved = previousResult?.value;\n    }\n\n    const childDependencies = new Set<BindingInstance>();\n    dependencyModel.trackSubset(\"children\");\n\n    if (\"children\" in resolvedAST) {\n      const newChildren = resolvedAST.children?.map((child) => {\n        const computedChildTree = this.computeTree(\n          child.value,\n          node,\n          dataChanges,\n          cacheUpdate,\n          resolveOptions,\n          resolvedAST,\n          prevASTMap,\n          nextAsyncIdMap,\n        );\n        const {\n          dependencies: childTreeDeps,\n          node: childNode,\n          updated: childUpdated,\n          value: childValue,\n        } = computedChildTree;\n\n        childTreeDeps.forEach((binding) => childDependencies.add(binding));\n\n        if (childValue) {\n          if (childNode.type === NodeType.MultiNode && !childNode.override) {\n            const arr = addLast(\n              dlv(resolved, child.path as any[], []),\n              childValue,\n            );\n            resolved = setIn(resolved, child.path, arr);\n          } else {\n            resolved = setIn(resolved, child.path, childValue);\n          }\n        }\n\n        updated = updated || childUpdated;\n\n        return { ...child, value: childNode };\n      });\n\n      resolvedAST.children = newChildren;\n    } else if (resolvedAST.type === NodeType.MultiNode) {\n      const childValue: any = [];\n      const rawParentToPassIn = node;\n\n      resolvedAST.values = resolvedAST.values.map((mValue) => {\n        const mTree = this.computeTree(\n          mValue,\n          rawParentToPassIn,\n          dataChanges,\n          cacheUpdate,\n          resolveOptions,\n          resolvedAST,\n          prevASTMap,\n          nextAsyncIdMap,\n        );\n\n        if (mTree.value !== undefined && mTree.value !== null) {\n          mTree.dependencies.forEach((bindingDep) =>\n            childDependencies.add(bindingDep),\n          );\n\n          updated = updated || mTree.updated;\n          childValue.push(mTree.value);\n        }\n\n        return mTree.node;\n      });\n\n      resolved = childValue;\n    }\n\n    childDependencies.forEach((bindingDep) =>\n      dependencyModel.addChildReadDep(bindingDep),\n    );\n\n    dependencyModel.trackSubset(\"core\");\n    if (previousResult && !updated) {\n      resolved = previousResult?.value;\n    }\n\n    resolved = this.hooks.afterResolve.call(resolved, resolvedAST, {\n      ...resolveOptions,\n      getDependencies: (scope?: \"core\" | \"children\") =>\n        dependencyModel.getDependencies(scope),\n    });\n\n    const update: NodeUpdate = {\n      node: resolvedAST,\n      updated,\n      value: resolved,\n      dependencies: new Set([\n        ...dependencyModel.getDependencies(),\n        ...childDependencies,\n      ]),\n    };\n\n    this.hooks.afterNodeUpdate.call(node, rawParent, update);\n    cacheUpdate.set(node, update);\n\n    return update;\n  }\n}\n","import { setIn } from \"timm\";\nimport { SyncBailHook, SyncWaterfallHook } from \"tapable-ts\";\nimport type { AnyAssetType, Node } from \"./types\";\nimport { NodeType } from \"./types\";\n\nexport * from \"./types\";\nexport * from \"./utils\";\n\nexport const EMPTY_NODE: Node.Empty = {\n  type: NodeType.Empty,\n};\n\nexport interface ParseObjectOptions {\n  /** how nested the templated is */\n  templateDepth?: number;\n}\n\nexport interface ParseObjectChildOptions {\n  key: string;\n  path: Node.PathSegment[];\n  parentObj: object;\n}\n\nexport type ParserHooks = {\n  /**\n   * A hook to interact with an object _before_ parsing it into an AST\n   *\n   * @param value - The object we're are about to parse\n   * @returns - A new value to parse.\n   *  If undefined, the original value is used.\n   *  If null, we stop parsing this node.\n   */\n  onParseObject: SyncWaterfallHook<[object, NodeType]>;\n  /**\n   * A callback to interact with an AST _after_ we parse it into the AST\n   *\n   * @param value - The object we parsed\n   * @param node - The AST node we generated\n   * @returns - A new AST node to use\n   *   If undefined, the original value is used.\n   *   If null, we ignore this node all together\n   */\n  onCreateASTNode: SyncWaterfallHook<[Node.Node | undefined | null, object]>;\n  /** A hook to call when parsing an object into an AST node\n   *\n   * @param obj - The object we're are about to parse\n   * @param nodeType - The type of node we're parsing\n   * @param parseOptions - Additional options when parsing\n   * @param childOptions - Additional options that are populated when the node being parsed is a child of another node\n   * @returns - A new AST node to use\n   *   If undefined, the original value is used.\n   *   If null, we ignore this node all together\n   */\n  parseNode: SyncBailHook<\n    [\n      obj: object,\n      nodeType: Node.ChildrenTypes,\n      parseOptions: ParseObjectOptions,\n      childOptions?: ParseObjectChildOptions,\n    ],\n    Node.Node | Node.Child[]\n  >;\n};\n\ninterface NestedObj {\n  /** The values of a nested local object */\n  children: Node.Child[];\n\n  value: any;\n}\n/**\n * The Parser is the way to take an incoming view from the user and parse it into an AST.\n * It provides a few ways to interact with the parsing, including mutating an object before and after creation of an AST node\n */\nexport class Parser {\n  public readonly hooks: ParserHooks = {\n    onParseObject: new SyncWaterfallHook(),\n    onCreateASTNode: new SyncWaterfallHook(),\n    parseNode: new SyncBailHook(),\n  };\n\n  public parseView(value: AnyAssetType): Node.View {\n    const viewNode = this.parseObject(value, NodeType.View);\n\n    if (!viewNode) {\n      throw new Error(\"Unable to parse object into a view\");\n    }\n\n    return viewNode as Node.View;\n  }\n\n  public createASTNode(node: Node.Node | null, value: any): Node.Node | null {\n    const tapped = this.hooks.onCreateASTNode.call(node, value);\n\n    if (tapped === undefined) {\n      return node;\n    }\n\n    return tapped;\n  }\n\n  public parseObject(\n    obj: object,\n    type: Node.ChildrenTypes = NodeType.Value,\n    options: ParseObjectOptions = { templateDepth: 0 },\n  ): Node.Node | null {\n    const parsedNode = this.hooks.parseNode.call(\n      obj,\n      type,\n      options,\n    ) as Node.Node | null;\n\n    if (parsedNode || parsedNode === null) {\n      return parsedNode;\n    }\n\n    const parseLocalObject = (\n      currentValue: any,\n      objToParse: unknown,\n      path: string[] = [],\n    ): NestedObj => {\n      if (typeof objToParse !== \"object\" || objToParse === null) {\n        return { value: objToParse, children: [] };\n      }\n\n      const localObj = this.hooks.onParseObject.call(objToParse, type);\n\n      if (!localObj) {\n        return currentValue;\n      }\n\n      const objEntries = Array.isArray(localObj)\n        ? localObj.map((v, i) => [i, v])\n        : [\n            ...Object.entries(localObj),\n            ...Object.getOwnPropertySymbols(localObj).map((s) => [\n              s,\n              (localObj as any)[s],\n            ]),\n          ];\n\n      const defaultValue: NestedObj = {\n        children: [],\n        value: currentValue,\n      };\n\n      const newValue = objEntries.reduce((accumulation, current): NestedObj => {\n        let { value } = accumulation;\n        const { children } = accumulation;\n        const [localKey, localValue] = current;\n\n        const newChildren = this.hooks.parseNode.call(\n          localValue,\n          NodeType.Value,\n          options,\n          {\n            path,\n            key: localKey,\n            parentObj: localObj,\n          },\n        ) as Node.Child[];\n\n        if (newChildren) {\n          children.push(...newChildren);\n        } else if (localValue && typeof localValue === \"object\") {\n          const result = parseLocalObject(accumulation.value, localValue, [\n            ...path,\n            localKey,\n          ]);\n\n          value = result.value;\n          children.push(...result.children);\n        } else {\n          value = setIn(accumulation.value, [...path, localKey], localValue);\n        }\n\n        return {\n          value,\n          children,\n        };\n      }, defaultValue);\n\n      return newValue;\n    };\n\n    const { value, children } = parseLocalObject(undefined, obj);\n\n    const baseAst =\n      value === undefined && !children.length\n        ? undefined\n        : {\n            type,\n            value,\n          };\n\n    if (baseAst && children.length) {\n      const parent: Node.BaseWithChildren<any> = baseAst;\n      parent.children = children;\n      children.forEach((child) => {\n        child.value.parent = parent;\n      });\n    }\n\n    return this.hooks.onCreateASTNode.call(baseAst, obj) ?? null;\n  }\n}\n","import { omit } from \"timm\";\nimport type { Options } from \"./options\";\nimport type { Resolver } from \"../resolver\";\nimport type {\n  Node,\n  ParseObjectOptions,\n  ParseObjectChildOptions,\n  Parser,\n} from \"../parser\";\nimport { NodeType } from \"../parser\";\nimport { ViewInstance, ViewPlugin } from \"../view\";\n\n/** A view plugin to remove inapplicable assets from the tree */\nexport class ApplicabilityPlugin implements ViewPlugin {\n  private isApplicability(obj: any) {\n    return obj && Object.prototype.hasOwnProperty.call(obj, \"applicability\");\n  }\n\n  applyResolver(resolver: Resolver) {\n    resolver.hooks.beforeResolve.tap(\n      \"applicability\",\n      (node: Node.Node | null, options: Options) => {\n        let newNode = node;\n\n        if (node?.type === NodeType.Applicability) {\n          const isApplicable = options.evaluate(node.expression);\n\n          if (isApplicable === false) {\n            return null;\n          }\n\n          newNode = node.value;\n        }\n\n        return newNode;\n      },\n    );\n  }\n\n  applyParser(parser: Parser) {\n    parser.hooks.parseNode.tap(\n      \"applicability\",\n      (\n        obj: any,\n        nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        childOptions?: ParseObjectChildOptions,\n      ) => {\n        if (this.isApplicability(obj)) {\n          const parsedApplicability = parser.parseObject(\n            omit(obj, \"applicability\"),\n            nodeType,\n            options,\n          );\n\n          if (!parsedApplicability) {\n            return childOptions ? [] : null;\n          }\n\n          const applicabilityNode = parser.createASTNode(\n            {\n              type: NodeType.Applicability,\n              expression: (obj as any).applicability,\n              value: parsedApplicability,\n            },\n            obj,\n          );\n\n          if (!applicabilityNode) {\n            return childOptions ? [] : null;\n          }\n\n          if (applicabilityNode.type === NodeType.Applicability) {\n            applicabilityNode.value.parent = applicabilityNode;\n          }\n\n          return childOptions\n            ? [\n                {\n                  path: [...childOptions.path, childOptions.key],\n                  value: applicabilityNode,\n                },\n              ]\n            : applicabilityNode;\n        }\n      },\n    );\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.resolver.tap(\"applicability\", this.applyResolver.bind(this));\n    view.hooks.parser.tap(\"applicability\", this.applyParser.bind(this));\n  }\n}\n","import { setIn } from \"timm\";\nimport deferred from \"p-defer\";\nimport type { Flow, FlowResult } from \"@player-ui/types\";\nimport queueMicrotask from \"queue-microtask\";\n\nimport { SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport type { Logger } from \"./logger\";\nimport { TapableLogger } from \"./logger\";\nimport type { ExpressionType } from \"./expressions\";\nimport { ExpressionEvaluator, isPromiseLike } from \"./expressions\";\nimport { SchemaController } from \"./schema\";\nimport { BindingParser } from \"./binding\";\nimport type { ViewInstance } from \"./view\";\nimport { resolveDataRefs } from \"./string-resolver\";\nimport type { FlowInstance } from \"./controllers\";\nimport {\n  ConstantsController,\n  ViewController,\n  DataController,\n  ValidationController,\n  FlowController,\n} from \"./controllers\";\nimport { FlowExpPlugin } from \"./plugins/flow-exp-plugin\";\nimport { DefaultExpPlugin } from \"./plugins/default-exp-plugin\";\nimport type {\n  PlayerFlowState,\n  InProgressState,\n  CompletedState,\n  ErrorState,\n  PlayerHooks,\n} from \"./types\";\nimport { NOT_STARTED_STATE } from \"./types\";\n\n/**\nVariables injected at build time\n*/\ndeclare global {\n  const __VERSION__: string;\n  const __GIT_COMMIT__: string;\n}\n\n// Version of Player at buildtime\nconst PLAYER_VERSION: string =\n  typeof __VERSION__ !== \"undefined\" ? __VERSION__ : \"unknown\";\n\n// HEAD commit used to build Player\nconst COMMIT: string =\n  typeof __GIT_COMMIT__ !== \"undefined\" ? __GIT_COMMIT__ : \"unknown\";\n\nexport interface PlayerPlugin {\n  /**\n   * Unique identifier of the plugin.\n   * Enables the plugin to be retrievable from Player.\n   */\n  symbol?: symbol;\n\n  /** The name of the plugin */\n  name: string;\n\n  /**\n   * Use this to tap into Player hooks\n   */\n  apply: (player: Player) => void;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface ExtendedPlayerPlugin<\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  Assets = void,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  Views = void,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  Expressions = void,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  DataTypes = void,\n> {}\n\nexport interface PlayerConfigOptions {\n  /** A set of plugins to load  */\n  plugins?: PlayerPlugin[];\n\n  /** A logger to use */\n  logger?: Logger;\n}\n\nexport interface PlayerInfo {\n  /** Version of the running player */\n  version: typeof PLAYER_VERSION;\n\n  /** Hash of the HEAD commit used to build the current version */\n  commit: typeof COMMIT;\n}\n\n/**\n * This is it.\n */\nexport class Player {\n  public static readonly info: PlayerInfo = {\n    version: PLAYER_VERSION,\n    commit: COMMIT,\n  };\n\n  public readonly logger: TapableLogger = new TapableLogger();\n  public readonly constantsController: ConstantsController =\n    new ConstantsController();\n  private config: PlayerConfigOptions;\n  private state: PlayerFlowState = NOT_STARTED_STATE;\n\n  public readonly hooks: PlayerHooks = {\n    flowController: new SyncHook<[FlowController]>(),\n    viewController: new SyncHook<[ViewController]>(),\n    view: new SyncHook<[ViewInstance]>(),\n    expressionEvaluator: new SyncHook<[ExpressionEvaluator]>(),\n    dataController: new SyncHook<[DataController]>(),\n    schema: new SyncHook<[SchemaController]>(),\n    validationController: new SyncHook<[ValidationController]>(),\n    bindingParser: new SyncHook<[BindingParser]>(),\n    state: new SyncHook<[PlayerFlowState]>(),\n    onStart: new SyncHook<[Flow]>(),\n    onEnd: new SyncHook<[]>(),\n    resolveFlowContent: new SyncWaterfallHook<[Flow]>(),\n  };\n\n  constructor(config?: PlayerConfigOptions) {\n    if (config?.logger) {\n      this.logger.addHandler(config.logger);\n    }\n\n    this.config = config || {};\n    this.config.plugins = [\n      new DefaultExpPlugin(),\n      ...(this.config.plugins || []),\n      new FlowExpPlugin(),\n    ];\n    this.config.plugins?.forEach((plugin) => {\n      plugin.apply(this);\n    });\n  }\n\n  /**  Returns currently registered plugins */\n  public getPlugins(): PlayerPlugin[] {\n    return this.config.plugins ?? [];\n  }\n\n  /** Find instance of [Plugin] that has been registered to Player */\n  public findPlugin<Plugin extends PlayerPlugin>(\n    symbol: symbol,\n  ): Plugin | undefined {\n    return this.config.plugins?.find((el) => el.symbol === symbol) as Plugin;\n  }\n\n  /** Retrieve an instance of [Plugin] and conditionally invoke [apply] if it exists */\n  public applyTo<Plugin extends PlayerPlugin>(\n    symbol: symbol,\n    apply: (plugin: Plugin) => void,\n  ): void {\n    const plugin = this.findPlugin<Plugin>(symbol);\n\n    if (plugin) {\n      apply(plugin);\n    }\n  }\n\n  /** Register and apply [Plugin] if one with the same symbol is not already registered. */\n  public registerPlugin(plugin: PlayerPlugin): void {\n    plugin.apply(this);\n    this.config.plugins?.push(plugin);\n  }\n\n  /** Returns the current version of the running player */\n  public getVersion(): string {\n    return Player.info.version;\n  }\n\n  /** Returns the git commit used to build Player version */\n  public getCommit(): string {\n    return Player.info.commit;\n  }\n\n  /**\n   * Fetch the current state of Player.\n   * It will return either `not-started`, `in-progress`, `completed`\n   * with some extra data in each\n   */\n  public getState(): PlayerFlowState {\n    return this.state;\n  }\n\n  /**\n   * A private means of setting the state of Player\n   * Calls the hooks for subscribers to listen for this event\n   */\n  private setState(state: PlayerFlowState) {\n    this.state = state;\n    this.hooks.state.call(state);\n  }\n\n  /** Start Player with the given flow */\n  private setupFlow(userContent: Flow): {\n    /** a callback to _actually_ start the flow */\n    start: () => void;\n\n    /** the state object to kick if off */\n    state: Omit<InProgressState, \"ref\">;\n  } {\n    const userFlow = this.hooks.resolveFlowContent.call(userContent);\n\n    const flowController = new FlowController(userFlow.navigation, {\n      logger: this.logger,\n    });\n\n    this.hooks.onStart.call(userFlow);\n\n    this.hooks.flowController.call(flowController);\n\n    // eslint-disable-next-line prefer-const\n    let expressionEvaluator: ExpressionEvaluator;\n    // eslint-disable-next-line prefer-const\n    let dataController: DataController;\n\n    const pathResolver = new BindingParser({\n      get: (binding) => {\n        return dataController.get(binding);\n      },\n      set: (transaction) => {\n        return dataController.set(transaction);\n      },\n      evaluate: (expression) => {\n        return expressionEvaluator.evaluate(expression);\n      },\n    });\n\n    this.hooks.bindingParser.call(pathResolver);\n    const parseBinding = pathResolver.parse;\n    const flowResultDeferred = deferred<FlowResult>();\n\n    const schema = new SchemaController(userFlow.schema);\n    this.hooks.schema.call(schema);\n\n    const validationController = new ValidationController(schema);\n\n    this.hooks.validationController.call(validationController);\n\n    dataController = new DataController(userFlow.data, {\n      pathResolver,\n      middleware: validationController.getDataMiddleware(),\n      logger: this.logger,\n    });\n\n    dataController.hooks.format.tap(\"player\", (value, binding) => {\n      const formatter = schema.getFormatter(binding);\n\n      return formatter ? formatter.format(value) : value;\n    });\n\n    dataController.hooks.deformat.tap(\"player\", (value, binding) => {\n      const formatter = schema.getFormatter(binding);\n\n      return formatter ? formatter.deformat(value) : value;\n    });\n\n    dataController.hooks.resolveDefaultValue.tap(\n      \"player\",\n      (binding) => schema.getApparentType(binding)?.default,\n    );\n\n    // eslint-disable-next-line prefer-const\n    let viewController: ViewController;\n\n    expressionEvaluator = new ExpressionEvaluator({\n      model: dataController,\n      logger: this.logger,\n    });\n\n    this.hooks.expressionEvaluator.call(expressionEvaluator);\n\n    expressionEvaluator.hooks.onError.tap(\"player\", (e) => {\n      flowResultDeferred.reject(e);\n\n      return true;\n    });\n\n    /** Resolve any data references in a string */\n    function resolveStrings<T>(val: T, formatted?: boolean) {\n      return resolveDataRefs(val, {\n        model: dataController,\n        evaluate: expressionEvaluator.evaluate,\n        formatted,\n      });\n    }\n\n    flowController.hooks.flow.tap(\"player\", (flow: FlowInstance) => {\n      flow.hooks.beforeTransition.tap(\"player\", (state, transitionVal) => {\n        /** Checks to see if there are any transitions for a specific transition state (i.e. next, back). If not, it will default to * */\n        const computedTransitionVal = state.transitions[transitionVal]\n          ? transitionVal\n          : \"*\";\n        if (state.onEnd && state.transitions[computedTransitionVal]) {\n          if (typeof state.onEnd === \"object\" && \"exp\" in state.onEnd) {\n            expressionEvaluator?.evaluate(state.onEnd.exp);\n          } else {\n            expressionEvaluator?.evaluate(state.onEnd as ExpressionType);\n          }\n        }\n\n        /** If the transition does not exist, then do not resolve any expressions */\n        if (\n          !(\"transitions\" in state) ||\n          !state.transitions[computedTransitionVal]\n        ) {\n          return state;\n        }\n\n        /** resolves and sets the transition to the computed exp */\n        return setIn(\n          state,\n          [\"transitions\", computedTransitionVal],\n          resolveStrings(state.transitions[computedTransitionVal]),\n        ) as any;\n      });\n\n      flow.hooks.skipTransition.tap(\"validation\", (currentState) => {\n        if (currentState?.value.state_type === \"VIEW\") {\n          const { canTransition, validations } =\n            validationController.validateView(\"navigation\");\n\n          if (!canTransition && validations) {\n            const bindings = new Set(validations.keys());\n            viewController?.currentView?.update(bindings);\n\n            return true;\n          }\n        }\n\n        return undefined;\n      });\n\n      flow.hooks.resolveTransitionNode.tap(\"player\", (state) => {\n        let newState = state;\n\n        if (\"ref\" in state) {\n          newState = setIn(state, [\"ref\"], resolveStrings(state.ref)) as any;\n        }\n\n        if (\"param\" in state) {\n          newState = setIn(\n            state,\n            [\"param\"],\n            resolveStrings(state.param, false),\n          ) as any;\n        }\n\n        return newState;\n      });\n\n      flow.hooks.transition.tap(\"player\", (_oldState, newState) => {\n        if (newState.value.state_type !== \"VIEW\") {\n          validationController.reset();\n        }\n      });\n\n      // Tap for action states\n      flow.hooks.afterTransition.tap(\"player-action-states\", (flowInstance) => {\n        const value = flowInstance.currentState?.value;\n        if (value && value.state_type === \"ASYNC_ACTION\") {\n          const { exp } = value;\n          // defer async execution to next tick to allow transition to settle\n          try {\n            const result = expressionEvaluator.evaluateAsync(exp);\n            if (isPromiseLike(result)) {\n              if (value.await) {\n                queueMicrotask(() => {\n                  result\n                    .then((r) => flowController?.transition(String(r)))\n                    .catch(flowResultDeferred.reject);\n                });\n              } else {\n                this.logger.warn(\n                  \"Unawaited promise used as return value in in non-async context, transitioning with '*' value\",\n                );\n                flowController?.transition(String(result));\n              }\n            } else {\n              this.logger.warn(\n                \"Non async expression used in async action node\",\n              );\n              flowController?.transition(String(result));\n            }\n          } catch (e) {\n            flowResultDeferred.reject(e);\n          }\n        } else if (value && value.state_type === \"ACTION\") {\n          // handle sync actions\n          const { exp } = value;\n          const result = expressionEvaluator.evaluate(exp);\n          if (isPromiseLike(result)) {\n            this.logger.warn(\n              \"Async expression used as return value in in non-async context, transitioning with '*' value\",\n            );\n          }\n          flowController?.transition(String(result));\n        }\n\n        expressionEvaluator.reset();\n      });\n    });\n\n    this.hooks.dataController.call(dataController);\n\n    validationController.setOptions({\n      parseBinding,\n      model: dataController,\n      logger: this.logger,\n      evaluate: expressionEvaluator.evaluate,\n      constants: this.constantsController,\n    });\n\n    viewController = new ViewController(userFlow.views || [], {\n      evaluator: expressionEvaluator,\n      parseBinding,\n      transition: flowController.transition,\n      model: dataController,\n      utils: {\n        findPlugin: <Plugin = unknown>(pluginSymbol: symbol) => {\n          return this.findPlugin(pluginSymbol) as unknown as Plugin;\n        },\n      },\n      logger: this.logger,\n      flowController,\n      schema,\n      format: (binding, value) => {\n        const formatter = schema.getFormatter(binding);\n\n        return formatter?.format ? formatter.format(value) : value;\n      },\n      formatValue: (ref, value) => {\n        const formatter = schema.getFormatterForType(ref);\n\n        return formatter?.format ? formatter.format(value) : value;\n      },\n      validation: {\n        ...validationController.forView(parseBinding),\n        type: (b) => schema.getType(parseBinding(b)),\n      },\n      constants: this.constantsController,\n    });\n\n    viewController.hooks.view.tap(\"player\", (view) => {\n      validationController.onView(view);\n      this.hooks.view.call(view);\n    });\n    this.hooks.viewController.call(viewController);\n\n    return {\n      start: () => {\n        flowController\n          .start()\n          .then((endState) => {\n            const flowResult: FlowResult = {\n              endState: resolveStrings(endState, false),\n              data: dataController.serialize(),\n            };\n\n            return flowResult;\n          })\n          .then(flowResultDeferred.resolve)\n          .catch((e) => {\n            this.logger.error(`Something went wrong: ${e.message}`);\n            throw e;\n          })\n          .catch(flowResultDeferred.reject)\n          .finally(() => this.hooks.onEnd.call());\n      },\n      state: {\n        status: \"in-progress\",\n        flowResult: flowResultDeferred.promise,\n        controllers: {\n          data: dataController,\n          view: viewController,\n          flow: flowController,\n          schema,\n          expression: expressionEvaluator,\n          binding: pathResolver,\n          validation: validationController,\n        },\n        fail: flowResultDeferred.reject,\n        flow: userFlow,\n        logger: this.logger,\n      },\n    };\n  }\n\n  public async start(payload: Flow): Promise<CompletedState> {\n    const ref = Symbol(payload?.id ?? \"payload\");\n\n    /** A check to avoid updating the state for a flow that's not the current one */\n    const maybeUpdateState = <T extends PlayerFlowState>(newState: T) => {\n      if (this.state.ref !== ref) {\n        this.logger.warn(\n          `Received update for a flow that's not the current one`,\n        );\n\n        return newState;\n      }\n\n      this.setState(newState);\n\n      return newState;\n    };\n\n    this.setState({\n      status: \"not-started\",\n      ref,\n    });\n\n    try {\n      const { state, start } = this.setupFlow(payload);\n      this.setState({\n        ref,\n        ...state,\n      });\n\n      start();\n\n      // common data for the end state\n      // make sure to use the same ref as the starting one\n      const endProps = {\n        ref,\n        status: \"completed\",\n        flow: state.flow,\n        controllers: {\n          data: state.controllers.data.makeReadOnly(),\n        },\n      } as const;\n\n      return maybeUpdateState({\n        ...(await state.flowResult),\n        ...endProps,\n      });\n    } catch (error: any) {\n      const errorState: ErrorState = {\n        status: \"error\",\n        ref,\n        flow: payload,\n        error,\n      };\n\n      maybeUpdateState(errorState);\n\n      throw error;\n    }\n  }\n}\n","import { SyncBailHook, SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport type { DeferredPromise } from \"p-defer\";\nimport defer from \"p-defer\";\nimport type {\n  NavigationFlow,\n  NavigationFlowState,\n  NavigationFlowEndState,\n  NavigationFlowActionState,\n  NavigationFlowAsyncActionState,\n  NavigationFlowExternalState,\n  NavigationFlowFlowState,\n  NavigationFlowViewState,\n} from \"@player-ui/types\";\nimport type { Logger } from \"../../logger\";\n\nexport interface NamedState {\n  /** The name of the navigation node */\n  name: string;\n\n  /** The nav node */\n  value: NavigationFlowState;\n}\n\nexport interface TransitionOptions {\n  /** Ignore any validations or other signals preventing the transition from taking place  */\n  force?: boolean;\n}\nexport type TransitionFunction = (\n  name: string,\n  options?: TransitionOptions,\n) => void;\n\nexport interface FlowInstanceHooks {\n  beforeStart: SyncBailHook<\n    [NavigationFlow],\n    NavigationFlow,\n    Record<string, any>\n  >;\n  /** A callback when the onStart node was present */\n  onStart: SyncHook<[any], Record<string, any>>;\n  /** A callback when the onEnd node was present */\n  onEnd: SyncHook<[any], Record<string, any>>;\n  /** A hook to intercept and block a transition */\n  skipTransition: SyncBailHook<\n    [NamedState | undefined],\n    boolean | undefined,\n    Record<string, any>\n  >;\n  /** A chance to manipulate the flow-node used to calculate the given transition used  */\n  beforeTransition: SyncWaterfallHook<\n    [\n      (\n        | NavigationFlowViewState\n        | NavigationFlowFlowState\n        | NavigationFlowActionState\n        | NavigationFlowAsyncActionState\n        | NavigationFlowExternalState\n      ),\n      string,\n    ],\n    Record<string, any>\n  >;\n  /** A chance to manipulate the flow-node calculated after a transition */\n  resolveTransitionNode: SyncWaterfallHook<\n    [NavigationFlowState],\n    Record<string, any>\n  >;\n  /** A callback when a transition from 1 state to another was made */\n  transition: SyncHook<\n    [NamedState | undefined, NamedState],\n    Record<string, any>\n  >;\n  /** A callback to run actions after a transition occurs */\n  afterTransition: SyncHook<[FlowInstance], Record<string, any>>;\n}\n\n/** The Content navigation state machine */\nexport class FlowInstance {\n  private flow: NavigationFlow;\n  private log?: Logger;\n  private history: string[];\n  private isTransitioning = false;\n  private flowPromise?: DeferredPromise<NavigationFlowEndState>;\n  public readonly id: string;\n  public currentState?: NamedState;\n  public readonly hooks: FlowInstanceHooks = {\n    beforeStart: new SyncBailHook<[NavigationFlow], NavigationFlow>(),\n    onStart: new SyncHook<[any]>(),\n    onEnd: new SyncHook<[any]>(),\n    skipTransition: new SyncBailHook<\n      [NamedState | undefined],\n      boolean | undefined\n    >(),\n    beforeTransition: new SyncWaterfallHook<\n      [Exclude<NavigationFlowState, NavigationFlowEndState>, string]\n    >(),\n    resolveTransitionNode: new SyncWaterfallHook<[NavigationFlowState]>(),\n    transition: new SyncHook<[NamedState | undefined, NamedState]>(),\n    afterTransition: new SyncHook<[FlowInstance]>(),\n  };\n\n  constructor(\n    id: string,\n    flow: NavigationFlow,\n    options?: {\n      /** Logger instance to use */\n      logger?: Logger;\n    },\n  ) {\n    this.id = id;\n    this.flow = flow;\n    this.log = options?.logger;\n    this.history = [];\n\n    this.hooks.transition.tap(\n      \"startPromise\",\n      async (_oldState, nextState: NamedState) => {\n        const newState = nextState.value;\n\n        if (this.flowPromise && newState.state_type === \"END\") {\n          this.flowPromise.resolve(newState);\n        }\n      },\n    );\n  }\n\n  /** Start the state machine */\n  public async start(): Promise<NavigationFlowEndState> {\n    if (this.flowPromise) {\n      this.log?.warn(\"Already called start for flow\");\n\n      return this.flowPromise.promise;\n    }\n\n    this.flow = this.hooks.beforeStart.call(this.flow) || this.flow;\n\n    if (this.flow.onStart) {\n      this.hooks.onStart.call(this.flow.onStart);\n    }\n\n    const initialState = this.flow.startState;\n\n    if (!initialState) {\n      return Promise.reject(new Error(\"No 'startState' defined for flow\"));\n    }\n\n    this.flowPromise = defer();\n    this.pushHistory(initialState);\n\n    return this.flowPromise.promise;\n  }\n\n  public transition(\n    transitionValue: string,\n    options?: TransitionOptions,\n  ): void {\n    if (this.isTransitioning) {\n      throw new Error(\n        `Transitioning while ongoing transition from ${this.currentState?.name} is in progress is not supported`,\n      );\n    }\n\n    if (this.currentState?.value.state_type === \"END\") {\n      this.log?.warn(\n        `Skipping transition using ${transitionValue}. Already at and END state`,\n      );\n\n      return;\n    }\n\n    if (this.currentState === undefined) {\n      throw new Error(\"Cannot transition when there's no current state\");\n    }\n\n    if (options?.force) {\n      this.log?.debug(`Forced transition. Skipping validation checks`);\n    } else {\n      const skipTransition = this.hooks.skipTransition.call(this.currentState);\n\n      if (skipTransition) {\n        this.log?.debug(\n          `Skipping transition from ${this.currentState.name} b/c hook told us to`,\n        );\n        return;\n      }\n    }\n\n    const state = this.hooks.beforeTransition.call(\n      this.currentState.value,\n      transitionValue,\n    );\n\n    if (!(\"transitions\" in state)) {\n      throw new Error(`No transitions defined for ${this.currentState.value}`);\n    }\n\n    const { transitions } = state;\n    const nextState = transitions[transitionValue] || transitions[\"*\"];\n\n    if (nextState === undefined) {\n      this.log?.warn(\n        `No transition from ${this.currentState.name} using ${transitionValue} or *`,\n      );\n\n      return;\n    }\n\n    this.log?.debug(\n      `Transitioning from ${this.currentState.name} to ${nextState} using ${transitionValue} `,\n    );\n\n    return this.pushHistory(nextState, options);\n  }\n\n  private pushHistory(stateName: string, options?: TransitionOptions) {\n    if (!Object.prototype.hasOwnProperty.call(this.flow, stateName)) {\n      throw new Error(`No flow definition for: ${stateName} was found.`);\n    }\n\n    let nextState = this.flow[stateName];\n\n    if (\n      !this.flow[stateName] ||\n      typeof nextState !== \"object\" ||\n      !(\"state_type\" in nextState)\n    ) {\n      this.log?.error(`Flow doesn't contain any states named: ${stateName}`);\n\n      return;\n    }\n\n    const prevState = this.currentState;\n\n    this.isTransitioning = true;\n    nextState = this.hooks.resolveTransitionNode.call(nextState);\n\n    const newCurrentState = {\n      name: stateName,\n      value: nextState,\n    } as NamedState;\n    this.currentState = newCurrentState;\n    this.history.push(stateName);\n\n    // If the new state is an END state call the `onEnd` if it exists\n\n    if (newCurrentState.value.state_type === \"END\" && this.flow.onEnd) {\n      this.hooks.onEnd.call(this.flow.onEnd);\n    }\n\n    this.hooks.transition.call(prevState, {\n      ...newCurrentState,\n    });\n\n    this.isTransitioning = false;\n\n    this.hooks.afterTransition.call(this);\n  }\n}\n","import { SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport queueMicrotask from \"queue-microtask\";\nimport { Registry } from \"@player-ui/partial-match-registry\";\nimport type { View, NavigationFlowViewState } from \"@player-ui/types\";\n\nimport { resolveDataRefsInString } from \"../../string-resolver\";\nimport type { Resolve, ViewPlugin } from \"../../view\";\nimport {\n  ApplicabilityPlugin,\n  AssetPlugin,\n  AssetTransformCorePlugin,\n  MultiNodePlugin,\n  StringResolverPlugin,\n  SwitchPlugin,\n  TemplatePlugin,\n  toNodeResolveOptions,\n  ViewInstance,\n} from \"../../view\";\nimport type { Logger } from \"../../logger\";\nimport type { FlowInstance, FlowController } from \"../flow\";\nimport type { DataController } from \"../data/controller\";\nimport type { TransformRegistry } from \"./types\";\nimport type { BindingInstance } from \"../../binding\";\n\nexport interface ViewControllerOptions {\n  /** Where to get data from */\n  model: DataController;\n\n  /** Where to log data */\n  logger?: Logger;\n\n  /** A flow-controller instance to listen for view changes */\n  flowController: FlowController;\n}\n\nexport type ViewControllerHooks = {\n  /** Do any processing before the `View` instance is created */\n  resolveView: SyncWaterfallHook<\n    [View | undefined, string, NavigationFlowViewState]\n  >;\n\n  /** The hook right before the View starts resolving. Attach anything custom here */\n  view: SyncHook<[ViewInstance]>;\n};\n\n/** A controller to manage updating/switching views */\nexport class ViewController {\n  public readonly hooks: ViewControllerHooks = {\n    resolveView: new SyncWaterfallHook(),\n    view: new SyncHook(),\n  };\n\n  private readonly viewMap: Record<string, View>;\n  private readonly viewOptions: Resolve.ResolverOptions & ViewControllerOptions;\n  private pendingUpdate?: {\n    /** pending data binding changes */\n    changedBindings?: Set<BindingInstance>;\n    /** Whether we have a microtask queued to handle this pending update */\n    scheduled?: boolean;\n  };\n  private readonly viewPlugins: Array<ViewPlugin>;\n\n  public currentView?: ViewInstance;\n  public transformRegistry: TransformRegistry = new Registry();\n  public optimizeUpdates = true;\n\n  constructor(\n    initialViews: View[],\n    options: Resolve.ResolverOptions & ViewControllerOptions,\n  ) {\n    this.viewOptions = options;\n    this.viewMap = initialViews.reduce<Record<string, View>>(\n      (viewMap, view) => {\n        viewMap[view.id] = view;\n        return viewMap;\n      },\n      {},\n    );\n\n    options.flowController.hooks.flow.tap(\n      \"viewController\",\n      (flow: FlowInstance) => {\n        flow.hooks.transition.tap(\"viewController\", (_oldState, newState) => {\n          if (newState.value.state_type === \"VIEW\") {\n            this.onView(newState.value);\n          } else {\n            this.currentView = undefined;\n          }\n        });\n      },\n    );\n\n    /** Trigger a view update */\n    const update = (updates: Set<BindingInstance>, silent = false) => {\n      if (this.currentView) {\n        if (this.optimizeUpdates) {\n          this.queueUpdate(updates, silent);\n        } else {\n          this.currentView.update();\n        }\n      }\n    };\n\n    options.model.hooks.onUpdate.tap(\n      \"viewController\",\n      (updates, updateOptions) => {\n        update(\n          new Set(updates.map((t) => t.binding)),\n          updateOptions?.silent ?? false,\n        );\n      },\n    );\n\n    options.model.hooks.onDelete.tap(\"viewController\", (binding) => {\n      const parentBinding = binding.parent();\n      const property = binding.key();\n\n      // Deleting an array item will trigger an update for the entire array\n      if (typeof property === \"number\" && parentBinding) {\n        update(new Set([parentBinding]));\n      } else {\n        update(new Set([binding]));\n      }\n    });\n\n    this.viewPlugins = this.createViewPlugins();\n  }\n\n  private queueUpdate(bindings: Set<BindingInstance>, silent = false) {\n    if (this.pendingUpdate?.changedBindings) {\n      // If there's already a pending update, just add to it don't worry about silent updates here yet\n      this.pendingUpdate.changedBindings = new Set([\n        ...this.pendingUpdate.changedBindings,\n        ...bindings,\n      ]);\n    } else {\n      this.pendingUpdate = { changedBindings: bindings, scheduled: false };\n    }\n\n    // If there's no pending update, schedule one only if this one isn't silent\n    // otherwise if this is silent, we'll just wait for the next non-silent update and make sure our bindings are included\n    if (!this.pendingUpdate.scheduled && !silent) {\n      this.pendingUpdate.scheduled = true;\n      queueMicrotask(() => {\n        const updates = this.pendingUpdate?.changedBindings;\n        this.pendingUpdate = undefined;\n        this.currentView?.update(updates);\n      });\n    }\n  }\n\n  private getViewForRef(viewRef: string): View | undefined {\n    // First look for a 1:1 viewRef -> id mapping (this is most common)\n    if (this.viewMap[viewRef]) {\n      return this.viewMap[viewRef];\n    }\n\n    // The view ids saved may also contain model refs, resolve those and try again\n    const matchingViewId = Object.keys(this.viewMap).find(\n      (possibleViewIdMatch) =>\n        viewRef ===\n        resolveDataRefsInString(possibleViewIdMatch, {\n          model: this.viewOptions.model,\n          evaluate: this.viewOptions.evaluator.evaluate,\n        }),\n    );\n\n    if (matchingViewId && this.viewMap[matchingViewId]) {\n      return this.viewMap[matchingViewId];\n    }\n  }\n\n  public onView(state: NavigationFlowViewState): void {\n    const viewId = state.ref;\n\n    const source = this.hooks.resolveView.call(\n      this.getViewForRef(viewId),\n      viewId,\n      state,\n    );\n\n    if (!source) {\n      throw new Error(`No view with id ${viewId}`);\n    }\n\n    const view = new ViewInstance(source, this.viewOptions);\n    this.currentView = view;\n\n    // Give people a chance to attach their\n    // own listeners to the view before we resolve it\n    this.applyViewPlugins(view);\n    this.hooks.view.call(view);\n    view.update();\n  }\n\n  private applyViewPlugins(view: ViewInstance): void {\n    for (const plugin of this.viewPlugins) {\n      plugin.apply(view);\n    }\n  }\n\n  private createViewPlugins(): Array<ViewPlugin> {\n    const pluginOptions = toNodeResolveOptions(this.viewOptions);\n    return [\n      new AssetPlugin(),\n      new SwitchPlugin(pluginOptions),\n      new ApplicabilityPlugin(),\n      new AssetTransformCorePlugin(this.transformRegistry),\n      new StringResolverPlugin(),\n      new TemplatePlugin(pluginOptions),\n      new MultiNodePlugin(),\n    ];\n  }\n}\n","export interface Node<T extends string> {\n  /** The basic node type */\n  name: T;\n}\n\n/**\n * An AST node that represents a nested path in the model\n * foo.{{bar}}.baz (this is {{bar}})\n */\nexport interface PathNode extends Node<\"PathNode\"> {\n  /** The path in the model that this node represents */\n  path: Array<AnyNode>;\n}\n\n/**\n * A segment representing a query\n * [foo=bar]\n */\nexport interface QueryNode extends Node<\"Query\"> {\n  /** The key to query */\n  key: AnyNode;\n\n  /** The target value */\n  value?: AnyNode;\n}\n\n/** A simple segment */\nexport interface ValueNode extends Node<\"Value\"> {\n  /** The segment value */\n  value: string | number | boolean;\n}\n\n/** A nested expression */\nexport interface ExpressionNode extends Node<\"Expression\"> {\n  /** The expression */\n  value: string;\n}\n\n/** Helper to create a value node */\nexport const toValue = (value: string | number | boolean): ValueNode => ({\n  name: \"Value\",\n  value,\n});\n\n/** Helper to create an expression node */\nexport const toExpression = (value: string): ExpressionNode => ({\n  name: \"Expression\",\n  value,\n});\n\n/** Helper to create a nested path node */\nexport const toPath = (path: Array<AnyNode>): PathNode => ({\n  name: \"PathNode\",\n  path,\n});\n\n/** Helper to create a query node */\nexport const toQuery = (key: AnyNode, value?: AnyNode): QueryNode => ({\n  name: \"Query\",\n  key,\n  value,\n});\n\n/** Create a concat node */\nexport const toConcatenatedNode = (\n  values: Array<PathNode | ValueNode | ExpressionNode>,\n): PathNode | ValueNode | ConcatenatedNode | ExpressionNode => {\n  if (values.length === 1) {\n    return values[0];\n  }\n\n  return {\n    name: \"Concatenated\",\n    value: values,\n  };\n};\n\n/**\n * A binding segment that's multiple smaller ones\n * {{foo}}_bar_{{baz}}\n */\nexport interface ConcatenatedNode extends Node<\"Concatenated\"> {\n  /** A list of nested paths, or value nodes to concat together to form a segment */\n  value: Array<PathNode | ValueNode | ExpressionNode>;\n}\n\nexport type AnyNode =\n  | PathNode\n  | QueryNode\n  | ValueNode\n  | ConcatenatedNode\n  | ExpressionNode;\nexport type Path = Array<AnyNode>;\n\nexport interface ParserSuccessResult {\n  /** A successful parse result */\n  status: true;\n\n  /** The path the binding represents */\n  path: PathNode;\n}\n\nexport interface ParserFailureResult {\n  /** A failed parse result */\n  status: false;\n\n  /** The message representing the reason the parse result failed */\n  error: string;\n}\n\nexport type ParserResult = ParserSuccessResult | ParserFailureResult;\n\nexport type Parser = (raw: string) => ParserResult;\n","import type {\n  Parser,\n  AnyNode,\n  PathNode,\n  ConcatenatedNode,\n  ValueNode,\n  QueryNode,\n  ExpressionNode,\n} from \"../ast\";\nimport {\n  toValue,\n  toPath,\n  toConcatenatedNode,\n  toQuery,\n  toExpression,\n} from \"../ast\";\n\nconst SEGMENT_SEPARATOR = \".\";\nconst OPEN_CURL = \"{\";\nconst CLOSE_CURL = \"}\";\nconst OPEN_BRACKET = \"[\";\nconst CLOSE_BRACKET = \"]\";\nconst EQUALS = \"=\";\nconst SINGLE_QUOTE = \"'\";\nconst DOUBLE_QUOTE = '\"';\nconst BACK_TICK = \"`\";\n// const IDENTIFIER_REGEX = /[\\w\\-@]+/;\n\n/** A _faster_ way to match chars instead of a regex. */\nconst isIdentifierChar = (char?: string): boolean => {\n  if (!char) {\n    return false;\n  }\n\n  const charCode = char.charCodeAt(0);\n\n  const matches =\n    charCode === 32 || // ' '\n    charCode === 34 || // \"\n    charCode === 39 || // '\n    charCode === 40 || // (\n    charCode === 41 || // )\n    charCode === 42 || // *\n    charCode === 46 || // .\n    charCode === 61 || // =\n    charCode === 91 || // [\n    charCode === 93 || // ]\n    charCode === 96 || // `\n    charCode === 123 || // {\n    charCode === 125; // }\n\n  return !matches;\n};\n\n/** Parse out a binding AST from a path */\nexport const parse: Parser = (path) => {\n  let index = 1;\n  let ch = path.charAt(0);\n\n  /** get the next char in the string */\n  const next = (expected?: string) => {\n    if (expected && ch !== expected) {\n      throw new Error(`Expected char: ${expected} but got: ${ch}`);\n    }\n\n    ch = path.charAt(index);\n    index += 1;\n    return ch;\n  };\n\n  /** gobble all whitespace */\n  const whitespace = () => {\n    while (ch === \" \") {\n      next();\n    }\n  };\n\n  /** get an identifier if you can */\n  const identifier = (allowBoolValue = false): ValueNode | undefined => {\n    if (!isIdentifierChar(ch)) {\n      return;\n    }\n\n    let value: string | number = ch;\n\n    while (next()) {\n      if (!isIdentifierChar(ch)) {\n        break;\n      }\n\n      value += ch;\n    }\n\n    if (allowBoolValue) {\n      if (value === \"true\") {\n        return toValue(true);\n      }\n      if (value === \"false\") {\n        return toValue(false);\n      }\n    }\n\n    if (value) {\n      const maybeNumber = Number(value);\n      value = isNaN(maybeNumber) ? value : maybeNumber;\n      return toValue(value);\n    }\n  };\n\n  /** get an expression node if you can */\n  const expression = (): ExpressionNode | undefined => {\n    if (ch === BACK_TICK) {\n      next(BACK_TICK);\n\n      let exp = ch;\n\n      while (next()) {\n        if (ch === BACK_TICK) {\n          break;\n        }\n\n        exp += ch;\n      }\n\n      next(BACK_TICK);\n\n      if (exp) {\n        return toExpression(exp);\n      }\n    }\n  };\n\n  /** Grab a value using a regex */\n  const regex = (match: RegExp): ValueNode | undefined => {\n    if (!ch?.match(match)) {\n      return;\n    }\n\n    let value = ch;\n\n    while (next()) {\n      if (!ch?.match(match)) {\n        break;\n      }\n\n      value += ch;\n    }\n\n    if (value) {\n      return toValue(value);\n    }\n  };\n\n  /** parse out a nestedPath if you can */\n  const nestedPath = (): PathNode | undefined => {\n    if (ch === OPEN_CURL) {\n      next(OPEN_CURL);\n      next(OPEN_CURL);\n\n      const modelRef = parsePath();\n      next(CLOSE_CURL);\n      next(CLOSE_CURL);\n      return modelRef;\n    }\n  };\n\n  /** get a simple segment node */\n  const simpleSegment = (allowBoolValue = false) =>\n    nestedPath() ?? expression() ?? identifier(allowBoolValue);\n\n  /** Parse a segment */\n  const segment = ():\n    | ConcatenatedNode\n    | PathNode\n    | ValueNode\n    | ExpressionNode\n    | undefined => {\n    // Either a string, modelRef, or concatenated version (both)\n    const segments: Array<ValueNode | PathNode | ExpressionNode> = [];\n    let nextSegment = simpleSegment();\n\n    while (nextSegment !== undefined) {\n      segments.push(nextSegment);\n      nextSegment = simpleSegment();\n    }\n\n    if (segments.length === 0) {\n      return undefined;\n    }\n\n    return toConcatenatedNode(segments);\n  };\n\n  /** get an optionally quoted block */\n  const optionallyQuotedSegment = (\n    allowBoolValue = false,\n  ): ValueNode | PathNode | ExpressionNode | undefined => {\n    whitespace();\n\n    // see if we have a quote\n\n    if (ch === SINGLE_QUOTE || ch === DOUBLE_QUOTE) {\n      const singleQuote = ch === SINGLE_QUOTE;\n      next(singleQuote ? SINGLE_QUOTE : DOUBLE_QUOTE);\n      const id = regex(/[^'\"]+/);\n      next(singleQuote ? SINGLE_QUOTE : DOUBLE_QUOTE);\n      return id;\n    }\n\n    return simpleSegment(allowBoolValue);\n  };\n\n  /** eat equals signs */\n  const equals = (): boolean => {\n    if (ch !== EQUALS) {\n      return false;\n    }\n\n    while (ch === EQUALS) {\n      next();\n    }\n\n    return true;\n  };\n\n  /** Parse out a bracket */\n  const parseBracket = ():\n    | ValueNode\n    | QueryNode\n    | PathNode\n    | ExpressionNode\n    | undefined => {\n    if (ch === OPEN_BRACKET) {\n      next(OPEN_BRACKET);\n      whitespace();\n      let value: ValueNode | QueryNode | PathNode | ExpressionNode | undefined =\n        optionallyQuotedSegment();\n      if (value) {\n        whitespace();\n        if (equals()) {\n          whitespace();\n          const second = optionallyQuotedSegment(true);\n          value = toQuery(value, second);\n          whitespace();\n        }\n      } else {\n        throw new Error(`Expected identifier`);\n      }\n\n      if (value) {\n        next(CLOSE_BRACKET);\n      }\n\n      return value;\n    }\n  };\n\n  /** Parse a segment and any number of brackets following it */\n  const parseSegmentAndBrackets = (): Array<AnyNode> => {\n    // try to parse a segment first\n\n    const parsed: Array<AnyNode> = [];\n\n    const firstSegment = segment();\n\n    if (firstSegment) {\n      parsed.push(firstSegment);\n\n      let bracketSegment = parseBracket();\n\n      if (bracketSegment?.name === \"Value\") {\n        const maybeNumber = Number(bracketSegment.value);\n        bracketSegment.value =\n          isNaN(maybeNumber) || String(maybeNumber) !== bracketSegment.value\n            ? bracketSegment.value\n            : maybeNumber;\n      }\n\n      while (bracketSegment !== undefined) {\n        parsed.push(bracketSegment);\n        bracketSegment = parseBracket();\n      }\n    }\n\n    return parsed;\n  };\n\n  /** Parse out a path segment */\n  const parsePath = (): PathNode => {\n    const parts: AnyNode[] = [];\n\n    let nextSegment = parseSegmentAndBrackets();\n\n    while (nextSegment !== undefined) {\n      parts.push(...nextSegment);\n\n      if (!ch || ch === CLOSE_CURL) {\n        break;\n      }\n\n      if (nextSegment.length === 0 && ch) {\n        throw new Error(`Unexpected character: ${ch}`);\n      }\n\n      next(SEGMENT_SEPARATOR);\n      nextSegment = parseSegmentAndBrackets();\n    }\n\n    return toPath(parts);\n  };\n\n  try {\n    const result = parsePath();\n\n    return {\n      status: true,\n      path: result,\n    };\n  } catch (e: any) {\n    return {\n      status: false,\n      error: e.message,\n    };\n  }\n};\n","import { getBindingSegments } from \"./utils\";\n\nexport interface BindingParserOptions {\n  /** Get the value for a specific binding */\n  get: (binding: BindingInstance) => any;\n\n  /**\n   * Set the values for bindings.\n   * This is used when the query syntax needs to modify an object\n   */\n  set: (transaction: Array<[BindingInstance, any]>) => void;\n\n  /**\n   * Get the result of evaluating an expression\n   */\n  evaluate: (exp: string) => any;\n\n  /**\n   * Without readOnly, if a binding such as this is used: arr[key='does not exist'],\n   * then an object with that key will be created.\n   * This is done to make assignment such as arr[key='abc'].val = 'foo' work smoothly.\n   * Setting readOnly to true will prevent this behavior, avoiding unintended data changes.\n   */\n  readOnly?: boolean;\n}\n\nexport type Getter = (path: BindingInstance) => any;\n\nexport type RawBindingSegment = number | string;\nexport type RawBinding = string | RawBindingSegment[];\nexport type BindingLike = RawBinding | BindingInstance;\nexport type BindingFactory = (\n  raw: RawBinding,\n  options?: Partial<BindingParserOptions>,\n) => BindingInstance;\n\n/**\n * A path in the data model\n */\nexport class BindingInstance {\n  private split: RawBindingSegment[];\n  private joined: string;\n  private factory: BindingFactory;\n\n  constructor(\n    raw: RawBinding,\n    factory = (rawBinding: RawBinding) => new BindingInstance(rawBinding),\n  ) {\n    const split = Array.isArray(raw) ? raw : raw.split(\".\");\n    this.split = split.map((segment) => {\n      if (typeof segment === \"number\") {\n        return segment;\n      }\n\n      const tryNum = Number(segment);\n      // test to make sure turning a numerical string to a number doesn't change\n      // the actual value of the string by getting rid of a leading zero\n      return isNaN(tryNum) || String(tryNum) !== segment ? segment : tryNum;\n    });\n    Object.freeze(this.split);\n    this.joined = this.split.join(\".\");\n    this.factory = factory;\n  }\n\n  asArray(): RawBindingSegment[] {\n    return this.split;\n  }\n\n  asString(): string {\n    return this.joined;\n  }\n\n  /**\n   * Check to see if the given binding is a sub-path of the current one\n   */\n  contains(binding: BindingInstance): boolean {\n    // need to account for partial key matches\n    // [foo, bar] !== [foo, ba]\n    const bindingAsArray = binding.asArray();\n\n    if (bindingAsArray.length < this.split.length) {\n      return false;\n    }\n\n    // Check every overlapping index to make sure they're the same\n    // Intentionally use a for loop for speeeed\n    for (let i = 0; i < this.split.length; i++) {\n      if (this.split[i] !== bindingAsArray[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  relative(binding: BindingInstance): RawBindingSegment[] {\n    return this.asArray().slice(binding.asArray().length);\n  }\n\n  parent(): BindingInstance {\n    return this.factory(this.split.slice(0, -1));\n  }\n\n  key(): RawBindingSegment {\n    return this.split[this.split.length - 1];\n  }\n\n  /**\n   * This is a utility method to get a binding that is a descendent of this binding\n   *\n   * @param relative - The relative path to descend to\n   */\n  descendent(relative: BindingLike): BindingInstance {\n    const descendentSegments = getBindingSegments(relative);\n\n    return this.factory(this.split.concat(descendentSegments));\n  }\n}\n","import type { BindingInstance } from \"../binding\";\nimport type {\n  BatchSetTransaction,\n  DataModelImpl,\n  DataModelMiddleware,\n  DataModelOptions,\n  Updates,\n} from \"./model\";\n\nexport type DependencySets = \"core\" | \"children\";\n\n/** A class to track usage of read/writes to/from a data model */\nexport class DependencyTracker {\n  protected readDeps: Set<BindingInstance>;\n  protected writeDeps: Set<BindingInstance>;\n  protected namedSet: DependencySets;\n\n  private namedDependencySets: Partial<\n    Record<\n      DependencySets,\n      {\n        /** readDeps */\n        readDeps: Set<BindingInstance>;\n        /** writeDeps */\n        writeDeps: Set<BindingInstance>;\n      }\n    >\n  >;\n\n  constructor() {\n    this.readDeps = new Set();\n    this.writeDeps = new Set();\n    this.namedDependencySets = {};\n    this.namedSet = \"core\";\n\n    this.createSubset(\"core\");\n    this.createSubset(\"children\");\n  }\n\n  protected createSubset(name: DependencySets, force = false): void {\n    if (force || !this.namedDependencySets[name]) {\n      this.namedDependencySets[name] = {\n        readDeps: new Set(),\n        writeDeps: new Set(),\n      };\n    }\n  }\n\n  /** Grab all of the bindings that this depended on */\n  public getDependencies(name?: DependencySets): Set<BindingInstance> {\n    if (name !== undefined) {\n      return this.namedDependencySets?.[name]?.readDeps ?? new Set();\n    }\n\n    return this.readDeps;\n  }\n\n  public trackSubset(name: DependencySets) {\n    this.createSubset(name);\n    this.namedSet = name;\n  }\n\n  public trackDefault() {\n    this.namedSet = \"core\";\n  }\n\n  /** Grab all of the bindings this wrote to */\n  public getModified(name?: DependencySets): Set<BindingInstance> {\n    if (name !== undefined) {\n      return this.namedDependencySets?.[name]?.writeDeps ?? new Set();\n    }\n\n    return this.writeDeps;\n  }\n\n  /**\n   * Check to see if the dataModel has read the value at the given binding\n   *\n   * @param binding - The binding you want to check for\n   */\n  public readsBinding(binding: BindingInstance): boolean {\n    return this.readDeps.has(binding);\n  }\n\n  /**\n   * Check to see if the dataModel has written to the binding\n   */\n  public writesBinding(binding: BindingInstance): boolean {\n    return this.writeDeps.has(binding);\n  }\n\n  /** Reset all tracking of dependencies */\n  public reset() {\n    this.readDeps = new Set();\n    this.writeDeps = new Set();\n    this.namedDependencySets = {};\n    this.namedSet = \"core\";\n\n    this.createSubset(\"core\", true);\n    this.createSubset(\"children\", true);\n  }\n\n  protected addReadDep(\n    binding: BindingInstance,\n    namedSet = this.namedSet,\n  ): void {\n    if (namedSet) {\n      this.namedDependencySets?.[namedSet]?.readDeps.add(binding);\n    }\n\n    this.readDeps.add(binding);\n  }\n\n  protected addWriteDep(\n    binding: BindingInstance,\n    namedSet = this.namedSet,\n  ): void {\n    if (namedSet) {\n      this.namedDependencySets?.[namedSet]?.writeDeps.add(binding);\n    }\n\n    this.writeDeps.add(binding);\n  }\n\n  public addChildReadDep(binding: BindingInstance): void {\n    this.addReadDep(binding, \"children\");\n  }\n}\n\n/** Middleware that tracks dependencies of read/written data */\nexport class DependencyMiddleware\n  extends DependencyTracker\n  implements DataModelMiddleware\n{\n  constructor() {\n    super();\n    this.get = this.get.bind(this);\n    this.set = this.set.bind(this);\n  }\n\n  public set(\n    transaction: BatchSetTransaction,\n    options?: DataModelOptions,\n    next?: DataModelImpl | undefined,\n  ): Updates {\n    transaction.forEach(([binding]) => this.addWriteDep(binding));\n\n    return next?.set(transaction, options) ?? [];\n  }\n\n  public get(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl | undefined,\n  ) {\n    this.addReadDep(binding);\n\n    return next?.get(binding, options);\n  }\n\n  public delete(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl | undefined,\n  ) {\n    this.addWriteDep(binding);\n    return next?.delete(binding, options);\n  }\n}\n\n/** A data-model that tracks dependencies of read/written data */\nexport class DependencyModel<Options = DataModelOptions>\n  extends DependencyTracker\n  implements DataModelImpl<Options>\n{\n  private readonly rootModel: DataModelImpl<Options>;\n\n  constructor(rootModel: DataModelImpl<Options>) {\n    super();\n    this.rootModel = rootModel;\n    this.set = this.set.bind(this);\n    this.get = this.get.bind(this);\n  }\n\n  public set(transaction: BatchSetTransaction, options?: Options): Updates {\n    transaction.forEach(([binding]) => this.addWriteDep(binding));\n\n    return this.rootModel.set(transaction, options);\n  }\n\n  public get(binding: BindingInstance, options?: Options) {\n    this.addReadDep(binding);\n\n    return this.rootModel.get(binding, options);\n  }\n\n  public delete(binding: BindingInstance, options?: Options) {\n    this.addWriteDep(binding);\n    return this.rootModel.delete(binding, options);\n  }\n}\n","import type { DataModelImpl } from \"./model\";\n\n/**\n * A model that does nothing\n * Helpful for testing and other default DataModel applications\n */\nexport class NOOPDataModel implements DataModelImpl {\n  get() {\n    return undefined;\n  }\n\n  set() {\n    return [];\n  }\n\n  delete() {}\n}\n\n/** You only really need 1 instance of the NOOP model */\nexport const NOOP_MODEL = new NOOPDataModel();\n","import type { Binding } from \"@player-ui/types\";\n\nimport type { BindingLike } from \"../binding\";\nimport type {\n  ExpressionHandler,\n  ExpressionContext,\n  ExpressionNode,\n} from \"./types\";\nimport { Awaitable, isAwaitable, makeAwaitable } from \"./async\";\n\n/** Sets a value to the data-model */\nexport const setDataVal: ExpressionHandler<[Binding, any], any> = (\n  _context: ExpressionContext,\n  binding,\n  value,\n) => {\n  _context.model.set([[binding as BindingLike, value]]);\n};\n\n/** Fetches a valid from the data-model */\nexport const getDataVal: ExpressionHandler<[Binding], unknown> = (\n  _context: ExpressionContext,\n  binding,\n) => {\n  return _context.model.get(binding as BindingLike);\n};\n\n/** Deletes a value from the model */\nexport const deleteDataVal: ExpressionHandler<[Binding], void> = (\n  _context: ExpressionContext,\n  binding,\n) => {\n  return _context.model.delete(binding);\n};\n\n/** Conditional expression handler */\nexport const conditional: ExpressionHandler<\n  [ExpressionNode, ExpressionNode, ExpressionNode?]\n> = (ctx, condition, ifTrue, ifFalse) => {\n  const testResult = ctx.evaluate(condition);\n\n  // Handle Promise case automatically (same pattern as ternary operator)\n  if (isAwaitable(testResult)) {\n    return testResult.awaitableThen((resolvedTest: any) => {\n      if (resolvedTest) {\n        return ctx.evaluate(ifTrue);\n      }\n      if (ifFalse) {\n        return ctx.evaluate(ifFalse);\n      }\n      return null;\n    });\n  }\n\n  // Handle sync case\n  if (testResult) {\n    return ctx.evaluate(ifTrue);\n  }\n  if (ifFalse) {\n    return ctx.evaluate(ifFalse);\n  }\n  return null;\n};\n\nconditional.resolveParams = false;\n\n/**\n * Internal await function\n * This is technically registered as `await` but can't be called that due to conflicting with the keyword\n */\nexport const waitFor: ExpressionHandler<[Promise<any>], Awaitable<any>> = (\n  ctx,\n  promise,\n) => {\n  return makeAwaitable(promise);\n};\n","import { SyncHook } from \"tapable-ts\";\nimport type { Logger, Severity } from \"./types\";\n\n/** A logger that has a tapable subscriptions to callbacks */\nexport class TapableLogger implements Logger {\n  public readonly hooks = {\n    trace: new SyncHook<[Array<any>]>(),\n    debug: new SyncHook<[Array<any>]>(),\n    info: new SyncHook<[Array<any>]>(),\n    warn: new SyncHook<[Array<any>]>(),\n    error: new SyncHook<[Array<any>]>(),\n    log: new SyncHook<[Severity, Array<any>]>(),\n  };\n\n  private logHandlers: Set<Logger> = new Set();\n\n  private createHandler(severity: Severity): (...args: any[]) => void {\n    return (...args: any[]) => {\n      this.hooks[severity].call(args);\n      this.hooks.log.call(severity, args);\n      this.logHandlers.forEach((logger) => logger[severity](...args));\n    };\n  }\n\n  public addHandler(logHandler: Logger) {\n    this.logHandlers.add(logHandler);\n  }\n\n  public removeHandler(logHandler: Logger) {\n    this.logHandlers.delete(logHandler);\n  }\n\n  public readonly trace = this.createHandler(\"trace\");\n  public readonly debug = this.createHandler(\"debug\");\n  public readonly info = this.createHandler(\"info\");\n  public readonly warn = this.createHandler(\"warn\");\n  public readonly error = this.createHandler(\"error\");\n}\n","import type { Logger, Severity, LoggerProvider } from \"./types\";\n\n/**\n * The ProxyLogger allows a user to log to another Logger instance that may not exist yet\n */\nexport class ProxyLogger implements Logger {\n  private proxiedLoggerProvider: LoggerProvider;\n\n  constructor(loggerProvider: LoggerProvider) {\n    this.proxiedLoggerProvider = loggerProvider;\n  }\n\n  private createHandler(severity: Severity): (...args: any[]) => void {\n    return (...args: any[]) => {\n      const logger = this.proxiedLoggerProvider();\n      logger?.[severity](...args);\n    };\n  }\n\n  public readonly trace = this.createHandler(\"trace\");\n  public readonly debug = this.createHandler(\"debug\");\n  public readonly info = this.createHandler(\"info\");\n  public readonly warn = this.createHandler(\"warn\");\n  public readonly error = this.createHandler(\"error\");\n}\n","import type { ValidatorFunction } from \"./types\";\n\n/** A registry that tracks validators  */\nexport class ValidatorRegistry {\n  private registry: Map<string, ValidatorFunction<any>>;\n\n  constructor() {\n    this.registry = new Map();\n  }\n\n  /** Use the given validator name to fetch the handler */\n  public get(name: string): ValidatorFunction | undefined {\n    return this.registry.get(name);\n  }\n\n  /** Register a new validator */\n  public register<T>(name: string, handler: ValidatorFunction<T>) {\n    this.registry.set(name, handler);\n  }\n}\n","import type { Asset as AssetType, Expression, Binding } from \"@player-ui/types\";\n\nexport type AnyAssetType = AssetType<string>;\nexport enum NodeType {\n  Asset = \"asset\",\n  View = \"view\",\n  Applicability = \"applicability\",\n  Template = \"template\",\n  Value = \"value\",\n  MultiNode = \"multi-node\",\n  Switch = \"switch\",\n  Async = \"async\",\n  Unknown = \"unknown\",\n  Empty = \"empty\",\n}\nexport declare namespace Node {\n  export type ChildrenTypes = NodeType.Asset | NodeType.Value | NodeType.View;\n\n  export interface Base<T extends NodeType> {\n    /** Every node contains a type to distinguish it from other nodes */\n    type: T;\n\n    /** Every node (outside of the root) contains a reference to it's parent */\n    parent?: Node;\n\n    /** The ids of async nodes resolved within this node */\n    asyncNodesResolved?: string[];\n  }\n\n  export type PathSegment = string | number;\n\n  export interface Child {\n    /** The path of the child relative to the parent */\n    path: PathSegment[];\n\n    /** If true, the path points to an array, and the value will be appended to it result */\n    array?: boolean;\n\n    /** The child node */\n    value: Node;\n  }\n\n  export interface BaseWithChildren<T extends NodeType> extends Base<T> {\n    /** Any node that contains a list of children underneath it */\n    children?: Child[];\n  }\n\n  export interface Asset<T extends AnyAssetType = AnyAssetType>\n    extends BaseWithChildren<NodeType.Asset>,\n      PluginOptions {\n    /** Any asset nested within a view */\n    value: T;\n  }\n\n  export interface View<T extends AnyAssetType = AnyAssetType>\n    extends BaseWithChildren<NodeType.View>,\n      PluginOptions {\n    /** The root of the parsed view */\n    value: T;\n  }\n\n  export interface Applicability extends Base<NodeType.Applicability> {\n    /** The expression to execute that determines applicability of the target node */\n    expression: Expression;\n\n    /** The node to use if the expression is truthy */\n    value: Node;\n  }\n\n  export interface Template extends Base<NodeType.Template> {\n    /** The location of an array in the model */\n    data: Binding;\n\n    /** The template to use when mapping over the data */\n    template: unknown;\n\n    /** The number of nested templates so far */\n    depth: number;\n\n    /** Should the template recompute when data changes */\n    dynamic?: boolean;\n\n    /** Specifies the template placement in relation to existing elements*/\n    placement?: \"prepend\" | \"append\";\n  }\n\n  export interface Value\n    extends BaseWithChildren<NodeType.Value>,\n      PluginOptions {\n    /** A simple node representing a value */\n    value: any;\n  }\n\n  export interface MultiNode extends Base<NodeType.MultiNode> {\n    /**\n     * Should this list override the target node if they overlap?\n     * If not amend the existing list\n     */\n    override?: boolean;\n\n    /** A list of values that comprise this node */\n    values: Array<Node>;\n  }\n\n  export interface Switch extends Base<NodeType.Switch> {\n    /** Should this list be re-computed when data changes */\n    dynamic?: boolean;\n\n    /** A list of cases to evaluate in order */\n    cases: SwitchCase[];\n  }\n\n  export interface SwitchCase {\n    /** The expression to evaluate for a single case statement */\n    case: Expression | true;\n    /** The value to use if this case is true */\n    value: Value;\n  }\n\n  export interface Async extends Base<NodeType.Async> {\n    /** The unique id of the node */\n    id: string;\n    /** The value representing the node */\n    value: Node;\n    /**\n     * Should the content streamed in be flattened during resolving\n     */\n    flatten?: boolean;\n    /** Function to run against parsed content from the node to manipulate the content before resolving it. */\n    onValueReceived?: (node: Node.Node) => Node.Node;\n  }\n\n  export interface PluginOptions {\n    /** A list of plugins */\n    plugins?: {\n      /** StringResolverPlugin options */\n      stringResolver?: {\n        /**\n         * An optional array of node properties to skip during string resolution\n         * Specified in the AssetTransformPlugin\n         */\n        propertiesToSkip?: string[];\n      };\n    };\n  }\n\n  export type Unknown = Base<NodeType.Unknown>;\n  export type Empty = Base<NodeType.Empty>;\n  export type ViewOrAsset = View | Asset;\n\n  export type Node =\n    | Asset\n    | Applicability\n    | Template\n    | Value\n    | View\n    | MultiNode\n    | Switch\n    | Async\n    | Unknown\n    | Empty;\n}\n","import { SyncHook } from \"tapable-ts\";\nimport type { View as ViewType } from \"@player-ui/types\";\nimport type { BindingInstance, BindingFactory } from \"../binding\";\nimport type { ValidationProvider, ValidationObject } from \"../validator\";\nimport type { Logger } from \"../logger\";\nimport type { Resolve } from \"./resolver\";\nimport { Resolver } from \"./resolver\";\nimport type { Node } from \"./parser\";\nimport { Parser } from \"./parser\";\nimport { TemplatePlugin } from \"./plugins\";\n\n/**\n * Manages the view level validations\n */\nclass CrossfieldProvider implements ValidationProvider {\n  private allValidations = new Set<ValidationObject>();\n  private byBinding = new Map<BindingInstance, Array<ValidationObject>>();\n  private logger?: Logger;\n\n  constructor(initialView: ViewType, parser: BindingFactory, logger?: Logger) {\n    this.logger = logger;\n    this.parse(initialView, parser);\n  }\n\n  private parse(contentView: ViewType, parser: BindingFactory) {\n    const xfieldRefs = contentView.validation;\n\n    if (xfieldRefs === undefined) {\n      return;\n    }\n\n    if (!Array.isArray(xfieldRefs)) {\n      this.logger?.warn(\n        `Unable to register view validations for id: ${contentView.id}. 'validation' property must be an Array.`,\n      );\n\n      return;\n    }\n\n    // Grab the validations from the view (as authored) and parse out the ones that have a _ref_ (to a binding)\n    // Group them all by binding to make it easier to return than later\n\n    xfieldRefs.forEach((vRef) => {\n      // x-field validations by default are triggered by navigating away from the page\n      // the reference can also override that _or_ the severity\n      const withDefaults: ValidationObject = {\n        trigger: \"navigation\",\n        severity: \"error\",\n        ...vRef,\n      };\n\n      this.allValidations.add(withDefaults);\n\n      // The validation reference contains a _ref_ (a binding)\n      const { ref } = vRef;\n\n      if (ref) {\n        /** Group together validations by binding */\n        const parsed = parser(ref);\n\n        if (this.byBinding.has(parsed)) {\n          this.byBinding.get(parsed)?.push(withDefaults);\n        } else {\n          this.byBinding.set(parsed, [withDefaults]);\n        }\n      }\n    });\n  }\n\n  getValidationsForBinding(binding: BindingInstance) {\n    return this.byBinding.get(binding);\n  }\n}\n\nexport type ViewHooks = {\n  /** Hook every time there is an update to this view instance */\n  onUpdate: SyncHook<[ViewType]>;\n  /** Hook to retrieve the parser used for this view */\n  parser: SyncHook<[Parser]>;\n  /** Hook to retrieve the resolver used for this view */\n  resolver: SyncHook<[Resolver]>;\n  /** Hook to retrieve the template plugin used for this view */\n  templatePlugin: SyncHook<[TemplatePlugin]>;\n};\n\n/** A stateful view instance from an content */\nexport class ViewInstance implements ValidationProvider {\n  public hooks: ViewHooks = {\n    onUpdate: new SyncHook(),\n    parser: new SyncHook(),\n    resolver: new SyncHook(),\n    templatePlugin: new SyncHook(),\n  };\n\n  private resolver?: Resolver;\n  public readonly initialView: ViewType;\n  public readonly resolverOptions: Resolve.ResolverOptions;\n  private rootNode?: Node.Node;\n\n  private validationProvider?: CrossfieldProvider;\n\n  private templatePlugin: TemplatePlugin | undefined;\n\n  // TODO might want to add a version/timestamp to this to compare updates\n  public lastUpdate: Record<string, any> | undefined;\n\n  constructor(initialView: ViewType, resolverOptions: Resolve.ResolverOptions) {\n    this.initialView = initialView;\n    this.resolverOptions = resolverOptions;\n  }\n\n  public updateAsync(asyncNode: string): void {\n    const update = this.resolver?.update(new Set(), new Set([asyncNode]));\n    this.lastUpdate = update;\n    this.hooks.onUpdate.call(update);\n  }\n\n  public update(changes?: Set<BindingInstance>): any {\n    if (this.rootNode === undefined) {\n      /** On initialization of the view, also create a validation parser */\n      this.validationProvider = new CrossfieldProvider(\n        this.initialView,\n        this.resolverOptions.parseBinding,\n        this.resolverOptions.logger,\n      );\n\n      if (this.templatePlugin) {\n        this.hooks.templatePlugin.call(this.templatePlugin);\n      } else {\n        this.resolverOptions.logger?.warn(\n          \"templatePlugin not set for View, legacy templates may not work\",\n        );\n      }\n\n      const parser = new Parser();\n      this.hooks.parser.call(parser);\n      this.rootNode = parser.parseView(this.initialView);\n\n      this.resolver = new Resolver(this.rootNode, {\n        ...this.resolverOptions,\n        parseNode: parser.parseObject.bind(parser),\n      });\n      this.hooks.resolver.call(this.resolver);\n    }\n\n    const update = this.resolver?.update(changes);\n\n    if (this.lastUpdate === update) {\n      return this.lastUpdate;\n    }\n\n    this.lastUpdate = update;\n    this.hooks.onUpdate.call(update);\n\n    return update;\n  }\n\n  getValidationsForBinding(\n    binding: BindingInstance,\n  ): Array<ValidationObject> | undefined {\n    return this.validationProvider?.getValidationsForBinding(binding);\n  }\n\n  public setTemplatePlugin(plugin: TemplatePlugin): void {\n    this.templatePlugin = plugin;\n  }\n}\n\n/** A plugin for a view */\nexport interface ViewPlugin {\n  /** Called with a view instance */\n  apply(view: ViewInstance): void;\n}\n","import type { Node, AnyAssetType } from \"../parser\";\nimport { NodeType } from \"../parser\";\n\n/**\n * Functions for building AST nodes (relatively) easily\n */\nexport class Builder {\n  /**\n   * Creates an asset node\n   *\n   * @param value - the value to put in the asset node\n   */\n  static asset<T extends AnyAssetType>(value: T): Node.Asset<T> {\n    return {\n      type: NodeType.Asset,\n      value,\n    };\n  }\n\n  static assetWrapper<T extends Node.Node>(value: T): Node.Value {\n    const valueNode = Builder.value();\n    Builder.addChild(valueNode, \"asset\", value);\n    return valueNode;\n  }\n\n  /**\n   * Creates a value node\n   *\n   * @param v - The object to put in the value node\n   */\n  static value(v?: object): Node.Value {\n    return {\n      type: NodeType.Value,\n      value: v,\n    };\n  }\n\n  /**\n   * Creates a multiNode and associates the multiNode as the parent\n   * of all the value nodes\n   *\n   * @param values - the value, applicability or async nodes to put in the multinode\n   */\n  static multiNode(\n    ...values: (Node.Value | Node.Applicability | Node.Async)[]\n  ): Node.MultiNode {\n    const m: Node.MultiNode = {\n      type: NodeType.MultiNode,\n      override: true,\n      values,\n    };\n\n    values.forEach((v) => {\n      v.parent = m;\n    });\n\n    return m;\n  }\n\n  /**\n   * Creates an async node\n   *\n   * @param id - the id of async node. It should be identical for each async node\n   */\n  static asyncNode(\n    id: string,\n    flatten = true,\n    onValueReceived?: (node: Node.Node) => Node.Node,\n  ): Node.Async {\n    return {\n      id,\n      type: NodeType.Async,\n      flatten: flatten,\n      onValueReceived,\n      value: {\n        type: NodeType.Value,\n        value: {\n          id,\n        },\n      },\n    };\n  }\n\n  /**\n   * Adds a child node to a node\n   *\n   * @param node - The node to add a child to\n   * @param path - The path at which to add the child\n   * @param child - The child node\n   */\n  static addChild<N extends Node.BaseWithChildren<NT>, NT extends NodeType>(\n    node: N,\n    path: Node.PathSegment | Node.PathSegment[],\n    child: Node.Node,\n  ): N {\n    child.parent = node as Node.Node;\n\n    const newChild: Node.Child = {\n      path: Array.isArray(path) ? path : [path],\n      value: child,\n    };\n\n    node.children = node.children || [];\n    node.children.push(newChild);\n\n    return node;\n  }\n\n  /**\n   * Updates children of a node of the same path and preserves order\n   *\n   * @param node - The node to update children for\n   * @param pathToMatch - The path to match against child paths\n   * @param mapFn - Function to transform matching children\n   */\n  static updateChildrenByPath<T extends Node.ViewOrAsset | Node.Value>(\n    node: T,\n    pathToMatch: Node.PathSegment[],\n    updateFn: (child: Node.Child) => Node.Node,\n  ): T {\n    if (!node.children) return node;\n\n    // Use map to preserve original order\n    const updatedChildren = node.children.map((child) =>\n      // Check if paths match exactly\n      child.path.join() === pathToMatch.join()\n        ? { ...child, value: updateFn(child) }\n        : child,\n    );\n\n    return {\n      ...node,\n      children: updatedChildren,\n    };\n  }\n}\n","import { SyncWaterfallHook } from \"tapable-ts\";\nimport type { Template } from \"@player-ui/types\";\nimport type {\n  Node,\n  ParseObjectOptions,\n  ParseObjectChildOptions,\n  Parser,\n} from \"../parser\";\nimport { NodeType } from \"../parser\";\nimport { ViewInstance, ViewPlugin } from \"../view\";\nimport type { Options } from \"./options\";\nimport type { Resolver } from \"../resolver\";\nimport { hasTemplateKey } from \"../parser/utils\";\n\nconst templateSymbol = Symbol(\"template\");\n\nexport interface TemplateItemInfo {\n  /** The index of the data for the current iteration of the template */\n  index: number;\n  /** The data for the current iteration of the template */\n  data: any;\n  /** The depth of the template node */\n  depth: number;\n}\n\nexport interface TemplateSubstitution {\n  /** Regular expression to find and replace. The global flag will be always be added to this expression. */\n  expression: string | RegExp;\n  /** The value to replace matches with. */\n  value: string;\n}\n\nexport type TemplateSubstitutionsFunc = (\n  baseSubstitutions: TemplateSubstitution[],\n  templateItemInfo: TemplateItemInfo,\n) => TemplateSubstitution[];\n\n/** A view plugin to resolve/manage templates */\nexport class TemplatePlugin implements ViewPlugin {\n  private readonly options: Options;\n\n  hooks: {\n    resolveTemplateSubstitutions: SyncWaterfallHook<\n      [TemplateSubstitution[], TemplateItemInfo],\n      Record<string, any>\n    >;\n  } = {\n    resolveTemplateSubstitutions: new SyncWaterfallHook<\n      [TemplateSubstitution[], TemplateItemInfo]\n    >(),\n  };\n\n  constructor(options: Options) {\n    this.options = options;\n  }\n\n  private parseTemplate(\n    parseObject: any,\n    node: Node.Template,\n    options: Options,\n  ): Node.Node | null {\n    const { template, depth } = node;\n    const data = options.data.model.get(node.data);\n\n    if (!data) {\n      return null;\n    }\n\n    if (!Array.isArray(data)) {\n      throw new Error(`Template using '${node.data}' but is not an array`);\n    }\n\n    const values: Array<Node.Node> = [];\n\n    data.forEach((dataItem, index) => {\n      const templateSubstitutions =\n        this.hooks.resolveTemplateSubstitutions.call(\n          [\n            {\n              expression: new RegExp(`_index${depth || \"\"}_`),\n              value: String(index),\n            },\n          ],\n          {\n            depth,\n            data: dataItem,\n            index,\n          },\n        );\n      let templateStr = JSON.stringify(template);\n\n      for (const { expression, value } of templateSubstitutions) {\n        let flags = \"g\";\n        if (typeof expression === \"object\") {\n          flags = `${expression.flags}${expression.global ? \"\" : \"g\"}`;\n        }\n\n        templateStr = templateStr.replace(new RegExp(expression, flags), value);\n      }\n\n      const parsed = parseObject(JSON.parse(templateStr), NodeType.Value, {\n        templateDepth: node.depth + 1,\n      });\n\n      if (parsed) {\n        values.push(parsed);\n      }\n    });\n\n    const result: Node.MultiNode = {\n      type: NodeType.MultiNode,\n      override: false,\n      values,\n    };\n\n    // Removes undefined Symbol property\n    if (node.placement !== undefined) {\n      (result as any)[templateSymbol] = node.placement;\n    }\n\n    return result;\n  }\n\n  applyParser(parser: Parser): void {\n    parser.hooks.onCreateASTNode.tap(\"template\", (node) => {\n      if (node && node.type === NodeType.Template && !node.dynamic) {\n        return this.parseTemplate(\n          parser.parseObject.bind(parser),\n          node,\n          this.options,\n        );\n      }\n\n      return node;\n    });\n\n    parser.hooks.onCreateASTNode.tap(\"template\", (node) => {\n      function getTemplateSymbolValue(node: Node.Node): string | undefined {\n        if (node.type === NodeType.MultiNode) {\n          return (node as any)[templateSymbol];\n        } else if (node.type === NodeType.Template) {\n          return node.placement;\n        }\n        return undefined;\n      }\n\n      if (\n        node &&\n        (node.type === NodeType.View || node.type === NodeType.Asset) &&\n        Array.isArray(node.children)\n      ) {\n        node.children = node.children.sort((a, b) => {\n          // compare template output with static values\n          const aPath = a.path.join();\n          const bPath = b.path.join();\n\n          const pathsEqual = aPath === bPath;\n\n          if (pathsEqual) {\n            const aPlacement = getTemplateSymbolValue(a.value);\n            const bPlacement = getTemplateSymbolValue(b.value);\n\n            if (aPlacement !== undefined && bPlacement === undefined) {\n              return aPlacement === \"prepend\" ? -1 : 1;\n            } else if (bPlacement !== undefined && aPlacement === undefined) {\n              return bPlacement === \"prepend\" ? 1 : -1;\n            } else if (aPlacement !== undefined && bPlacement !== undefined) {\n              // Both have placement values\n              if (aPlacement === bPlacement) {\n                return 0; // Same placement, no preference\n              }\n              // \"prepend\" should come before \"append\"\n              return aPlacement === \"prepend\" ? -1 : 1;\n            }\n            return 0;\n          }\n\n          // Trigger more sorting for nested assets\n          return aPath > bPath ? 1 : -1;\n        });\n      }\n\n      return node;\n    });\n\n    parser.hooks.parseNode.tap(\n      \"template\",\n      (\n        obj: any,\n        _nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        childOptions?: ParseObjectChildOptions,\n      ) => {\n        if (childOptions && hasTemplateKey(childOptions.key)) {\n          return obj\n            .map((template: Template) => {\n              const templateAST = parser.createASTNode(\n                {\n                  type: NodeType.Template,\n                  depth: options.templateDepth ?? 0,\n                  data: template.data,\n                  template: template.value,\n                  dynamic: template.dynamic ?? false,\n                  placement: template.placement,\n                },\n                template,\n              );\n\n              if (!templateAST) return;\n\n              if (templateAST.type === NodeType.MultiNode) {\n                templateAST.values.forEach((v) => {\n                  v.parent = templateAST;\n                });\n              }\n\n              return {\n                path: [...childOptions.path, template.output],\n                value: templateAST,\n              };\n            })\n            .filter(Boolean);\n        }\n      },\n    );\n  }\n\n  applyResolverHooks(resolver: Resolver): void {\n    // Transform dynamic templates into MultiNodes\n    resolver.hooks.beforeResolve.tap(\"template\", (node, options) => {\n      if (node && node.type === NodeType.Template && node.dynamic) {\n        return this.parseTemplate(options.parseNode, node, options);\n      }\n\n      return node;\n    });\n  }\n\n  apply(view: ViewInstance): void {\n    view.hooks.parser.tap(\"template\", this.applyParser.bind(this));\n    view.hooks.resolver.tap(\"template\", this.applyResolverHooks.bind(this));\n    view.setTemplatePlugin(this);\n  }\n}\n","import { ViewInstance, ViewPlugin } from \"../view\";\nimport type { Options } from \"./options\";\nimport type {\n  Parser,\n  Node,\n  ParseObjectOptions,\n  ParseObjectChildOptions,\n} from \"../parser\";\nimport { EMPTY_NODE, NodeType } from \"../parser\";\nimport type { Resolver } from \"../resolver\";\nimport { hasSwitchKey } from \"../parser/utils\";\n\n/** A view plugin to resolve switches */\nexport class SwitchPlugin implements ViewPlugin {\n  private readonly options: Options;\n\n  constructor(options: Options) {\n    this.options = options;\n  }\n\n  private resolveSwitch(node: Node.Switch, options: Options): Node.Node {\n    for (const switchCase of node.cases) {\n      const isApplicable = options.evaluate(switchCase.case);\n      if (isApplicable) {\n        return switchCase.value;\n      }\n    }\n\n    return EMPTY_NODE;\n  }\n\n  private isSwitch(obj: any) {\n    return (\n      obj &&\n      (Object.prototype.hasOwnProperty.call(obj, \"dynamicSwitch\") ||\n        Object.prototype.hasOwnProperty.call(obj, \"staticSwitch\"))\n    );\n  }\n\n  applyParser(parser: Parser) {\n    /** Switches resolved during the parsing phase are static */\n    parser.hooks.onCreateASTNode.tap(\"switch\", (node) => {\n      if (node && node.type === NodeType.Switch && !node.dynamic) {\n        return this.resolveSwitch(node, this.options);\n      }\n\n      return node;\n    });\n\n    parser.hooks.parseNode.tap(\n      \"switch\",\n      (\n        obj: any,\n        _nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        childOptions?: ParseObjectChildOptions,\n      ) => {\n        if (\n          this.isSwitch(obj) ||\n          (childOptions && hasSwitchKey(childOptions.key))\n        ) {\n          const objToParse =\n            childOptions && hasSwitchKey(childOptions.key)\n              ? { [childOptions.key]: obj }\n              : obj;\n          const dynamic = \"dynamicSwitch\" in objToParse;\n          const switchContent = dynamic\n            ? objToParse.dynamicSwitch\n            : objToParse.staticSwitch;\n\n          const cases: Node.SwitchCase[] = switchContent\n            .map(\n              (switchCase: {\n                [x: string]: any;\n                /**\n                 *\n                 */\n                case: any;\n              }) => {\n                const { case: switchCaseExpr, ...switchBody } = switchCase;\n                const value = parser.parseObject(\n                  switchBody,\n                  NodeType.Value,\n                  options,\n                );\n\n                if (value) {\n                  return {\n                    case: switchCaseExpr,\n                    value: value as Node.Value,\n                  };\n                }\n\n                return;\n              },\n            )\n            .filter(Boolean);\n\n          const switchAST = parser.createASTNode(\n            {\n              type: NodeType.Switch,\n              dynamic,\n              cases,\n            },\n            objToParse,\n          );\n\n          if (!switchAST || switchAST.type === NodeType.Empty) {\n            return childOptions ? [] : null;\n          }\n\n          if (switchAST.type === NodeType.Switch) {\n            switchAST.cases.forEach((sCase) => {\n              sCase.value.parent = switchAST;\n            });\n          }\n\n          if (childOptions) {\n            let path = [...childOptions.path, childOptions.key];\n            let value: any = switchAST;\n\n            if (\n              switchAST.type === NodeType.Value &&\n              switchAST.children?.length === 1 &&\n              switchAST.value === undefined\n            ) {\n              const firstChild = switchAST.children[0];\n              path = [...path, ...firstChild.path];\n              value = firstChild.value;\n            }\n\n            return [{ path, value }];\n          }\n\n          return switchAST;\n        }\n      },\n    );\n  }\n\n  applyResolver(resolver: Resolver) {\n    /** Switches resolved during the parsing phase are dynamic */\n    resolver.hooks.beforeResolve.tap(\"switch\", (node, options) => {\n      if (node && node.type === NodeType.Switch && node.dynamic) {\n        return this.resolveSwitch(node, options);\n      }\n\n      return node;\n    });\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.parser.tap(\"switch\", this.applyParser.bind(this));\n    view.hooks.resolver.tap(\"switch\", this.applyResolver.bind(this));\n  }\n}\n","import { ViewInstance, ViewPlugin } from \"../view\";\nimport type {\n  Parser,\n  Node,\n  ParseObjectOptions,\n  ParseObjectChildOptions,\n} from \"../parser\";\nimport { NodeType } from \"../parser\";\nimport { hasTemplateValues, hasTemplateKey } from \"../parser/utils\";\n\n/** A view plugin to resolve multi nodes */\nexport class MultiNodePlugin implements ViewPlugin {\n  applyParser(parser: Parser): void {\n    parser.hooks.parseNode.tap(\n      \"multi-node\",\n      (\n        obj: any,\n        nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        childOptions?: ParseObjectChildOptions,\n      ) => {\n        if (\n          (childOptions === undefined || !hasTemplateKey(childOptions.key)) &&\n          Array.isArray(obj)\n        ) {\n          const values = obj\n            .map((childVal) =>\n              parser.parseObject(childVal, NodeType.Value, options),\n            )\n            .filter((child): child is Node.Node => !!child);\n\n          if (!values.length) {\n            return [];\n          }\n\n          const multiNode = parser.createASTNode(\n            {\n              type: NodeType.MultiNode,\n              override:\n                childOptions !== undefined &&\n                !hasTemplateValues(childOptions.parentObj, childOptions.key),\n              values,\n            },\n            obj,\n          );\n\n          if (!multiNode) {\n            return [];\n          }\n\n          if (multiNode.type === NodeType.MultiNode) {\n            multiNode.values.forEach((v) => {\n              v.parent = multiNode;\n            });\n          }\n\n          return childOptions === undefined\n            ? multiNode\n            : [\n                {\n                  path: [...childOptions.path, childOptions.key],\n                  value: multiNode,\n                },\n              ];\n        }\n      },\n    );\n  }\n\n  apply(view: ViewInstance): void {\n    view.hooks.parser.tap(\"multi-node\", this.applyParser.bind(this));\n  }\n}\n","import { ViewInstance, ViewPlugin } from \"../view\";\nimport type {\n  Parser,\n  Node,\n  ParseObjectOptions,\n  ParseObjectChildOptions,\n} from \"../parser\";\nimport { NodeType } from \"../parser\";\n\n/** A view plugin to resolve assets */\nexport class AssetPlugin implements ViewPlugin {\n  applyParser(parser: Parser) {\n    parser.hooks.parseNode.tap(\n      \"asset\",\n      (\n        obj: any,\n        nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        childOptions?: ParseObjectChildOptions,\n      ) => {\n        if (childOptions?.key === \"asset\" && typeof obj === \"object\") {\n          const assetAST = parser.parseObject(obj, NodeType.Asset, options);\n\n          if (!assetAST) {\n            return [];\n          }\n\n          return [\n            {\n              path: [...childOptions.path, childOptions.key],\n              value: assetAST,\n            },\n          ];\n        }\n      },\n    );\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.parser.tap(\"asset\", this.applyParser.bind(this));\n  }\n}\n","export interface Store {\n  useLocalState<T>(initialState: T): readonly [T, (value: T) => void];\n  useSharedState<T>(\n    key: string | symbol,\n  ): (initialState: T) => readonly [T, (value: T) => void];\n}\n\ninterface SharedStore {\n  getLocalStateFunction<T>(\n    key: string | symbol,\n    countKey: symbol,\n  ): (initialState: T) => readonly [T, (value: T) => void];\n  useSharedState<T>(\n    key: string | symbol,\n  ): (initialState: T) => readonly [T, (value: T) => void];\n}\n\n/** A store that holds on to state for a transform */\nexport class LocalStateStore implements SharedStore {\n  private state: Map<string | symbol, any>;\n\n  private updateCallback?: () => void;\n\n  constructor(onUpdate?: () => void) {\n    this.updateCallback = onUpdate;\n\n    this.state = new Map();\n  }\n\n  public removeKey(key: symbol | string) {\n    this.state.delete(key);\n  }\n\n  public reset() {\n    this.state.clear();\n  }\n\n  useSharedState<T>(key: string | symbol) {\n    return (initialState: T) => {\n      if (!this.state.has(key)) {\n        this.state.set(key, initialState);\n      }\n\n      return [\n        this.state.get(key) as T,\n        (newState: T) => {\n          const current = this.state.get(key) as T;\n\n          this.state.set(key, newState);\n\n          if (current !== newState) {\n            this.updateCallback?.();\n          }\n        },\n      ] as const;\n    };\n  }\n\n  getLocalStateFunction<T>(key: symbol, countKey: symbol) {\n    return (initialState: T) => {\n      // initialize if not already created\n      if (!this.state.has(key)) {\n        this.state.set(key, []);\n      }\n\n      if (!this.state.has(countKey)) {\n        this.state.set(countKey, 0);\n      }\n\n      const localState = this.state.get(key);\n      const oldCount = this.state.get(countKey);\n\n      this.state.set(countKey, oldCount + 1);\n\n      if (localState.length <= oldCount) {\n        localState.push(initialState);\n      }\n\n      const value = localState[oldCount] as T;\n\n      return [\n        value,\n        (newState: T) => {\n          const oldValue = localState[oldCount] as T;\n          localState[oldCount] = newState;\n\n          if (oldValue !== newState) {\n            this.updateCallback?.();\n          }\n        },\n      ] as const;\n    };\n  }\n}\n","import type { Node, ViewInstance } from \"..\";\nimport { NodeType } from \"..\";\nimport { LocalStateStore } from \"../../controllers/view/store\";\nimport type { TransformRegistry } from \"../../controllers/view/types\";\n\n/** Traverse up the nodes until the target is found */\nfunction findUp(node: Node.Node, target: Node.Node): boolean {\n  if (node === target) {\n    return true;\n  }\n\n  if (node.parent) {\n    return findUp(node.parent, target);\n  }\n\n  return false;\n}\n\n/**\n * A plugin to register custom transforms on certain asset types\n * This allows users to embed stateful data into transforms.\n */\nexport class AssetTransformCorePlugin {\n  public readonly stateStore: Map<Node.Node, LocalStateStore>;\n  private readonly registry: TransformRegistry;\n  private beforeResolveSymbol: symbol;\n  private resolveSymbol: symbol;\n  private beforeResolveCountSymbol: symbol;\n  private resolveCountSymbol: symbol;\n\n  constructor(registry: TransformRegistry) {\n    this.registry = registry;\n    this.stateStore = new Map();\n    this.beforeResolveSymbol = Symbol(\"before resolve\");\n    this.resolveSymbol = Symbol(\"resolve\");\n    this.beforeResolveCountSymbol = Symbol(\"before resolve count\");\n    this.resolveCountSymbol = Symbol(\"resolve count\");\n  }\n\n  apply(view: ViewInstance) {\n    // Clear out everything when we create a new view\n    this.stateStore.clear();\n\n    view.hooks.resolver.tap(\"asset-transform\", (resolver) => {\n      let lastUpdatedNode: Node.Node | undefined;\n\n      /** A function to update the state and trigger a view re-compute */\n      const updateState = (node: Node.Node) => {\n        lastUpdatedNode = node;\n        view.update(new Set());\n      };\n\n      /** Given a node and a transform step, fetch a local store */\n      const getStore = (node: Node.Node, stepKey: symbol) => {\n        let store: LocalStateStore;\n        const countKey =\n          stepKey === this.resolveSymbol\n            ? this.resolveCountSymbol\n            : this.beforeResolveCountSymbol;\n\n        const storedState = this.stateStore.get(node);\n\n        if (storedState) {\n          store = storedState;\n          store.removeKey(countKey);\n        } else {\n          store = new LocalStateStore(() => {\n            updateState(node);\n          });\n          this.stateStore.set(node, store);\n        }\n\n        return {\n          useSharedState: (\n            key: string | symbol,\n          ): (<T>(initialState: T) => readonly [T, (value: T) => void]) => {\n            return store.useSharedState(key);\n          },\n          useLocalState: <T>(initialState: T) => {\n            return store.getLocalStateFunction<T>(\n              stepKey,\n              countKey,\n            )(initialState);\n          },\n        };\n      };\n\n      resolver.hooks.beforeResolve.tap(\"asset-transform\", (node, options) => {\n        if (node && (node.type === \"asset\" || node.type === \"view\")) {\n          const transform = this.registry.get(node.value);\n\n          if (transform?.beforeResolve) {\n            const store = getStore(\n              options.node ?? node,\n              this.beforeResolveSymbol,\n            );\n\n            return transform.beforeResolve(node, options, store);\n          }\n        }\n\n        return node;\n      });\n\n      resolver.hooks.afterUpdate.tap(\"asset-transform\", () => {\n        lastUpdatedNode = undefined;\n      });\n\n      resolver.hooks.skipResolve.tap(\"asset-transform\", (skip, node) => {\n        if (!skip || !lastUpdatedNode) {\n          return skip;\n        }\n\n        const isParentOfUpdated = findUp(lastUpdatedNode, node);\n        const isChildOfUpdated = findUp(node, lastUpdatedNode);\n\n        return !isParentOfUpdated && !isChildOfUpdated;\n      });\n\n      resolver.hooks.afterResolve.tap(\n        \"asset-transform\",\n        (value, node, options) => {\n          if (node.type !== NodeType.Asset && node.type !== NodeType.View) {\n            return value;\n          }\n\n          const originalNode = resolver.getSourceNode(node);\n\n          if (!originalNode) {\n            return value;\n          }\n\n          const transform = this.registry.get(value);\n\n          if (transform?.resolve) {\n            const store = getStore(originalNode, this.resolveSymbol);\n\n            return transform?.resolve(value, options, store);\n          }\n\n          return value;\n        },\n      );\n    });\n  }\n}\n","import { SyncHook } from \"tapable-ts\";\nimport type { Navigation, NavigationFlowEndState } from \"@player-ui/types\";\nimport type { Logger } from \"../../logger\";\nimport type { TransitionOptions } from \"./flow\";\nimport { FlowInstance } from \"./flow\";\n\nexport interface FlowControllerHooks {\n  flow: SyncHook<[FlowInstance], Record<string, any>>;\n}\n\n/** A manager for the navigation section of a Content blob */\nexport class FlowController {\n  public readonly hooks: FlowControllerHooks = {\n    flow: new SyncHook<[FlowInstance]>(),\n  };\n\n  private readonly log?: Logger;\n  private navigation: Navigation;\n  private navStack: FlowInstance[];\n  public current?: FlowInstance;\n\n  constructor(\n    navigation: Navigation,\n    options?: {\n      /** A logger instance to use */\n      logger?: Logger;\n    },\n  ) {\n    this.navigation = navigation;\n    this.navStack = [];\n    this.log = options?.logger;\n\n    this.start = this.start.bind(this);\n    this.run = this.run.bind(this);\n    this.transition = this.transition.bind(this);\n    this.addNewFlow = this.addNewFlow.bind(this);\n  }\n\n  /** Navigate to another state in the state-machine */\n  public transition(\n    stateTransition: string,\n    options?: TransitionOptions,\n  ): void {\n    if (this.current === undefined) {\n      throw new Error(\"Not currently in a flow. Cannot transition.\");\n    }\n\n    this.current.transition(stateTransition, options);\n  }\n\n  private addNewFlow(flow: FlowInstance) {\n    this.navStack.push(flow);\n    this.current = flow;\n    this.hooks.flow.call(flow);\n  }\n\n  private async run(startState: string): Promise<NavigationFlowEndState> {\n    if (!Object.prototype.hasOwnProperty.call(this.navigation, startState)) {\n      return Promise.reject(new Error(`No flow defined for: ${startState}`));\n    }\n\n    const startFlow = this.navigation[startState];\n\n    if (startFlow === null || typeof startFlow !== \"object\") {\n      return Promise.reject(\n        new Error(`Flow: ${startState} needs to be an object`),\n      );\n    }\n\n    this.log?.debug(`Starting flow: ${startState}`);\n\n    const flow = new FlowInstance(startState, startFlow, { logger: this.log });\n    this.addNewFlow(flow);\n\n    flow.hooks.afterTransition.tap(\"flow-controller\", (flowInstance) => {\n      if (flowInstance.currentState?.value.state_type === \"FLOW\") {\n        const subflowId = flowInstance.currentState?.value.ref;\n        this.log?.debug(`Loading subflow ${subflowId}`);\n        this.run(subflowId).then((subFlowEndState) => {\n          this.log?.debug(\n            `Subflow ended. Using outcome: ${subFlowEndState.outcome}`,\n          );\n          flowInstance.transition(subFlowEndState?.outcome);\n        });\n      }\n    });\n\n    const end = await flow.start();\n    this.navStack.pop();\n\n    if (this.navStack.length > 0) {\n      const firstItem = 0;\n      this.current = this.navStack[firstItem];\n    }\n\n    return end;\n  }\n\n  public async start(): Promise<NavigationFlowEndState> {\n    if (!this.navigation.BEGIN) {\n      return Promise.reject(new Error(\"Must supply a BEGIN state\"));\n    }\n\n    return this.run(this.navigation.BEGIN);\n  }\n}\n","import type { Validation } from \"@player-ui/types\";\nimport type { ViewPlugin, Resolver, Node, ViewInstance } from \"../../view\";\nimport { NodeType } from \"../../view\";\nimport type {\n  BindingInstance,\n  BindingLike,\n  BindingFactory,\n} from \"../../binding\";\nimport { isBinding } from \"../../binding\";\nimport type { ValidationResponse } from \"../../validator\";\n\nconst CONTEXT = \"validation-binding-tracker\";\n\nexport interface BindingTracker {\n  /** Get the bindings currently being tracked for validation */\n  getBindings(): Set<BindingInstance>;\n\n  /** Add a binding to the tracked set */\n  trackBinding(binding: BindingInstance): void;\n}\ninterface Options {\n  /** Parse a binding from a view */\n  parseBinding: BindingFactory;\n\n  /** Callbacks when events happen */\n  callbacks?: {\n    /** Called when a binding is encountered for the first time in a view */\n    onAdd?: (binding: BindingInstance) => void;\n  };\n}\n\n/** A view plugin that manages bindings tracked across updates */\nexport class ValidationBindingTrackerViewPlugin\n  implements ViewPlugin, BindingTracker\n{\n  private options: Options;\n\n  private trackedBindings = new Set<BindingInstance>();\n\n  constructor(options: Options) {\n    this.options = options;\n  }\n\n  /** Fetch the tracked bindings in the current view */\n  getBindings(): Set<BindingInstance> {\n    return this.trackedBindings;\n  }\n\n  /** Add a binding to the tracked set */\n  trackBinding(binding: BindingInstance) {\n    if (this.trackedBindings.has(binding)) {\n      return;\n    }\n\n    this.trackedBindings.add(binding);\n    this.options.callbacks?.onAdd?.(binding);\n  }\n\n  /** Attach hooks to the given resolver */\n  applyResolver(resolver: Resolver) {\n    this.trackedBindings.clear();\n\n    /** Each node maps to a set of bindings that it directly tracks */\n    const tracked = new Map<Node.Node, Set<BindingInstance>>();\n\n    /** Each Node is a registered section or page that maps to a set of nodes in its section */\n    const sections = new Map<Node.Node, Set<Node.Node>>();\n\n    let lastViewUpdateChangeSet: Set<BindingInstance> | undefined;\n\n    /** Map of node to all bindings in children */\n    const lastComputedBindingTree = new Map<Node.Node, Set<BindingInstance>>();\n    let currentBindingTree = new Map<Node.Node, Set<BindingInstance>>();\n\n    /** Map of registered section nodes to bindings */\n    const lastSectionBindingTree = new Map<Node.Node, Set<BindingInstance>>();\n\n    /** Map of resolved nodes to their original nodes. */\n    const resolvedNodeMap: Map<Node.Node, Node.Node> = new Map();\n\n    resolver.hooks.beforeUpdate.tap(CONTEXT, (changes) => {\n      lastViewUpdateChangeSet = changes;\n    });\n\n    resolver.hooks.skipResolve.tap(CONTEXT, (shouldSkip, node) => {\n      const trackedBindingsForNode = lastComputedBindingTree.get(node);\n\n      if (!shouldSkip || !lastViewUpdateChangeSet || !trackedBindingsForNode) {\n        return shouldSkip;\n      }\n\n      const intersection = new Set(\n        [...lastViewUpdateChangeSet].filter((b) =>\n          trackedBindingsForNode.has(b),\n        ),\n      );\n\n      return intersection.size === 0;\n    });\n\n    resolver.hooks.resolveOptions.tap(CONTEXT, (options, node) => {\n      if (options.validation === undefined) {\n        return options;\n      }\n\n      // Clear out any old tracked bindings for this node since we're re-compiling it\n      tracked.delete(node);\n\n      /** Validation callback to track a binding */\n      const track = (binding: BindingLike) => {\n        const parsed = isBinding(binding)\n          ? binding\n          : this.options.parseBinding(binding);\n\n        if (tracked.has(node)) {\n          tracked.get(node)?.add(parsed);\n        } else {\n          tracked.set(node, new Set([parsed]));\n        }\n\n        /** find first parent registered as section and add self to its list */\n        let { parent } = node;\n\n        while (parent) {\n          if (sections.has(parent)) {\n            sections.get(parent)?.add(node);\n            break;\n          } else {\n            parent = parent.parent;\n          }\n        }\n\n        this.trackedBindings.add(parsed);\n        this.options.callbacks?.onAdd?.(parsed);\n      };\n\n      return {\n        ...options,\n        validation: {\n          ...options.validation,\n          get: (binding, getOptions) => {\n            if (getOptions?.track) {\n              track(binding);\n            }\n\n            const eows = options.validation\n              ?._getValidationForBinding(binding)\n              ?.getAll(getOptions);\n\n            const firstFieldEOW = eows?.find(\n              (eow) =>\n                eow.displayTarget === \"field\" ||\n                eow.displayTarget === undefined,\n            );\n\n            return firstFieldEOW;\n          },\n          getValidationsForBinding(binding, getOptions) {\n            if (getOptions?.track) {\n              track(binding);\n            }\n\n            return (\n              options.validation\n                ?._getValidationForBinding(binding)\n                ?.getAll(getOptions) ?? []\n            );\n          },\n          getChildren: (type?: Validation.DisplayTarget) => {\n            const validations = new Array<ValidationResponse>();\n            lastComputedBindingTree.get(node)?.forEach((binding) => {\n              const eow = options.validation\n                ?._getValidationForBinding(binding)\n                ?.get();\n\n              if (eow && (type === undefined || type === eow.displayTarget)) {\n                validations.push(eow);\n              }\n            });\n\n            return validations;\n          },\n          getValidationsForSection: () => {\n            const validations = new Array<ValidationResponse>();\n            lastSectionBindingTree.get(node)?.forEach((binding) => {\n              const eow = options.validation\n                ?._getValidationForBinding(binding)\n                ?.get();\n\n              if (eow && eow.displayTarget === \"section\") {\n                validations.push(eow);\n              }\n            });\n\n            return validations;\n          },\n          register: (registerOptions) => {\n            if (registerOptions?.type === \"section\") {\n              if (!sections.has(node)) {\n                sections.set(node, new Set());\n              }\n            }\n          },\n          track,\n        },\n      };\n    });\n\n    resolver.hooks.afterNodeUpdate.tap(\n      CONTEXT,\n      (originalNode, parent, update) => {\n        // Compute the new tree for this node\n        // If it's not-updated, use the last known value\n\n        const { updated, node: resolvedNode } = update;\n        resolvedNodeMap.set(resolvedNode, originalNode);\n\n        if (updated) {\n          const newlyComputed = new Set(tracked.get(originalNode));\n          if (resolvedNode.type === NodeType.MultiNode) {\n            resolvedNode.values.forEach((value) =>\n              currentBindingTree\n                .get(value)\n                ?.forEach((b) => newlyComputed.add(b)),\n            );\n          }\n\n          if (\"children\" in resolvedNode && resolvedNode.children) {\n            resolvedNode.children.forEach((child) => {\n              currentBindingTree\n                .get(child.value)\n                ?.forEach((b) => newlyComputed.add(b));\n            });\n          }\n\n          currentBindingTree.set(resolvedNode, newlyComputed);\n        } else {\n          currentBindingTree.set(\n            resolvedNode,\n            lastComputedBindingTree.get(originalNode) ?? new Set(),\n          );\n        }\n\n        if (originalNode === resolver.root) {\n          this.trackedBindings = new Set(currentBindingTree.get(resolvedNode));\n          lastComputedBindingTree.clear();\n          currentBindingTree.forEach((value, key) => {\n            const node = resolvedNodeMap.get(key);\n            if (node) {\n              lastComputedBindingTree.set(node, value);\n            }\n          });\n\n          lastSectionBindingTree.clear();\n          sections.forEach((nodeSet, sectionNode) => {\n            const temp = new Set<BindingInstance>();\n            nodeSet.forEach((n) => {\n              tracked.get(n)?.forEach(temp.add, temp);\n            });\n            lastSectionBindingTree.set(sectionNode, temp);\n          });\n\n          tracked.clear();\n          sections.clear();\n          currentBindingTree = new Map();\n        }\n      },\n    );\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.resolver.tap(CONTEXT, this.applyResolver.bind(this));\n  }\n}\n","import type { DataController } from \".\";\nimport type { Logger } from \"../../logger\";\nimport type { BindingLike } from \"../../binding\";\nimport type {\n  DataModelWithParser,\n  DataModelOptions,\n  Updates,\n} from \"../../data\";\n\n/** Wrapper for the Data Controller Class that prevents writes */\nexport class ReadOnlyDataController\n  implements DataModelWithParser<DataModelOptions>\n{\n  private controller: DataController;\n  private logger?: Logger;\n\n  constructor(controller: DataController, logger?: Logger) {\n    this.controller = controller;\n    this.logger = logger;\n  }\n\n  get(binding: BindingLike, options?: DataModelOptions | undefined) {\n    return this.controller.get(binding, options);\n  }\n\n  set(\n    transaction: [BindingLike, any][],\n    options?: DataModelOptions | undefined,\n  ): Updates {\n    this.logger?.error(\n      \"Error: Tried to set in a read only instance of the DataController\",\n    );\n    return [];\n  }\n\n  delete(binding: BindingLike, options?: DataModelOptions | undefined): void {\n    this.logger?.error(\n      \"Error: Tried to delete in a read only instance of the DataController\",\n    );\n  }\n}\n","import { SyncHook, SyncWaterfallHook, SyncBailHook } from \"tapable-ts\";\nimport { dequal } from \"dequal\";\nimport type { Logger } from \"../../logger\";\nimport type { BindingParser, BindingLike } from \"../../binding\";\nimport { BindingInstance } from \"../../binding\";\nimport type {\n  BatchSetTransaction,\n  Updates,\n  DataModelOptions,\n  DataModelWithParser,\n  DataPipeline,\n  DataModelMiddleware,\n} from \"../../data\";\nimport { PipelinedDataModel, LocalModel } from \"../../data\";\nimport type { RawSetTransaction } from \"../../types\";\nimport { ReadOnlyDataController } from \"./utils\";\n\n/** The orchestrator for player data */\nexport class DataController implements DataModelWithParser<DataModelOptions> {\n  public hooks = {\n    resolve: new SyncWaterfallHook(),\n    resolveDataStages: new SyncWaterfallHook<[DataPipeline]>(),\n\n    // On any set or get of an undefined value, redirect the value to be the default\n    resolveDefaultValue: new SyncBailHook<[BindingInstance], any>(),\n\n    onDelete: new SyncHook<[any]>(),\n\n    onSet: new SyncHook<[BatchSetTransaction]>(),\n\n    onGet: new SyncHook<[any, any]>(),\n\n    onUpdate: new SyncHook<[Updates, DataModelOptions | undefined]>(),\n\n    format: new SyncWaterfallHook<[any, BindingInstance]>(),\n\n    deformat: new SyncWaterfallHook<[any, BindingInstance]>(),\n\n    serialize: new SyncWaterfallHook<[any]>(),\n  };\n\n  private model?: PipelinedDataModel;\n  private trash: Set<BindingInstance>;\n  private pathResolver: BindingParser;\n  private baseMiddleware: Array<DataModelMiddleware>;\n  private logger?: Logger;\n\n  constructor(\n    model: Record<any, unknown> | undefined,\n    options: {\n      /** A means of parsing a raw binding to a Binding object */\n      pathResolver: BindingParser;\n\n      /** middleware to use. typically for validation */\n      middleware?: Array<DataModelMiddleware>;\n\n      /** A logger to use  */\n      logger?: Logger;\n    },\n  ) {\n    this.logger = options.logger;\n    const middleware = options.middleware || [];\n    this.baseMiddleware = [new LocalModel(model), ...middleware];\n\n    this.trash = new Set();\n    this.pathResolver = options.pathResolver;\n  }\n\n  public getModel(): PipelinedDataModel {\n    if (!this.model) {\n      const stages = this.hooks.resolveDataStages.call(this.baseMiddleware);\n      const model = new PipelinedDataModel();\n      model.setMiddleware(stages);\n      this.model = model;\n    }\n\n    return this.model;\n  }\n\n  private resolveDataValue(\n    binding: BindingInstance,\n    value: any,\n    deformat: boolean,\n  ) {\n    if (deformat) {\n      return this.hooks.deformat.call(value, binding);\n    }\n\n    return value;\n  }\n\n  public set(\n    transaction: RawSetTransaction,\n    options?: DataModelOptions,\n  ): Updates {\n    let normalizedTransaction: BatchSetTransaction = [];\n\n    if (Array.isArray(transaction)) {\n      normalizedTransaction = transaction.map(([binding, value]) => {\n        const parsed = this.pathResolver.parse(binding);\n\n        return [\n          parsed,\n          this.resolveDataValue(parsed, value, Boolean(options?.formatted)),\n        ];\n      }) as BatchSetTransaction;\n    } else {\n      normalizedTransaction = Object.keys(transaction).map(\n        (binding: string) => {\n          const parsed = this.pathResolver.parse(binding);\n          const val = transaction[binding];\n\n          return [\n            parsed,\n            this.resolveDataValue(parsed, val, Boolean(options?.formatted)),\n          ];\n        },\n      ) as BatchSetTransaction;\n    }\n\n    // Figure out what the base changes being applied are\n    const setUpdates = normalizedTransaction.reduce<Updates>(\n      (updates, [binding, newVal]) => {\n        const oldVal = this.get(binding, { includeInvalid: true });\n\n        const update = {\n          binding,\n          newValue: newVal,\n          oldValue: oldVal,\n        };\n\n        if (dequal(oldVal, newVal)) {\n          this.logger?.debug(\n            `Skipping update for path: ${binding.asString()}. Value was unchanged: ${oldVal}`,\n          );\n        } else {\n          updates.push(update);\n\n          this.logger?.debug(\n            `Setting path: ${binding.asString()} from: ${oldVal} to: ${newVal}`,\n          );\n        }\n\n        return updates;\n      },\n      [],\n    );\n\n    // Get the applied update\n    const result = this.getModel().set(normalizedTransaction, options);\n\n    // Add any extra bindings that were effected\n    const setUpdateBindings = new Set(setUpdates.map((su) => su.binding));\n    result.forEach((tr) => {\n      if (\n        !setUpdateBindings.has(tr.binding) &&\n        (tr.force === true || !dequal(tr.oldValue, tr.newValue))\n      ) {\n        this.logger?.debug(\n          `Path: ${tr.binding.asString()} was changed from: ${\n            tr.oldValue\n          } to: ${tr.newValue}`,\n        );\n        setUpdates.push(tr);\n      }\n    });\n\n    this.hooks.onSet.call(normalizedTransaction);\n\n    if (setUpdates.length > 0) {\n      this.hooks.onUpdate.call(setUpdates, options);\n    }\n\n    return result;\n  }\n\n  private resolve(binding: BindingLike, readOnly: boolean): BindingInstance {\n    return Array.isArray(binding) || typeof binding === \"string\"\n      ? this.pathResolver.parse(binding, { readOnly })\n      : binding;\n  }\n\n  public get(binding: BindingLike, options?: DataModelOptions) {\n    const resolved =\n      binding instanceof BindingInstance\n        ? binding\n        : this.resolve(binding, true);\n    let result = this.getModel().get(resolved, options);\n\n    if (result === undefined && !options?.ignoreDefaultValue) {\n      const defaultVal = this.hooks.resolveDefaultValue.call(resolved);\n\n      if (defaultVal !== result) {\n        result = defaultVal;\n      }\n    }\n\n    if (options?.formatted) {\n      result = this.hooks.format.call(result, resolved);\n    } else if (options?.formatted === false) {\n      result = this.hooks.deformat.call(result, resolved);\n    }\n\n    this.hooks.onGet.call(binding, result);\n\n    return result;\n  }\n\n  public delete(binding: BindingLike, options?: DataModelOptions) {\n    if (\n      typeof binding !== \"string\" &&\n      !Array.isArray(binding) &&\n      !(binding instanceof BindingInstance)\n    ) {\n      throw new Error(\"Invalid arguments: delete expects a data path (string)\");\n    }\n\n    const resolved =\n      binding instanceof BindingInstance\n        ? binding\n        : this.resolve(binding, false);\n\n    const parentBinding = resolved.parent();\n    const property = resolved.key();\n    const parentValue = this.get(parentBinding);\n\n    const existedBeforeDelete =\n      typeof parentValue === \"object\" &&\n      parentValue !== null &&\n      Object.prototype.hasOwnProperty.call(parentValue, property);\n\n    this.getModel().delete(resolved, options);\n\n    if (existedBeforeDelete && !this.get(resolved)) {\n      this.trash.add(resolved);\n    }\n\n    this.hooks.onDelete.call(resolved);\n  }\n\n  public serialize(): object {\n    return this.hooks.serialize.call(this.get(\"\"));\n  }\n\n  public makeReadOnly(): ReadOnlyDataController {\n    return new ReadOnlyDataController(this, this.logger);\n  }\n}\n","import { LocalModel } from \"../../data\";\nimport { BindingInstance } from \"../../binding\";\nimport { objectToBatchSet } from \"./utils\";\n\nexport interface ConstantsProvider {\n  /**\n   * Function to add constants to the providers store\n   * - @param data values to add to the constants store\n   */\n  addConstants(data: Record<string, any>, namespace: string): void;\n\n  /**\n   * Function to retrieve constants from the providers store\n   *  - @param key Key used for the store access\n   *  - @param namespace namespace values were loaded under (defined in the plugin)\n   *  - @param fallback Optional - if key doesn't exist in namespace what to return (will return unknown if not provided)\n   */\n  getConstants(key: any, namespace: string, fallback?: any): any;\n\n  /**\n   * Function to set values to temporarily override certain keys in the perminant store\n   * - @param data values to override store with\n   * - @param namespace namespace to override\n   */\n  setTemporaryValues(data: any, namespace: string): void;\n\n  /**\n   * Clears any temporary values that were previously set\n   */\n  clearTemporaryValues(): void;\n}\n\n/**\n * Key/Value store for constants and context for Player\n */\nexport class ConstantsController implements ConstantsProvider {\n  /**\n   * Data store is basically a map of namespaces to DataModels to provide some data isolation\n   */\n  private store: Map<string, LocalModel>;\n\n  /**\n   * Separate store for temporary flow specific overrides.\n   * They are kept in a separate data model to make clearing it easier between flows\n   * and so there is no confusion on what is static and what is temporary\n   */\n  private tempStore: Map<string, LocalModel>;\n\n  constructor() {\n    this.store = new Map();\n    this.tempStore = new Map();\n  }\n\n  addConstants(data: any, namespace: string): void {\n    if (this.store.has(namespace)) {\n      this.store.get(namespace)?.set(objectToBatchSet(data));\n    } else {\n      this.store.set(namespace, new LocalModel(data));\n    }\n  }\n\n  getConstants(key: string, namespace: string, fallback?: any): any {\n    const path = new BindingInstance(key);\n\n    return (\n      this.tempStore.get(namespace)?.get(path) ??\n      this.store.get(namespace)?.get(path) ??\n      fallback\n    );\n  }\n\n  setTemporaryValues(data: any, namespace: string): void {\n    if (this.tempStore.has(namespace)) {\n      this.tempStore.get(namespace)?.set(objectToBatchSet(data));\n    } else {\n      this.tempStore.set(namespace, new LocalModel(data));\n    }\n  }\n\n  clearTemporaryValues(namespace?: string): void {\n    if (namespace) {\n      this.tempStore.get(namespace)?.reset();\n    } else {\n      this.tempStore.forEach((value: LocalModel) => {\n        value.reset();\n      });\n    }\n  }\n}\n","import type {\n  Expression,\n  ExpressionObject,\n  NavigationFlowState,\n} from \"@player-ui/types\";\nimport type { ExpressionEvaluator, ExpressionType } from \"../expressions\";\nimport type { FlowInstance } from \"../controllers\";\nimport type { Player, PlayerPlugin } from \"../player\";\n\n/**\n * A plugin that taps into the flow controller to evaluate available expressions\n * Expressions can be exposed via lifecycle \"hooks\" in flow/state nodes\n * e.g: onStart, onEnd\n */\nexport class FlowExpPlugin implements PlayerPlugin {\n  name = \"flow-exp-plugin\";\n\n  apply(player: Player) {\n    let expressionEvaluator: ExpressionEvaluator | undefined;\n\n    /**\n     * Eval Helper\n     *\n     * @param exp - an expression to be evaluated\n     */\n    const handleEval = (exp: Expression | ExpressionObject) => {\n      if (exp) {\n        if (typeof exp === \"object\" && \"exp\" in exp) {\n          expressionEvaluator?.evaluate(exp.exp);\n        } else {\n          expressionEvaluator?.evaluate(exp as ExpressionType);\n        }\n      }\n    };\n\n    player.hooks.expressionEvaluator.tap(this.name, (evaluator) => {\n      expressionEvaluator = evaluator;\n    });\n\n    player.hooks.flowController.tap(this.name, (fc) => {\n      fc.hooks.flow.tap(this.name, (flow: FlowInstance) => {\n        // Eval flow nodes\n        flow.hooks.onStart.tap(this.name, (exp) => handleEval(exp));\n\n        flow.hooks.onEnd.tap(this.name, (exp) => handleEval(exp));\n        // Eval state nodes\n        flow.hooks.resolveTransitionNode.intercept({\n          call: (nextState: NavigationFlowState) => {\n            if (nextState?.onStart) {\n              handleEval(nextState.onStart);\n            }\n          },\n        });\n      });\n    });\n  }\n}\n","import type { ExpressionHandler, ExpressionType } from \"../expressions\";\nimport type { SchemaController } from \"../schema\";\nimport type { Player, PlayerPlugin } from \"../player\";\n\n/** Gets formatter for given formatName and formats value if found, returns value otherwise */\nconst createFormatFunction = (schema: SchemaController) => {\n  /**\n   * The generated handler for the given schema\n   */\n  const handler: ExpressionHandler<[unknown, string], any> = (\n    ctx,\n    value,\n    formatName,\n  ) => {\n    return (\n      schema.getFormatterForType({ type: formatName })?.format(value) ?? value\n    );\n  };\n\n  return handler;\n};\n\n/**\n * A plugin that provides the out-of-the-box expressions for player\n */\nexport class DefaultExpPlugin implements PlayerPlugin {\n  name = \"flow-exp-plugin\";\n\n  apply(player: Player) {\n    let formatFunction: ExpressionHandler<[unknown, string]> | undefined;\n\n    player.hooks.schema.tap(this.name, (schemaController) => {\n      formatFunction = createFormatFunction(schemaController);\n    });\n\n    player.hooks.expressionEvaluator.tap(this.name, (expEvaluator) => {\n      if (formatFunction) {\n        expEvaluator.addExpressionFunction(\"format\", formatFunction);\n      }\n\n      expEvaluator.addExpressionFunction(\"log\", (ctx, ...args) => {\n        player.logger.info(...args);\n      });\n\n      expEvaluator.addExpressionFunction(\"debug\", (ctx, ...args) => {\n        player.logger.debug(...args);\n      });\n\n      expEvaluator.addExpressionFunction(\n        \"eval\",\n        (ctx, ...args: [ExpressionType]) => {\n          return ctx.evaluate(...args);\n        },\n      );\n    });\n  }\n}\n","import type { Asset, Flow, FlowResult } from \"@player-ui/types\";\nimport type { BindingParser, BindingLike } from \"./binding\";\nimport type { SchemaController } from \"./schema\";\nimport type { ExpressionEvaluator } from \"./expressions\";\nimport type { Logger } from \"./logger\";\nimport type {\n  ViewController,\n  DataController,\n  ValidationController,\n  FlowController,\n} from \"./controllers\";\nimport type { ReadOnlyDataController } from \"./controllers/data/utils\";\nimport { SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport { ViewInstance } from \"./view\";\n\n/**\n * Public Player Hooks\n */\nexport interface PlayerHooks {\n  /** The hook that fires every time we create a new flowController (a new Content blob is passed in) */\n  flowController: SyncHook<[FlowController], Record<string, any>>;\n  /** The hook that updates/handles views */\n  viewController: SyncHook<[ViewController], Record<string, any>>;\n  /** A hook called every-time there's a new view. This is equivalent to the view hook on the view-controller */\n  view: SyncHook<[ViewInstance], Record<string, any>>;\n  /** Called when an expression evaluator was created */\n  expressionEvaluator: SyncHook<[ExpressionEvaluator], Record<string, any>>;\n  /** The hook that creates and manages data */\n  dataController: SyncHook<[DataController], Record<string, any>>;\n  /** Called after the schema is created for a flow */\n  schema: SyncHook<[SchemaController], Record<string, any>>;\n  /** Manages validations (schema and x-field ) */\n  validationController: SyncHook<[ValidationController], Record<string, any>>;\n  /** Manages parsing binding */\n  bindingParser: SyncHook<[BindingParser], Record<string, any>>;\n  /** A that's called for state changes in the flow execution */\n  state: SyncHook<[PlayerFlowState], Record<string, any>>;\n  /** A hook to access the current flow */\n  onStart: SyncHook<[Flow<Asset<string>>], Record<string, any>>;\n  /** A hook for when the flow ends either in success or failure */\n  onEnd: SyncHook<[], Record<string, any>>;\n  /** Mutate the Content flow before starting */\n  resolveFlowContent: SyncWaterfallHook<\n    [Flow<Asset<string>>],\n    Record<string, any>\n  >;\n}\n\n/** The status for a flow's execution state */\nexport type PlayerFlowStatus =\n  | \"not-started\"\n  | \"in-progress\"\n  | \"completed\"\n  | \"error\";\n\n/** Common interface for the state of Player's flow execution */\nexport interface BaseFlowState<T extends PlayerFlowStatus> {\n  /** A unique reference for the life-cycle of a flow */\n  ref: symbol;\n\n  /** The status of the given flow */\n  status: T;\n}\n\n/** The beginning state of Player, before it's seen a flow  */\nexport type NotStartedState = BaseFlowState<\"not-started\">;\n\nexport const NOT_STARTED_STATE: NotStartedState = {\n  ref: Symbol(\"not-started\"),\n  status: \"not-started\",\n};\n\n/** Shared properties for a flow in any state of execution (in-progress, completed successfully, or errored out) */\nexport interface PlayerFlowExecutionData {\n  /** The currently executing flow */\n  flow: Flow;\n}\n\nexport interface ControllerState {\n  /** The manager for data for a flow */\n  data: DataController;\n\n  /** The view manager for a flow */\n  view: ViewController;\n\n  /** The schema manager for a flow */\n  schema: SchemaController;\n\n  /** The validation manager for a flow */\n  validation: ValidationController;\n\n  /** The expression evaluator for a flow */\n  expression: ExpressionEvaluator;\n\n  /** The manager for parsing and resolving bindings */\n  binding: BindingParser;\n\n  /** the manager for the flow state machine */\n  flow: FlowController;\n}\n\n/** A flow is currently executing */\nexport type InProgressState = BaseFlowState<\"in-progress\"> &\n  PlayerFlowExecutionData & {\n    /** A promise that resolves when the flow is completed */\n    flowResult: Promise<FlowResult>;\n\n    /** The underlying state controllers for the current flow */\n    controllers: ControllerState;\n\n    /** Allow other platforms to abort the current flow with an error  */\n    fail: (error: Error) => void;\n\n    /**\n     * The Logger for the current player instance\n     */\n    logger: Logger;\n  };\n\n/** The flow completed properly */\nexport type CompletedState = BaseFlowState<\"completed\"> &\n  PlayerFlowExecutionData &\n  FlowResult & {\n    /** Readonly Player controllers to provide Player functionality after the flow has ended */\n    controllers: {\n      /** A read only instance of the Data Controller */\n      data: ReadOnlyDataController;\n    };\n  };\n\n/** The flow finished but not successfully */\nexport type ErrorState = BaseFlowState<\"error\"> & {\n  /** The currently executing flow */\n  flow: Flow;\n\n  /** The error associated with the failed flow */\n  error: Error;\n};\n\n/** Any Player state  */\nexport type PlayerFlowState =\n  | NotStartedState\n  | InProgressState\n  | CompletedState\n  | ErrorState;\n\n// Model\n\nexport type RawSetType = [BindingLike, any];\nexport type RawSetTransaction = Record<string, any> | RawSetType[];\n","import { NodeType, getNodeID } from \"@player-ui/player\";\nimport type {\n  Player,\n  PlayerPlugin,\n  Node,\n  ParseObjectOptions,\n  ParseObjectChildOptions,\n  ViewInstance,\n  Parser,\n  ViewPlugin,\n  Resolver,\n  Resolve,\n} from \"@player-ui/player\";\nimport { AsyncSeriesBailHook, SyncBailHook } from \"tapable-ts\";\nimport queueMicrotask from \"queue-microtask\";\n\nexport * from \"./types\";\nexport * from \"./transform\";\nexport * from \"./createAsyncTransform\";\n\n/** Object type for storing data related to a single `apply` of the `AsyncNodePluginPlugin`\n * This object should be setup once per ViewInstance to keep any cached info just for that view to avoid conflicts of shared async node ids across different view states.\n */\ntype AsyncPluginContext = {\n  /** Map of async node id to resolved content */\n  nodeResolveCache: Map<string, any>;\n  /** The view instance this context is attached to. */\n  view: ViewInstance;\n  /** Map of async node id to promises being used to resolve them */\n  inProgressNodes: Set<string>;\n};\n\nexport interface AsyncNodePluginOptions {\n  /** A set of plugins to load  */\n  plugins?: AsyncNodeViewPlugin[];\n}\n\nexport interface AsyncNodeViewPlugin extends ViewPlugin {\n  /** Use this to tap into the async node plugin hooks */\n  applyPlugin: (asyncNodePlugin: AsyncNodePlugin) => void;\n}\nexport type AsyncHandler = (\n  node: Node.Async,\n  callback?: (result: any) => void,\n) => Promise<any>;\n\nexport type AsyncContent = {\n  async: true;\n  flatten?: boolean;\n  [key: string]: unknown;\n};\n\n/** Hook declaration for the AsyncNodePlugin */\nexport type AsyncNodeHooks = {\n  /** Async hook to get content for an async node */\n  onAsyncNode: AsyncSeriesBailHook<[Node.Async, (result: any) => void], any>;\n  /** Sync hook to manage errors coming from the onAsyncNode hook. Return a fallback node or null to render a fallback. The first argument of passed in the call is the error thrown. */\n  onAsyncNodeError: SyncBailHook<[Error, Node.Async], any>;\n};\n\nexport const AsyncNodePluginSymbol: symbol = Symbol.for(\"AsyncNodePlugin\");\n\n/**\n * Async node plugin used to resolve async nodes in the content\n * If an async node is present, allow users to provide a replacement node to be rendered when ready\n */\nexport class AsyncNodePlugin implements PlayerPlugin {\n  private plugins: AsyncNodeViewPlugin[] | undefined;\n  private playerInstance: Player | undefined;\n\n  static Symbol: symbol = AsyncNodePluginSymbol;\n  public readonly symbol: symbol = AsyncNodePlugin.Symbol;\n\n  constructor(options: AsyncNodePluginOptions, asyncHandler?: AsyncHandler) {\n    if (options?.plugins) {\n      this.plugins = options.plugins;\n      options.plugins.forEach((plugin) => {\n        plugin.applyPlugin(this);\n      });\n    }\n\n    if (asyncHandler) {\n      this.hooks.onAsyncNode.tap(\n        \"async\",\n        async (node: Node.Async, callback) => {\n          return await asyncHandler(node, callback);\n        },\n      );\n    }\n  }\n\n  public readonly hooks: AsyncNodeHooks = {\n    onAsyncNode: new AsyncSeriesBailHook(),\n    onAsyncNodeError: new SyncBailHook(),\n  };\n\n  getPlayerInstance(): Player | undefined {\n    return this.playerInstance;\n  }\n\n  name = \"AsyncNode\";\n\n  apply(player: Player): void {\n    this.playerInstance = player;\n\n    player.hooks.viewController.tap(this.name, (viewController) => {\n      viewController.hooks.view.tap(this.name, (view) => {\n        this.plugins?.forEach((plugin) => {\n          plugin.apply(view);\n        });\n      });\n    });\n  }\n}\n\nexport class AsyncNodePluginPlugin implements AsyncNodeViewPlugin {\n  private basePlugin: AsyncNodePlugin | undefined;\n\n  name = \"AsyncNode\";\n\n  /**\n   * Parses the node from the result and triggers an asynchronous view update if necessary.\n   * @param node The asynchronous node that might be updated.\n   * @param result The result obtained from resolving the async node. This could be any data structure or value.\n   * @param options Options provided for node resolution, including a potential parseNode function to process the result.\n   * @param view The view instance where the node resides. This can be undefined if the view is not currently active.\n   */\n  private parseNodeAndUpdate(\n    node: Node.Async,\n    context: AsyncPluginContext,\n    result: any,\n    options: Resolve.NodeResolveOptions,\n  ) {\n    let parsedNode =\n      options.parseNode && result ? options.parseNode(result) : undefined;\n\n    if (parsedNode && node.onValueReceived) {\n      parsedNode = node.onValueReceived(parsedNode);\n    }\n\n    this.handleAsyncUpdate(node, context, parsedNode);\n  }\n\n  /**\n   * Updates the node asynchronously based on the result provided.\n   * This method is responsible for handling the update logic of asynchronous nodes.\n   * It checks if the node needs to be updated based on the new result and updates the mapping accordingly.\n   * If an update is necessary, it triggers an asynchronous update on the view.\n   * @param node The asynchronous node that might be updated.\n   * @param newNode The new node to replace the async node.\n   * @param view The view instance where the node resides. This can be undefined if the view is not currently active.\n   */\n  private handleAsyncUpdate(\n    node: Node.Async,\n    context: AsyncPluginContext,\n    newNode?: Node.Node | null,\n  ) {\n    const { nodeResolveCache, view } = context;\n    if (nodeResolveCache.get(node.id) !== newNode) {\n      nodeResolveCache.set(node.id, newNode ? newNode : node);\n      view.updateAsync(node.id);\n    }\n  }\n\n  private hasValidMapping(\n    node: Node.Async,\n    context: AsyncPluginContext,\n  ): boolean {\n    const { nodeResolveCache } = context;\n    return (\n      nodeResolveCache.has(node.id) && nodeResolveCache.get(node.id) !== node\n    );\n  }\n\n  /**\n   * Handles the asynchronous API integration for resolving nodes.\n   * This method sets up a hook on the resolver's `beforeResolve` event to process async nodes.\n   * @param resolver The resolver instance to attach the hook to.\n   * @param view\n   */\n  applyResolver(resolver: Resolver, context: AsyncPluginContext): void {\n    resolver.hooks.beforeResolve.tap(this.name, (node, options) => {\n      if (!this.isAsync(node)) {\n        return node === null ? node : this.resolveAsyncChildren(node, context);\n      }\n\n      const resolvedNode = context.nodeResolveCache.get(node.id);\n      if (resolvedNode !== undefined) {\n        if (resolvedNode.asyncNodesResolved === undefined) {\n          resolvedNode.asyncNodesResolved = [];\n        }\n        resolvedNode.asyncNodesResolved.push(node.id);\n        return this.resolveAsyncChildren(resolvedNode, context);\n      }\n\n      if (context.inProgressNodes.has(node.id)) {\n        return node;\n      }\n\n      // Track that the node is in progress.\n      context.inProgressNodes.add(node.id);\n      queueMicrotask(() => {\n        this.runAsyncNode(node, context, options).finally();\n      });\n\n      return node;\n    });\n  }\n\n  /**\n   * Replaces child async nodes with their resolved content and flattens when necessary. Resolving the children directly helps manage the `parent` reference without needing as much work within the resolver itself.\n   * Handles async node chains as well to make sure all applicable nodes can get flattened.\n   * @param node - The node whose children need to be resolved.\n   * @param context - the async plugin context needed to reach into the cache\n   * @returns The same node but with async node children mapped to their resolved AST.\n   */\n  private resolveAsyncChildren(\n    node: Node.Node,\n    context: AsyncPluginContext,\n  ): Node.Node {\n    const asyncNodesResolved: string[] = node.asyncNodesResolved ?? [];\n    node.asyncNodesResolved = asyncNodesResolved;\n    if (node.type === NodeType.MultiNode) {\n      // Using a while loop lets us catch when async nodes produce more async nodes that need to be flattened further\n      let index = 0;\n      while (index < node.values.length) {\n        const childNode = node.values[index];\n        if (\n          childNode?.type !== NodeType.Async ||\n          !this.hasValidMapping(childNode, context)\n        ) {\n          index++;\n          continue;\n        }\n\n        const mappedNode = context.nodeResolveCache.get(childNode.id);\n        asyncNodesResolved.push(childNode.id);\n        if (mappedNode.type === NodeType.MultiNode && childNode.flatten) {\n          mappedNode.values.forEach((v: Node.Node) => (v.parent = node));\n          node.values = [\n            ...node.values.slice(0, index),\n            ...mappedNode.values,\n            ...node.values.slice(index + 1),\n          ];\n        } else {\n          node.values[index] = mappedNode;\n          mappedNode.parent = node;\n        }\n      }\n    } else if (\"children\" in node) {\n      node.children?.forEach((c) => {\n        // Similar to above, using a while loop lets us handle when async nodes produce more async nodes.\n        while (\n          c.value.type === NodeType.Async &&\n          this.hasValidMapping(c.value, context)\n        ) {\n          asyncNodesResolved.push(c.value.id);\n          c.value = context.nodeResolveCache.get(c.value.id);\n          c.value.parent = node;\n        }\n      });\n    }\n\n    return node;\n  }\n\n  private async runAsyncNode(\n    node: Node.Async,\n    context: AsyncPluginContext,\n    options: Resolve.NodeResolveOptions,\n  ) {\n    try {\n      const result = await this.basePlugin?.hooks.onAsyncNode.call(\n        node,\n        (result) => {\n          this.parseNodeAndUpdate(node, context, result, options);\n        },\n      );\n\n      // Stop tracking before the next update is triggered\n      context.inProgressNodes.delete(node.id);\n      this.parseNodeAndUpdate(node, context, result, options);\n    } catch (e: unknown) {\n      const error = e instanceof Error ? e : new Error(String(e));\n      const result = this.basePlugin?.hooks.onAsyncNodeError.call(error, node);\n\n      if (result === undefined) {\n        const playerState = this.basePlugin?.getPlayerInstance()?.getState();\n\n        if (playerState?.status === \"in-progress\") {\n          playerState.fail(error);\n        }\n\n        return;\n      }\n\n      options.logger?.error(\n        \"Async node handling failed and resolved with a fallback. Error:\",\n        error,\n      );\n\n      // Stop tracking before the next update is triggered\n      context.inProgressNodes.delete(node.id);\n      this.parseNodeAndUpdate(node, context, result, options);\n    }\n  }\n\n  private isAsync(node: Node.Node | null): node is Node.Async {\n    return node?.type === NodeType.Async;\n  }\n\n  private isDeterminedAsync(obj: unknown): obj is AsyncContent {\n    return (\n      typeof obj === \"object\" &&\n      obj !== null &&\n      Object.prototype.hasOwnProperty.call(obj, \"async\")\n    );\n  }\n\n  applyParser(parser: Parser): void {\n    parser.hooks.parseNode.tap(\n      this.name,\n      (\n        obj: any,\n        nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        childOptions?: ParseObjectChildOptions,\n      ) => {\n        if (this.isDeterminedAsync(obj)) {\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const { async, flatten, ...rest } = obj;\n          const parsedAsync = parser.parseObject(rest, nodeType, options);\n          const parsedNodeId = getNodeID(parsedAsync);\n\n          if (parsedAsync === null || !parsedNodeId) {\n            return childOptions ? [] : null;\n          }\n\n          const asyncAST = parser.createASTNode(\n            {\n              id: parsedNodeId,\n              type: NodeType.Async,\n              value: parsedAsync,\n              flatten,\n            },\n            obj,\n          );\n\n          if (childOptions) {\n            return asyncAST\n              ? [\n                  {\n                    path: [...childOptions.path, childOptions.key],\n                    value: asyncAST,\n                  },\n                ]\n              : [];\n          }\n\n          return asyncAST;\n        }\n      },\n    );\n  }\n\n  apply(view: ViewInstance): void {\n    const context: AsyncPluginContext = {\n      nodeResolveCache: new Map(),\n      inProgressNodes: new Set(),\n      view,\n    };\n\n    view.hooks.parser.tap(\"async\", this.applyParser.bind(this));\n    view.hooks.resolver.tap(\"async\", (resolver) => {\n      this.applyResolver(resolver, context);\n    });\n  }\n\n  applyPlugin(asyncNodePlugin: AsyncNodePlugin): void {\n    this.basePlugin = asyncNodePlugin;\n  }\n}\n","import type { Node } from \"@player-ui/player\";\n\n/** Matches 2 segments where pathA matches or is a subset of pathB. Returns the number of matching segments */\nconst getMatchValue = (\n  pathA: Node.PathSegment[],\n  pathB: Node.PathSegment[],\n): number => {\n  if (pathA.length > pathB.length) {\n    return 0;\n  }\n\n  let matchCount = 0;\n  for (let i = 0; i < pathA.length; i++) {\n    if (pathA[i] === pathB[i]) {\n      matchCount++;\n    } else {\n      return 0;\n    }\n  }\n\n  return matchCount;\n};\n\n/** Follows the given path and returns the node. If there is no match, returns undefined */\nexport const extractNodeFromPath = (\n  node: Node.Node,\n  path?: string[],\n): Node.Node | undefined => {\n  if (path === undefined || path.length === 0) {\n    return node;\n  }\n\n  if (!(\"children\" in node && node.children)) {\n    return undefined;\n  }\n\n  let matchResult = 0;\n  let bestMatch: Node.Child | undefined;\n  for (const child of node.children) {\n    const matchValue = getMatchValue(child.path, path);\n    if (matchValue > matchResult) {\n      matchResult = matchValue;\n      bestMatch = child;\n    }\n  }\n\n  if (!bestMatch) {\n    return undefined;\n  }\n\n  if (matchResult >= path.length) {\n    return bestMatch.value;\n  }\n\n  return extractNodeFromPath(bestMatch.value, path.slice(matchResult));\n};\n","import { NodeType, Node } from \"@player-ui/player\";\n\n/** Replaces a node using the given replace function. If the node is a multi-node it does this transformation to all of its values. */\nexport const traverseAndReplace = (\n  node: Node.Node,\n  replaceFn: (node: Node.Node) => Node.Node,\n): Node.Node => {\n  if (node.type === NodeType.MultiNode) {\n    let index = 0;\n    while (index < node.values.length) {\n      const child = node.values[index];\n      if (!child) {\n        index++;\n        continue;\n      }\n\n      const result = replaceFn(child);\n      if (result.type === NodeType.MultiNode) {\n        node.values = [\n          ...node.values.slice(0, index),\n          ...result.values,\n          ...node.values.slice(index + 1),\n        ];\n      } else {\n        node.values[index] = result;\n        index++;\n      }\n    }\n\n    return node;\n  }\n\n  return replaceFn(node);\n};\n","import { NodeType, Node } from \"@player-ui/player\";\n\nexport const unwrapAsset = (node: Node.Node): Node.Node => {\n  if (node.type !== NodeType.Value) {\n    return node;\n  }\n  const child = node.children?.find(\n    (x) => x.path.length === 1 && x.path[0] === \"asset\",\n  );\n\n  if (!child) {\n    return node;\n  }\n\n  return child.value;\n};\n","import { NodeType } from \"@player-ui/player\";\nimport type { Node } from \"@player-ui/player\";\n\nexport const requiresAssetWrapper = (node: Node.Node): boolean => {\n  if (node.type === NodeType.Asset) {\n    return true;\n  }\n\n  if (node.type !== NodeType.Applicability) {\n    return false;\n  }\n\n  return node.value.type === NodeType.Asset;\n};\n","import {\n  BeforeTransformFunction,\n  Builder,\n  Node,\n  NodeType,\n} from \"@player-ui/player\";\nimport {\n  extractNodeFromPath,\n  requiresAssetWrapper,\n  traverseAndReplace,\n  unwrapAsset,\n} from \"./utils\";\n\nexport type AsyncTransformOptions = {\n  /** Whether or not to flatten the results into its container. Defaults to true */\n  flatten?: boolean;\n  /** The path to the array within the `wrapperAssetType` that will contain the async content. Defaults to [\"values\"] */\n  path?: string[];\n  /** The asset type that the transform is matching against. */\n  transformAssetType: string;\n  /** The asset type that will contain the async content. */\n  wrapperAssetType: string;\n  /** Function to get any nested asset that will need to be extracted and kept when creating the wrapper asset. */\n  getNestedAsset?: (node: Node.ViewOrAsset) => Node.Node | undefined;\n  /** Function to get the id for the async node being generated. Defaults to creating an id with the format of async-<ASSET.ID> */\n  getAsyncNodeId?: (node: Node.ViewOrAsset) => string;\n  /** Where to place the async node relative to the asset from `getNestedAsset`. Defaults to \"append\" */\n  asyncNodePosition?: \"append\" | \"prepend\";\n};\n\nconst defaultGetNodeId = (node: Node.ViewOrAsset): string => {\n  return `async-${node.value.id}`;\n};\n\n/** Creates a BeforeTransformFunction that turns the given asset into a wrapper asset with an async node in it.\n * By setting {@link AsyncTransformOptions.flatten} to true, you can chain multiple of the same asset type to create a flow of async content that\n * exists within a single collection.\n *\n * @param options - Options for managing the transform\n * @returns The {@link BeforeTransformFunction} that can be used for your asset.\n */\nexport const createAsyncTransform = (\n  options: AsyncTransformOptions,\n): BeforeTransformFunction => {\n  const {\n    transformAssetType,\n    wrapperAssetType,\n    getNestedAsset,\n    getAsyncNodeId = defaultGetNodeId,\n    path = [\"values\"],\n    flatten = true,\n    asyncNodePosition = \"append\",\n  } = options;\n\n  const replaceNode = (node: Node.Node): Node.Node => {\n    const unwrapped = unwrapAsset(node);\n\n    if (\n      unwrapped.type !== NodeType.Asset ||\n      unwrapped.value.type !== transformAssetType\n    ) {\n      return node;\n    }\n\n    const transformed = asyncTransform(unwrapped);\n    return extractNodeFromPath(transformed, path) ?? node;\n  };\n\n  const replacer = (node: Node.Node) => traverseAndReplace(node, replaceNode);\n\n  const asyncTransform = (node: Node.ViewOrAsset) => {\n    const id = getAsyncNodeId(node);\n    const asset = getNestedAsset?.(node);\n\n    // If flattening is disabled, don't need to extract the multi-node when async node is resolved.\n    const replaceFunction = flatten ? replacer : undefined;\n    const asyncNode = Builder.asyncNode(id, flatten, replaceFunction);\n\n    const values: Node.Node[] = [asyncNode];\n    if (asset) {\n      const otherValues = [];\n      if (requiresAssetWrapper(asset)) {\n        otherValues.push(Builder.assetWrapper(asset));\n      } else if (asset.type === NodeType.MultiNode) {\n        otherValues.push(...asset.values);\n      } else {\n        otherValues.push(asset);\n      }\n\n      if (asyncNodePosition === \"append\") {\n        values.unshift(...otherValues);\n      } else {\n        values.push(...otherValues);\n      }\n    }\n\n    const multiNode = Builder.multiNode(...(values as any[]));\n\n    const wrapperAsset: Node.ViewOrAsset = Builder.asset({\n      id: wrapperAssetType + \"-\" + id,\n      type: wrapperAssetType,\n    });\n\n    Builder.addChild(wrapperAsset, path, multiNode);\n\n    return wrapperAsset;\n  };\n\n  return asyncTransform;\n};\n","import type {\n  BeforeTransformFunction,\n  TransformFunctions,\n} from \"@player-ui/player\";\nimport { composeBefore, compose } from \"@player-ui/asset-transform-plugin\";\nimport { createAsyncTransform } from \"@player-ui/async-node-plugin\";\nimport { ChatMessageAsset } from \"./types\";\n/**\n * In beforeTransform function, pass in flatten marker and call beforeResolve function.\n * Flatten default value is true.\n * input: ChatMessageAsset\n * @param asset - Asset to apply the transform to\n * @returns - transformed asset with async node and asset node\n */\nexport const transform: BeforeTransformFunction<ChatMessageAsset> =\n  createAsyncTransform({\n    transformAssetType: \"chat-message\",\n    wrapperAssetType: \"collection\",\n    getNestedAsset: (node) => node.children?.[0]?.value,\n  });\n\nexport const chatMessageTransform: TransformFunctions = compose(\n  composeBefore(transform),\n);\n","import type { Player, PlayerPlugin } from \"@player-ui/player\";\n\n/**\n * A plugin that can wrap a set of other plugins.\n */\nexport class MetaPlugin implements PlayerPlugin {\n  name = \"meta-plugin\";\n\n  public readonly plugins: Array<PlayerPlugin>;\n\n  constructor(plugins: Array<PlayerPlugin> = []) {\n    this.plugins = plugins;\n  }\n\n  apply(player: Player) {\n    this.plugins.forEach((plugin) => player.registerPlugin(plugin));\n  }\n}\n","import type {\n  Player,\n  PlayerPlugin,\n  ExpressionHandler,\n} from \"@player-ui/player\";\n\nexport type ExpressionMap = Map<string, ExpressionHandler<any[], any>>;\n\n/**\n * The ExpressionPlugin is an easy way to inject custom expression handlers into the running player instance.\n * Simply supply a map of function name to handler, and the expressions will be available inside of the Content.\n *\n * Any subsequent expressions registered with the same name will override previous handlers.\n */\nexport class ExpressionPlugin implements PlayerPlugin {\n  name = \"ExpressionPlugin\";\n  private expressions: ExpressionMap;\n\n  constructor(expressionMap: ExpressionMap) {\n    this.expressions = expressionMap;\n  }\n\n  apply(player: Player) {\n    player.hooks.expressionEvaluator.tap(this.name, (expEvaluator) => {\n      this.expressions.forEach((handler, name) => {\n        expEvaluator.addExpressionFunction(name, handler);\n      });\n    });\n  }\n}\n","import { AsyncNodePlugin } from \"@player-ui/async-node-plugin\";\nimport {\n  ExpressionContext,\n  ExtendedPlayerPlugin,\n  NodeType,\n  Player,\n} from \"@player-ui/player\";\nimport { ExpressionPlugin } from \"@player-ui/expression-plugin\";\nimport { send } from \"./send\";\n\nconst createContentFromMessage = (message: string, id: string): any => ({\n  asset: {\n    type: \"chat-message\",\n    id,\n    value: {\n      asset: {\n        type: \"text\",\n        id: `${id}-value`,\n        value: message,\n      },\n    },\n  },\n});\n\nexport class ChatUiDemoPlugin implements ExtendedPlayerPlugin<[], [], [send]> {\n  public readonly name = \"chat-ui-demo-plugin\";\n\n  public apply(player: Player): void {\n    const asyncNodePlugin = player.findPlugin<AsyncNodePlugin>(\n      AsyncNodePlugin.Symbol,\n    );\n\n    if (!asyncNodePlugin) {\n      player.logger.warn(\n        `Failed to apply '${this.name}'. Reason: Could not find AsyncNodePlugin.`,\n      );\n      return;\n    }\n\n    let deferredPromises: Record<string, (val: string) => void> = {};\n    let allPromiseKeys: string[] = [];\n    let counter = 0;\n\n    const sendMessage: send = (\n      context: ExpressionContext,\n      message: string,\n      nodeId?: string,\n    ): void => {\n      if (nodeId && !(nodeId in deferredPromises)) {\n        context.logger?.warn(\n          `'send' expression called with unrecognized id '${nodeId}'`,\n        );\n        return;\n      }\n\n      if (!nodeId && allPromiseKeys.length === 0) {\n        context.logger?.warn(`'send' called with no waiting async nodes`);\n        return;\n      }\n\n      // Either resolve the node by the id or resolve all of them if no id provided\n      const keys = nodeId ? [nodeId] : allPromiseKeys;\n\n      for (const id of keys) {\n        const content = createContentFromMessage(\n          message,\n          `chat-demo-${counter++}`,\n        );\n        const resolveFunction = deferredPromises[id];\n        resolveFunction?.(content);\n        delete deferredPromises[id];\n      }\n\n      if (nodeId) {\n        const index = allPromiseKeys.indexOf(nodeId);\n        allPromiseKeys.splice(index, 1);\n      } else {\n        allPromiseKeys = [];\n      }\n    };\n\n    asyncNodePlugin.hooks.onAsyncNode.tap(this.name, (node) => {\n      // Ensure this is only used on the chat-ui.tsx mock to prevent the promise from setting up during tests.\n      if (\n        (node.parent?.parent?.type !== NodeType.Asset &&\n          node.parent?.parent?.type !== NodeType.View) ||\n        !node.parent.parent.value.id.startsWith(\"collection-async-chat-demo\")\n      ) {\n        return Promise.resolve(undefined);\n      }\n\n      return new Promise((res) => {\n        deferredPromises[node.id] = res;\n        allPromiseKeys.push(node.id);\n      });\n    });\n\n    // Reset at the start of a new view.\n    player.hooks.view.tap(this.name, (_) => {\n      deferredPromises = {};\n      allPromiseKeys = [];\n      counter = 0;\n    });\n\n    // Register 'send' expression\n    const expressionPlugin = new ExpressionPlugin(\n      new Map([[\"send\", sendMessage]]),\n    );\n    player.registerPlugin(expressionPlugin);\n  }\n}\n","import type { ExtendedPlayerPlugin, Player } from \"@player-ui/player\";\nimport { AssetTransformPlugin } from \"@player-ui/asset-transform-plugin\";\nimport {\n  actionTransform,\n  chatMessageTransform,\n  choiceTransform,\n  imageTransform,\n  infoTransform,\n  inputTransform,\n} from \"../assets\";\nimport type {\n  ActionAsset,\n  ChatMessageAsset,\n  ChoiceAsset,\n  CollectionAsset,\n  ImageAsset,\n  InfoAsset,\n  InputAsset,\n  TextAsset,\n} from \"../assets\";\n\nexport class ReferenceAssetsTransformPlugin\n  implements\n    ExtendedPlayerPlugin<\n      [\n        ActionAsset,\n        InputAsset,\n        ImageAsset,\n        TextAsset,\n        CollectionAsset,\n        ChoiceAsset,\n        ChatMessageAsset,\n      ],\n      [InfoAsset]\n    >\n{\n  name = \"reference-assets-transforms\";\n\n  apply(player: Player): void {\n    player.registerPlugin(\n      new AssetTransformPlugin([\n        [{ type: \"action\" }, actionTransform],\n        [{ type: \"input\" }, inputTransform],\n        [{ type: \"image\" }, imageTransform],\n        [{ type: \"info\" }, infoTransform],\n        [{ type: \"choice\" }, choiceTransform],\n        [{ type: \"chat-message\" }, chatMessageTransform],\n      ]),\n    );\n  }\n}\n","import type { Player, PlayerPlugin } from \"@player-ui/player\";\nimport { MetaPlugin } from \"@player-ui/meta-plugin\";\nimport { ChatUiDemoPlugin, ReferenceAssetsTransformPlugin } from \"./plugins\";\nimport {\n  AsyncNodePlugin,\n  AsyncNodePluginPlugin,\n} from \"@player-ui/async-node-plugin\";\n\n/**\n * A plugin to add transforms for the reference assets\n */\nexport class ReferenceAssetsPlugin implements PlayerPlugin {\n  name = \"reference-assets-plugin\";\n\n  private readonly metaPlugin = new MetaPlugin([\n    new AsyncNodePlugin({\n      plugins: [new AsyncNodePluginPlugin()],\n    }),\n    new ReferenceAssetsTransformPlugin(),\n    new ChatUiDemoPlugin(),\n  ]);\n\n  apply(player: Player): void {\n    player.registerPlugin(this.metaPlugin);\n  }\n}\n"]}