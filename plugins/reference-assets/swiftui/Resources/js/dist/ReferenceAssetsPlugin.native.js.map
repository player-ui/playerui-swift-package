{"version":3,"sources":["../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/sorted-array@2.0.4/node_modules/sorted-array/sorted-array.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/input/transform.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/partial-match-registry/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dlv@1.1.3/node_modules/dlv/index.js","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/partial-match-registry/src/deep-partial-matcher.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/asset-transform/core/src/utils.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/asset-transform/core/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/action/transform.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/info/transform.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/image/transform.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/assets/choice/transform.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/reference-assets/core/src/plugin.ts"],"names":["SortedArray","obj","key","def","p","undef","split","length"],"mappings":"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","sourcesContent":["var SortedArray = (function () {\n    var SortedArray = defclass({\n\n        constructor: function (array, compare) {\n            this.array   = [];\n            this.compare = compare || compareDefault;\n            var length   = array.length,\n                index    = 0;\n            while (index < length) this.insert(array[index++]);\n        },\n        insert: function (element) {\n            var array   = this.array,\n                compare = this.compare,\n                high    = array.length-1,\n                low     = 0,\n                pos = -1,\n                index,\n                ordering;\n\n            // The array is sorted. You must find the position of new element in O(log(n)), not O(n).\n            while (high >= low) {\n                index    = (high + low) / 2 >>> 0;\n                ordering = compare(array[index], element);                \n                if (ordering < 0) low  = index + 1;\n                else if (ordering > 0) high = index - 1;\n                else {\n                    pos = index;\n                    break;\n                };\n            }\n\n            if (pos === -1) {\n                // if element was not found, high < low.\n                pos = high;\n            }\n            // This assures that equal elements inserted after will be in a higher position in array.\n            // They can be equal for comparison purposes, but different objects with different data.\n            // Respecting the chronological order can be important for many applications.\n            pos++;\n            high = array.length-1;\n            while ((pos < high) && (compare(element, array[pos]) === 0)){\n                pos++;\n            }\n            index = array.length;\n            // Just to increase array size.\n            array.push(element);            \n            // Much faster. No need to elements swap.\n            while (index > pos) {\n                array[index] = array[--index];\n            }\n            // Set the new element on its correct position.\n            array[pos] = element;\n\n            return this;\n        },\n        search: function (element) {\n            var array   = this.array,\n                compare = this.compare,\n                high    = array.length-1,\n                low     = 0,\n                // In most languages, inner variable declaration makes the code slower.\n                index,\n                ordering;\n\n            while (high >= low) {\n                index    = (high + low) / 2 >>> 0;\n                ordering = compare(array[index], element);\n\n                     if (ordering < 0) low  = index + 1;\n                else if (ordering > 0) high = index - 1;\n                else return index;\n            }\n\n            return -1;\n        },\n        remove: function (element) {\n            var index = this.search(element);\n            if (index >= 0) this.array.splice(index, 1);\n            return this;\n        }\n    });\n\n    SortedArray.comparing = function (property, array) {\n        return new SortedArray(array, function (a, b) {\n            // This should be faster than calling functions.\n            // Besides, this way it is not needed to create useless function to return property value.\n            return compareDefault(a[property], b[property]);\n        });\n    };\n\n    return SortedArray;\n\n    function defclass(prototype) {\n        var constructor = prototype.constructor;\n        constructor.prototype = prototype;\n        return constructor;\n    }\n\n    function compareDefault(a, b) {\n        // Equality has a very low chance to happen. It should be the last option.\n        if (a < b)\n            return -1;\n        else if (a > b)\n            return 1;\n        else\n            return 0;\n    }\n}());\n\nif (typeof module === \"object\") module.exports = SortedArray;\nif (typeof define === \"function\" && define.amd)\n    define(function () { return SortedArray; });\n","export * from \"./assets\";\nexport * from \"./plugin\";\n","import type { TransformFunction } from \"@player-ui/player\";\nimport type { InputAsset, TransformedInput } from \"./types\";\n\n/**\n * Docs about the asset transform\n */\nexport const inputTransform: TransformFunction<InputAsset, TransformedInput> = (\n  asset,\n  options,\n) => {\n  return {\n    ...asset,\n    format(val) {\n      if (asset.binding === undefined) {\n        return val;\n      }\n\n      return options.data.format(asset.binding, val);\n    },\n    set(val) {\n      if (asset.binding === undefined) {\n        return;\n      }\n\n      return options.data.model.set([[asset.binding, val]], {\n        formatted: true,\n      });\n    },\n    value:\n      asset.binding === undefined\n        ? \"\"\n        : options.data.model.get(asset.binding, {\n            includeInvalid: true,\n            formatted: true,\n          }),\n    validation:\n      asset.binding === undefined\n        ? undefined\n        : options.validation?.get(asset.binding, { track: true }),\n    dataType:\n      asset.binding === undefined\n        ? undefined\n        : options.validation?.type(asset.binding),\n  };\n};\n","import SortedArray from \"sorted-array\";\nimport type { Matcher } from \"./deep-partial-matcher\";\nimport createObjectMatcher from \"./deep-partial-matcher\";\n\nexport { default as createObjectMatcher } from \"./deep-partial-matcher\";\n\n/** create a matcher function that matches exactly */\nfunction createBasicMatcher(seed: any): Matcher {\n  /** a simple matcher function that only matches itself */\n  const matcher = (match: any) => seed === match;\n  matcher.count = 1;\n\n  return matcher;\n}\n\ninterface RegistryIndex<V> {\n  /** The original object we wanted to match on  */\n  key: object;\n\n  /** The value to return */\n  value: V;\n\n  /** The matcher function for this entry */\n  matcher: Matcher;\n}\n\n/** create an empty sorted array using the matcher count */\nconst createSortedArray = <V>() =>\n  new SortedArray<RegistryIndex<V>>([], (c) => c.matcher.count);\n\n/**\n * A partial match registry is a map that uses an object to \"match\" against keys.\n * More specific matches take precedence over less specific ones.\n */\nexport class Registry<V> {\n  private store = createSortedArray<V>();\n\n  constructor(initialSet?: Array<[any, V]>) {\n    initialSet?.forEach(([match, value]) => {\n      this.set(match, value);\n    });\n  }\n\n  /** Add match -> value mapping to the registry */\n  set(match: any, value: V) {\n    const matcher =\n      typeof match === \"object\"\n        ? createObjectMatcher(match)\n        : createBasicMatcher(match);\n\n    this.store.insert({\n      key: match,\n      value,\n      matcher,\n    });\n  }\n\n  /** Fetch the best match in the registry */\n  get(query: any): V | undefined {\n    for (const entry of this.store.array) {\n      if (entry.matcher(query)) {\n        return entry.value;\n      }\n    }\n  }\n\n  /** Loop over all entries and run callback */\n  forEach(callbackfn: (value: RegistryIndex<V>) => void): void {\n    for (const entry of this.store.array) {\n      callbackfn(entry);\n    }\n  }\n\n  /** Reset the items in the registry */\n  clear() {\n    this.store = createSortedArray<V>();\n  }\n\n  /** Check if the registry is empty*/\n  isRegistryEmpty() {\n    return this.store.array.length === 0;\n  }\n}\n","export default function dlv(obj, key, def, p, undef) {\n\tkey = key.split ? key.split('.') : key;\n\tfor (p = 0; p < key.length; p++) {\n\t\tobj = obj ? obj[key[p]] : undef;\n\t}\n\treturn obj === undef ? def : obj;\n}\n","import dlv from \"dlv\";\n\n/** A function that checks overlapping properties against a reference value */\nexport type Matcher = ((searchObj: object) => boolean) & {\n  /** The count represents the specificity of this matcher */\n  count: number;\n};\n\n/** Traverse an object and collect any key/value pairs including nested keys */\nfunction traverseObj(\n  object: Record<any, any>,\n  path: string[] = [],\n  pairs: Map<string[], any> = new Map(),\n): Map<string[], any> {\n  for (const key of Object.keys(object)) {\n    const val: any = object[key];\n    const nestedPath = [...path, key];\n    (\"\");\n\n    if (typeof val === \"object\") {\n      traverseObj(val, nestedPath, pairs);\n    } else {\n      pairs.set(nestedPath, val);\n    }\n  }\n\n  return pairs;\n}\n\n/** Given an object, create a function that compares any set key/value pairs in the given object against a new value */\nexport default function createMatcher(partialObj: object): Matcher {\n  // Convert the partial object into a list of [key, value] pairs;\n  const pairs = traverseObj(partialObj);\n\n  /** Generate a function to match against all of the properties we care about */\n  const matchFunction = (searchObj: object) => {\n    for (const entry of Array.from(pairs)) {\n      const [path, value] = entry;\n\n      if (dlv(searchObj, path) !== value) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  // Keep track of the specificity of the comparator\n  matchFunction.count = pairs.size;\n\n  return matchFunction;\n}\n","import type {\n  Resolve,\n  Store,\n  BeforeTransformFunction,\n  TransformFunction,\n  TransformFunctions,\n} from \"@player-ui/player\";\n\nfunction composeTransforms(\n  ...args: TransformFunction<any>[]\n): TransformFunction<any>;\n\nfunction composeTransforms(\n  ...args: BeforeTransformFunction<any>[]\n): BeforeTransformFunction<any>;\n\n/**\n * More closely resembles the `compose` function you may have used. Performs\n * right-to-left function evaluation, but leveraging the common signature for\n * Transform Functions. The `options` and `store` is unchanging for each\n * transform since only `value` is returned, allowing them to safely be passed\n * into each transform.\n */\nfunction composeTransforms(\n  ...args: TransformFunction<any>[] | BeforeTransformFunction<any>[]\n): TransformFunction<any> | BeforeTransformFunction<any> {\n  const [fn, ...fns] = args.reverse();\n\n  return (asset: any, options: Resolve.NodeResolveOptions, store: Store) => {\n    const value = fn(asset, options, store);\n\n    if (!fns.length) {\n      return value;\n    }\n\n    return fns.reduce((prevValue, current) => {\n      return current(prevValue, options, store);\n    }, value);\n  };\n}\n\n/**\n * Helper function to make it easier to create transforms that need to be ran in\n * the `beforeResolve` hook. Just like `compose`, functions are evaluated from\n * right-to-left.\n */\nexport function composeBefore(\n  ...args: BeforeTransformFunction<any>[]\n): TransformFunctions {\n  return {\n    beforeResolve: composeTransforms(...args),\n  };\n}\n\n/**\n * Performs right-to-left function evaluation of each transform function. Unlike\n * other compose functions, this does not require unary arguments for all but the\n * last function. The value returned from each function will be used as the value\n * for the next function.\n */\nexport function compose(\n  ...args: Array<TransformFunction<any> | TransformFunctions>\n): TransformFunctions {\n  const beforeResolveFns: BeforeTransformFunction<any>[] = [];\n  const resolveFns: TransformFunction<any>[] = [];\n\n  for (const arg of args) {\n    if (typeof arg === \"function\") {\n      resolveFns.push(arg);\n    } else {\n      if (arg?.resolve) {\n        resolveFns.push(arg.resolve);\n      }\n\n      if (arg?.beforeResolve) {\n        beforeResolveFns.push(arg.beforeResolve);\n      }\n    }\n  }\n\n  return {\n    beforeResolve: beforeResolveFns.length\n      ? composeTransforms(...beforeResolveFns)\n      : undefined,\n    resolve: resolveFns.length ? composeTransforms(...resolveFns) : undefined,\n  };\n}\n","import type {\n  Player,\n  PlayerPlugin,\n  TransformRegistry,\n  TransformFunction,\n  TransformFunctions,\n} from \"@player-ui/player\";\nimport { Registry } from \"@player-ui/partial-match-registry\";\nimport { compose } from \"./utils\";\n\nexport * from \"./utils\";\nexport * from \"./propertiesToSkip\";\n\nexport type TransformType = TransformFunction<any> | TransformFunctions;\nexport type TransformRegistryEntries = Array<[any, TransformType]>;\nexport type AssetTransformInit =\n  | Registry<TransformType>\n  | TransformRegistryEntries;\n\n/**\n * Normalize asset transform values so that they are all objects that contains\n * the resolve & beforeResolve functions.\n */\nfunction maybeCompose(maybeFn: any): TransformFunctions {\n  if (typeof maybeFn === \"object\") {\n    return maybeFn;\n  }\n\n  return compose(maybeFn);\n}\n\n/**\n * Standardize each variation of Asset Registry input into the same transform\n * registry shape.\n */\nfunction cleanupTransformRegistry(\n  maybeRegistry: AssetTransformInit,\n): TransformRegistry {\n  if (Array.isArray(maybeRegistry)) {\n    const wrappedTransforms = maybeRegistry.map(([key, value]) => {\n      return [key, maybeCompose(value)] as [any, TransformFunctions];\n    });\n\n    return new Registry(wrappedTransforms);\n  }\n\n  const registry = new Registry<TransformFunctions>();\n\n  maybeRegistry.forEach(({ key, value }) => {\n    registry.set(key, maybeCompose(value));\n  });\n\n  return registry;\n}\n\n/**\n * A plugin to register custom transforms on certain asset types\n * This allows users to embed stateful data into transforms.\n */\nexport class AssetTransformPlugin implements PlayerPlugin {\n  name = \"asset-transform\";\n  public readonly registry: TransformRegistry;\n\n  constructor(transforms: AssetTransformInit) {\n    this.registry = cleanupTransformRegistry(transforms);\n  }\n\n  apply(player: Player) {\n    player.hooks.viewController.tap(this.name, (vc) => {\n      this.registry.forEach(({ key, value }) =>\n        vc.transformRegistry.set(key, maybeCompose(value)),\n      );\n    });\n  }\n}\n","import type {\n  Asset,\n  TransformFunction,\n  BeforeTransformFunction,\n} from \"@player-ui/player\";\nimport { compose, composeBefore } from \"@player-ui/asset-transform-plugin\";\nimport type { ActionAsset, TransformedAction } from \"./types\";\n\n/**\n * Function to find prev button\n */\nexport function isBackAction(action: ActionAsset): boolean {\n  return action.value === \"Prev\";\n}\n\n/**\n * Attaches the methods to execute an action to an action\n */\nconst transform: TransformFunction<ActionAsset, TransformedAction> = (\n  action,\n  options,\n) => {\n  return {\n    ...action,\n    run() {\n      if (action.exp) {\n        options.evaluate(action.exp);\n      }\n\n      if (action.value) {\n        const skipValidation = action.metaData?.skipValidation;\n        options.transition?.(action.value, { force: skipValidation });\n      }\n    },\n  };\n};\n\n/**\n * De couples back button from the back icon\n */\nconst backIconTransform: TransformFunction<ActionAsset, ActionAsset> = (\n  action,\n) => {\n  /** For previous versions of player, the back button would already have the back icon.\n   *  This ensures that the old functionality does not break and back button is still visible when they update the player.\n   */\n  if (isBackAction(action) && action?.metaData?.role === undefined) {\n    return {\n      ...action,\n      metaData: {\n        ...action?.metaData,\n        role: \"back\",\n      },\n    };\n  }\n\n  return action;\n};\n\n/**\n * Appends `exp` to the plugins.stringResolver.propertiesToSkip array or creates it if it doesn't exist\n *\n * @param asset - Asset to apply the transform to\n */\nexport const expPropTransform: BeforeTransformFunction<Asset> = (asset) => {\n  const skipArray = asset.plugins?.stringResolver?.propertiesToSkip;\n\n  if (skipArray && skipArray.indexOf(\"exp\") > 1) {\n    return asset;\n  }\n\n  return {\n    ...asset,\n    plugins: {\n      ...asset.plugins,\n      stringResolver: {\n        ...asset?.plugins?.stringResolver,\n        propertiesToSkip: [\n          ...(asset.plugins?.stringResolver?.propertiesToSkip ?? []),\n          \"exp\",\n        ],\n      },\n    },\n  };\n};\n\nexport const actionTransform = compose(\n  transform,\n  backIconTransform,\n  composeBefore(expPropTransform),\n);\n","import type { TransformFunction } from \"@player-ui/player\";\nimport type { AssetWrapper } from \"@player-ui/player\";\nimport type { InfoAsset, InfoAssetTransform } from \"./types\";\nimport type { ActionAsset } from \"../action/types\";\nimport { isBackAction } from \"../action/transform\";\n\n/**\n * This transform should add segmentedActions to the info asset.\n * Segmented actions display side by side in larger viewports. Segmented Actions is an object of next and prev actions\n */\nexport const infoTransform: TransformFunction<InfoAsset, InfoAssetTransform> = (\n  infoAsset,\n) => {\n  const actions = infoAsset?.actions;\n  const segmentedActions = actions?.reduce(\n    (segmentedActionsArray, action) => {\n      segmentedActionsArray[\n        isBackAction(action.asset as ActionAsset) ? \"prev\" : \"next\"\n      ].push(action as AssetWrapper<ActionAsset>);\n      return segmentedActionsArray;\n    },\n    { next: [], prev: [] } as {\n      /**\n       * next is an array of next actions\n       */\n      next: Array<AssetWrapper<ActionAsset>>;\n      /**\n       * prev is an array of prev actions\n       */\n      prev: Array<AssetWrapper<ActionAsset>>;\n    },\n  );\n\n  return {\n    ...infoAsset,\n    segmentedActions,\n  };\n};\n","import type { TransformFunction } from \"@player-ui/player\";\nimport type { ImageAsset, TransformedImage } from \"./types\";\n\n/**\n * Function to retrieve the desired alt text based on passed in props.\n * @param props Image props\n * @returns The alt text for the image asset\n */\nconst getImageAlt = (props: ImageAsset): string => {\n  const { metaData, placeholder } = props;\n  if (metaData.accessibility) return metaData.accessibility;\n\n  if (placeholder) return placeholder;\n\n  return \"Image\";\n};\n\n/**\n * Sets the Image's placeholder and accessibilty\n */\nexport const imageTransform: TransformFunction<ImageAsset, TransformedImage> = (\n  props,\n) => {\n  const altText = getImageAlt(props);\n\n  const newImage = {\n    ...props,\n    altText,\n  };\n\n  return newImage;\n};\n","import type { TransformFunction } from \"@player-ui/player\";\nimport type {\n  ChoiceAsset,\n  TransformedChoice,\n  TransformedChoiceItem,\n} from \"./types\";\n\n/**\n * Docs about the asset transform\n */\nexport const choiceTransform: TransformFunction<\n  ChoiceAsset,\n  TransformedChoice\n> = (asset, options) => {\n  const { items, binding, ...rest } = asset;\n\n  const assetHasBinding = binding !== undefined;\n\n  const currentValue = assetHasBinding\n    ? options.data.model.get(binding, {\n        includeInvalid: true,\n      })\n    : undefined;\n\n  const resetValue = () => {\n    if (assetHasBinding) {\n      return options.data.model.set([[binding, null]]);\n    }\n  };\n\n  const transformedChoiceItems: TransformedChoiceItem[] = (items || []).map(\n    (item, index) => ({\n      ...item,\n      id: item.id ?? `${asset.id}-choice-${index}`,\n      select() {\n        if (assetHasBinding) {\n          return options.data.model.set([[binding, item.value]]);\n        }\n      },\n      unselect: resetValue,\n    }),\n  );\n\n  return {\n    ...rest,\n    binding,\n    clearSelection: resetValue,\n    items: transformedChoiceItems,\n    value: currentValue,\n    validation: assetHasBinding\n      ? options.validation?.get(binding, { track: true })\n      : undefined,\n    dataType: assetHasBinding ? options.validation?.type(binding) : undefined,\n  };\n};\n","import type { Player, ExtendedPlayerPlugin } from \"@player-ui/player\";\nimport { AssetTransformPlugin } from \"@player-ui/asset-transform-plugin\";\nimport type {\n  ActionAsset,\n  InputAsset,\n  ImageAsset,\n  InfoAsset,\n  TextAsset,\n  CollectionAsset,\n  ChoiceAsset,\n} from \"./assets\";\nimport {\n  inputTransform,\n  actionTransform,\n  imageTransform,\n  infoTransform,\n  choiceTransform,\n} from \"./assets\";\n\n/**\n * A plugin to add transforms for the reference assets\n */\nexport class ReferenceAssetsPlugin\n  implements\n    ExtendedPlayerPlugin<\n      [\n        ActionAsset,\n        InputAsset,\n        ImageAsset,\n        TextAsset,\n        CollectionAsset,\n        ChoiceAsset,\n      ],\n      [InfoAsset]\n    >\n{\n  name = \"reference-assets-transforms\";\n\n  apply(player: Player) {\n    player.registerPlugin(\n      new AssetTransformPlugin([\n        [{ type: \"action\" }, actionTransform],\n        [{ type: \"input\" }, inputTransform],\n        [{ type: \"image\" }, imageTransform],\n        [{ type: \"info\" }, infoTransform],\n        [{ type: \"choice\" }, choiceTransform],\n      ]),\n    );\n  }\n}\n"]}