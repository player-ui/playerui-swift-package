{"version":3,"sources":["/home/circleci/.cache/bazel/_bazel_circleci/e8362d362e14c7d23506d1dfa3aea8b8/sandbox/processwrapper-sandbox/2575/execroot/_main/bazel-out/k8-fastbuild/bin/plugins/check-path/core/dist/index.global.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/tapable-ts@0.2.4/node_modules/tapable-ts/src/utils.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/tapable-ts@0.2.4/node_modules/tapable-ts/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dlv@1.1.3/node_modules/dlv/index.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dequal@2.0.3/node_modules/dequal/dist/index.mjs","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/partial-match-registry/src/deep-partial-matcher.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/partial-match-registry/src/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/utils.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/model.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/types.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/parser.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/async.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/utils.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/evaluator.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/schema/schema.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/string-resolver/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/validator/binding-map-splice.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/parser/utils.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/resolver/utils.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/string-resolver.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/utils/replaceParams.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/validation/controller.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/constants/utils.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/check-path/core/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/ts-nested-error@1.2.1/node_modules/ts-nested-error/src/nested-error.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/timm@1.7.1/node_modules/timm/lib/timm.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/p-defer@3.0.0/node_modules/p-defer/index.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/queue-microtask@1.2.3/node_modules/queue-microtask/index.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/sorted-array@2.0.4/node_modules/sorted-array/sorted-array.js","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/resolver.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/local-model.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/validator/validation-middleware.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/resolver/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/parser/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/applicability.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/player.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/flow/flow.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/view/controller.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding-grammar/ast.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding-grammar/custom/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/binding.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/dependency-tracker.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/noop-model.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/evaluator-functions.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/logger/tapableLogger.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/logger/proxyLogger.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/validator/registry.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/parser/types.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/view.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/template.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/switch.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/multi-node.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/asset.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/view/store.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/asset-transform.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/flow/controller.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/validation/binding-tracker.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/data/utils.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/data/controller.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/constants/index.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/plugins/flow-exp-plugin.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/plugins/default-exp-plugin.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/types.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/check-path/core/src/symbols.ts"],"names":["CheckPathPlugin","equalToOrIn","value","check","Array","isArray","includes","callTap","tap","args","ctx","context","callback","dlv_es_default","obj","key","def","p","undef","split","length","find","iter","tar","keys","dequal","createMatcher","partialObj","pairs","traverseObj","matchFunction","searchObj","from","entry","path","count","size","createBasicMatcher","seed","matcher","match","isBinding","binding","maybeConvertToNum","i","asInt","parseInt","isNaN","getBindingSegments","asArray","findInArray","array","findIndex","withParser","model","parseBinding","maybeParse","readOnly","parsed","get","set","Error","options","transaction","map","val","delete","toModel","middleware","defaultOptions","next","resolvedOptions","constructModelForPipeline","pipeline","NOOP_MODEL","createModelWithOptions","reduce","nextModel","isExpressionNode","x","__id","ExpNodeOpaqueIdentifier","throwError","message","index","err","description","createSpanningLocation","start","end","getMaxKeyLen","maxLen","Object","forEach","prototype","hasOwnProperty","call","binaryPrecedence","opVal","binaryOps","createBinaryExpression","operator","left","right","location","type","isDecimalDigit","ch","isIdentifierStart","isIdentifierPart","isModelRefStart","ch0","ch1","OCURL_CODE","parseExpression","expr","strictMode","strict","charAtFunc","charAt","charCodeAtFunc","charCodeAt","getLocation","startChar","character","exprI","exprICode","gobbleObjects","attributes","closed","shouldDefineKey","chCode","startCharIndex","gobbleSpaces","CCURL_CODE","SQUOTE_CODE","DQUOTE_CODE","gobbleStringLiteral","COLON_CODE","gobbleExpression","push","COMMA_CODE","test","gobbleBinaryExpression","QUMARK_CODE","consequent","alternate","gobbleBinaryOp","toCheck","substr","maxBinopLen","tcLen","node","prec","gobbleToken","biop","biopInfo","stack","pop","PERIOD_CODE","gobbleNumericLiteral","OPAREN_CODE","gobbleVariable","OBRACK_CODE","gobbleArray","gobbleModelRef","maxUnopLen","unaryOps","argument","prefix","num","parseFloat","raw","quote","str","openBraceCount","ref","gobbleIdentifier","identifier","slice","literals","thisStr","name","gobbleArguments","termination","charIndex","String","fromCharCode","gobbleGroup","computed","object","property","CBRACK_CODE","CPAREN_CODE","callTarget","elements","nodes","chIndex","SEMCOL_CODE","body","e","error","isPromiseLike","then","Promise","catch","finally","isAwaitable","AwaitableSymbol","collateAwaitable","promises","result","all","makeAwaitable","isObjectExpression","makePromiseAwareBinaryOp","operation","a","b","async","resolve","awaitableThen","resolvedA","resolvedB","makePromiseAwareUnaryOp","resolved","handleConditionalBranching","testValue","getTrueBranch","getFalseBranch","resolveNode","branch","branchResult","parse","schema","parseQueue","shift","visited","entries","prop","nestedPath","nestedPathStr","join","expandedPaths","has","isRecord","Set","Map","ROOT","findNextExp","expStart","indexOf","DOUBLE_OPEN_CURLY","offset","workingString","substring","nextCloseCurly","DOUBLE_CLOSE_CURLY","nextOpenCurly","resolveExpressionsInString","evaluate","expMatch","newVal","expStrWithBrackets","matchStart","expString","expValue","resolveDataRefsInString","formatted","expLocation","trim","evaledVal","resolveDataRefs","traverseObject","removeBindingAndChildrenFromMap","sourceMap","targetMap","parentBinding","parent","_value","trackedBinding","contains","bindingsToRewrite","filter","relative","childIndex","sort","childPath","newSegments","newChildBinding","descendent","hasTemplateValues","localKey","template","tmpl","output","hasSwitchKey","hasTemplateKey","getNodeID","id","caresAboutDataChanges","dataChanges","dependencies","depArray","values","dataChangeArray","dep","change","toNodeResolveOptions","resolverOptions","data","formatValue","format","bindingLike","exp","evaluator","hasSomethingToResolve","bindingResolveLookup","expressionResolveLookup","resolveString","resolveOptions","replaceParams","params","replace","ANY_CHAR_REGEX","keyExpr","isSubset","subset","containingSet","createStatefulValidationObject","severity","state","isBlockingNavigation","objectToBatchSet","flattenedObj","flatten","batchTxn","BindingInstance","getParent","viewInfo","working","NodeType","Asset","View","__create","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","__commonJS","cb","mod","__require","exports","__export","target","enumerable","__copyProps","to","except","desc","__toESM","isNodeMode","__esModule","__toCommonJS","require_nested_error","toError","NestedError","_NestedError","innerErrors","thisErrorReport","getErrorReport","innerError","errReport","innerErrorReports","idx","rethrow","errs","require_timm","clone","addLast","addFirst","removeLast","removeFirst","insert","removeAt","replaceAt","getIn","setIn","update","updateIn","merge","mergeDeep","mergeIn","omit","addDefaults","default","INVALID_ARGS","IS_DEV","throwStr","msg","getKeysAndSymbols","getOwnPropertySymbols","concat","obj0","out","isObject","o","newItem","len","ptr","obj2","doSetIn","newValue","nestedObj","fnUpdate","prevVal","nextVal","c","d","f","rest","doMerge","attrs","omitList","fDoSomething","fAddDefaults","fDeep","first","fChanged","j","timm","_default","require_p_defer","module","pDefer","deferred","promise","reject","require_queue_microtask","queueMicrotask","bind","window","global","setTimeout","require_sorted_array","SortedArray","defclass","compare","compareDefault","element","high","low","pos","ordering","search","remove","splice","comparing","constructor","define","amd","src_exports","InterceptionManager","interceptions","interceptionKeySet","isUsed","intercept","int","s","add","_a","_b","loop","asError","r","done","Hook","taps","Symbol","before","insertionIndex","beforeSet","t","untap","SyncHook","SyncBailHook","tapIndex","rtn","SyncWaterfallHook","tapValue","import_ts_nested_error","import_timm","foo","bar","ctor","tmp","Date","getTime","RegExp","toString","ArrayBuffer","Uint8Array","DataView","byteLength","getInt8","isView","import_p_defer","import_queue_microtask","import_sorted_array","createSortedArray","Registry","initialSet","store","query","callbackfn","clear","isRegistryEmpty","__defProp2","__export2","toValue","toExpression","toPath","toQuery","toConcatenatedNode","SEGMENT_SEPARATOR","OPEN_CURL","CLOSE_CURL","OPEN_BRACKET","CLOSE_BRACKET","EQUALS","SINGLE_QUOTE","DOUBLE_QUOTE","BACK_TICK","isIdentifierChar","char","charCode","matches","expected","whitespace","allowBoolValue","maybeNumber","Number","expression","regex","modelRef","parsePath","simpleSegment","segment","segments","nextSegment","optionallyQuotedSegment","singleQuote","equals","parseBracket","second","parseSegmentAndBrackets","firstSegment","bracketSegment","parts","status","_BindingInstance","factory","rawBinding","tryNum","freeze","joined","asString","bindingAsArray","descendentSegments","resolveBindingAST","bindingPathNode","hooks","updates","getValueForNode","nestedResolvedValue","convertToPath","getValue","import_ts_nested_error2","actualValue","appendPathSegments","_node","resolvedNode","beforeResolveNode","objToQuery","resolvedKey","resolvedValue","BINDING_BRACKETS_REGEX","LAZY_BINDING_REGEX","DEFAULT_OPTIONS","BindingParser","skipOptimization","parserOptions","cache","parseCache","normalizePath","ast","TypeError","getBindingForNormalizedResult","normalized","normalizedStr","created","overrides","normalizeConfig","joinedNormalizedPath","updateKeys","updateTransaction","updatedBinding","DependencyTracker","readDeps","writeDeps","namedDependencySets","namedSet","createSubset","force","getDependencies","trackSubset","trackDefault","getModified","readsBinding","writesBinding","reset","addReadDep","addWriteDep","addChildReadDep","DependencyModel","rootModel","NOOPDataModel","ROOT_BINDING","PipelinedDataModel","onSet","effectiveDataModel","setMiddleware","handlers","addMiddleware","handler","appliedTransaction","LocalModel","effectiveOperations","oldValue","parentValue","true","false","null","undefined","evaluator_functions_exports","conditional","deleteDataVal","getDataVal","setDataVal","waitFor","arg","_context","condition","ifTrue","ifFalse","testResult","resolvedTest","resolveParams","andandOperator","LogicalOperators","and","ororOperator","or","DEFAULT_BINARY_OPERATORS","DEFAULT_UNARY_OPERATORS","PromiseCollectionHandler","handleArray","items","hasPromises","some","item","handleObject","resolvedAttributes","attr","keyPromise","valuePromise","leftNode","rightNode","leftResult","awaitedLeft","rightResult","ExpressionEvaluator","vars","beforeEvaluate","onError","expressionsCache","operators","binary","unary","expressions","defaultHookOptions","_execAST","_resolveNode","resolvedOpts","_nothing","_execString","evaluateAsync","addExpressionFunction","addBinaryOperator","addUnaryOperator","setExpressionVariable","getExpressionVariable","matchedExp","matched","storedAST","throwErrors","_currentValue","isAsync","expressionContext","leftVal","rightVal","argVal","expressionName","n","resolvedArgs","objVal","propVal","logger","warn","results","ele","TapableLogger","trace","debug","info","log","logHandlers","createHandler","addHandler","logHandler","removeHandler","ProxyLogger","loggerProvider","proxiedLoggerProvider","identify","SchemaController","formatters","types","bindingSchemaNormalizedCache","resolveTypeForBinding","addFormatters","fns","addDataTypes","getValidationsForBinding","typeDef","getApparentType","validation","vRef","trigger","normalizeBinding","cached","bindingArray","recordBinding","getType","schemaType","baseType","getTypeDefinition","dataType","getFormatterForType","formatReference","formatType","formatter","deformat","getFormatter","ValidationMiddleware","validator","shadowModelPaths","shouldIncludeInvalid","asModel","includeInvalid","nextTransaction","includedBindings","invalidBindings","validations","isStrong","validResults","invalidResults","shadowValue","shadowBinding","ValidatorRegistry","registry","register","EMPTY_NODE","Parser","onParseObject","onCreateASTNode","parseNode","parseView","viewNode","parseObject","createASTNode","tapped","templateDepth","parsedNode","parseLocalObject","currentValue","objToParse","children","localObj","objEntries","v","defaultValue","accumulation","current","localValue","newChildren","parentObj","baseAst","child","withContext","Resolver","root","skipResolve","beforeUpdate","afterUpdate","beforeResolve","afterResolve","afterNodeUpdate","resolveCache","ASTMap","idCache","AsyncIdMap","getSourceNode","convertedAST","changes","asyncChanges","prevASTMap","prevAsyncIdMap","nextAsyncIdMap","updated","computeTree","getResolveCache","getPreviousResult","isFirstUpdate","cloneNode","clonedNode","import_timm4","rawParent","cacheUpdate","partiallyResolvedParent","dependencyModel","depModelWithParser","previousResult","previousDeps","dataChanged","shouldUseLastValue","repopulateASTMapFromCache","AST","ASTParent","resolvedASTLocal","resolvedUpdate","asyncNodesResolved","handleChildNode","childNode","originalChildNode","previousChildResult","childAST","resolvedAST","childDependencies","computedChildTree","childTreeDeps","childUpdated","childValue","override","arr","rawParentToPassIn","mValue","mTree","bindingDep","scope","CrossfieldProvider","initialView","parser","allValidations","byBinding","contentView","xfieldRefs","withDefaults","ViewInstance","onUpdate","resolver","templatePlugin","updateAsync","asyncNode","lastUpdate","rootNode","validationProvider","setTemplatePlugin","plugin","templateSymbol","TemplatePlugin","resolveTemplateSubstitutions","parseTemplate","depth","dataItem","templateSubstitutions","templateStr","JSON","stringify","flags","placement","applyParser","dynamic","getTemplateSymbolValue","aPath","bPath","pathsEqual","aPlacement","bPlacement","_nodeType","childOptions","templateAST","Boolean","applyResolverHooks","apply","view","createPatternMatcher","testStr","startLocation","endLocation","resolveAllRefs","propertiesToSkip","newNode","import_timm6","findBasePath","parentNode","original","StringResolverPlugin","propertiesToSkipCache","applyResolver","propsToSkip","plugins","stringResolver","nodePath","ApplicabilityPlugin","isApplicability","isApplicable","nodeType","parsedApplicability","applicabilityNode","applicability","SwitchPlugin","resolveSwitch","cases","switchCase","case","isSwitch","switchContent","dynamicSwitch","staticSwitch","switchCaseExpr","switchBody","switchAST","sCase","firstChild","MultiNodePlugin","childVal","multiNode","AssetPlugin","assetAST","LocalStateStore","updateCallback","removeKey","useSharedState","initialState","newState","getLocalStateFunction","countKey","localState","oldCount","findUp","AssetTransformCorePlugin","stateStore","beforeResolveSymbol","resolveSymbol","beforeResolveCountSymbol","resolveCountSymbol","lastUpdatedNode","updateState","getStore","stepKey","storedState","useLocalState","transform","skip","isParentOfUpdated","isChildOfUpdated","originalNode","FlowInstance","flow","isTransitioning","beforeStart","onStart","onEnd","skipTransition","beforeTransition","resolveTransitionNode","transition","afterTransition","history","_oldState","nextState","flowPromise","state_type","startState","import_p_defer2","defer","pushHistory","transitionValue","currentState","transitions","stateName","prevState","newCurrentState","FlowController","navigation","navStack","run","addNewFlow","stateTransition","startFlow","firstItem","flowInstance","subflowId","subFlowEndState","outcome","BEGIN","CONTEXT","ValidationBindingTrackerViewPlugin","trackedBindings","getBindings","trackBinding","callbacks","onAdd","tracked","sections","lastViewUpdateChangeSet","lastComputedBindingTree","currentBindingTree","lastSectionBindingTree","resolvedNodeMap","shouldSkip","trackedBindingsForNode","intersection","track","getOptions","eows","_getValidationForBinding","getAll","firstFieldEOW","eow","displayTarget","getChildren","getValidationsForSection","registerOptions","newlyComputed","nodeSet","sectionNode","temp","SCHEMA_VALIDATION_PROVIDER_NAME","VIEW_VALIDATION_PROVIDER_NAME","VALIDATION_PROVIDER_NAME_SYMBOL","for","ValidatedBinding","possibleValidations","onDismiss","weakBindings","applicableValidations","validationsByState","load","vObj","statefulValidationObject","flat","checkIfBlocking","statefulObj","response","blocking","firstInvalid","runApplicableValidations","runner","canDismiss","phase","originalValue","dismissable","dismiss","newApplicableValidations","currentPhase","ValidationController","createValidatorRegistry","onAddValidation","onRemoveValidation","resolveValidationProviders","onTrackBinding","weakBindingTracker","setOptions","getDataMiddleware","strongValidation","updateValidationsForBinding","getValidationForBinding","newInvalidBindings","weakValidation","strongBinding","weakBinding","getValidationProviders","providers","source","provider","viewValidationProvider","getValidationsForView","tracker","onView","bindingTrackerPlugin","withoutDefault","ignoreDefaultValue","silent","validationContext","vals","valObj","trackedValidations","validationObj","validationRunner","vBinding","getValidator","dataTarget","parameters","updateValidationsForView","isNavigationTrigger","lastActiveBindings","activeBindings","updateValidations","dismissValidations","validatorRegistry","validateView","canTransition","forView","bindings","validationMapping","ViewController","initialViews","resolveView","transformRegistry","optimizeUpdates","viewOptions","viewMap","flowController","currentView","queueUpdate","updateOptions","onDelete","viewPlugins","createViewPlugins","pendingUpdate","changedBindings","scheduled","import_queue_microtask2","getViewForRef","viewRef","matchingViewId","possibleViewIdMatch","viewId","applyViewPlugins","pluginOptions","ReadOnlyDataController","controller","DataController","resolveDataStages","resolveDefaultValue","onGet","serialize","baseMiddleware","trash","pathResolver","getModel","stages","resolveDataValue","normalizedTransaction","setUpdates","oldVal","setUpdateBindings","su","tr","defaultVal","existedBeforeDelete","makeReadOnly","roots","sep","memo","ConstantsController","tempStore","addConstants","namespace","getConstants","fallback","setTemporaryValues","clearTemporaryValues","FlowExpPlugin","player","expressionEvaluator","handleEval","fc","createFormatFunction","formatName","DefaultExpPlugin","formatFunction","schemaController","expEvaluator","NOT_STARTED_STATE","PLAYER_VERSION","COMMIT","_Player","config","constantsController","viewController","dataController","validationController","bindingParser","resolveFlowContent","getPlugins","findPlugin","symbol","el","applyTo","registerPlugin","getVersion","version","getCommit","commit","getState","setState","setupFlow","userContent","userFlow","flowResultDeferred","resolveStrings","transitionVal","computedTransitionVal","param","await","constants","views","utils","pluginSymbol","endState","flowResult","controllers","fail","payload","maybeUpdateState","endProps","errorState","CheckPathPluginSymbol","resolvedMap","assetIdMap","sourceNode","getSourceAssetNode","assetNode","potentialMatch","getAssetFromAssetNode","queryArray","parentQuery","getParentProp","childProp","hasParentContext","findChildPath","includeSelfMatch","Applicability","getResolvedValue","includesSelf","childQuery","MultiNode","hasChildContext","getAsset","getPath","findWorkingChild","actualIndex","undefCount"],"mappings":"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","sourcesContent":["\"use strict\";\nvar CheckPathPlugin = (() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __export = (target, all) => {\n    for (var name in all)\n      __defProp(target, name, { get: all[name], enumerable: true });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n  var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/ts-nested-error@1.2.1/node_modules/ts-nested-error/build/nested-error.js\n  var require_nested_error = __commonJS({\n    \"../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/ts-nested-error@1.2.1/node_modules/ts-nested-error/build/nested-error.js\"(exports) {\n      \"use strict\";\n      Object.defineProperty(exports, \"__esModule\", { value: true });\n      exports.toError = exports.NestedError = void 0;\n      var NestedError4 = class _NestedError extends Error {\n        /**\n         * Allocates an instance of `NestedError` with the given error `message` and\n         * optional `innerError` (which will be automatically coerced using `toError()`).\n         *\n         * @param message     Laconic error message to attach to the created `NestedError`.\n         * @param innerErrors Optional errors that will be wrapped by this higher level\n         *                    error. This value will be automatically coerced using `toError()`.\n         */\n        constructor(message, ...innerErrors) {\n          super(message);\n          const thisErrorReport = _NestedError.getErrorReport(this);\n          if (innerErrors.length === 1) {\n            const innerError = toError(innerErrors[0]);\n            this.innerErrors = [innerError];\n            const errReport = _NestedError.getErrorReport(innerError);\n            this.stack = `${thisErrorReport}\n\n======= INNER ERROR =======\n\n${errReport}`;\n            return;\n          }\n          this.innerErrors = innerErrors.map((err) => toError(err));\n          const innerErrorReports = this.innerErrors.map((error, idx) => {\n            const errReport = _NestedError.getErrorReport(error);\n            return `======= INNER ERROR (${idx + 1} of ${innerErrors.length}) =======\n\n${errReport}`;\n          }).join(\"\\n\\n\");\n          this.stack = `${thisErrorReport}\n\n${innerErrorReports}`;\n        }\n        /**\n         * Provides the first `Error` of the `innerErrors` (if it exists);\n         * otherwise, `null`.\n         *\n         * @deprecated Please shift to using the `innerErrors` (with an 's') property.\n         */\n        get innerError() {\n          return this.innerErrors.length === 0 ? null : this.innerErrors[0];\n        }\n        /**\n         * Returns the function that accepts any value that was thrown as the first argument and\n         * throws it wrapped into `NestedError` or class derived from `NestedError` (provided\n         * this method was called directly in the context of that dervied class constructor)\n         * with the given `message`.\n         * Returned function will pass accepted `Error` object directly to `NestedError`\n         * as `innerErrors` by invoking `toError(err)` on it.\n         *\n         * You'll most likely want to use this method with promises:\n         *\n         * ```ts\n         * userService.getPage().then(\n         *     data => console.log(`Hooray! data: ${data}`),\n         *     NestedError.rethrow('failed to fetch users page')\n         * );\n         * ```\n         *\n         * @param message Message to attach `NestedError` created by the returned function.\n         */\n        static rethrow(message) {\n          return (...errs) => {\n            throw new this(message, ...errs);\n          };\n        }\n      };\n      exports.NestedError = NestedError4;\n      NestedError4.getErrorReport = typeof new Error().stack === \"string\" ? (err) => err.stack : (err) => `${err.name}: ${err.message}`;\n      NestedError4.prototype.name = \"NestedError\";\n      function toError(err) {\n        try {\n          return err instanceof Error ? err : new Error(`Value that is not an instance of Error was thrown: ${err}`);\n        } catch {\n          return new Error(\"Failed to stringify non-instance of Error that was thrown.This is possibly due to the fact that toString() method of the valuedoesn't return a primitive value.\");\n        }\n      }\n      exports.toError = toError;\n    }\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/timm@1.7.1/node_modules/timm/lib/timm.js\n  var require_timm = __commonJS({\n    \"../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/timm@1.7.1/node_modules/timm/lib/timm.js\"(exports) {\n      \"use strict\";\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.clone = clone2;\n      exports.addLast = addLast2;\n      exports.addFirst = addFirst;\n      exports.removeLast = removeLast;\n      exports.removeFirst = removeFirst;\n      exports.insert = insert;\n      exports.removeAt = removeAt2;\n      exports.replaceAt = replaceAt;\n      exports.getIn = getIn;\n      exports.set = set2;\n      exports.setIn = setIn8;\n      exports.update = update;\n      exports.updateIn = updateIn;\n      exports.merge = merge;\n      exports.mergeDeep = mergeDeep;\n      exports.mergeIn = mergeIn;\n      exports.omit = omit3;\n      exports.addDefaults = addDefaults;\n      exports.default = void 0;\n      var INVALID_ARGS = \"INVALID_ARGS\";\n      var IS_DEV = false;\n      function throwStr(msg) {\n        throw new Error(msg);\n      }\n      function getKeysAndSymbols(obj) {\n        const keys = Object.keys(obj);\n        if (Object.getOwnPropertySymbols) {\n          return keys.concat(Object.getOwnPropertySymbols(obj));\n        }\n        return keys;\n      }\n      var hasOwnProperty = {}.hasOwnProperty;\n      function clone2(obj0) {\n        if (Array.isArray(obj0))\n          return obj0.slice();\n        const obj = obj0;\n        const keys = getKeysAndSymbols(obj);\n        const out = {};\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          out[key] = obj[key];\n        }\n        return out;\n      }\n      function isObject(o) {\n        return o != null && typeof o === \"object\";\n      }\n      function addLast2(array, val) {\n        if (Array.isArray(val))\n          return array.concat(val);\n        return array.concat([val]);\n      }\n      function addFirst(array, val) {\n        if (Array.isArray(val))\n          return val.concat(array);\n        return [val].concat(array);\n      }\n      function removeLast(array) {\n        if (!array.length)\n          return array;\n        return array.slice(0, array.length - 1);\n      }\n      function removeFirst(array) {\n        if (!array.length)\n          return array;\n        return array.slice(1);\n      }\n      function insert(array, idx, val) {\n        return array.slice(0, idx).concat(Array.isArray(val) ? val : [val]).concat(array.slice(idx));\n      }\n      function removeAt2(array, idx) {\n        if (idx >= array.length || idx < 0)\n          return array;\n        return array.slice(0, idx).concat(array.slice(idx + 1));\n      }\n      function replaceAt(array, idx, newItem) {\n        if (array[idx] === newItem)\n          return array;\n        const len = array.length;\n        const result = Array(len);\n        for (let i = 0; i < len; i++) {\n          result[i] = array[i];\n        }\n        result[idx] = newItem;\n        return result;\n      }\n      function getIn(obj, path) {\n        if (!Array.isArray(path)) {\n          throwStr(IS_DEV ? \"A path array should be provided when calling getIn()\" : INVALID_ARGS);\n        }\n        if (obj == null)\n          return void 0;\n        let ptr = obj;\n        for (let i = 0; i < path.length; i++) {\n          const key = path[i];\n          ptr = ptr != null ? ptr[key] : void 0;\n          if (ptr === void 0)\n            return ptr;\n        }\n        return ptr;\n      }\n      function set2(obj0, key, val) {\n        let obj = obj0;\n        if (obj == null)\n          obj = typeof key === \"number\" ? [] : {};\n        if (obj[key] === val)\n          return obj;\n        const obj2 = clone2(obj);\n        obj2[key] = val;\n        return obj2;\n      }\n      function setIn8(obj, path, val) {\n        if (!path.length)\n          return val;\n        return doSetIn(obj, path, val, 0);\n      }\n      function doSetIn(obj, path, val, idx) {\n        let newValue;\n        const key = path[idx];\n        if (idx === path.length - 1) {\n          newValue = val;\n        } else {\n          const nestedObj = isObject(obj) && isObject(obj[key]) ? obj[key] : typeof path[idx + 1] === \"number\" ? [] : {};\n          newValue = doSetIn(nestedObj, path, val, idx + 1);\n        }\n        return set2(obj, key, newValue);\n      }\n      function update(obj, key, fnUpdate) {\n        const prevVal = obj == null ? void 0 : obj[key];\n        const nextVal = fnUpdate(prevVal);\n        return set2(obj, key, nextVal);\n      }\n      function updateIn(obj, path, fnUpdate) {\n        const prevVal = getIn(obj, path);\n        const nextVal = fnUpdate(prevVal);\n        return setIn8(obj, path, nextVal);\n      }\n      function merge(a, b, c, d, e, f, ...rest) {\n        return rest.length ? doMerge.call(null, false, false, a, b, c, d, e, f, ...rest) : doMerge(false, false, a, b, c, d, e, f);\n      }\n      function mergeDeep(a, b, c, d, e, f, ...rest) {\n        return rest.length ? doMerge.call(null, false, true, a, b, c, d, e, f, ...rest) : doMerge(false, true, a, b, c, d, e, f);\n      }\n      function mergeIn(a, path, b, c, d, e, f, ...rest) {\n        let prevVal = getIn(a, path);\n        if (prevVal == null)\n          prevVal = {};\n        let nextVal;\n        if (rest.length) {\n          nextVal = doMerge.call(null, false, false, prevVal, b, c, d, e, f, ...rest);\n        } else {\n          nextVal = doMerge(false, false, prevVal, b, c, d, e, f);\n        }\n        return setIn8(a, path, nextVal);\n      }\n      function omit3(obj, attrs) {\n        const omitList = Array.isArray(attrs) ? attrs : [attrs];\n        let fDoSomething = false;\n        for (let i = 0; i < omitList.length; i++) {\n          if (hasOwnProperty.call(obj, omitList[i])) {\n            fDoSomething = true;\n            break;\n          }\n        }\n        if (!fDoSomething)\n          return obj;\n        const out = {};\n        const keys = getKeysAndSymbols(obj);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          if (omitList.indexOf(key) >= 0)\n            continue;\n          out[key] = obj[key];\n        }\n        return out;\n      }\n      function addDefaults(a, b, c, d, e, f, ...rest) {\n        return rest.length ? doMerge.call(null, true, false, a, b, c, d, e, f, ...rest) : doMerge(true, false, a, b, c, d, e, f);\n      }\n      function doMerge(fAddDefaults, fDeep, first, ...rest) {\n        let out = first;\n        if (!(out != null)) {\n          throwStr(IS_DEV ? \"At least one object should be provided to merge()\" : INVALID_ARGS);\n        }\n        let fChanged = false;\n        for (let idx = 0; idx < rest.length; idx++) {\n          const obj = rest[idx];\n          if (obj == null)\n            continue;\n          const keys = getKeysAndSymbols(obj);\n          if (!keys.length)\n            continue;\n          for (let j = 0; j <= keys.length; j++) {\n            const key = keys[j];\n            if (fAddDefaults && out[key] !== void 0)\n              continue;\n            let nextVal = obj[key];\n            if (fDeep && isObject(out[key]) && isObject(nextVal)) {\n              nextVal = doMerge(fAddDefaults, fDeep, out[key], nextVal);\n            }\n            if (nextVal === void 0 || nextVal === out[key])\n              continue;\n            if (!fChanged) {\n              fChanged = true;\n              out = clone2(out);\n            }\n            out[key] = nextVal;\n          }\n        }\n        return out;\n      }\n      var timm = {\n        clone: clone2,\n        addLast: addLast2,\n        addFirst,\n        removeLast,\n        removeFirst,\n        insert,\n        removeAt: removeAt2,\n        replaceAt,\n        getIn,\n        set: set2,\n        setIn: setIn8,\n        update,\n        updateIn,\n        merge,\n        mergeDeep,\n        mergeIn,\n        omit: omit3,\n        addDefaults\n      };\n      var _default = timm;\n      exports.default = _default;\n    }\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/p-defer@3.0.0/node_modules/p-defer/index.js\n  var require_p_defer = __commonJS({\n    \"../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/p-defer@3.0.0/node_modules/p-defer/index.js\"(exports, module) {\n      \"use strict\";\n      var pDefer = () => {\n        const deferred2 = {};\n        deferred2.promise = new Promise((resolve, reject) => {\n          deferred2.resolve = resolve;\n          deferred2.reject = reject;\n        });\n        return deferred2;\n      };\n      module.exports = pDefer;\n    }\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/queue-microtask@1.2.3/node_modules/queue-microtask/index.js\n  var require_queue_microtask = __commonJS({\n    \"../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/queue-microtask@1.2.3/node_modules/queue-microtask/index.js\"(exports, module) {\n      \"use strict\";\n      var promise;\n      module.exports = typeof queueMicrotask === \"function\" ? queueMicrotask.bind(typeof window !== \"undefined\" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {\n        throw err;\n      }, 0));\n    }\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/sorted-array@2.0.4/node_modules/sorted-array/sorted-array.js\n  var require_sorted_array = __commonJS({\n    \"../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/sorted-array@2.0.4/node_modules/sorted-array/sorted-array.js\"(exports, module) {\n      \"use strict\";\n      var SortedArray2 = function() {\n        var SortedArray3 = defclass({\n          constructor: function(array, compare) {\n            this.array = [];\n            this.compare = compare || compareDefault;\n            var length = array.length, index = 0;\n            while (index < length)\n              this.insert(array[index++]);\n          },\n          insert: function(element) {\n            var array = this.array, compare = this.compare, high = array.length - 1, low = 0, pos = -1, index, ordering;\n            while (high >= low) {\n              index = (high + low) / 2 >>> 0;\n              ordering = compare(array[index], element);\n              if (ordering < 0)\n                low = index + 1;\n              else if (ordering > 0)\n                high = index - 1;\n              else {\n                pos = index;\n                break;\n              }\n              ;\n            }\n            if (pos === -1) {\n              pos = high;\n            }\n            pos++;\n            high = array.length - 1;\n            while (pos < high && compare(element, array[pos]) === 0) {\n              pos++;\n            }\n            index = array.length;\n            array.push(element);\n            while (index > pos) {\n              array[index] = array[--index];\n            }\n            array[pos] = element;\n            return this;\n          },\n          search: function(element) {\n            var array = this.array, compare = this.compare, high = array.length - 1, low = 0, index, ordering;\n            while (high >= low) {\n              index = (high + low) / 2 >>> 0;\n              ordering = compare(array[index], element);\n              if (ordering < 0)\n                low = index + 1;\n              else if (ordering > 0)\n                high = index - 1;\n              else\n                return index;\n            }\n            return -1;\n          },\n          remove: function(element) {\n            var index = this.search(element);\n            if (index >= 0)\n              this.array.splice(index, 1);\n            return this;\n          }\n        });\n        SortedArray3.comparing = function(property, array) {\n          return new SortedArray3(array, function(a, b) {\n            return compareDefault(a[property], b[property]);\n          });\n        };\n        return SortedArray3;\n        function defclass(prototype) {\n          var constructor = prototype.constructor;\n          constructor.prototype = prototype;\n          return constructor;\n        }\n        function compareDefault(a, b) {\n          if (a < b)\n            return -1;\n          else if (a > b)\n            return 1;\n          else\n            return 0;\n        }\n      }();\n      if (typeof module === \"object\")\n        module.exports = SortedArray2;\n      if (typeof define === \"function\" && define.amd)\n        define(function() {\n          return SortedArray2;\n        });\n    }\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/check-path/core/src/index.ts\n  var src_exports = {};\n  __export(src_exports, {\n    CheckPathPlugin: () => CheckPathPlugin\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/tapable-ts@0.2.4/node_modules/tapable-ts/dist/hooks.mjs\n  function equalToOrIn(value, check) {\n    if (Array.isArray(check)) {\n      return check.includes(value);\n    }\n    return check === value;\n  }\n  function callTap(tap, args, ctx) {\n    if (tap.context) {\n      return tap.callback(ctx, ...args);\n    }\n    return tap.callback(...args);\n  }\n  var InterceptionManager = class {\n    constructor() {\n      this.interceptions = [];\n      this.interceptionKeySet = /* @__PURE__ */ new Set();\n    }\n    isUsed() {\n      return this.interceptions.length > 0;\n    }\n    intercept(int) {\n      this.interceptions.push(int);\n      Object.keys(int).forEach((s) => {\n        this.interceptionKeySet.add(s);\n      });\n    }\n    tap(tap) {\n      if (this.interceptionKeySet.has(\"tap\")) {\n        this.interceptions.forEach((i) => {\n          var _a;\n          (_a = i.tap) == null ? void 0 : _a.call(i, tap);\n        });\n      }\n    }\n    call(ctx, ...args) {\n      if (this.interceptionKeySet.has(\"call\")) {\n        this.interceptions.forEach((i) => {\n          var _a, _b;\n          if (i.context) {\n            (_a = i.call) == null ? void 0 : _a.call(i, ctx, ...args);\n          } else {\n            (_b = i.call) == null ? void 0 : _b.call(i, ...args);\n          }\n        });\n      }\n    }\n    loop(...args) {\n      if (this.interceptionKeySet.has(\"loop\")) {\n        this.interceptions.forEach((i) => {\n          var _a;\n          (_a = i.loop) == null ? void 0 : _a.call(i, ...args);\n        });\n      }\n    }\n    error(err) {\n      if (this.interceptionKeySet.has(\"error\")) {\n        if (err instanceof Error) {\n          const asError = err;\n          this.interceptions.forEach((i) => {\n            var _a;\n            (_a = i.error) == null ? void 0 : _a.call(i, asError);\n          });\n        }\n      }\n    }\n    result(r) {\n      if (this.interceptionKeySet.has(\"result\")) {\n        this.interceptions.forEach((i) => {\n          var _a;\n          (_a = i.result) == null ? void 0 : _a.call(i, r);\n        });\n      }\n    }\n    done() {\n      if (this.interceptionKeySet.has(\"done\")) {\n        this.interceptions.forEach((i) => {\n          var _a;\n          (_a = i.done) == null ? void 0 : _a.call(i);\n        });\n      }\n    }\n  };\n  var Hook = class {\n    constructor() {\n      this.taps = [];\n      this.interceptions = new InterceptionManager();\n    }\n    tap(options, callback) {\n      const resolvedOptions = typeof options === \"string\" ? {\n        name: options,\n        context: false\n      } : {\n        context: false,\n        ...options\n      };\n      const key = Symbol(resolvedOptions.name);\n      const tap = {\n        key,\n        ...resolvedOptions,\n        callback\n      };\n      if (tap.before) {\n        let insertionIndex = this.taps.length;\n        const beforeSet = new Set(Array.isArray(tap.before) ? tap.before : [tap.before]);\n        for (insertionIndex; insertionIndex > 0 && beforeSet.size > 0; insertionIndex--) {\n          const t2 = this.taps[insertionIndex - 1];\n          if (beforeSet.has(t2.name)) {\n            beforeSet.delete(t2.name);\n          }\n          if (t2.before && equalToOrIn(tap.name, t2.before)) {\n            break;\n          }\n        }\n        this.taps.splice(insertionIndex, 0, tap);\n      } else {\n        this.taps.push(tap);\n      }\n      this.interceptions.tap(tap);\n      return tap;\n    }\n    untap(tap) {\n      this.taps = this.taps.filter((t2) => t2.key !== tap.key);\n    }\n    isUsed() {\n      return this.taps.length > 0 || this.interceptions.isUsed();\n    }\n    intercept(int) {\n      this.interceptions.intercept(int);\n    }\n  };\n  var SyncHook = class extends Hook {\n    call(...args) {\n      if (!this.isUsed()) {\n        return;\n      }\n      const ctx = {};\n      this.interceptions.call(ctx, ...args);\n      try {\n        this.taps.forEach((t2) => {\n          callTap(t2, args, ctx);\n        });\n      } catch (err) {\n        this.interceptions.error(err);\n        throw err;\n      }\n      this.interceptions.done();\n    }\n  };\n  var SyncBailHook = class extends Hook {\n    call(...args) {\n      if (!this.isUsed()) {\n        return;\n      }\n      const ctx = {};\n      this.interceptions.call(ctx, ...args);\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        const rtn = callTap(this.taps[tapIndex], args, ctx);\n        if (rtn !== void 0) {\n          this.interceptions.result(rtn);\n          return rtn;\n        }\n      }\n      this.interceptions.done();\n    }\n  };\n  var SyncWaterfallHook = class extends Hook {\n    call(...args) {\n      const ctx = {};\n      this.interceptions.call(ctx, ...args);\n      let [rtn, ...rest] = args;\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        const tapValue = callTap(this.taps[tapIndex], [rtn, ...rest], ctx);\n        if (tapValue !== void 0) {\n          rtn = tapValue;\n        }\n      }\n      this.interceptions.result(rtn);\n      return rtn;\n    }\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+player@0.0.0/node_modules/@player-ui/player/dist/index.mjs\n  var import_ts_nested_error = __toESM(require_nested_error(), 1);\n  var import_ts_nested_error2 = __toESM(require_nested_error(), 1);\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dlv@1.1.3/node_modules/dlv/dist/dlv.es.js\n  function dlv_es_default(t2, e, l, n, r) {\n    for (e = e.split ? e.split(\".\") : e, n = 0; n < e.length; n++)\n      t2 = t2 ? t2[e[n]] : r;\n    return t2 === r ? l : t2;\n  }\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+player@0.0.0/node_modules/@player-ui/player/dist/index.mjs\n  var import_timm = __toESM(require_timm(), 1);\n  var import_ts_nested_error3 = __toESM(require_nested_error(), 1);\n  var import_timm2 = __toESM(require_timm(), 1);\n  var import_timm3 = __toESM(require_timm(), 1);\n  var import_timm4 = __toESM(require_timm(), 1);\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dequal@2.0.3/node_modules/dequal/dist/index.mjs\n  var has = Object.prototype.hasOwnProperty;\n  function find(iter, tar, key) {\n    for (key of iter.keys()) {\n      if (dequal(key, tar))\n        return key;\n    }\n  }\n  function dequal(foo, bar) {\n    var ctor, len, tmp;\n    if (foo === bar)\n      return true;\n    if (foo && bar && (ctor = foo.constructor) === bar.constructor) {\n      if (ctor === Date)\n        return foo.getTime() === bar.getTime();\n      if (ctor === RegExp)\n        return foo.toString() === bar.toString();\n      if (ctor === Array) {\n        if ((len = foo.length) === bar.length) {\n          while (len-- && dequal(foo[len], bar[len]))\n            ;\n        }\n        return len === -1;\n      }\n      if (ctor === Set) {\n        if (foo.size !== bar.size) {\n          return false;\n        }\n        for (len of foo) {\n          tmp = len;\n          if (tmp && typeof tmp === \"object\") {\n            tmp = find(bar, tmp);\n            if (!tmp)\n              return false;\n          }\n          if (!bar.has(tmp))\n            return false;\n        }\n        return true;\n      }\n      if (ctor === Map) {\n        if (foo.size !== bar.size) {\n          return false;\n        }\n        for (len of foo) {\n          tmp = len[0];\n          if (tmp && typeof tmp === \"object\") {\n            tmp = find(bar, tmp);\n            if (!tmp)\n              return false;\n          }\n          if (!dequal(len[1], bar.get(tmp))) {\n            return false;\n          }\n        }\n        return true;\n      }\n      if (ctor === ArrayBuffer) {\n        foo = new Uint8Array(foo);\n        bar = new Uint8Array(bar);\n      } else if (ctor === DataView) {\n        if ((len = foo.byteLength) === bar.byteLength) {\n          while (len-- && foo.getInt8(len) === bar.getInt8(len))\n            ;\n        }\n        return len === -1;\n      }\n      if (ArrayBuffer.isView(foo)) {\n        if ((len = foo.byteLength) === bar.byteLength) {\n          while (len-- && foo[len] === bar[len])\n            ;\n        }\n        return len === -1;\n      }\n      if (!ctor || typeof foo === \"object\") {\n        len = 0;\n        for (ctor in foo) {\n          if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))\n            return false;\n          if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))\n            return false;\n        }\n        return Object.keys(bar).length === len;\n      }\n    }\n    return foo !== foo && bar !== bar;\n  }\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+player@0.0.0/node_modules/@player-ui/player/dist/index.mjs\n  var import_timm5 = __toESM(require_timm(), 1);\n  var import_timm6 = __toESM(require_timm(), 1);\n  var import_timm7 = __toESM(require_timm(), 1);\n  var import_timm8 = __toESM(require_timm(), 1);\n  var import_p_defer = __toESM(require_p_defer(), 1);\n  var import_queue_microtask = __toESM(require_queue_microtask(), 1);\n  var import_p_defer2 = __toESM(require_p_defer(), 1);\n  var import_timm9 = __toESM(require_timm(), 1);\n  var import_queue_microtask2 = __toESM(require_queue_microtask(), 1);\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+partial-match-registry@0.0.0/node_modules/@player-ui/partial-match-registry/dist/index.mjs\n  var import_sorted_array = __toESM(require_sorted_array(), 1);\n  function traverseObj(object, path = [], pairs = /* @__PURE__ */ new Map()) {\n    for (const key of Object.keys(object)) {\n      const val = object[key];\n      const nestedPath = [...path, key];\n      if (typeof val === \"object\") {\n        traverseObj(val, nestedPath, pairs);\n      } else {\n        pairs.set(nestedPath, val);\n      }\n    }\n    return pairs;\n  }\n  function createMatcher(partialObj) {\n    const pairs = traverseObj(partialObj);\n    const matchFunction = (searchObj) => {\n      for (const entry of Array.from(pairs)) {\n        const [path, value] = entry;\n        if (dlv_es_default(searchObj, path) !== value) {\n          return false;\n        }\n      }\n      return true;\n    };\n    matchFunction.count = pairs.size;\n    return matchFunction;\n  }\n  function createBasicMatcher(seed) {\n    const matcher = (match) => seed === match;\n    matcher.count = 1;\n    return matcher;\n  }\n  var createSortedArray = () => new import_sorted_array.default([], (c) => c.matcher.count);\n  var Registry = class {\n    constructor(initialSet) {\n      this.store = createSortedArray();\n      initialSet?.forEach(([match, value]) => {\n        this.set(match, value);\n      });\n    }\n    /** Add match -> value mapping to the registry */\n    set(match, value) {\n      const matcher = typeof match === \"object\" ? createMatcher(match) : createBasicMatcher(match);\n      this.store.insert({\n        key: match,\n        value,\n        matcher\n      });\n    }\n    /** Fetch the best match in the registry */\n    get(query) {\n      for (const entry of this.store.array) {\n        if (entry.matcher(query)) {\n          return entry.value;\n        }\n      }\n    }\n    /** Loop over all entries and run callback */\n    forEach(callbackfn) {\n      for (const entry of this.store.array) {\n        callbackfn(entry);\n      }\n    }\n    /** Reset the items in the registry */\n    clear() {\n      this.store = createSortedArray();\n    }\n    /** Check if the registry is empty*/\n    isRegistryEmpty() {\n      return this.store.array.length === 0;\n    }\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+player@0.0.0/node_modules/@player-ui/player/dist/index.mjs\n  var __defProp2 = Object.defineProperty;\n  var __export2 = (target, all) => {\n    for (var name in all)\n      __defProp2(target, name, { get: all[name], enumerable: true });\n  };\n  var toValue = (value) => ({\n    name: \"Value\",\n    value\n  });\n  var toExpression = (value) => ({\n    name: \"Expression\",\n    value\n  });\n  var toPath = (path) => ({\n    name: \"PathNode\",\n    path\n  });\n  var toQuery = (key, value) => ({\n    name: \"Query\",\n    key,\n    value\n  });\n  var toConcatenatedNode = (values) => {\n    if (values.length === 1) {\n      return values[0];\n    }\n    return {\n      name: \"Concatenated\",\n      value: values\n    };\n  };\n  var SEGMENT_SEPARATOR = \".\";\n  var OPEN_CURL = \"{\";\n  var CLOSE_CURL = \"}\";\n  var OPEN_BRACKET = \"[\";\n  var CLOSE_BRACKET = \"]\";\n  var EQUALS = \"=\";\n  var SINGLE_QUOTE = \"'\";\n  var DOUBLE_QUOTE = '\"';\n  var BACK_TICK = \"`\";\n  var isIdentifierChar = (char) => {\n    if (!char) {\n      return false;\n    }\n    const charCode = char.charCodeAt(0);\n    const matches = charCode === 32 || // ' '\n    charCode === 34 || // \"\n    charCode === 39 || // '\n    charCode === 40 || // (\n    charCode === 41 || // )\n    charCode === 42 || // *\n    charCode === 46 || // .\n    charCode === 61 || // =\n    charCode === 91 || // [\n    charCode === 93 || // ]\n    charCode === 96 || // `\n    charCode === 123 || // {\n    charCode === 125;\n    return !matches;\n  };\n  var parse = (path) => {\n    let index = 1;\n    let ch = path.charAt(0);\n    const next = (expected) => {\n      if (expected && ch !== expected) {\n        throw new Error(`Expected char: ${expected} but got: ${ch}`);\n      }\n      ch = path.charAt(index);\n      index += 1;\n      return ch;\n    };\n    const whitespace = () => {\n      while (ch === \" \") {\n        next();\n      }\n    };\n    const identifier = (allowBoolValue = false) => {\n      if (!isIdentifierChar(ch)) {\n        return;\n      }\n      let value = ch;\n      while (next()) {\n        if (!isIdentifierChar(ch)) {\n          break;\n        }\n        value += ch;\n      }\n      if (allowBoolValue) {\n        if (value === \"true\") {\n          return toValue(true);\n        }\n        if (value === \"false\") {\n          return toValue(false);\n        }\n      }\n      if (value) {\n        const maybeNumber = Number(value);\n        value = isNaN(maybeNumber) ? value : maybeNumber;\n        return toValue(value);\n      }\n    };\n    const expression = () => {\n      if (ch === BACK_TICK) {\n        next(BACK_TICK);\n        let exp = ch;\n        while (next()) {\n          if (ch === BACK_TICK) {\n            break;\n          }\n          exp += ch;\n        }\n        next(BACK_TICK);\n        if (exp) {\n          return toExpression(exp);\n        }\n      }\n    };\n    const regex = (match) => {\n      if (!ch?.match(match)) {\n        return;\n      }\n      let value = ch;\n      while (next()) {\n        if (!ch?.match(match)) {\n          break;\n        }\n        value += ch;\n      }\n      if (value) {\n        return toValue(value);\n      }\n    };\n    const nestedPath = () => {\n      if (ch === OPEN_CURL) {\n        next(OPEN_CURL);\n        next(OPEN_CURL);\n        const modelRef = parsePath();\n        next(CLOSE_CURL);\n        next(CLOSE_CURL);\n        return modelRef;\n      }\n    };\n    const simpleSegment = (allowBoolValue = false) => nestedPath() ?? expression() ?? identifier(allowBoolValue);\n    const segment = () => {\n      const segments = [];\n      let nextSegment = simpleSegment();\n      while (nextSegment !== void 0) {\n        segments.push(nextSegment);\n        nextSegment = simpleSegment();\n      }\n      if (segments.length === 0) {\n        return void 0;\n      }\n      return toConcatenatedNode(segments);\n    };\n    const optionallyQuotedSegment = (allowBoolValue = false) => {\n      whitespace();\n      if (ch === SINGLE_QUOTE || ch === DOUBLE_QUOTE) {\n        const singleQuote = ch === SINGLE_QUOTE;\n        next(singleQuote ? SINGLE_QUOTE : DOUBLE_QUOTE);\n        const id = regex(/[^'\"]+/);\n        next(singleQuote ? SINGLE_QUOTE : DOUBLE_QUOTE);\n        return id;\n      }\n      return simpleSegment(allowBoolValue);\n    };\n    const equals = () => {\n      if (ch !== EQUALS) {\n        return false;\n      }\n      while (ch === EQUALS) {\n        next();\n      }\n      return true;\n    };\n    const parseBracket = () => {\n      if (ch === OPEN_BRACKET) {\n        next(OPEN_BRACKET);\n        whitespace();\n        let value = optionallyQuotedSegment();\n        if (value) {\n          whitespace();\n          if (equals()) {\n            whitespace();\n            const second = optionallyQuotedSegment(true);\n            value = toQuery(value, second);\n            whitespace();\n          }\n        } else {\n          throw new Error(`Expected identifier`);\n        }\n        if (value) {\n          next(CLOSE_BRACKET);\n        }\n        return value;\n      }\n    };\n    const parseSegmentAndBrackets = () => {\n      const parsed = [];\n      const firstSegment = segment();\n      if (firstSegment) {\n        parsed.push(firstSegment);\n        let bracketSegment = parseBracket();\n        if (bracketSegment?.name === \"Value\") {\n          const maybeNumber = Number(bracketSegment.value);\n          bracketSegment.value = isNaN(maybeNumber) || String(maybeNumber) !== bracketSegment.value ? bracketSegment.value : maybeNumber;\n        }\n        while (bracketSegment !== void 0) {\n          parsed.push(bracketSegment);\n          bracketSegment = parseBracket();\n        }\n      }\n      return parsed;\n    };\n    const parsePath = () => {\n      const parts = [];\n      let nextSegment = parseSegmentAndBrackets();\n      while (nextSegment !== void 0) {\n        parts.push(...nextSegment);\n        if (!ch || ch === CLOSE_CURL) {\n          break;\n        }\n        if (nextSegment.length === 0 && ch) {\n          throw new Error(`Unexpected character: ${ch}`);\n        }\n        next(SEGMENT_SEPARATOR);\n        nextSegment = parseSegmentAndBrackets();\n      }\n      return toPath(parts);\n    };\n    try {\n      const result = parsePath();\n      return {\n        status: true,\n        path: result\n      };\n    } catch (e) {\n      return {\n        status: false,\n        error: e.message\n      };\n    }\n  };\n  function isBinding(binding) {\n    return !(typeof binding === \"string\" || Array.isArray(binding));\n  }\n  function maybeConvertToNum(i) {\n    const asInt = parseInt(i, 10);\n    if (isNaN(asInt)) {\n      return i;\n    }\n    return asInt;\n  }\n  function getBindingSegments(binding) {\n    if (Array.isArray(binding)) {\n      return binding;\n    }\n    if (typeof binding === \"string\") {\n      return binding.split(\".\");\n    }\n    return binding.asArray();\n  }\n  function findInArray(array, key, value) {\n    return array.findIndex((obj) => {\n      if (obj && typeof obj === \"object\") {\n        return obj[key] == value;\n      }\n      return false;\n    });\n  }\n  var BindingInstance = class _BindingInstance {\n    constructor(raw, factory = (rawBinding) => new _BindingInstance(rawBinding)) {\n      const split = Array.isArray(raw) ? raw : raw.split(\".\");\n      this.split = split.map((segment) => {\n        if (typeof segment === \"number\") {\n          return segment;\n        }\n        const tryNum = Number(segment);\n        return isNaN(tryNum) || String(tryNum) !== segment ? segment : tryNum;\n      });\n      Object.freeze(this.split);\n      this.joined = this.split.join(\".\");\n      this.factory = factory;\n    }\n    asArray() {\n      return this.split;\n    }\n    asString() {\n      return this.joined;\n    }\n    /**\n     * Check to see if the given binding is a sub-path of the current one\n     */\n    contains(binding) {\n      const bindingAsArray = binding.asArray();\n      if (bindingAsArray.length < this.split.length) {\n        return false;\n      }\n      for (let i = 0; i < this.split.length; i++) {\n        if (this.split[i] !== bindingAsArray[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    relative(binding) {\n      return this.asArray().slice(binding.asArray().length);\n    }\n    parent() {\n      return this.factory(this.split.slice(0, -1));\n    }\n    key() {\n      return this.split[this.split.length - 1];\n    }\n    /**\n     * This is a utility method to get a binding that is a descendent of this binding\n     *\n     * @param relative - The relative path to descend to\n     */\n    descendent(relative) {\n      const descendentSegments = getBindingSegments(relative);\n      return this.factory(this.split.concat(descendentSegments));\n    }\n  };\n  function resolveBindingAST(bindingPathNode, options, hooks) {\n    const context = {\n      updates: {},\n      path: []\n    };\n    function getValueForNode(node) {\n      if (node.name === \"Value\") {\n        return node.value;\n      }\n      if (node.name === \"PathNode\") {\n        const nestedResolvedValue = resolveBindingAST(node, options);\n        if (nestedResolvedValue.updates) {\n          context.updates = {\n            ...context.updates,\n            ...nestedResolvedValue.updates\n          };\n        }\n        try {\n          return options.convertToPath(\n            options.getValue(nestedResolvedValue.path)\n          );\n        } catch (e) {\n          throw new import_ts_nested_error2.NestedError(\n            `Unable to resolve path segment: ${nestedResolvedValue.path}`,\n            e\n          );\n        }\n      }\n      if (node.name === \"Expression\") {\n        try {\n          const actualValue = options.evaluate(node.value);\n          return options.convertToPath(actualValue);\n        } catch (e) {\n          throw new import_ts_nested_error2.NestedError(`Unable to resolve path: ${node.value}`, e);\n        }\n      }\n      throw new Error(`Unable to resolve value for node: ${node.name}`);\n    }\n    function appendPathSegments(segment) {\n      if (typeof segment === \"string\" && segment.indexOf(\".\") > -1) {\n        segment.split(\".\").forEach((i) => {\n          context.path.push(maybeConvertToNum(i));\n        });\n      } else {\n        context.path.push(segment);\n      }\n    }\n    function resolveNode(_node) {\n      const resolvedNode = hooks?.beforeResolveNode.call(_node, { ...context, ...options }) ?? _node;\n      switch (resolvedNode.name) {\n        case \"Expression\":\n        case \"PathNode\":\n          appendPathSegments(getValueForNode(resolvedNode));\n          break;\n        case \"Value\":\n          appendPathSegments(\n            typeof resolvedNode.value === \"boolean\" ? String(resolvedNode.value) : resolvedNode.value\n          );\n          break;\n        case \"Query\": {\n          const objToQuery = options.getValue(context.path) ?? [];\n          const { key, value } = resolvedNode;\n          const resolvedKey = getValueForNode(key);\n          const resolvedValue = value && getValueForNode(value);\n          const index = findInArray(objToQuery, resolvedKey, resolvedValue);\n          if (index === void 0 || index === -1) {\n            context.updates[[...context.path, objToQuery.length, resolvedKey].join(\".\")] = resolvedValue;\n            context.path.push(objToQuery.length);\n          } else {\n            context.path.push(index);\n          }\n          break;\n        }\n        case \"Concatenated\":\n          context.path.push(resolvedNode.value.map(getValueForNode).join(\"\"));\n          break;\n        default:\n          throw new Error(`Unsupported node type: ${resolvedNode.name}`);\n      }\n    }\n    bindingPathNode.path.forEach(resolveNode);\n    return {\n      path: context.path,\n      updates: Object.keys(context.updates ?? {}).length > 0 ? context.updates : void 0\n    };\n  }\n  var BINDING_BRACKETS_REGEX = /[\\s()*=`{}'\"[\\]]/;\n  var LAZY_BINDING_REGEX = /^[^.]+(\\..+)*$/;\n  var DEFAULT_OPTIONS = {\n    get: () => {\n      throw new Error(\"Not Implemented\");\n    },\n    set: () => {\n      throw new Error(\"Not Implemented\");\n    },\n    evaluate: () => {\n      throw new Error(\"Not Implemented\");\n    }\n  };\n  var BindingParser = class {\n    constructor(options) {\n      this.hooks = {\n        skipOptimization: new SyncBailHook(),\n        beforeResolveNode: new SyncWaterfallHook()\n      };\n      this.parserOptions = { ...DEFAULT_OPTIONS, ...options };\n      this.cache = {};\n      this.parseCache = {};\n      this.parse = this.parse.bind(this);\n    }\n    /**\n     * Takes a binding path, parses it, and returns an equivalent, normalized\n     * representation of that path.\n     */\n    normalizePath(path, resolveOptions) {\n      if (!BINDING_BRACKETS_REGEX.test(path) && LAZY_BINDING_REGEX.test(path) && this.hooks.skipOptimization.call(path) !== true) {\n        return { path: path.split(\".\"), updates: void 0 };\n      }\n      const ast = this.parseCache[path] ?? parse(path);\n      this.parseCache[path] = ast;\n      if (typeof ast !== \"object\" || !ast?.status) {\n        throw new TypeError(\n          `Cannot normalize path \"${path}\": ${ast?.error ?? \"Unknown Error.\"}`\n        );\n      }\n      try {\n        return resolveBindingAST(ast.path, resolveOptions, this.hooks);\n      } catch (e) {\n        throw new import_ts_nested_error.NestedError(`Cannot resolve binding: ${path}`, e);\n      }\n    }\n    getBindingForNormalizedResult(normalized) {\n      const normalizedStr = normalized.path.join(\".\");\n      if (this.cache[normalizedStr]) {\n        return this.cache[normalizedStr];\n      }\n      const created = new BindingInstance(\n        normalizedStr === \"\" ? [] : normalized.path,\n        this.parse\n      );\n      this.cache[normalizedStr] = created;\n      return created;\n    }\n    parse(rawBinding, overrides = {}) {\n      if (isBinding(rawBinding)) {\n        return rawBinding;\n      }\n      const options = {\n        ...this.parserOptions,\n        ...overrides\n      };\n      let updates = {};\n      const joined = Array.isArray(rawBinding) ? rawBinding.join(\".\") : String(rawBinding);\n      const normalizeConfig = {\n        getValue: (path) => {\n          const normalized2 = this.normalizePath(path.join(\".\"), normalizeConfig);\n          return options.get(this.getBindingForNormalizedResult(normalized2));\n        },\n        evaluate: (exp) => {\n          return options.evaluate(exp);\n        },\n        convertToPath: (path) => {\n          if (path === void 0) {\n            throw new Error(\n              \"Attempted to convert undefined value to binding path\"\n            );\n          }\n          if (typeof path !== \"string\" && typeof path !== \"number\" && typeof path !== \"boolean\") {\n            throw new Error(\n              `Attempting to convert ${typeof path} to a binding path.`\n            );\n          }\n          const normalized2 = this.normalizePath(String(path), normalizeConfig);\n          if (normalized2.updates) {\n            updates = {\n              ...updates,\n              ...normalized2.updates\n            };\n          }\n          const joinedNormalizedPath = normalized2.path.join(\".\");\n          if (joinedNormalizedPath === \"\") {\n            throw new Error(\"Nested path resolved to an empty path\");\n          }\n          return joinedNormalizedPath;\n        }\n      };\n      const normalized = this.normalizePath(joined, normalizeConfig);\n      if (normalized.updates) {\n        updates = {\n          ...updates,\n          ...normalized.updates\n        };\n      }\n      const updateKeys = Object.keys(updates);\n      if (!options.readOnly && updateKeys.length > 0) {\n        const updateTransaction = updateKeys.map(\n          (updatedBinding) => [\n            this.parse(updatedBinding),\n            updates[updatedBinding]\n          ]\n        );\n        options.set(updateTransaction);\n      }\n      return this.getBindingForNormalizedResult(normalized);\n    }\n  };\n  var DependencyTracker = class {\n    constructor() {\n      this.readDeps = /* @__PURE__ */ new Set();\n      this.writeDeps = /* @__PURE__ */ new Set();\n      this.namedDependencySets = {};\n      this.namedSet = \"core\";\n      this.createSubset(\"core\");\n      this.createSubset(\"children\");\n    }\n    createSubset(name, force = false) {\n      if (force || !this.namedDependencySets[name]) {\n        this.namedDependencySets[name] = {\n          readDeps: /* @__PURE__ */ new Set(),\n          writeDeps: /* @__PURE__ */ new Set()\n        };\n      }\n    }\n    /** Grab all of the bindings that this depended on */\n    getDependencies(name) {\n      if (name !== void 0) {\n        return this.namedDependencySets?.[name]?.readDeps ?? /* @__PURE__ */ new Set();\n      }\n      return this.readDeps;\n    }\n    trackSubset(name) {\n      this.createSubset(name);\n      this.namedSet = name;\n    }\n    trackDefault() {\n      this.namedSet = \"core\";\n    }\n    /** Grab all of the bindings this wrote to */\n    getModified(name) {\n      if (name !== void 0) {\n        return this.namedDependencySets?.[name]?.writeDeps ?? /* @__PURE__ */ new Set();\n      }\n      return this.writeDeps;\n    }\n    /**\n     * Check to see if the dataModel has read the value at the given binding\n     *\n     * @param binding - The binding you want to check for\n     */\n    readsBinding(binding) {\n      return this.readDeps.has(binding);\n    }\n    /**\n     * Check to see if the dataModel has written to the binding\n     */\n    writesBinding(binding) {\n      return this.writeDeps.has(binding);\n    }\n    /** Reset all tracking of dependencies */\n    reset() {\n      this.readDeps = /* @__PURE__ */ new Set();\n      this.writeDeps = /* @__PURE__ */ new Set();\n      this.namedDependencySets = {};\n      this.namedSet = \"core\";\n      this.createSubset(\"core\", true);\n      this.createSubset(\"children\", true);\n    }\n    addReadDep(binding, namedSet = this.namedSet) {\n      if (namedSet) {\n        this.namedDependencySets?.[namedSet]?.readDeps.add(binding);\n      }\n      this.readDeps.add(binding);\n    }\n    addWriteDep(binding, namedSet = this.namedSet) {\n      if (namedSet) {\n        this.namedDependencySets?.[namedSet]?.writeDeps.add(binding);\n      }\n      this.writeDeps.add(binding);\n    }\n    addChildReadDep(binding) {\n      this.addReadDep(binding, \"children\");\n    }\n  };\n  var DependencyModel = class extends DependencyTracker {\n    constructor(rootModel) {\n      super();\n      this.rootModel = rootModel;\n      this.set = this.set.bind(this);\n      this.get = this.get.bind(this);\n    }\n    set(transaction, options) {\n      transaction.forEach(([binding]) => this.addWriteDep(binding));\n      return this.rootModel.set(transaction, options);\n    }\n    get(binding, options) {\n      this.addReadDep(binding);\n      return this.rootModel.get(binding, options);\n    }\n    delete(binding, options) {\n      this.addWriteDep(binding);\n      return this.rootModel.delete(binding, options);\n    }\n  };\n  var NOOPDataModel = class {\n    get() {\n      return void 0;\n    }\n    set() {\n      return [];\n    }\n    delete() {\n    }\n  };\n  var NOOP_MODEL = new NOOPDataModel();\n  var ROOT_BINDING = new BindingInstance([]);\n  function withParser(model, parseBinding) {\n    function maybeParse(binding, readOnly) {\n      const parsed = isBinding(binding) ? binding : parseBinding(binding, {\n        get: model.get,\n        set: model.set,\n        readOnly\n      });\n      if (!parsed) {\n        throw new Error(\"Unable to parse binding\");\n      }\n      return parsed;\n    }\n    return {\n      get(binding, options) {\n        return model.get(maybeParse(binding, true), options);\n      },\n      set(transaction, options) {\n        return model.set(\n          transaction.map(([key, val]) => [maybeParse(key, false), val]),\n          options\n        );\n      },\n      delete(binding, options) {\n        return model.delete(maybeParse(binding, false), options);\n      }\n    };\n  }\n  function toModel(middleware, defaultOptions, next) {\n    if (!next) {\n      return middleware;\n    }\n    return {\n      get: (binding, options) => {\n        const resolvedOptions = options ?? defaultOptions;\n        if (middleware.get) {\n          return middleware.get(binding, resolvedOptions, next);\n        }\n        return next?.get(binding, resolvedOptions);\n      },\n      set: (transaction, options) => {\n        const resolvedOptions = options ?? defaultOptions;\n        if (middleware.set) {\n          return middleware.set(transaction, resolvedOptions, next);\n        }\n        return next?.set(transaction, resolvedOptions);\n      },\n      delete: (binding, options) => {\n        const resolvedOptions = options ?? defaultOptions;\n        if (middleware.delete) {\n          return middleware.delete(binding, resolvedOptions, next);\n        }\n        return next?.delete(binding, resolvedOptions);\n      }\n    };\n  }\n  function constructModelForPipeline(pipeline) {\n    if (pipeline.length === 0) {\n      return NOOP_MODEL;\n    }\n    if (pipeline.length === 1) {\n      return toModel(pipeline[0]);\n    }\n    function createModelWithOptions(options) {\n      const model = pipeline.reduce(\n        (nextModel, middleware) => toModel(middleware, options, nextModel),\n        void 0\n      ) ?? NOOP_MODEL;\n      return model;\n    }\n    return {\n      get: (binding, options) => {\n        return createModelWithOptions(options)?.get(binding, options);\n      },\n      set: (transaction, options) => {\n        return createModelWithOptions(options)?.set(transaction, options);\n      },\n      delete: (binding, options) => {\n        return createModelWithOptions(options)?.delete(binding, options);\n      }\n    };\n  }\n  var PipelinedDataModel = class {\n    constructor(pipeline = []) {\n      this.hooks = {\n        onSet: new SyncHook()\n      };\n      this.pipeline = pipeline;\n      this.effectiveDataModel = constructModelForPipeline(this.pipeline);\n    }\n    setMiddleware(handlers) {\n      this.pipeline = handlers;\n      this.effectiveDataModel = constructModelForPipeline(handlers);\n    }\n    addMiddleware(handler) {\n      this.pipeline = [...this.pipeline, handler];\n      this.effectiveDataModel = constructModelForPipeline(this.pipeline);\n    }\n    reset(model = {}) {\n      this.pipeline.forEach((middleware) => {\n        if (\"reset\" in middleware) {\n          middleware.reset?.();\n        }\n      });\n      this.set([[ROOT_BINDING, model]]);\n    }\n    set(transaction, options) {\n      const appliedTransaction = this.effectiveDataModel.set(\n        transaction,\n        options\n      );\n      this.hooks.onSet.call(transaction);\n      return appliedTransaction;\n    }\n    get(binding, options) {\n      return this.effectiveDataModel.get(binding, options);\n    }\n    delete(binding, options) {\n      return this.effectiveDataModel.delete(binding, options);\n    }\n  };\n  var LocalModel = class {\n    constructor(model = {}) {\n      this.model = model;\n      this.get = this.get.bind(this);\n      this.set = this.set.bind(this);\n    }\n    reset(model = {}) {\n      this.model = model;\n    }\n    get(binding) {\n      if (!binding || !binding.asString()) {\n        return this.model;\n      }\n      return dlv_es_default(this.model, binding.asArray());\n    }\n    set(transaction) {\n      const effectiveOperations = [];\n      transaction.forEach(([binding, value]) => {\n        const oldValue = this.get(binding);\n        this.model = (0, import_timm.setIn)(this.model, binding.asArray(), value);\n        effectiveOperations.push({ binding, oldValue, newValue: value });\n      });\n      return effectiveOperations;\n    }\n    delete(binding) {\n      const parentBinding = binding.parent();\n      if (parentBinding) {\n        const parentValue = this.get(parentBinding);\n        if (parentValue !== void 0) {\n          if (Array.isArray(parentValue)) {\n            this.model = (0, import_timm.setIn)(\n              this.model,\n              parentBinding.asArray(),\n              (0, import_timm.removeAt)(parentValue, binding.key())\n            );\n          } else {\n            this.model = (0, import_timm.setIn)(\n              this.model,\n              parentBinding.asArray(),\n              (0, import_timm.omit)(parentValue, binding.key())\n            );\n          }\n        }\n      }\n    }\n  };\n  var ExpNodeOpaqueIdentifier = Symbol(\"Expression Node ID\");\n  function isExpressionNode(x) {\n    return typeof x === \"object\" && x !== null && !Array.isArray(x) && x.__id === ExpNodeOpaqueIdentifier;\n  }\n  var PERIOD_CODE = 46;\n  var COMMA_CODE = 44;\n  var SQUOTE_CODE = 39;\n  var DQUOTE_CODE = 34;\n  var OPAREN_CODE = 40;\n  var CPAREN_CODE = 41;\n  var OBRACK_CODE = 91;\n  var CBRACK_CODE = 93;\n  var QUMARK_CODE = 63;\n  var SEMCOL_CODE = 59;\n  var COLON_CODE = 58;\n  var OCURL_CODE = 123;\n  var CCURL_CODE = 125;\n  var t = true;\n  var unaryOps = { \"-\": t, \"!\": t, \"~\": t, \"+\": t };\n  var binaryOps = {\n    \"=\": 3,\n    \"+=\": 3,\n    \"-=\": 3,\n    \"&=\": 3,\n    \"|=\": 3,\n    // Conditional: 4,\n    \"||\": 5,\n    \"&&\": 6,\n    \"|\": 7,\n    \"^\": 8,\n    \"&\": 9,\n    \"==\": 10,\n    \"!=\": 10,\n    \"===\": 10,\n    \"!==\": 10,\n    \"<\": 11,\n    \">\": 11,\n    \"<=\": 11,\n    \">=\": 11,\n    \"<<\": 12,\n    \">>\": 12,\n    \">>>\": 12,\n    \"+\": 13,\n    \"-\": 13,\n    \"*\": 14,\n    \"/\": 14,\n    \"%\": 14\n  };\n  function throwError(message, index) {\n    const err = new Error(`${message} at character ${index}`);\n    err.index = index;\n    err.description = message;\n    throw err;\n  }\n  function createSpanningLocation(start, end) {\n    if (!start || !end) {\n      return;\n    }\n    return {\n      start: start.start,\n      end: end.end\n    };\n  }\n  function getMaxKeyLen(obj) {\n    let maxLen = 0;\n    Object.keys(obj).forEach((key) => {\n      if (key.length > maxLen && Object.prototype.hasOwnProperty.call(obj, key)) {\n        maxLen = key.length;\n      }\n    });\n    return maxLen;\n  }\n  var maxUnopLen = getMaxKeyLen(unaryOps);\n  var maxBinopLen = getMaxKeyLen(binaryOps);\n  var literals = {\n    true: true,\n    false: false,\n    null: null,\n    undefined: void 0\n  };\n  var thisStr = \"this\";\n  function binaryPrecedence(opVal) {\n    return binaryOps[opVal] || 0;\n  }\n  function createBinaryExpression(operator, left, right, location) {\n    let type;\n    if (operator === \"||\" || operator === \"&&\") {\n      type = \"LogicalExpression\";\n    } else if (operator === \"=\") {\n      type = \"Assignment\";\n    } else if (operator === \"+=\" || operator === \"-=\" || operator === \"&=\" || operator === \"|=\") {\n      type = \"Modification\";\n    } else {\n      type = \"BinaryExpression\";\n    }\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type,\n      operator,\n      left,\n      right,\n      location\n    };\n  }\n  function isDecimalDigit(ch) {\n    return ch >= 48 && ch <= 57;\n  }\n  function isIdentifierStart(ch) {\n    return ch === 36 || ch === 95 || // `$` and `_`\n    ch >= 65 && ch <= 90 || // A...Z\n    ch >= 97 && ch <= 122;\n  }\n  function isIdentifierPart(ch) {\n    return ch === 36 || ch === 95 || // `$` and `_`\n    ch >= 65 && ch <= 90 || // A...Z\n    ch >= 97 && ch <= 122 || // A...z\n    ch >= 48 && ch <= 57;\n  }\n  function isModelRefStart(ch0, ch1) {\n    return ch0 === OCURL_CODE && ch1 === OCURL_CODE;\n  }\n  function parseExpression(expr, options) {\n    const strictMode = options?.strict ?? true;\n    const charAtFunc = expr.charAt;\n    const charCodeAtFunc = expr.charCodeAt;\n    const { length } = expr;\n    let index = 0;\n    const getLocation = (startChar) => {\n      return {\n        start: {\n          character: startChar\n        },\n        end: {\n          character: index\n        }\n      };\n    };\n    function exprI(i) {\n      return charAtFunc.call(expr, i);\n    }\n    function exprICode(i) {\n      return charCodeAtFunc.call(expr, i);\n    }\n    function gobbleObjects() {\n      const attributes = [];\n      let closed = false;\n      let shouldDefineKey = true;\n      let key;\n      let value;\n      let chCode;\n      const startCharIndex = index;\n      ++index;\n      while (index < length) {\n        gobbleSpaces();\n        chCode = exprICode(index);\n        if (chCode === CCURL_CODE) {\n          if (key) {\n            throwError(\"A key was defined but a value was not\", index);\n          }\n          index++;\n          closed = true;\n          break;\n        } else if (shouldDefineKey) {\n          if (chCode !== SQUOTE_CODE && chCode !== DQUOTE_CODE) {\n            throwError(\"An object must start wtih a key\", index);\n          }\n          key = gobbleStringLiteral();\n          gobbleSpaces();\n          if (exprICode(index) === COLON_CODE) {\n            index++;\n            shouldDefineKey = false;\n          } else {\n            throwError(\"A colon must follow an object key\", index);\n          }\n        } else {\n          value = gobbleExpression();\n          attributes.push({ key, value });\n          gobbleSpaces();\n          chCode = exprICode(index);\n          if (chCode === COMMA_CODE) {\n            index++;\n          } else if (chCode !== CCURL_CODE) {\n            throwError(\"Please add a comma to add another key\", index);\n          }\n          shouldDefineKey = true;\n          key = void 0;\n          value = void 0;\n        }\n        chCode = exprICode(index);\n      }\n      if (!closed) {\n        throwError(`Unclosed brace in object`, index);\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Object\",\n        attributes,\n        location: getLocation(startCharIndex)\n      };\n    }\n    function gobbleSpaces() {\n      let ch = exprICode(index);\n      while (ch === 32 || ch === 9) {\n        ch = exprICode(++index);\n      }\n    }\n    function gobbleExpression() {\n      const test = gobbleBinaryExpression();\n      gobbleSpaces();\n      const startCharIndex = index;\n      if (index < length && exprICode(index) === QUMARK_CODE) {\n        index++;\n        const consequent = gobbleExpression();\n        if (!consequent) {\n          throwError(\"Expected expression\", index);\n        }\n        gobbleSpaces();\n        if (exprICode(index) === COLON_CODE) {\n          index++;\n          const alternate = gobbleExpression();\n          if (!alternate) {\n            throwError(\"Expected expression\", index);\n          }\n          return {\n            __id: ExpNodeOpaqueIdentifier,\n            type: \"ConditionalExpression\",\n            test,\n            consequent,\n            alternate,\n            location: getLocation(startCharIndex)\n          };\n        }\n        throwError(\"Expected :\", index);\n      }\n      return test;\n    }\n    function gobbleBinaryOp() {\n      gobbleSpaces();\n      let toCheck = expr.substr(index, maxBinopLen);\n      let tcLen = toCheck.length;\n      while (tcLen > 0) {\n        if (Object.prototype.hasOwnProperty.call(binaryOps, toCheck)) {\n          index += tcLen;\n          return toCheck;\n        }\n        toCheck = toCheck.substr(0, --tcLen);\n      }\n      return false;\n    }\n    function gobbleBinaryExpression() {\n      let node;\n      let prec;\n      let i;\n      let left = gobbleToken();\n      let biop = gobbleBinaryOp();\n      if (!biop) {\n        return left;\n      }\n      let biopInfo = { value: biop, prec: binaryPrecedence(biop) };\n      let right = gobbleToken();\n      if (!right) {\n        throwError(`Expected expression after ${biop}`, index);\n      }\n      const stack = [left, biopInfo, right];\n      biop = gobbleBinaryOp();\n      while (biop) {\n        prec = binaryPrecedence(biop);\n        if (prec === 0) {\n          break;\n        }\n        biopInfo = { value: biop, prec };\n        while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n          right = stack.pop();\n          biop = stack.pop().value;\n          left = stack.pop();\n          node = createBinaryExpression(\n            biop,\n            left,\n            right,\n            createSpanningLocation(left.location, right.location)\n          );\n          stack.push(node);\n        }\n        node = gobbleToken();\n        if (!node) {\n          throwError(`Expected expression after ${biop}`, index);\n        }\n        stack.push(biopInfo, node);\n        biop = gobbleBinaryOp();\n      }\n      i = stack.length - 1;\n      node = stack[i];\n      while (i > 1) {\n        node = createBinaryExpression(\n          stack[i - 1].value,\n          stack[i - 2],\n          node,\n          createSpanningLocation(stack[i - 2].location, node.location)\n        );\n        i -= 2;\n      }\n      return node;\n    }\n    function gobbleToken() {\n      gobbleSpaces();\n      const ch = exprICode(index);\n      const startCharIndex = index;\n      if (isDecimalDigit(ch) || ch === PERIOD_CODE) {\n        return gobbleNumericLiteral();\n      }\n      if (ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\n        return gobbleStringLiteral();\n      }\n      if (isIdentifierStart(ch) || ch === OPAREN_CODE) {\n        return gobbleVariable();\n      }\n      if (ch === OBRACK_CODE) {\n        return gobbleArray();\n      }\n      if (isModelRefStart(ch, exprICode(index + 1))) {\n        return gobbleModelRef();\n      }\n      if (ch === OCURL_CODE) {\n        return gobbleObjects();\n      }\n      let toCheck = expr.substr(index, maxUnopLen);\n      let tcLen = toCheck.length;\n      while (tcLen > 0) {\n        if (Object.prototype.hasOwnProperty.call(unaryOps, toCheck)) {\n          index += tcLen;\n          return {\n            __id: ExpNodeOpaqueIdentifier,\n            type: \"UnaryExpression\",\n            operator: toCheck,\n            argument: gobbleToken(),\n            prefix: true,\n            location: getLocation(startCharIndex)\n          };\n        }\n        toCheck = toCheck.substr(0, --tcLen);\n      }\n      return false;\n    }\n    function gobbleNumericLiteral() {\n      let num = \"\";\n      const startCharIndex = index;\n      while (isDecimalDigit(exprICode(index))) {\n        num += exprI(index++);\n      }\n      if (exprICode(index) === PERIOD_CODE) {\n        num += exprI(index++);\n        while (isDecimalDigit(exprICode(index))) {\n          num += exprI(index++);\n        }\n      }\n      let ch = exprI(index);\n      if (ch === \"e\" || ch === \"E\") {\n        num += exprI(index++);\n        ch = exprI(index);\n        if (ch === \"+\" || ch === \"-\") {\n          num += exprI(index++);\n        }\n        while (isDecimalDigit(exprICode(index))) {\n          num += exprI(index++);\n        }\n        if (!isDecimalDigit(exprICode(index - 1))) {\n          throwError(`Expected exponent (${num}${exprI(index)})`, index);\n        }\n      }\n      const chCode = exprICode(index);\n      if (isIdentifierStart(chCode)) {\n        throwError(\n          `Variable names cannot start with a number (${num}${exprI(index)})`,\n          index\n        );\n      } else if (chCode === PERIOD_CODE) {\n        throwError(\"Unexpected period\", index);\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Literal\",\n        value: parseFloat(num),\n        raw: num,\n        location: getLocation(startCharIndex)\n      };\n    }\n    function gobbleStringLiteral() {\n      const quote = exprI(index++);\n      let str = \"\";\n      let closed = false;\n      const startCharIndex = index;\n      while (index < length) {\n        let ch = exprI(index++);\n        if (ch === quote) {\n          closed = true;\n          break;\n        }\n        if (ch !== \"\\\\\") {\n          str += ch;\n          continue;\n        }\n        ch = exprI(index++);\n        switch (ch) {\n          case \"n\":\n            str += \"\\n\";\n            break;\n          case \"r\":\n            str += \"\\r\";\n            break;\n          case \"t\":\n            str += \"\t\";\n            break;\n          case \"b\":\n            str += \"\\b\";\n            break;\n          case \"f\":\n            str += \"\\f\";\n            break;\n          case \"v\":\n            str += \"\\v\";\n            break;\n          default:\n        }\n      }\n      if (!closed) {\n        throwError(`Unclosed quote after \"${str}\"`, index);\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Literal\",\n        value: str,\n        raw: `${quote}${str}${quote}`,\n        location: getLocation(startCharIndex)\n      };\n    }\n    function gobbleModelRef() {\n      let str = \"\";\n      let closed = false;\n      let openBraceCount = 1;\n      const startCharIndex = index;\n      index += 2;\n      while (index < length) {\n        const ch = exprI(index++);\n        if (ch === \"}\" && exprICode(index) === CCURL_CODE) {\n          index++;\n          openBraceCount--;\n          if (openBraceCount === 0) {\n            closed = true;\n            break;\n          }\n          str += \"}}\";\n        } else if (ch === \"{\" && exprICode(index) === OCURL_CODE) {\n          openBraceCount++;\n          str += \"{{\";\n          index++;\n        } else {\n          str += ch;\n        }\n      }\n      if (!closed) {\n        throwError(`Unclosed brace after \"${str}\"`, index);\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"ModelRef\",\n        ref: str,\n        location: getLocation(startCharIndex)\n      };\n    }\n    function gobbleIdentifier() {\n      const start = index;\n      let ch = exprICode(start);\n      if (isIdentifierStart(ch)) {\n        index++;\n      } else {\n        throwError(`Unexpected ${exprI(index)}`, index);\n      }\n      while (index < length) {\n        ch = exprICode(index);\n        if (isIdentifierPart(ch)) {\n          index++;\n        } else {\n          break;\n        }\n      }\n      const identifier = expr.slice(start, index);\n      if (Object.prototype.hasOwnProperty.call(literals, identifier)) {\n        return {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"Literal\",\n          value: literals[identifier],\n          raw: identifier,\n          location: getLocation(start)\n        };\n      }\n      if (identifier === thisStr) {\n        return {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"ThisExpression\",\n          location: getLocation(start)\n        };\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Identifier\",\n        name: identifier,\n        location: getLocation(start)\n      };\n    }\n    function gobbleArguments(termination) {\n      const args = [];\n      let charIndex;\n      let node;\n      while (index < length) {\n        gobbleSpaces();\n        charIndex = exprICode(index);\n        if (charIndex === termination) {\n          index++;\n          break;\n        }\n        if (charIndex === COMMA_CODE) {\n          index++;\n          continue;\n        }\n        node = gobbleExpression();\n        if (!node || node.type === \"Compound\") {\n          throwError(\"Expected comma\", index);\n        }\n        args.push(node);\n      }\n      if (strictMode && charIndex !== termination) {\n        throwError(`Expected ${String.fromCharCode(termination)}`, index);\n      }\n      return args;\n    }\n    function gobbleVariable() {\n      let charIndex = exprICode(index);\n      let node = charIndex === OPAREN_CODE ? gobbleGroup() : gobbleIdentifier();\n      const startCharIndex = index;\n      gobbleSpaces();\n      charIndex = exprICode(index);\n      while (charIndex === PERIOD_CODE || charIndex === OBRACK_CODE || charIndex === OPAREN_CODE) {\n        index++;\n        if (charIndex === PERIOD_CODE) {\n          gobbleSpaces();\n          node = {\n            __id: ExpNodeOpaqueIdentifier,\n            type: \"MemberExpression\",\n            computed: false,\n            object: node,\n            property: gobbleIdentifier(),\n            location: getLocation(startCharIndex)\n          };\n        } else if (charIndex === OBRACK_CODE) {\n          node = {\n            __id: ExpNodeOpaqueIdentifier,\n            type: \"MemberExpression\",\n            computed: true,\n            object: node,\n            property: gobbleExpression(),\n            location: getLocation(startCharIndex)\n          };\n          gobbleSpaces();\n          charIndex = exprICode(index);\n          if (charIndex !== CBRACK_CODE) {\n            throwError(\"Unclosed [\", index);\n          }\n          index++;\n        } else if (charIndex === OPAREN_CODE) {\n          node = {\n            __id: ExpNodeOpaqueIdentifier,\n            type: \"CallExpression\",\n            args: gobbleArguments(CPAREN_CODE),\n            callTarget: node,\n            location: getLocation(startCharIndex)\n          };\n        }\n        gobbleSpaces();\n        charIndex = exprICode(index);\n      }\n      return node;\n    }\n    function gobbleGroup() {\n      index++;\n      const node = gobbleExpression();\n      gobbleSpaces();\n      if (exprICode(index) === CPAREN_CODE) {\n        index++;\n        return node;\n      }\n      throwError(\"Unclosed (\", index);\n    }\n    function gobbleArray() {\n      const startCharIndex = index;\n      index++;\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"ArrayExpression\",\n        elements: gobbleArguments(CBRACK_CODE),\n        location: getLocation(startCharIndex)\n      };\n    }\n    const nodes = [];\n    try {\n      while (index < length) {\n        const chIndex = exprICode(index);\n        if (chIndex === SEMCOL_CODE || chIndex === COMMA_CODE) {\n          index++;\n          continue;\n        }\n        const node = gobbleExpression();\n        if (node) {\n          nodes.push(node);\n        } else if (strictMode && index < length) {\n          throwError(`Unexpected \"${exprI(index)}\"`, index);\n        }\n      }\n      if (nodes.length === 1) {\n        return nodes[0];\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Compound\",\n        body: nodes,\n        location: getLocation(0)\n      };\n    } catch (e) {\n      if (strictMode || !(e instanceof Error)) {\n        throw e;\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Compound\",\n        body: nodes,\n        location: getLocation(0),\n        error: e\n      };\n    }\n  }\n  var evaluator_functions_exports = {};\n  __export2(evaluator_functions_exports, {\n    conditional: () => conditional,\n    deleteDataVal: () => deleteDataVal,\n    getDataVal: () => getDataVal,\n    setDataVal: () => setDataVal,\n    waitFor: () => waitFor\n  });\n  function isPromiseLike(value) {\n    return value != null && typeof value === \"object\" && typeof value.then === \"function\" && // Additional safeguards against false positives\n    (value instanceof Promise || // Check for standard Promise constructor name\n    value.constructor?.name === \"Promise\" || // Verify it has other Promise-like methods to reduce false positives\n    typeof value.catch === \"function\" && typeof value.finally === \"function\");\n  }\n  var AwaitableSymbol = Symbol(\"Awaitable\");\n  function isAwaitable(val) {\n    return isPromiseLike(val) && val[AwaitableSymbol] !== void 0;\n  }\n  function collateAwaitable(promises) {\n    const result = Promise.all(promises);\n    return makeAwaitable(result);\n  }\n  function makeAwaitable(promise) {\n    promise[AwaitableSymbol] = AwaitableSymbol;\n    promise.awaitableThen = (arg) => {\n      return makeAwaitable(promise.then(arg));\n    };\n    return promise;\n  }\n  var setDataVal = (_context, binding, value) => {\n    _context.model.set([[binding, value]]);\n  };\n  var getDataVal = (_context, binding) => {\n    return _context.model.get(binding);\n  };\n  var deleteDataVal = (_context, binding) => {\n    return _context.model.delete(binding);\n  };\n  var conditional = (ctx, condition, ifTrue, ifFalse) => {\n    const testResult = ctx.evaluate(condition);\n    if (isAwaitable(testResult)) {\n      return testResult.awaitableThen((resolvedTest) => {\n        if (resolvedTest) {\n          return ctx.evaluate(ifTrue);\n        }\n        if (ifFalse) {\n          return ctx.evaluate(ifFalse);\n        }\n        return null;\n      });\n    }\n    if (testResult) {\n      return ctx.evaluate(ifTrue);\n    }\n    if (ifFalse) {\n      return ctx.evaluate(ifFalse);\n    }\n    return null;\n  };\n  conditional.resolveParams = false;\n  var waitFor = (ctx, promise) => {\n    return makeAwaitable(promise);\n  };\n  function isObjectExpression(expr) {\n    if (isExpressionNode(expr)) {\n      return false;\n    }\n    return typeof expr === \"object\" && expr !== null && !Array.isArray(expr) && \"value\" in expr;\n  }\n  var andandOperator = (ctx, a, b, async) => {\n    return LogicalOperators.and(ctx, a, b, async);\n  };\n  andandOperator.resolveParams = false;\n  var ororOperator = (ctx, a, b, async) => {\n    return LogicalOperators.or(ctx, a, b, async);\n  };\n  ororOperator.resolveParams = false;\n  var DEFAULT_BINARY_OPERATORS = {\n    // TODO: A lot of these functions used to do type coercion. Not sure if we want to keep that behavior or not.\n    \"+\": (a, b) => a + b,\n    \"-\": (a, b) => a - b,\n    \"*\": (a, b) => a * b,\n    \"/\": (a, b) => a / b,\n    \"%\": (a, b) => a % b,\n    // Promise-aware comparison operators\n    // eslint-disable-next-line\n    \"==\": makePromiseAwareBinaryOp((a, b) => a == b),\n    // eslint-disable-next-line\n    \"!=\": makePromiseAwareBinaryOp((a, b) => a != b),\n    \">\": makePromiseAwareBinaryOp((a, b) => a > b),\n    \">=\": makePromiseAwareBinaryOp((a, b) => a >= b),\n    \"<\": makePromiseAwareBinaryOp((a, b) => a < b),\n    \"<=\": makePromiseAwareBinaryOp((a, b) => a <= b),\n    \"!==\": makePromiseAwareBinaryOp((a, b) => a !== b),\n    \"===\": makePromiseAwareBinaryOp((a, b) => a === b),\n    \"&&\": andandOperator,\n    \"||\": ororOperator,\n    // eslint-disable-next-line\n    \"|\": (a, b) => a | b,\n    // eslint-disable-next-line\n    \"&\": (a, b) => a & b,\n    \"+=\": (a, b) => a + b,\n    \"-=\": (a, b) => a - b,\n    // eslint-disable-next-line\n    \"&=\": (a, b) => a & b,\n    // eslint-disable-next-line\n    \"|=\": (a, b) => a | b\n  };\n  var DEFAULT_UNARY_OPERATORS = {\n    \"-\": (a) => -a,\n    \"+\": (a) => Number(a),\n    \"!\": makePromiseAwareUnaryOp((a) => !a)\n  };\n  function makePromiseAwareBinaryOp(operation) {\n    return (a, b, async) => {\n      if (async && (isAwaitable(a) || isAwaitable(b))) {\n        return collateAwaitable([\n          Promise.resolve(a),\n          Promise.resolve(b)\n        ]).awaitableThen(\n          ([resolvedA, resolvedB]) => operation(resolvedA, resolvedB)\n        );\n      }\n      return operation(a, b);\n    };\n  }\n  function makePromiseAwareUnaryOp(operation) {\n    return (a, async) => {\n      if (async && isAwaitable(a)) {\n        return a.awaitableThen((resolved) => operation(resolved));\n      }\n      return operation(a);\n    };\n  }\n  function handleConditionalBranching(testValue, getTrueBranch, getFalseBranch, resolveNode, async) {\n    if (async && isAwaitable(testValue)) {\n      return testValue.awaitableThen((resolved) => {\n        const branch2 = resolved ? getTrueBranch() : getFalseBranch();\n        const branchResult = resolveNode(branch2);\n        return isAwaitable(branchResult) ? Promise.resolve(branchResult) : branchResult;\n      });\n    }\n    const branch = testValue ? getTrueBranch() : getFalseBranch();\n    return resolveNode(branch);\n  }\n  var PromiseCollectionHandler = {\n    /**\n     * Handle array with potential Promise elements\n     */\n    handleArray(items, async) {\n      if (!async) {\n        return items;\n      }\n      const hasPromises = items.some((item) => isAwaitable(item));\n      return hasPromises ? collateAwaitable(items) : items;\n    },\n    /**\n     * Handle object with potential Promise keys/values\n     */\n    handleObject(attributes, resolveNode, async) {\n      const resolvedAttributes = {};\n      const promises = [];\n      let hasPromises = false;\n      attributes.forEach((attr) => {\n        const key = resolveNode(attr.key);\n        const value = resolveNode(attr.value);\n        if (async && (isAwaitable(key) || isAwaitable(value))) {\n          hasPromises = true;\n          const keyPromise = Promise.resolve(key);\n          const valuePromise = Promise.resolve(value);\n          promises.push(\n            collateAwaitable([keyPromise, valuePromise]).awaitableThen(\n              ([resolvedKey, resolvedValue]) => {\n                resolvedAttributes[resolvedKey] = resolvedValue;\n              }\n            )\n          );\n        } else {\n          resolvedAttributes[key] = value;\n        }\n      });\n      return hasPromises ? collateAwaitable(promises).awaitableThen(() => resolvedAttributes) : resolvedAttributes;\n    }\n  };\n  var LogicalOperators = {\n    and: (ctx, leftNode, rightNode, async) => {\n      const leftResult = ctx.evaluate(leftNode);\n      if (async && isAwaitable(leftResult)) {\n        return leftResult.awaitableThen((awaitedLeft) => {\n          if (!awaitedLeft)\n            return awaitedLeft;\n          const rightResult = ctx.evaluate(rightNode);\n          return isAwaitable(rightResult) ? rightResult : Promise.resolve(rightResult);\n        });\n      }\n      return leftResult && ctx.evaluate(rightNode);\n    },\n    or: (ctx, leftNode, rightNode, async) => {\n      const leftResult = ctx.evaluate(leftNode);\n      if (async && isAwaitable(leftResult)) {\n        return leftResult.awaitableThen((awaitedLeft) => {\n          if (awaitedLeft)\n            return awaitedLeft;\n          const rightResult = ctx.evaluate(rightNode);\n          return isAwaitable(rightResult) ? rightResult : Promise.resolve(rightResult);\n        });\n      }\n      return leftResult || ctx.evaluate(rightNode);\n    }\n  };\n  var ExpressionEvaluator = class {\n    constructor(defaultOptions) {\n      this.vars = {};\n      this.hooks = {\n        /** Resolve an AST node for an expression to a value */\n        resolve: new SyncWaterfallHook(),\n        /** Gets the options that will be passed in calls to the resolve hook */\n        resolveOptions: new SyncWaterfallHook(),\n        /** Allows users to change the expression to be evaluated before processing */\n        beforeEvaluate: new SyncWaterfallHook(),\n        /**\n         * An optional means of handling an error in the expression execution\n         * Return true if handled, to stop propagation of the error\n         */\n        onError: new SyncBailHook()\n      };\n      this.expressionsCache = /* @__PURE__ */ new Map();\n      this.operators = {\n        binary: new Map(\n          Object.entries(DEFAULT_BINARY_OPERATORS)\n        ),\n        unary: new Map(\n          Object.entries(DEFAULT_UNARY_OPERATORS)\n        ),\n        expressions: new Map([\n          ...Object.entries(evaluator_functions_exports),\n          [\"await\", waitFor]\n        ])\n      };\n      this.defaultHookOptions = {\n        ...defaultOptions,\n        evaluate: (expr) => this.evaluate(expr, this.defaultHookOptions),\n        resolveNode: (node) => this._execAST(node, this.defaultHookOptions)\n      };\n      this.hooks.resolve.tap(\"ExpressionEvaluator\", (result, node, options) => {\n        return this._resolveNode(result, node, options);\n      });\n      this.evaluate = this.evaluate.bind(this);\n    }\n    reset() {\n      this.expressionsCache.clear();\n    }\n    evaluate(expr, options) {\n      const resolvedOpts = this.hooks.resolveOptions.call({\n        ...this.defaultHookOptions,\n        ...options,\n        resolveNode: (node) => this._execAST(node, resolvedOpts)\n      });\n      let expression = this.hooks.beforeEvaluate.call(expr, resolvedOpts) ?? expr;\n      while (isObjectExpression(expression)) {\n        expression = expression.value;\n      }\n      if (typeof expression === \"number\" || typeof expression === \"boolean\" || expression === void 0 || expression === null) {\n        return expression;\n      }\n      if (isExpressionNode(expression)) {\n        return this._execAST(expression, resolvedOpts);\n      }\n      if (Array.isArray(expression)) {\n        return expression.reduce(\n          (_nothing, exp) => this.evaluate(exp, options),\n          null\n        );\n      }\n      return this._execString(String(expression), resolvedOpts);\n    }\n    /**\n     * Evaluate functions in an async context\n     * @experimental These Player APIs are in active development and may change. Use with caution\n     */\n    evaluateAsync(expr, options) {\n      if (Array.isArray(expr)) {\n        return collateAwaitable(\n          expr.map(\n            async (exp) => this.evaluate(exp, { ...options, async: true })\n          )\n        ).awaitableThen((values) => {\n          return values.pop();\n        });\n      } else {\n        return this.evaluate(expr, { ...options, async: true });\n      }\n    }\n    addExpressionFunction(name, handler) {\n      this.operators.expressions.set(name, handler);\n    }\n    addBinaryOperator(operator, handler) {\n      this.operators.binary.set(operator, handler);\n    }\n    addUnaryOperator(operator, handler) {\n      this.operators.unary.set(operator, handler);\n    }\n    setExpressionVariable(name, value) {\n      this.vars[name] = value;\n    }\n    getExpressionVariable(name) {\n      return this.vars[name];\n    }\n    _execAST(node, options) {\n      return this.hooks.resolve.call(void 0, node, options);\n    }\n    _execString(exp, options) {\n      if (exp === \"\") {\n        return exp;\n      }\n      const matches = exp.match(/^@\\[(.*)\\]@$/);\n      let matchedExp = exp;\n      if (matches) {\n        const [, matched] = Array.from(matches);\n        if (matched) {\n          matchedExp = matched;\n        }\n      }\n      let storedAST;\n      try {\n        storedAST = this.expressionsCache.get(matchedExp) ?? parseExpression(matchedExp, { strict: options.strict });\n        this.expressionsCache.set(matchedExp, storedAST);\n      } catch (e) {\n        if (options.throwErrors || !this.hooks.onError.call(e)) {\n          throw new import_ts_nested_error3.NestedError(`Error parsing expression: ${exp}`, e);\n        }\n        return;\n      }\n      try {\n        return this._execAST(storedAST, options);\n      } catch (e) {\n        if (options.throwErrors || !this.hooks.onError.call(e)) {\n          throw new import_ts_nested_error3.NestedError(`Error evaluating expression: ${exp}`, e);\n        }\n      }\n    }\n    _resolveNode(_currentValue, node, options) {\n      const { resolveNode, model } = options;\n      const isAsync = options.async ?? false;\n      const expressionContext = {\n        ...options,\n        evaluate: (expr) => this.evaluate(expr, options)\n      };\n      if (node.type === \"Literal\") {\n        return node.value;\n      }\n      if (node.type === \"Identifier\") {\n        return this.vars[node.name];\n      }\n      if (node.type === \"Compound\" || node.type === \"ThisExpression\") {\n        throw new Error(`Expression type: ${node.type} is not supported`);\n      }\n      if (node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\") {\n        const operator = this.operators.binary.get(node.operator);\n        if (operator) {\n          if (\"resolveParams\" in operator) {\n            if (operator.resolveParams === false) {\n              return operator(expressionContext, node.left, node.right, isAsync);\n            }\n            const left2 = resolveNode(node.left);\n            const right2 = resolveNode(node.right);\n            if (options.async && (isAwaitable(left2) || isAwaitable(right2))) {\n              return collateAwaitable([left2, right2]).awaitableThen(\n                ([leftVal, rightVal]) => operator(expressionContext, leftVal, rightVal, isAsync)\n              );\n            }\n            return operator(expressionContext, left2, right2, isAsync);\n          }\n          const left = resolveNode(node.left);\n          const right = resolveNode(node.right);\n          if (options.async && (isAwaitable(left) || isAwaitable(right))) {\n            return collateAwaitable([left, right]).awaitableThen(\n              ([leftVal, rightVal]) => operator(leftVal, rightVal, isAsync)\n            );\n          }\n          return operator(left, right, isAsync);\n        }\n        return;\n      }\n      if (node.type === \"UnaryExpression\") {\n        const operator = this.operators.unary.get(node.operator);\n        if (operator) {\n          if (\"resolveParams\" in operator) {\n            if (operator.resolveParams === false) {\n              return operator(expressionContext, node.argument, isAsync);\n            }\n            const arg2 = resolveNode(node.argument);\n            if (options.async && isAwaitable(arg2)) {\n              return arg2.awaitableThen(\n                (argVal) => operator(expressionContext, argVal, isAsync)\n              );\n            }\n            return operator(expressionContext, arg2, isAsync);\n          }\n          const arg = resolveNode(node.argument);\n          if (options.async && isAwaitable(arg)) {\n            return arg.awaitableThen((argVal) => operator(argVal, isAsync));\n          }\n          return operator(arg, isAsync);\n        }\n        return;\n      }\n      if (node.type === \"Object\") {\n        return PromiseCollectionHandler.handleObject(\n          node.attributes,\n          resolveNode,\n          options.async || false\n        );\n      }\n      if (node.type === \"CallExpression\") {\n        const expressionName = node.callTarget.name;\n        const operator = this.operators.expressions.get(expressionName);\n        if (!operator) {\n          throw new Error(`Unknown expression function: ${expressionName}`);\n        }\n        if (operator.name === waitFor.name && !options.async) {\n          throw new Error(\"Usage of await outside of async context\");\n        }\n        if (\"resolveParams\" in operator && operator.resolveParams === false) {\n          return operator(expressionContext, ...node.args);\n        }\n        const args = node.args.map((n) => resolveNode(n));\n        if (options.async) {\n          const hasPromises = args.some(isAwaitable);\n          if (hasPromises) {\n            return collateAwaitable(args).awaitableThen(\n              (resolvedArgs) => operator(expressionContext, ...resolvedArgs)\n            );\n          }\n        }\n        return operator(expressionContext, ...args);\n      }\n      if (node.type === \"ModelRef\") {\n        return model.get(node.ref, { context: { model: options.model } });\n      }\n      if (node.type === \"MemberExpression\") {\n        const obj = resolveNode(node.object);\n        const prop = resolveNode(node.property);\n        if (options.async && (isAwaitable(obj) || isAwaitable(prop))) {\n          return collateAwaitable([obj, prop]).awaitableThen(\n            ([objVal, propVal]) => objVal[propVal]\n          );\n        }\n        return obj[prop];\n      }\n      if (node.type === \"Assignment\") {\n        if (node.left.type === \"ModelRef\") {\n          const value = resolveNode(node.right);\n          if (isPromiseLike(value)) {\n            if (options.async && isAwaitable(value)) {\n              return value.awaitableThen((resolvedValue) => {\n                model.set([[node.left.ref, resolvedValue]]);\n                return resolvedValue;\n              });\n            } else {\n              options.logger?.warn(\n                \"Unawaited promise written to mode, this behavior is undefined and may change in future releases\"\n              );\n            }\n          }\n          model.set([[node.left.ref, value]]);\n          return value;\n        }\n        if (node.left.type === \"Identifier\") {\n          const value = resolveNode(node.right);\n          if (options.async && isAwaitable(value)) {\n            return value.awaitableThen((resolvedValue) => {\n              this.vars[node.left.name] = resolvedValue;\n              return resolvedValue;\n            });\n          }\n          this.vars[node.left.name] = value;\n          return value;\n        }\n        return;\n      }\n      if (node.type === \"ConditionalExpression\") {\n        const testResult = resolveNode(node.test);\n        return handleConditionalBranching(\n          testResult,\n          () => node.consequent,\n          () => node.alternate,\n          resolveNode,\n          isAsync\n        );\n      }\n      if (node.type === \"ArrayExpression\") {\n        const results = node.elements.map((ele) => resolveNode(ele));\n        return PromiseCollectionHandler.handleArray(results, isAsync);\n      }\n      if (node.type === \"Modification\") {\n        const operation = this.operators.binary.get(node.operator);\n        if (operation) {\n          let newValue;\n          if (\"resolveParams\" in operation) {\n            if (operation.resolveParams === false) {\n              newValue = operation(\n                expressionContext,\n                node.left,\n                node.right,\n                isAsync\n              );\n            } else {\n              const left = resolveNode(node.left);\n              const right = resolveNode(node.right);\n              if (options.async && (isAwaitable(left) || isAwaitable(right))) {\n                newValue = collateAwaitable([left, right]).awaitableThen(\n                  ([leftVal, rightVal]) => operation(expressionContext, leftVal, rightVal, isAsync)\n                );\n              } else {\n                newValue = operation(expressionContext, left, right, isAsync);\n              }\n            }\n          } else {\n            const left = resolveNode(node.left);\n            const right = resolveNode(node.right);\n            if (options.async && (isAwaitable(left) || isAwaitable(right))) {\n              newValue = collateAwaitable([left, right]).awaitableThen(\n                ([leftVal, rightVal]) => operation(leftVal, rightVal, isAsync)\n              );\n            } else {\n              newValue = operation(left, right, isAsync);\n            }\n          }\n          if (node.left.type === \"ModelRef\") {\n            if (options.async && isAwaitable(newValue)) {\n              return newValue.awaitableThen((resolvedValue) => {\n                model.set([[node.left.ref, resolvedValue]]);\n                return resolvedValue;\n              });\n            }\n            model.set([[node.left.ref, newValue]]);\n          } else if (node.left.type === \"Identifier\") {\n            if (options.async && isAwaitable(newValue)) {\n              return newValue.awaitableThen((resolvedValue) => {\n                this.vars[node.left.name] = resolvedValue;\n                return resolvedValue;\n              });\n            }\n            this.vars[node.left.name] = newValue;\n          }\n          return newValue;\n        }\n        return resolveNode(node.left);\n      }\n    }\n  };\n  var TapableLogger = class {\n    constructor() {\n      this.hooks = {\n        trace: new SyncHook(),\n        debug: new SyncHook(),\n        info: new SyncHook(),\n        warn: new SyncHook(),\n        error: new SyncHook(),\n        log: new SyncHook()\n      };\n      this.logHandlers = /* @__PURE__ */ new Set();\n      this.trace = this.createHandler(\"trace\");\n      this.debug = this.createHandler(\"debug\");\n      this.info = this.createHandler(\"info\");\n      this.warn = this.createHandler(\"warn\");\n      this.error = this.createHandler(\"error\");\n    }\n    createHandler(severity) {\n      return (...args) => {\n        this.hooks[severity].call(args);\n        this.hooks.log.call(severity, args);\n        this.logHandlers.forEach((logger) => logger[severity](...args));\n      };\n    }\n    addHandler(logHandler) {\n      this.logHandlers.add(logHandler);\n    }\n    removeHandler(logHandler) {\n      this.logHandlers.delete(logHandler);\n    }\n  };\n  var ProxyLogger = class {\n    constructor(loggerProvider) {\n      this.trace = this.createHandler(\"trace\");\n      this.debug = this.createHandler(\"debug\");\n      this.info = this.createHandler(\"info\");\n      this.warn = this.createHandler(\"warn\");\n      this.error = this.createHandler(\"error\");\n      this.proxiedLoggerProvider = loggerProvider;\n    }\n    createHandler(severity) {\n      return (...args) => {\n        const logger = this.proxiedLoggerProvider();\n        logger?.[severity](...args);\n      };\n    }\n  };\n  var identify = (val) => val;\n  function parse2(schema) {\n    const expandedPaths = /* @__PURE__ */ new Map();\n    if (!schema.ROOT) {\n      return expandedPaths;\n    }\n    const parseQueue = [{ node: schema.ROOT, path: [], visited: /* @__PURE__ */ new Set() }];\n    while (parseQueue.length > 0) {\n      const next = parseQueue.shift();\n      if (!next) {\n        break;\n      }\n      const { node, path, visited } = next;\n      Object.entries(node).forEach(([prop, type]) => {\n        const nestedPath = [...path, prop];\n        const nestedPathStr = nestedPath.join(\".\");\n        if (expandedPaths.has(nestedPathStr)) {\n          throw new Error(\n            \"Path has already been processed. There's either a loop somewhere or a bug\"\n          );\n        }\n        if (visited.has(type.type)) {\n          throw new Error(\n            `Path already contained type: ${type.type}. This likely indicates a loop in the schema`\n          );\n        }\n        expandedPaths.set(nestedPathStr, type);\n        if (type.isArray) {\n          nestedPath.push(\"[]\");\n        }\n        if (type.isRecord) {\n          nestedPath.push(\"{}\");\n        }\n        if (type.type && schema[type.type]) {\n          parseQueue.push({\n            path: nestedPath,\n            node: schema[type.type],\n            visited: /* @__PURE__ */ new Set([...visited, type.type])\n          });\n        }\n      });\n    }\n    return expandedPaths;\n  }\n  var SchemaController = class {\n    constructor(schema) {\n      this.formatters = /* @__PURE__ */ new Map();\n      this.types = /* @__PURE__ */ new Map();\n      this.schema = /* @__PURE__ */ new Map();\n      this.bindingSchemaNormalizedCache = /* @__PURE__ */ new Map();\n      this.hooks = {\n        resolveTypeForBinding: new SyncWaterfallHook()\n      };\n      this.schema = schema ? parse2(schema) : /* @__PURE__ */ new Map();\n    }\n    addFormatters(fns) {\n      fns.forEach((def) => {\n        this.formatters.set(def.name, def);\n      });\n    }\n    addDataTypes(types) {\n      types.forEach((t2) => {\n        this.types.set(t2.type, t2);\n      });\n    }\n    getValidationsForBinding(binding) {\n      const typeDef = this.getApparentType(binding);\n      if (!typeDef?.validation?.length) {\n        return void 0;\n      }\n      return typeDef.validation.map((vRef) => ({\n        severity: \"error\",\n        trigger: \"change\",\n        ...vRef\n      }));\n    }\n    normalizeBinding(binding) {\n      const cached = this.bindingSchemaNormalizedCache.get(binding);\n      if (cached) {\n        return cached;\n      }\n      let bindingArray = binding.asArray();\n      let normalized = bindingArray.map((p) => typeof p === \"number\" ? \"[]\" : p).join(\".\");\n      if (normalized) {\n        this.bindingSchemaNormalizedCache.set(binding, normalized);\n        bindingArray = normalized.split(\".\");\n      }\n      bindingArray.forEach((item) => {\n        const recordBinding = bindingArray.map((p) => p === item ? \"{}\" : p).join(\".\");\n        if (this.schema.get(recordBinding)) {\n          this.bindingSchemaNormalizedCache.set(binding, recordBinding);\n          bindingArray = recordBinding.split(\".\");\n          normalized = recordBinding;\n        }\n      });\n      return normalized;\n    }\n    getType(binding) {\n      return this.hooks.resolveTypeForBinding.call(\n        this.schema.get(this.normalizeBinding(binding)),\n        binding\n      );\n    }\n    getApparentType(binding) {\n      const schemaType = this.getType(binding);\n      if (schemaType === void 0) {\n        return void 0;\n      }\n      const baseType = this.getTypeDefinition(schemaType?.type);\n      if (baseType === void 0) {\n        return schemaType;\n      }\n      return {\n        ...baseType,\n        ...schemaType,\n        validation: [\n          ...schemaType.validation ?? [],\n          ...baseType.validation ?? []\n        ]\n      };\n    }\n    getTypeDefinition(dataType) {\n      return this.types.get(dataType);\n    }\n    getFormatterForType(formatReference) {\n      const { type: formatType, ...options } = formatReference;\n      const formatter = this.formatters.get(formatType);\n      if (!formatter) {\n        return;\n      }\n      return {\n        format: formatter.format ? (val) => formatter.format?.(val, options) : identify,\n        deformat: formatter.deformat ? (val) => formatter.deformat?.(val, options) : identify\n      };\n    }\n    /**\n     * Given a binding, fetch a function that's responsible for formatting, and/or de-formatting the data\n     * If no formatter is registered, it will return undefined\n     */\n    getFormatter(binding) {\n      const type = this.getApparentType(binding);\n      if (!type?.format) {\n        return void 0;\n      }\n      return this.getFormatterForType(type.format);\n    }\n  };\n  var DOUBLE_OPEN_CURLY = \"{{\";\n  var DOUBLE_CLOSE_CURLY = \"}}\";\n  function findNextExp(str) {\n    const expStart = str.indexOf(DOUBLE_OPEN_CURLY);\n    if (expStart === -1) {\n      return void 0;\n    }\n    let count = 1;\n    let offset = expStart + DOUBLE_OPEN_CURLY.length;\n    let workingString = str.substring(expStart + DOUBLE_OPEN_CURLY.length);\n    while (count > 0 && workingString.length > 0) {\n      const nextCloseCurly = workingString.indexOf(DOUBLE_CLOSE_CURLY);\n      if (nextCloseCurly === -1) {\n        break;\n      }\n      const nextOpenCurly = workingString.indexOf(DOUBLE_OPEN_CURLY);\n      if (nextOpenCurly !== -1 && nextOpenCurly < nextCloseCurly) {\n        count++;\n        workingString = workingString.substring(\n          nextOpenCurly + DOUBLE_OPEN_CURLY.length\n        );\n        offset += nextOpenCurly + DOUBLE_OPEN_CURLY.length;\n      } else {\n        count--;\n        workingString = workingString.substring(\n          nextCloseCurly + DOUBLE_CLOSE_CURLY.length\n        );\n        offset += nextCloseCurly + DOUBLE_CLOSE_CURLY.length;\n      }\n    }\n    if (count !== 0) {\n      throw new Error(`Unbalanced {{ and }} in exp: ${str}`);\n    }\n    return {\n      start: expStart,\n      end: offset\n    };\n  }\n  function resolveExpressionsInString(val, { evaluate }) {\n    if (!evaluate) {\n      return val;\n    }\n    const expMatch = /@\\[.*?\\]@/;\n    let newVal = val;\n    let match = newVal.match(expMatch);\n    while (match !== null) {\n      const expStrWithBrackets = match[0];\n      const matchStart = newVal.indexOf(expStrWithBrackets);\n      const expString = expStrWithBrackets.substr(\n        \"@[\".length,\n        expStrWithBrackets.length - \"@[\".length - \"]@\".length\n      );\n      const expValue = evaluate(expString);\n      if (matchStart === 0 && expStrWithBrackets === val && typeof expValue !== \"string\") {\n        return expValue;\n      }\n      newVal = newVal.substr(0, matchStart) + expValue + newVal.substr(matchStart + expStrWithBrackets.length);\n      match = newVal.match(expMatch);\n    }\n    return newVal;\n  }\n  function resolveDataRefsInString(val, options) {\n    const { model, formatted = true } = options;\n    let workingString = resolveExpressionsInString(val, options);\n    if (!model || typeof workingString !== \"string\" || workingString.indexOf(DOUBLE_OPEN_CURLY) === -1) {\n      return workingString;\n    }\n    while (workingString.indexOf(DOUBLE_OPEN_CURLY) !== -1) {\n      const expLocation = findNextExp(workingString);\n      if (!expLocation) {\n        return workingString;\n      }\n      const { start, end } = expLocation;\n      const binding = workingString.substring(\n        start + DOUBLE_OPEN_CURLY.length,\n        end - DOUBLE_OPEN_CURLY.length\n      ).trim();\n      const evaledVal = model.get(binding, { formatted });\n      if (start === 0 && end === workingString.length && typeof evaledVal !== \"string\") {\n        return evaledVal;\n      }\n      workingString = workingString.substr(0, start) + evaledVal + workingString.substr(end);\n    }\n    return workingString;\n  }\n  function traverseObject(val, options) {\n    switch (typeof val) {\n      case \"string\": {\n        return resolveDataRefsInString(val, options);\n      }\n      case \"object\": {\n        if (!val)\n          return val;\n        const keys = Object.keys(val);\n        let newVal = val;\n        if (keys.length > 0) {\n          keys.forEach((key) => {\n            newVal = (0, import_timm2.setIn)(\n              newVal,\n              [key],\n              traverseObject(val[key], options)\n            );\n          });\n        }\n        return newVal;\n      }\n      default:\n        return val;\n    }\n  }\n  function resolveDataRefs(val, options) {\n    return traverseObject(val, options);\n  }\n  function removeBindingAndChildrenFromMap(sourceMap, binding) {\n    const targetMap = new Map(sourceMap);\n    const parentBinding = binding.parent();\n    const property = binding.key();\n    targetMap.forEach((_value, trackedBinding) => {\n      if (binding === trackedBinding || binding.contains(trackedBinding)) {\n        targetMap.delete(trackedBinding);\n      }\n    });\n    if (typeof property === \"number\") {\n      const bindingsToRewrite = Array.from(sourceMap.keys()).filter((b) => {\n        if (parentBinding.contains(b)) {\n          const [childIndex] = b.relative(parentBinding);\n          return typeof childIndex === \"number\" && childIndex > property;\n        }\n        return false;\n      }).sort();\n      bindingsToRewrite.forEach((trackedBinding) => {\n        const [childIndex, ...childPath] = trackedBinding.relative(parentBinding);\n        if (typeof childIndex === \"number\") {\n          const newSegments = [childIndex - 1, ...childPath];\n          const newChildBinding = parentBinding.descendent(newSegments);\n          targetMap.set(newChildBinding, targetMap.get(trackedBinding));\n          targetMap.delete(trackedBinding);\n        }\n      });\n    }\n    return targetMap;\n  }\n  var ValidationMiddleware = class {\n    constructor(validator, options) {\n      this.validator = validator;\n      this.shadowModelPaths = /* @__PURE__ */ new Map();\n      this.logger = options?.logger;\n      this.shouldIncludeInvalid = options?.shouldIncludeInvalid;\n    }\n    set(transaction, options, next) {\n      const asModel = toModel(this, { ...options, includeInvalid: true }, next);\n      const nextTransaction = [];\n      const includedBindings = /* @__PURE__ */ new Set();\n      transaction.forEach(([binding, value]) => {\n        this.shadowModelPaths.set(binding, value);\n        includedBindings.add(binding);\n      });\n      const invalidBindings = [];\n      this.shadowModelPaths.forEach((value, binding) => {\n        const validations = this.validator(binding, asModel);\n        if (validations === void 0) {\n          nextTransaction.push([binding, value]);\n        } else if (validations instanceof Set) {\n          validations.forEach((validation) => {\n            invalidBindings.push(validation.binding);\n            if (!validation.isStrong && validation.binding.asString() === binding.asString()) {\n              nextTransaction.push([validation.binding, value]);\n            }\n          });\n        } else if (includedBindings.has(binding)) {\n          invalidBindings.push(binding);\n          this.logger?.debug(\n            `Invalid value for path: ${binding.asString()} - ${validations.severity} - ${validations.message}`\n          );\n        }\n      });\n      let validResults = [];\n      if (next && nextTransaction.length > 0) {\n        nextTransaction.forEach(\n          ([binding]) => this.shadowModelPaths.delete(binding)\n        );\n        const result = next.set(nextTransaction, options);\n        if (invalidBindings.length === 0) {\n          return result;\n        }\n        validResults = result;\n      }\n      const invalidResults = invalidBindings.map((binding) => {\n        return {\n          binding,\n          oldValue: asModel.get(binding),\n          newValue: asModel.get(binding),\n          force: true\n        };\n      });\n      return [...validResults, ...invalidResults];\n    }\n    get(binding, options, next) {\n      let val = next?.get(binding, options);\n      if (this.shouldIncludeInvalid?.(options) ?? options?.includeInvalid === true) {\n        this.shadowModelPaths.forEach((shadowValue, shadowBinding) => {\n          if (shadowBinding === binding) {\n            val = shadowValue;\n            return;\n          }\n          if (binding.contains(shadowBinding)) {\n            val = (0, import_timm3.setIn)(val, shadowBinding.relative(binding), shadowValue);\n          }\n        });\n      }\n      return val;\n    }\n    delete(binding, options, next) {\n      this.shadowModelPaths = removeBindingAndChildrenFromMap(\n        this.shadowModelPaths,\n        binding\n      );\n      return next?.delete(binding, options);\n    }\n  };\n  var ValidatorRegistry = class {\n    constructor() {\n      this.registry = /* @__PURE__ */ new Map();\n    }\n    /** Use the given validator name to fetch the handler */\n    get(name) {\n      return this.registry.get(name);\n    }\n    /** Register a new validator */\n    register(name, handler) {\n      this.registry.set(name, handler);\n    }\n  };\n  var NodeType = /* @__PURE__ */ ((NodeType2) => {\n    NodeType2[\"Asset\"] = \"asset\";\n    NodeType2[\"View\"] = \"view\";\n    NodeType2[\"Applicability\"] = \"applicability\";\n    NodeType2[\"Template\"] = \"template\";\n    NodeType2[\"Value\"] = \"value\";\n    NodeType2[\"MultiNode\"] = \"multi-node\";\n    NodeType2[\"Switch\"] = \"switch\";\n    NodeType2[\"Async\"] = \"async\";\n    NodeType2[\"Unknown\"] = \"unknown\";\n    NodeType2[\"Empty\"] = \"empty\";\n    return NodeType2;\n  })(NodeType || {});\n  function hasTemplateValues(obj, localKey) {\n    return Object.hasOwnProperty.call(obj, \"template\") && Array.isArray(obj?.template) && obj.template.length && obj.template.find((tmpl) => tmpl.output === localKey);\n  }\n  function hasSwitchKey(localKey) {\n    return localKey === \"staticSwitch\" || localKey === \"dynamicSwitch\";\n  }\n  function hasTemplateKey(localKey) {\n    return localKey === \"template\";\n  }\n  function getNodeID(node) {\n    if (!node) {\n      return;\n    }\n    if (\"value\" in node && typeof node.value === \"object\" && typeof node.value?.id === \"string\") {\n      return node.value.id;\n    }\n  }\n  var EMPTY_NODE = {\n    type: \"empty\"\n    /* Empty */\n  };\n  var Parser = class {\n    constructor() {\n      this.hooks = {\n        onParseObject: new SyncWaterfallHook(),\n        onCreateASTNode: new SyncWaterfallHook(),\n        parseNode: new SyncBailHook()\n      };\n    }\n    parseView(value) {\n      const viewNode = this.parseObject(\n        value,\n        \"view\"\n        /* View */\n      );\n      if (!viewNode) {\n        throw new Error(\"Unable to parse object into a view\");\n      }\n      return viewNode;\n    }\n    createASTNode(node, value) {\n      const tapped = this.hooks.onCreateASTNode.call(node, value);\n      if (tapped === void 0) {\n        return node;\n      }\n      return tapped;\n    }\n    parseObject(obj, type = \"value\", options = { templateDepth: 0 }) {\n      const parsedNode = this.hooks.parseNode.call(\n        obj,\n        type,\n        options\n      );\n      if (parsedNode || parsedNode === null) {\n        return parsedNode;\n      }\n      const parseLocalObject = (currentValue, objToParse, path = []) => {\n        if (typeof objToParse !== \"object\" || objToParse === null) {\n          return { value: objToParse, children: [] };\n        }\n        const localObj = this.hooks.onParseObject.call(objToParse, type);\n        if (!localObj) {\n          return currentValue;\n        }\n        const objEntries = Array.isArray(localObj) ? localObj.map((v, i) => [i, v]) : [\n          ...Object.entries(localObj),\n          ...Object.getOwnPropertySymbols(localObj).map((s) => [\n            s,\n            localObj[s]\n          ])\n        ];\n        const defaultValue = {\n          children: [],\n          value: currentValue\n        };\n        const newValue = objEntries.reduce((accumulation, current) => {\n          let { value: value2 } = accumulation;\n          const { children: children2 } = accumulation;\n          const [localKey, localValue] = current;\n          const newChildren = this.hooks.parseNode.call(\n            localValue,\n            \"value\",\n            options,\n            {\n              path,\n              key: localKey,\n              parentObj: localObj\n            }\n          );\n          if (newChildren) {\n            children2.push(...newChildren);\n          } else if (localValue && typeof localValue === \"object\") {\n            const result = parseLocalObject(accumulation.value, localValue, [\n              ...path,\n              localKey\n            ]);\n            value2 = result.value;\n            children2.push(...result.children);\n          } else {\n            value2 = (0, import_timm5.setIn)(accumulation.value, [...path, localKey], localValue);\n          }\n          return {\n            value: value2,\n            children: children2\n          };\n        }, defaultValue);\n        return newValue;\n      };\n      const { value, children } = parseLocalObject(void 0, obj);\n      const baseAst = value === void 0 && !children.length ? void 0 : {\n        type,\n        value\n      };\n      if (baseAst && children.length) {\n        const parent = baseAst;\n        parent.children = children;\n        children.forEach((child) => {\n          child.value.parent = parent;\n        });\n      }\n      return this.hooks.onCreateASTNode.call(baseAst, obj) ?? null;\n    }\n  };\n  function caresAboutDataChanges(dataChanges, dependencies) {\n    if (!dataChanges || !dependencies) {\n      return true;\n    }\n    const depArray = Array.from(dependencies.values());\n    const dataChangeArray = Array.from(dataChanges.values());\n    return depArray.find(\n      (dep) => !!dataChangeArray.find(\n        (change) => change === dep || change.contains(dep) || dep.contains(change)\n      )\n    ) !== void 0;\n  }\n  function toNodeResolveOptions(resolverOptions) {\n    return {\n      ...resolverOptions,\n      data: {\n        model: resolverOptions.model,\n        formatValue: (ref, value) => {\n          if (resolverOptions.formatValue) {\n            return resolverOptions.formatValue(ref, value);\n          }\n          return value;\n        },\n        format: (bindingLike, value) => resolverOptions.format ? resolverOptions.format(\n          isBinding(bindingLike) ? bindingLike : resolverOptions.parseBinding(bindingLike),\n          value\n        ) : value\n      },\n      evaluate: (exp) => resolverOptions.evaluator.evaluate(exp, resolverOptions)\n    };\n  }\n  var withContext = (model) => {\n    return {\n      get: (binding, options) => {\n        return model.get(binding, {\n          context: { model },\n          ...options\n        });\n      },\n      set: (transaction, options) => {\n        return model.set(transaction, {\n          context: { model },\n          ...options\n        });\n      },\n      delete: (binding, options) => {\n        return model.delete(binding, {\n          context: { model },\n          ...options\n        });\n      }\n    };\n  };\n  var Resolver = class {\n    constructor(root, options) {\n      this.hooks = {\n        skipResolve: new SyncWaterfallHook(),\n        beforeUpdate: new SyncHook(),\n        afterUpdate: new SyncHook(),\n        resolveOptions: new SyncWaterfallHook(),\n        beforeResolve: new SyncWaterfallHook(),\n        resolve: new SyncWaterfallHook(),\n        afterResolve: new SyncWaterfallHook(),\n        afterNodeUpdate: new SyncHook()\n      };\n      this.root = root;\n      this.options = options;\n      this.resolveCache = /* @__PURE__ */ new Map();\n      this.ASTMap = /* @__PURE__ */ new Map();\n      this.logger = options.logger;\n      this.idCache = /* @__PURE__ */ new Set();\n      this.AsyncIdMap = /* @__PURE__ */ new Map();\n    }\n    getSourceNode(convertedAST) {\n      return this.ASTMap.get(convertedAST);\n    }\n    update(changes, asyncChanges) {\n      this.hooks.beforeUpdate.call(changes);\n      const resolveCache = /* @__PURE__ */ new Map();\n      this.idCache.clear();\n      const prevASTMap = new Map(this.ASTMap);\n      this.ASTMap.clear();\n      const prevAsyncIdMap = new Map(this.AsyncIdMap);\n      const nextAsyncIdMap = /* @__PURE__ */ new Map();\n      asyncChanges?.forEach((id) => {\n        let current = prevAsyncIdMap.get(id);\n        while (current && prevASTMap.has(current)) {\n          const next = prevASTMap.get(current);\n          if (next && this.resolveCache.has(next)) {\n            this.resolveCache.delete(next);\n          }\n          current = current.parent;\n        }\n      });\n      const updated = this.computeTree(\n        this.root,\n        void 0,\n        changes,\n        resolveCache,\n        toNodeResolveOptions(this.options),\n        void 0,\n        prevASTMap,\n        nextAsyncIdMap\n      );\n      this.AsyncIdMap = nextAsyncIdMap;\n      this.resolveCache = resolveCache;\n      this.hooks.afterUpdate.call(updated.value);\n      return updated.value;\n    }\n    getResolveCache() {\n      return new Map(this.resolveCache);\n    }\n    getPreviousResult(node) {\n      if (!node) {\n        return;\n      }\n      const isFirstUpdate = this.resolveCache.size === 0;\n      const id = getNodeID(node);\n      if (id) {\n        if (this.idCache.has(id)) {\n          if (isFirstUpdate) {\n            if (node.type === \"asset\" || node.type === \"view\") {\n              this.logger?.error(\n                `Cache conflict: Found Asset/View nodes that have conflicting ids: ${id}, may cause cache issues.`\n              );\n            } else if (node.type === \"value\") {\n              this.logger?.info(\n                `Cache conflict: Found Value nodes that have conflicting ids: ${id}, may cause cache issues. To improve performance make value node IDs globally unique.`\n              );\n            }\n          }\n          return;\n        }\n        this.idCache.add(id);\n      }\n      return this.resolveCache.get(node);\n    }\n    cloneNode(node) {\n      const clonedNode = (0, import_timm4.clone)(node);\n      Object.keys(clonedNode).forEach((key) => {\n        if (key === \"parent\")\n          return;\n        const value = clonedNode[key];\n        if (typeof value === \"object\" && value !== null) {\n          clonedNode[key] = Array.isArray(value) ? [...value] : { ...value };\n        }\n      });\n      return clonedNode;\n    }\n    computeTree(node, rawParent, dataChanges, cacheUpdate, options, partiallyResolvedParent, prevASTMap, nextAsyncIdMap) {\n      const dependencyModel = new DependencyModel(options.data.model);\n      dependencyModel.trackSubset(\"core\");\n      const depModelWithParser = withContext(\n        withParser(dependencyModel, this.options.parseBinding)\n      );\n      const resolveOptions = this.hooks.resolveOptions.call(\n        {\n          ...options,\n          data: {\n            ...options.data,\n            model: depModelWithParser\n          },\n          evaluate: (exp) => this.options.evaluator.evaluate(exp, { model: depModelWithParser }),\n          node\n        },\n        node\n      );\n      const previousResult = this.getPreviousResult(node);\n      const previousDeps = previousResult?.dependencies;\n      const dataChanged = caresAboutDataChanges(dataChanges, previousDeps);\n      const shouldUseLastValue = this.hooks.skipResolve.call(\n        !dataChanged,\n        node,\n        resolveOptions\n      );\n      if (previousResult && shouldUseLastValue) {\n        const update2 = {\n          ...previousResult,\n          updated: false\n        };\n        const repopulateASTMapFromCache = (resolvedNode, AST, ASTParent) => {\n          const { node: resolvedASTLocal } = resolvedNode;\n          this.ASTMap.set(resolvedASTLocal, AST);\n          const resolvedUpdate = {\n            ...resolvedNode,\n            updated: false\n          };\n          cacheUpdate.set(AST, resolvedUpdate);\n          if (resolvedUpdate.node.type === \"async\") {\n            nextAsyncIdMap.set(resolvedUpdate.node.id, resolvedUpdate.node);\n          }\n          for (const key of resolvedUpdate.node.asyncNodesResolved ?? []) {\n            nextAsyncIdMap.set(key, resolvedUpdate.node);\n          }\n          const handleChildNode = (childNode) => {\n            const originalChildNode = prevASTMap.get(childNode) ?? childNode;\n            const previousChildResult = this.getPreviousResult(originalChildNode);\n            if (!previousChildResult)\n              return;\n            repopulateASTMapFromCache(\n              previousChildResult,\n              originalChildNode,\n              AST\n            );\n          };\n          if (\"children\" in resolvedASTLocal) {\n            resolvedASTLocal.children?.forEach(\n              ({ value: childAST }) => handleChildNode(childAST)\n            );\n          } else if (resolvedASTLocal.type === \"multi-node\") {\n            resolvedASTLocal.values.forEach(handleChildNode);\n          }\n          this.hooks.afterNodeUpdate.call(AST, ASTParent, resolvedUpdate);\n        };\n        previousResult.node.parent = partiallyResolvedParent;\n        repopulateASTMapFromCache(previousResult, node, rawParent);\n        return update2;\n      }\n      const clonedNode = {\n        ...this.cloneNode(node),\n        parent: partiallyResolvedParent\n      };\n      const resolvedAST = this.hooks.beforeResolve.call(\n        clonedNode,\n        resolveOptions\n      ) ?? {\n        type: \"empty\"\n        /* Empty */\n      };\n      resolvedAST.parent = partiallyResolvedParent;\n      if (resolvedAST.type === \"async\") {\n        nextAsyncIdMap.set(resolvedAST.id, resolvedAST);\n      }\n      for (const id of resolvedAST.asyncNodesResolved ?? []) {\n        nextAsyncIdMap.set(id, resolvedAST);\n      }\n      resolveOptions.node = resolvedAST;\n      this.ASTMap.set(resolvedAST, node);\n      let resolved = this.hooks.resolve.call(\n        void 0,\n        resolvedAST,\n        resolveOptions\n      );\n      let updated = !dequal(previousResult?.value, resolved);\n      if (previousResult && !updated) {\n        resolved = previousResult?.value;\n      }\n      const childDependencies = /* @__PURE__ */ new Set();\n      dependencyModel.trackSubset(\"children\");\n      if (\"children\" in resolvedAST) {\n        const newChildren = resolvedAST.children?.map((child) => {\n          const computedChildTree = this.computeTree(\n            child.value,\n            node,\n            dataChanges,\n            cacheUpdate,\n            resolveOptions,\n            resolvedAST,\n            prevASTMap,\n            nextAsyncIdMap\n          );\n          const {\n            dependencies: childTreeDeps,\n            node: childNode,\n            updated: childUpdated,\n            value: childValue\n          } = computedChildTree;\n          childTreeDeps.forEach((binding) => childDependencies.add(binding));\n          if (childValue) {\n            if (childNode.type === \"multi-node\" && !childNode.override) {\n              const arr = (0, import_timm4.addLast)(\n                dlv_es_default(resolved, child.path, []),\n                childValue\n              );\n              resolved = (0, import_timm4.setIn)(resolved, child.path, arr);\n            } else {\n              resolved = (0, import_timm4.setIn)(resolved, child.path, childValue);\n            }\n          }\n          updated = updated || childUpdated;\n          return { ...child, value: childNode };\n        });\n        resolvedAST.children = newChildren;\n      } else if (resolvedAST.type === \"multi-node\") {\n        const childValue = [];\n        const rawParentToPassIn = node;\n        resolvedAST.values = resolvedAST.values.map((mValue) => {\n          const mTree = this.computeTree(\n            mValue,\n            rawParentToPassIn,\n            dataChanges,\n            cacheUpdate,\n            resolveOptions,\n            resolvedAST,\n            prevASTMap,\n            nextAsyncIdMap\n          );\n          if (mTree.value !== void 0 && mTree.value !== null) {\n            mTree.dependencies.forEach(\n              (bindingDep) => childDependencies.add(bindingDep)\n            );\n            updated = updated || mTree.updated;\n            childValue.push(mTree.value);\n          }\n          return mTree.node;\n        });\n        resolved = childValue;\n      }\n      childDependencies.forEach(\n        (bindingDep) => dependencyModel.addChildReadDep(bindingDep)\n      );\n      dependencyModel.trackSubset(\"core\");\n      if (previousResult && !updated) {\n        resolved = previousResult?.value;\n      }\n      resolved = this.hooks.afterResolve.call(resolved, resolvedAST, {\n        ...resolveOptions,\n        getDependencies: (scope) => dependencyModel.getDependencies(scope)\n      });\n      const update = {\n        node: resolvedAST,\n        updated,\n        value: resolved,\n        dependencies: /* @__PURE__ */ new Set([\n          ...dependencyModel.getDependencies(),\n          ...childDependencies\n        ])\n      };\n      this.hooks.afterNodeUpdate.call(node, rawParent, update);\n      cacheUpdate.set(node, update);\n      return update;\n    }\n  };\n  var CrossfieldProvider = class {\n    constructor(initialView, parser, logger) {\n      this.allValidations = /* @__PURE__ */ new Set();\n      this.byBinding = /* @__PURE__ */ new Map();\n      this.logger = logger;\n      this.parse(initialView, parser);\n    }\n    parse(contentView, parser) {\n      const xfieldRefs = contentView.validation;\n      if (xfieldRefs === void 0) {\n        return;\n      }\n      if (!Array.isArray(xfieldRefs)) {\n        this.logger?.warn(\n          `Unable to register view validations for id: ${contentView.id}. 'validation' property must be an Array.`\n        );\n        return;\n      }\n      xfieldRefs.forEach((vRef) => {\n        const withDefaults = {\n          trigger: \"navigation\",\n          severity: \"error\",\n          ...vRef\n        };\n        this.allValidations.add(withDefaults);\n        const { ref } = vRef;\n        if (ref) {\n          const parsed = parser(ref);\n          if (this.byBinding.has(parsed)) {\n            this.byBinding.get(parsed)?.push(withDefaults);\n          } else {\n            this.byBinding.set(parsed, [withDefaults]);\n          }\n        }\n      });\n    }\n    getValidationsForBinding(binding) {\n      return this.byBinding.get(binding);\n    }\n  };\n  var ViewInstance = class {\n    constructor(initialView, resolverOptions) {\n      this.hooks = {\n        onUpdate: new SyncHook(),\n        parser: new SyncHook(),\n        resolver: new SyncHook(),\n        templatePlugin: new SyncHook()\n      };\n      this.initialView = initialView;\n      this.resolverOptions = resolverOptions;\n    }\n    updateAsync(asyncNode) {\n      const update = this.resolver?.update(/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set([asyncNode]));\n      this.lastUpdate = update;\n      this.hooks.onUpdate.call(update);\n    }\n    update(changes) {\n      if (this.rootNode === void 0) {\n        this.validationProvider = new CrossfieldProvider(\n          this.initialView,\n          this.resolverOptions.parseBinding,\n          this.resolverOptions.logger\n        );\n        if (this.templatePlugin) {\n          this.hooks.templatePlugin.call(this.templatePlugin);\n        } else {\n          this.resolverOptions.logger?.warn(\n            \"templatePlugin not set for View, legacy templates may not work\"\n          );\n        }\n        const parser = new Parser();\n        this.hooks.parser.call(parser);\n        this.rootNode = parser.parseView(this.initialView);\n        this.resolver = new Resolver(this.rootNode, {\n          ...this.resolverOptions,\n          parseNode: parser.parseObject.bind(parser)\n        });\n        this.hooks.resolver.call(this.resolver);\n      }\n      const update = this.resolver?.update(changes);\n      if (this.lastUpdate === update) {\n        return this.lastUpdate;\n      }\n      this.lastUpdate = update;\n      this.hooks.onUpdate.call(update);\n      return update;\n    }\n    getValidationsForBinding(binding) {\n      return this.validationProvider?.getValidationsForBinding(binding);\n    }\n    setTemplatePlugin(plugin) {\n      this.templatePlugin = plugin;\n    }\n  };\n  var templateSymbol = Symbol(\"template\");\n  var TemplatePlugin = class {\n    constructor(options) {\n      this.hooks = {\n        resolveTemplateSubstitutions: new SyncWaterfallHook()\n      };\n      this.options = options;\n    }\n    parseTemplate(parseObject, node, options) {\n      const { template, depth } = node;\n      const data = options.data.model.get(node.data);\n      if (!data) {\n        return null;\n      }\n      if (!Array.isArray(data)) {\n        throw new Error(`Template using '${node.data}' but is not an array`);\n      }\n      const values = [];\n      data.forEach((dataItem, index) => {\n        const templateSubstitutions = this.hooks.resolveTemplateSubstitutions.call(\n          [\n            {\n              expression: new RegExp(`_index${depth || \"\"}_`),\n              value: String(index)\n            }\n          ],\n          {\n            depth,\n            data: dataItem,\n            index\n          }\n        );\n        let templateStr = JSON.stringify(template);\n        for (const { expression, value } of templateSubstitutions) {\n          let flags = \"g\";\n          if (typeof expression === \"object\") {\n            flags = `${expression.flags}${expression.global ? \"\" : \"g\"}`;\n          }\n          templateStr = templateStr.replace(new RegExp(expression, flags), value);\n        }\n        const parsed = parseObject(JSON.parse(templateStr), \"value\", {\n          templateDepth: node.depth + 1\n        });\n        if (parsed) {\n          values.push(parsed);\n        }\n      });\n      const result = {\n        type: \"multi-node\",\n        override: false,\n        values\n      };\n      if (node.placement !== void 0) {\n        result[templateSymbol] = node.placement;\n      }\n      return result;\n    }\n    applyParser(parser) {\n      parser.hooks.onCreateASTNode.tap(\"template\", (node) => {\n        if (node && node.type === \"template\" && !node.dynamic) {\n          return this.parseTemplate(\n            parser.parseObject.bind(parser),\n            node,\n            this.options\n          );\n        }\n        return node;\n      });\n      parser.hooks.onCreateASTNode.tap(\"template\", (node) => {\n        function getTemplateSymbolValue(node2) {\n          if (node2.type === \"multi-node\") {\n            return node2[templateSymbol];\n          } else if (node2.type === \"template\") {\n            return node2.placement;\n          }\n          return void 0;\n        }\n        if (node && (node.type === \"view\" || node.type === \"asset\") && Array.isArray(node.children)) {\n          node.children = node.children.sort((a, b) => {\n            const aPath = a.path.join();\n            const bPath = b.path.join();\n            const pathsEqual = aPath === bPath;\n            if (pathsEqual) {\n              const aPlacement = getTemplateSymbolValue(a.value);\n              const bPlacement = getTemplateSymbolValue(b.value);\n              if (aPlacement !== void 0 && bPlacement === void 0) {\n                return aPlacement === \"prepend\" ? -1 : 1;\n              } else if (bPlacement !== void 0 && aPlacement === void 0) {\n                return bPlacement === \"prepend\" ? 1 : -1;\n              } else if (aPlacement !== void 0 && bPlacement !== void 0) {\n                if (aPlacement === bPlacement) {\n                  return 0;\n                }\n                return aPlacement === \"prepend\" ? -1 : 1;\n              }\n              return 0;\n            }\n            return aPath > bPath ? 1 : -1;\n          });\n        }\n        return node;\n      });\n      parser.hooks.parseNode.tap(\n        \"template\",\n        (obj, _nodeType, options, childOptions) => {\n          if (childOptions && hasTemplateKey(childOptions.key)) {\n            return obj.map((template) => {\n              const templateAST = parser.createASTNode(\n                {\n                  type: \"template\",\n                  depth: options.templateDepth ?? 0,\n                  data: template.data,\n                  template: template.value,\n                  dynamic: template.dynamic ?? false,\n                  placement: template.placement\n                },\n                template\n              );\n              if (!templateAST)\n                return;\n              if (templateAST.type === \"multi-node\") {\n                templateAST.values.forEach((v) => {\n                  v.parent = templateAST;\n                });\n              }\n              return {\n                path: [...childOptions.path, template.output],\n                value: templateAST\n              };\n            }).filter(Boolean);\n          }\n        }\n      );\n    }\n    applyResolverHooks(resolver) {\n      resolver.hooks.beforeResolve.tap(\"template\", (node, options) => {\n        if (node && node.type === \"template\" && node.dynamic) {\n          return this.parseTemplate(options.parseNode, node, options);\n        }\n        return node;\n      });\n    }\n    apply(view) {\n      view.hooks.parser.tap(\"template\", this.applyParser.bind(this));\n      view.hooks.resolver.tap(\"template\", this.applyResolverHooks.bind(this));\n      view.setTemplatePlugin(this);\n    }\n  };\n  var createPatternMatcher = (start, end) => {\n    return (testStr) => {\n      const startLocation = testStr.indexOf(start);\n      if (startLocation === -1) {\n        return false;\n      }\n      const endLocation = testStr.indexOf(end);\n      if (endLocation === -1) {\n        return false;\n      }\n      return startLocation < endLocation;\n    };\n  };\n  var bindingResolveLookup = createPatternMatcher(\"{{\", \"}}\");\n  var expressionResolveLookup = createPatternMatcher(\"@[\", \"]@\");\n  function hasSomethingToResolve(str) {\n    return bindingResolveLookup(str) || expressionResolveLookup(str);\n  }\n  function resolveString(str, resolveOptions) {\n    return hasSomethingToResolve(str) ? resolveDataRefs(str, {\n      model: resolveOptions.data.model,\n      evaluate: resolveOptions.evaluate\n    }) : str;\n  }\n  function resolveAllRefs(node, resolveOptions, propertiesToSkip) {\n    if (node === null || node === void 0 || typeof node !== \"object\" && typeof node !== \"string\") {\n      return node;\n    }\n    if (typeof node === \"string\") {\n      return resolveString(node, resolveOptions);\n    }\n    let newNode = node;\n    Object.keys(node).forEach((key) => {\n      if (propertiesToSkip.has(key)) {\n        return;\n      }\n      const val = node[key];\n      let newVal = val;\n      if (typeof val === \"object\") {\n        newVal = resolveAllRefs(val, resolveOptions, propertiesToSkip);\n      } else if (typeof val === \"string\") {\n        newVal = resolveString(val, resolveOptions);\n      }\n      if (newVal !== val) {\n        newNode = (0, import_timm6.set)(newNode, key, newVal);\n      }\n    });\n    return newNode;\n  }\n  var findBasePath = (node, resolver) => {\n    const parentNode = node.parent;\n    if (!parentNode) {\n      return [];\n    }\n    if (\"children\" in parentNode) {\n      const original = resolver.getSourceNode(node);\n      return parentNode.children?.find((child) => child.value === original)?.path ?? [];\n    }\n    if (parentNode.type !== \"multi-node\") {\n      return [];\n    }\n    return findBasePath(parentNode, resolver);\n  };\n  var StringResolverPlugin = class {\n    constructor() {\n      this.propertiesToSkipCache = /* @__PURE__ */ new Map();\n    }\n    applyResolver(resolver) {\n      resolver.hooks.resolve.tap(\"string-resolver\", (value, node, options) => {\n        if (node.type === \"empty\" || node.type === \"unknown\") {\n          return null;\n        }\n        if (node.type === \"value\" || node.type === \"asset\" || node.type === \"view\") {\n          let propsToSkip;\n          if (node.type === \"asset\" || node.type === \"view\") {\n            propsToSkip = new Set(\n              node.plugins?.stringResolver?.propertiesToSkip ?? [\"exp\"]\n            );\n            if (node.value?.id) {\n              this.propertiesToSkipCache.set(node.value.id, propsToSkip);\n            }\n          } else if (node.parent?.type === \"multi-node\" && (node.parent?.parent?.type === \"asset\" || node.parent?.parent?.type === \"view\") && node.parent.parent.value?.id && this.propertiesToSkipCache.has(node.parent.parent.value.id)) {\n            propsToSkip = this.propertiesToSkipCache.get(\n              node.parent.parent.value.id\n            );\n          } else {\n            propsToSkip = /* @__PURE__ */ new Set([\"exp\"]);\n          }\n          const nodePath = findBasePath(node, resolver);\n          if (nodePath.length > 0 && nodePath.some((segment) => propsToSkip.has(segment.toString()))) {\n            return node.value;\n          }\n          return resolveAllRefs(node.value, options, propsToSkip);\n        }\n        return value;\n      });\n    }\n    apply(view) {\n      view.hooks.resolver.tap(\"string-resolver\", this.applyResolver.bind(this));\n    }\n  };\n  var ApplicabilityPlugin = class {\n    isApplicability(obj) {\n      return obj && Object.prototype.hasOwnProperty.call(obj, \"applicability\");\n    }\n    applyResolver(resolver) {\n      resolver.hooks.beforeResolve.tap(\n        \"applicability\",\n        (node, options) => {\n          let newNode = node;\n          if (node?.type === \"applicability\") {\n            const isApplicable = options.evaluate(node.expression);\n            if (isApplicable === false) {\n              return null;\n            }\n            newNode = node.value;\n          }\n          return newNode;\n        }\n      );\n    }\n    applyParser(parser) {\n      parser.hooks.parseNode.tap(\n        \"applicability\",\n        (obj, nodeType, options, childOptions) => {\n          if (this.isApplicability(obj)) {\n            const parsedApplicability = parser.parseObject(\n              (0, import_timm7.omit)(obj, \"applicability\"),\n              nodeType,\n              options\n            );\n            if (!parsedApplicability) {\n              return childOptions ? [] : null;\n            }\n            const applicabilityNode = parser.createASTNode(\n              {\n                type: \"applicability\",\n                expression: obj.applicability,\n                value: parsedApplicability\n              },\n              obj\n            );\n            if (!applicabilityNode) {\n              return childOptions ? [] : null;\n            }\n            if (applicabilityNode.type === \"applicability\") {\n              applicabilityNode.value.parent = applicabilityNode;\n            }\n            return childOptions ? [\n              {\n                path: [...childOptions.path, childOptions.key],\n                value: applicabilityNode\n              }\n            ] : applicabilityNode;\n          }\n        }\n      );\n    }\n    apply(view) {\n      view.hooks.resolver.tap(\"applicability\", this.applyResolver.bind(this));\n      view.hooks.parser.tap(\"applicability\", this.applyParser.bind(this));\n    }\n  };\n  var SwitchPlugin = class {\n    constructor(options) {\n      this.options = options;\n    }\n    resolveSwitch(node, options) {\n      for (const switchCase of node.cases) {\n        const isApplicable = options.evaluate(switchCase.case);\n        if (isApplicable) {\n          return switchCase.value;\n        }\n      }\n      return EMPTY_NODE;\n    }\n    isSwitch(obj) {\n      return obj && (Object.prototype.hasOwnProperty.call(obj, \"dynamicSwitch\") || Object.prototype.hasOwnProperty.call(obj, \"staticSwitch\"));\n    }\n    applyParser(parser) {\n      parser.hooks.onCreateASTNode.tap(\"switch\", (node) => {\n        if (node && node.type === \"switch\" && !node.dynamic) {\n          return this.resolveSwitch(node, this.options);\n        }\n        return node;\n      });\n      parser.hooks.parseNode.tap(\n        \"switch\",\n        (obj, _nodeType, options, childOptions) => {\n          if (this.isSwitch(obj) || childOptions && hasSwitchKey(childOptions.key)) {\n            const objToParse = childOptions && hasSwitchKey(childOptions.key) ? { [childOptions.key]: obj } : obj;\n            const dynamic = \"dynamicSwitch\" in objToParse;\n            const switchContent = dynamic ? objToParse.dynamicSwitch : objToParse.staticSwitch;\n            const cases = switchContent.map(\n              (switchCase) => {\n                const { case: switchCaseExpr, ...switchBody } = switchCase;\n                const value = parser.parseObject(\n                  switchBody,\n                  \"value\",\n                  options\n                );\n                if (value) {\n                  return {\n                    case: switchCaseExpr,\n                    value\n                  };\n                }\n                return;\n              }\n            ).filter(Boolean);\n            const switchAST = parser.createASTNode(\n              {\n                type: \"switch\",\n                dynamic,\n                cases\n              },\n              objToParse\n            );\n            if (!switchAST || switchAST.type === \"empty\") {\n              return childOptions ? [] : null;\n            }\n            if (switchAST.type === \"switch\") {\n              switchAST.cases.forEach((sCase) => {\n                sCase.value.parent = switchAST;\n              });\n            }\n            if (childOptions) {\n              let path = [...childOptions.path, childOptions.key];\n              let value = switchAST;\n              if (switchAST.type === \"value\" && switchAST.children?.length === 1 && switchAST.value === void 0) {\n                const firstChild = switchAST.children[0];\n                path = [...path, ...firstChild.path];\n                value = firstChild.value;\n              }\n              return [{ path, value }];\n            }\n            return switchAST;\n          }\n        }\n      );\n    }\n    applyResolver(resolver) {\n      resolver.hooks.beforeResolve.tap(\"switch\", (node, options) => {\n        if (node && node.type === \"switch\" && node.dynamic) {\n          return this.resolveSwitch(node, options);\n        }\n        return node;\n      });\n    }\n    apply(view) {\n      view.hooks.parser.tap(\"switch\", this.applyParser.bind(this));\n      view.hooks.resolver.tap(\"switch\", this.applyResolver.bind(this));\n    }\n  };\n  var MultiNodePlugin = class {\n    applyParser(parser) {\n      parser.hooks.parseNode.tap(\n        \"multi-node\",\n        (obj, nodeType, options, childOptions) => {\n          if ((childOptions === void 0 || !hasTemplateKey(childOptions.key)) && Array.isArray(obj)) {\n            const values = obj.map(\n              (childVal) => parser.parseObject(childVal, \"value\", options)\n            ).filter((child) => !!child);\n            if (!values.length) {\n              return [];\n            }\n            const multiNode = parser.createASTNode(\n              {\n                type: \"multi-node\",\n                override: childOptions !== void 0 && !hasTemplateValues(childOptions.parentObj, childOptions.key),\n                values\n              },\n              obj\n            );\n            if (!multiNode) {\n              return [];\n            }\n            if (multiNode.type === \"multi-node\") {\n              multiNode.values.forEach((v) => {\n                v.parent = multiNode;\n              });\n            }\n            return childOptions === void 0 ? multiNode : [\n              {\n                path: [...childOptions.path, childOptions.key],\n                value: multiNode\n              }\n            ];\n          }\n        }\n      );\n    }\n    apply(view) {\n      view.hooks.parser.tap(\"multi-node\", this.applyParser.bind(this));\n    }\n  };\n  var AssetPlugin = class {\n    applyParser(parser) {\n      parser.hooks.parseNode.tap(\n        \"asset\",\n        (obj, nodeType, options, childOptions) => {\n          if (childOptions?.key === \"asset\" && typeof obj === \"object\") {\n            const assetAST = parser.parseObject(obj, \"asset\", options);\n            if (!assetAST) {\n              return [];\n            }\n            return [\n              {\n                path: [...childOptions.path, childOptions.key],\n                value: assetAST\n              }\n            ];\n          }\n        }\n      );\n    }\n    apply(view) {\n      view.hooks.parser.tap(\"asset\", this.applyParser.bind(this));\n    }\n  };\n  var LocalStateStore = class {\n    constructor(onUpdate) {\n      this.updateCallback = onUpdate;\n      this.state = /* @__PURE__ */ new Map();\n    }\n    removeKey(key) {\n      this.state.delete(key);\n    }\n    reset() {\n      this.state.clear();\n    }\n    useSharedState(key) {\n      return (initialState) => {\n        if (!this.state.has(key)) {\n          this.state.set(key, initialState);\n        }\n        return [\n          this.state.get(key),\n          (newState) => {\n            const current = this.state.get(key);\n            this.state.set(key, newState);\n            if (current !== newState) {\n              this.updateCallback?.();\n            }\n          }\n        ];\n      };\n    }\n    getLocalStateFunction(key, countKey) {\n      return (initialState) => {\n        if (!this.state.has(key)) {\n          this.state.set(key, []);\n        }\n        if (!this.state.has(countKey)) {\n          this.state.set(countKey, 0);\n        }\n        const localState = this.state.get(key);\n        const oldCount = this.state.get(countKey);\n        this.state.set(countKey, oldCount + 1);\n        if (localState.length <= oldCount) {\n          localState.push(initialState);\n        }\n        const value = localState[oldCount];\n        return [\n          value,\n          (newState) => {\n            const oldValue = localState[oldCount];\n            localState[oldCount] = newState;\n            if (oldValue !== newState) {\n              this.updateCallback?.();\n            }\n          }\n        ];\n      };\n    }\n  };\n  function findUp(node, target) {\n    if (node === target) {\n      return true;\n    }\n    if (node.parent) {\n      return findUp(node.parent, target);\n    }\n    return false;\n  }\n  var AssetTransformCorePlugin = class {\n    constructor(registry) {\n      this.registry = registry;\n      this.stateStore = /* @__PURE__ */ new Map();\n      this.beforeResolveSymbol = Symbol(\"before resolve\");\n      this.resolveSymbol = Symbol(\"resolve\");\n      this.beforeResolveCountSymbol = Symbol(\"before resolve count\");\n      this.resolveCountSymbol = Symbol(\"resolve count\");\n    }\n    apply(view) {\n      this.stateStore.clear();\n      view.hooks.resolver.tap(\"asset-transform\", (resolver) => {\n        let lastUpdatedNode;\n        const updateState = (node) => {\n          lastUpdatedNode = node;\n          view.update(/* @__PURE__ */ new Set());\n        };\n        const getStore = (node, stepKey) => {\n          let store;\n          const countKey = stepKey === this.resolveSymbol ? this.resolveCountSymbol : this.beforeResolveCountSymbol;\n          const storedState = this.stateStore.get(node);\n          if (storedState) {\n            store = storedState;\n            store.removeKey(countKey);\n          } else {\n            store = new LocalStateStore(() => {\n              updateState(node);\n            });\n            this.stateStore.set(node, store);\n          }\n          return {\n            useSharedState: (key) => {\n              return store.useSharedState(key);\n            },\n            useLocalState: (initialState) => {\n              return store.getLocalStateFunction(\n                stepKey,\n                countKey\n              )(initialState);\n            }\n          };\n        };\n        resolver.hooks.beforeResolve.tap(\"asset-transform\", (node, options) => {\n          if (node && (node.type === \"asset\" || node.type === \"view\")) {\n            const transform = this.registry.get(node.value);\n            if (transform?.beforeResolve) {\n              const store = getStore(\n                options.node ?? node,\n                this.beforeResolveSymbol\n              );\n              return transform.beforeResolve(node, options, store);\n            }\n          }\n          return node;\n        });\n        resolver.hooks.afterUpdate.tap(\"asset-transform\", () => {\n          lastUpdatedNode = void 0;\n        });\n        resolver.hooks.skipResolve.tap(\"asset-transform\", (skip, node) => {\n          if (!skip || !lastUpdatedNode) {\n            return skip;\n          }\n          const isParentOfUpdated = findUp(lastUpdatedNode, node);\n          const isChildOfUpdated = findUp(node, lastUpdatedNode);\n          return !isParentOfUpdated && !isChildOfUpdated;\n        });\n        resolver.hooks.afterResolve.tap(\n          \"asset-transform\",\n          (value, node, options) => {\n            if (node.type !== \"asset\" && node.type !== \"view\") {\n              return value;\n            }\n            const originalNode = resolver.getSourceNode(node);\n            if (!originalNode) {\n              return value;\n            }\n            const transform = this.registry.get(value);\n            if (transform?.resolve) {\n              const store = getStore(originalNode, this.resolveSymbol);\n              return transform?.resolve(value, options, store);\n            }\n            return value;\n          }\n        );\n      });\n    }\n  };\n  var FlowInstance = class {\n    constructor(id, flow, options) {\n      this.isTransitioning = false;\n      this.hooks = {\n        beforeStart: new SyncBailHook(),\n        onStart: new SyncHook(),\n        onEnd: new SyncHook(),\n        skipTransition: new SyncBailHook(),\n        beforeTransition: new SyncWaterfallHook(),\n        resolveTransitionNode: new SyncWaterfallHook(),\n        transition: new SyncHook(),\n        afterTransition: new SyncHook()\n      };\n      this.id = id;\n      this.flow = flow;\n      this.log = options?.logger;\n      this.history = [];\n      this.hooks.transition.tap(\n        \"startPromise\",\n        async (_oldState, nextState) => {\n          const newState = nextState.value;\n          if (this.flowPromise && newState.state_type === \"END\") {\n            this.flowPromise.resolve(newState);\n          }\n        }\n      );\n    }\n    /** Start the state machine */\n    async start() {\n      if (this.flowPromise) {\n        this.log?.warn(\"Already called start for flow\");\n        return this.flowPromise.promise;\n      }\n      this.flow = this.hooks.beforeStart.call(this.flow) || this.flow;\n      if (this.flow.onStart) {\n        this.hooks.onStart.call(this.flow.onStart);\n      }\n      const initialState = this.flow.startState;\n      if (!initialState) {\n        return Promise.reject(new Error(\"No 'startState' defined for flow\"));\n      }\n      this.flowPromise = (0, import_p_defer2.default)();\n      this.pushHistory(initialState);\n      return this.flowPromise.promise;\n    }\n    transition(transitionValue, options) {\n      if (this.isTransitioning) {\n        throw new Error(\n          `Transitioning while ongoing transition from ${this.currentState?.name} is in progress is not supported`\n        );\n      }\n      if (this.currentState?.value.state_type === \"END\") {\n        this.log?.warn(\n          `Skipping transition using ${transitionValue}. Already at and END state`\n        );\n        return;\n      }\n      if (this.currentState === void 0) {\n        throw new Error(\"Cannot transition when there's no current state\");\n      }\n      if (options?.force) {\n        this.log?.debug(`Forced transition. Skipping validation checks`);\n      } else {\n        const skipTransition = this.hooks.skipTransition.call(this.currentState);\n        if (skipTransition) {\n          this.log?.debug(\n            `Skipping transition from ${this.currentState.name} b/c hook told us to`\n          );\n          return;\n        }\n      }\n      const state = this.hooks.beforeTransition.call(\n        this.currentState.value,\n        transitionValue\n      );\n      if (!(\"transitions\" in state)) {\n        throw new Error(`No transitions defined for ${this.currentState.value}`);\n      }\n      const { transitions } = state;\n      const nextState = transitions[transitionValue] || transitions[\"*\"];\n      if (nextState === void 0) {\n        this.log?.warn(\n          `No transition from ${this.currentState.name} using ${transitionValue} or *`\n        );\n        return;\n      }\n      this.log?.debug(\n        `Transitioning from ${this.currentState.name} to ${nextState} using ${transitionValue} `\n      );\n      return this.pushHistory(nextState, options);\n    }\n    pushHistory(stateName, options) {\n      if (!Object.prototype.hasOwnProperty.call(this.flow, stateName)) {\n        throw new Error(`No flow definition for: ${stateName} was found.`);\n      }\n      let nextState = this.flow[stateName];\n      if (!this.flow[stateName] || typeof nextState !== \"object\" || !(\"state_type\" in nextState)) {\n        this.log?.error(`Flow doesn't contain any states named: ${stateName}`);\n        return;\n      }\n      const prevState = this.currentState;\n      this.isTransitioning = true;\n      nextState = this.hooks.resolveTransitionNode.call(nextState);\n      const newCurrentState = {\n        name: stateName,\n        value: nextState\n      };\n      this.currentState = newCurrentState;\n      this.history.push(stateName);\n      if (newCurrentState.value.state_type === \"END\" && this.flow.onEnd) {\n        this.hooks.onEnd.call(this.flow.onEnd);\n      }\n      this.hooks.transition.call(prevState, {\n        ...newCurrentState\n      });\n      this.isTransitioning = false;\n      this.hooks.afterTransition.call(this);\n    }\n  };\n  var FlowController = class {\n    constructor(navigation, options) {\n      this.hooks = {\n        flow: new SyncHook()\n      };\n      this.navigation = navigation;\n      this.navStack = [];\n      this.log = options?.logger;\n      this.start = this.start.bind(this);\n      this.run = this.run.bind(this);\n      this.transition = this.transition.bind(this);\n      this.addNewFlow = this.addNewFlow.bind(this);\n    }\n    /** Navigate to another state in the state-machine */\n    transition(stateTransition, options) {\n      if (this.current === void 0) {\n        throw new Error(\"Not currently in a flow. Cannot transition.\");\n      }\n      this.current.transition(stateTransition, options);\n    }\n    addNewFlow(flow) {\n      this.navStack.push(flow);\n      this.current = flow;\n      this.hooks.flow.call(flow);\n    }\n    async run(startState) {\n      if (!Object.prototype.hasOwnProperty.call(this.navigation, startState)) {\n        return Promise.reject(new Error(`No flow defined for: ${startState}`));\n      }\n      const startFlow = this.navigation[startState];\n      if (startFlow === null || typeof startFlow !== \"object\") {\n        return Promise.reject(\n          new Error(`Flow: ${startState} needs to be an object`)\n        );\n      }\n      this.log?.debug(`Starting flow: ${startState}`);\n      const flow = new FlowInstance(startState, startFlow, { logger: this.log });\n      this.addNewFlow(flow);\n      flow.hooks.afterTransition.tap(\"flow-controller\", (flowInstance) => {\n        if (flowInstance.currentState?.value.state_type === \"FLOW\") {\n          const subflowId = flowInstance.currentState?.value.ref;\n          this.log?.debug(`Loading subflow ${subflowId}`);\n          this.run(subflowId).then((subFlowEndState) => {\n            this.log?.debug(\n              `Subflow ended. Using outcome: ${subFlowEndState.outcome}`\n            );\n            flowInstance.transition(subFlowEndState?.outcome);\n          });\n        }\n      });\n      const end = await flow.start();\n      this.navStack.pop();\n      if (this.navStack.length > 0) {\n        const firstItem = 0;\n        this.current = this.navStack[firstItem];\n      }\n      return end;\n    }\n    async start() {\n      if (!this.navigation.BEGIN) {\n        return Promise.reject(new Error(\"Must supply a BEGIN state\"));\n      }\n      return this.run(this.navigation.BEGIN);\n    }\n  };\n  var ANY_CHAR_REGEX = /%([a-zA-Z]+)/g;\n  function replaceParams(message, params) {\n    return message.slice().replace(ANY_CHAR_REGEX, (keyExpr) => params[keyExpr.slice(1)] || keyExpr);\n  }\n  var CONTEXT = \"validation-binding-tracker\";\n  var ValidationBindingTrackerViewPlugin = class {\n    constructor(options) {\n      this.trackedBindings = /* @__PURE__ */ new Set();\n      this.options = options;\n    }\n    /** Fetch the tracked bindings in the current view */\n    getBindings() {\n      return this.trackedBindings;\n    }\n    /** Add a binding to the tracked set */\n    trackBinding(binding) {\n      if (this.trackedBindings.has(binding)) {\n        return;\n      }\n      this.trackedBindings.add(binding);\n      this.options.callbacks?.onAdd?.(binding);\n    }\n    /** Attach hooks to the given resolver */\n    applyResolver(resolver) {\n      this.trackedBindings.clear();\n      const tracked = /* @__PURE__ */ new Map();\n      const sections = /* @__PURE__ */ new Map();\n      let lastViewUpdateChangeSet;\n      const lastComputedBindingTree = /* @__PURE__ */ new Map();\n      let currentBindingTree = /* @__PURE__ */ new Map();\n      const lastSectionBindingTree = /* @__PURE__ */ new Map();\n      const resolvedNodeMap = /* @__PURE__ */ new Map();\n      resolver.hooks.beforeUpdate.tap(CONTEXT, (changes) => {\n        lastViewUpdateChangeSet = changes;\n      });\n      resolver.hooks.skipResolve.tap(CONTEXT, (shouldSkip, node) => {\n        const trackedBindingsForNode = lastComputedBindingTree.get(node);\n        if (!shouldSkip || !lastViewUpdateChangeSet || !trackedBindingsForNode) {\n          return shouldSkip;\n        }\n        const intersection = new Set(\n          [...lastViewUpdateChangeSet].filter(\n            (b) => trackedBindingsForNode.has(b)\n          )\n        );\n        return intersection.size === 0;\n      });\n      resolver.hooks.resolveOptions.tap(CONTEXT, (options, node) => {\n        if (options.validation === void 0) {\n          return options;\n        }\n        tracked.delete(node);\n        const track = (binding) => {\n          const parsed = isBinding(binding) ? binding : this.options.parseBinding(binding);\n          if (tracked.has(node)) {\n            tracked.get(node)?.add(parsed);\n          } else {\n            tracked.set(node, /* @__PURE__ */ new Set([parsed]));\n          }\n          let { parent } = node;\n          while (parent) {\n            if (sections.has(parent)) {\n              sections.get(parent)?.add(node);\n              break;\n            } else {\n              parent = parent.parent;\n            }\n          }\n          this.trackedBindings.add(parsed);\n          this.options.callbacks?.onAdd?.(parsed);\n        };\n        return {\n          ...options,\n          validation: {\n            ...options.validation,\n            get: (binding, getOptions) => {\n              if (getOptions?.track) {\n                track(binding);\n              }\n              const eows = options.validation?._getValidationForBinding(binding)?.getAll(getOptions);\n              const firstFieldEOW = eows?.find(\n                (eow) => eow.displayTarget === \"field\" || eow.displayTarget === void 0\n              );\n              return firstFieldEOW;\n            },\n            getValidationsForBinding(binding, getOptions) {\n              if (getOptions?.track) {\n                track(binding);\n              }\n              return options.validation?._getValidationForBinding(binding)?.getAll(getOptions) ?? [];\n            },\n            getChildren: (type) => {\n              const validations = new Array();\n              lastComputedBindingTree.get(node)?.forEach((binding) => {\n                const eow = options.validation?._getValidationForBinding(binding)?.get();\n                if (eow && (type === void 0 || type === eow.displayTarget)) {\n                  validations.push(eow);\n                }\n              });\n              return validations;\n            },\n            getValidationsForSection: () => {\n              const validations = new Array();\n              lastSectionBindingTree.get(node)?.forEach((binding) => {\n                const eow = options.validation?._getValidationForBinding(binding)?.get();\n                if (eow && eow.displayTarget === \"section\") {\n                  validations.push(eow);\n                }\n              });\n              return validations;\n            },\n            register: (registerOptions) => {\n              if (registerOptions?.type === \"section\") {\n                if (!sections.has(node)) {\n                  sections.set(node, /* @__PURE__ */ new Set());\n                }\n              }\n            },\n            track\n          }\n        };\n      });\n      resolver.hooks.afterNodeUpdate.tap(\n        CONTEXT,\n        (originalNode, parent, update) => {\n          const { updated, node: resolvedNode } = update;\n          resolvedNodeMap.set(resolvedNode, originalNode);\n          if (updated) {\n            const newlyComputed = new Set(tracked.get(originalNode));\n            if (resolvedNode.type === \"multi-node\") {\n              resolvedNode.values.forEach(\n                (value) => currentBindingTree.get(value)?.forEach((b) => newlyComputed.add(b))\n              );\n            }\n            if (\"children\" in resolvedNode && resolvedNode.children) {\n              resolvedNode.children.forEach((child) => {\n                currentBindingTree.get(child.value)?.forEach((b) => newlyComputed.add(b));\n              });\n            }\n            currentBindingTree.set(resolvedNode, newlyComputed);\n          } else {\n            currentBindingTree.set(\n              resolvedNode,\n              lastComputedBindingTree.get(originalNode) ?? /* @__PURE__ */ new Set()\n            );\n          }\n          if (originalNode === resolver.root) {\n            this.trackedBindings = new Set(currentBindingTree.get(resolvedNode));\n            lastComputedBindingTree.clear();\n            currentBindingTree.forEach((value, key) => {\n              const node = resolvedNodeMap.get(key);\n              if (node) {\n                lastComputedBindingTree.set(node, value);\n              }\n            });\n            lastSectionBindingTree.clear();\n            sections.forEach((nodeSet, sectionNode) => {\n              const temp = /* @__PURE__ */ new Set();\n              nodeSet.forEach((n) => {\n                tracked.get(n)?.forEach(temp.add, temp);\n              });\n              lastSectionBindingTree.set(sectionNode, temp);\n            });\n            tracked.clear();\n            sections.clear();\n            currentBindingTree = /* @__PURE__ */ new Map();\n          }\n        }\n      );\n    }\n    apply(view) {\n      view.hooks.resolver.tap(CONTEXT, this.applyResolver.bind(this));\n    }\n  };\n  var SCHEMA_VALIDATION_PROVIDER_NAME = \"schema\";\n  var VIEW_VALIDATION_PROVIDER_NAME = \"view\";\n  var VALIDATION_PROVIDER_NAME_SYMBOL = Symbol.for(\n    \"validation-provider-name\"\n  );\n  function isSubset(subset, containingSet) {\n    if (subset.size > containingSet.size)\n      return false;\n    for (const entry of subset)\n      if (!containingSet.has(entry))\n        return false;\n    return true;\n  }\n  function createStatefulValidationObject(obj) {\n    return {\n      value: obj,\n      type: obj.severity,\n      state: \"none\",\n      isBlockingNavigation: false\n    };\n  }\n  var ValidatedBinding = class {\n    constructor(possibleValidations, onDismiss, log, weakBindings) {\n      this.applicableValidations = [];\n      this.validationsByState = {\n        load: [],\n        change: [],\n        navigation: []\n      };\n      this.onDismiss = onDismiss;\n      possibleValidations.forEach((vObj) => {\n        const { trigger } = vObj;\n        if (this.validationsByState[trigger]) {\n          const statefulValidationObject = createStatefulValidationObject(vObj);\n          this.validationsByState[trigger].push(statefulValidationObject);\n        } else {\n          log?.warn(`Unknown validation trigger: ${trigger}`);\n        }\n      });\n      this.weakBindings = weakBindings ?? /* @__PURE__ */ new Set();\n    }\n    get allValidations() {\n      return Object.values(this.validationsByState).flat();\n    }\n    checkIfBlocking(statefulObj) {\n      if (statefulObj.state === \"active\") {\n        const { isBlockingNavigation } = statefulObj;\n        return isBlockingNavigation;\n      }\n      return false;\n    }\n    getAll() {\n      return this.applicableValidations.reduce((all, statefulObj) => {\n        if (statefulObj.state === \"active\" && statefulObj.response) {\n          all.push({\n            ...statefulObj.response,\n            blocking: this.checkIfBlocking(statefulObj)\n          });\n        }\n        return all;\n      }, []);\n    }\n    get() {\n      const firstInvalid = this.applicableValidations.find((statefulObj) => {\n        return statefulObj.state === \"active\" && statefulObj.response;\n      });\n      if (firstInvalid?.state === \"active\") {\n        return {\n          ...firstInvalid.response,\n          blocking: this.checkIfBlocking(firstInvalid)\n        };\n      }\n    }\n    runApplicableValidations(runner, canDismiss, phase) {\n      this.applicableValidations = this.applicableValidations.map(\n        (originalValue) => {\n          if (originalValue.state === \"dismissed\") {\n            return originalValue;\n          }\n          const blocking = originalValue.value.blocking ?? (originalValue.value.severity === \"warning\" && \"once\" || true);\n          const obj = (0, import_timm9.setIn)(\n            originalValue,\n            [\"value\", \"blocking\"],\n            blocking\n          );\n          const isBlockingNavigation = blocking === true || blocking === \"once\" && !canDismiss;\n          if (phase === \"navigation\" && obj.state === \"active\" && obj.value.blocking !== true) {\n            if (obj.value.severity === \"warning\") {\n              const warn = obj;\n              if (warn.dismissable && warn.response.dismiss && (warn.response.blocking !== \"once\" || !warn.response.blocking)) {\n                warn.response.dismiss();\n              } else {\n                if (warn?.response.blocking === \"once\") {\n                  warn.response.blocking = false;\n                }\n                warn.dismissable = true;\n              }\n              return warn;\n            }\n          }\n          const response = runner(obj.value);\n          const newState = {\n            type: obj.type,\n            value: obj.value,\n            state: response ? \"active\" : \"none\",\n            isBlockingNavigation,\n            dismissable: obj.value.severity === \"warning\" && phase === \"navigation\",\n            response: response ? {\n              ...obj.value,\n              message: response.message ?? \"Something is broken\",\n              severity: obj.value.severity,\n              displayTarget: obj.value.displayTarget ?? \"field\"\n            } : void 0\n          };\n          if (newState.state === \"active\" && obj.value.severity === \"warning\") {\n            newState.response.dismiss = () => {\n              newState.state = \"dismissed\";\n              this.onDismiss?.();\n            };\n          }\n          return newState;\n        }\n      );\n    }\n    update(phase, canDismiss, runner) {\n      const newApplicableValidations = [];\n      if (phase === \"load\" && this.currentPhase !== void 0) {\n        return;\n      }\n      if (this.currentPhase === \"navigation\" || phase === this.currentPhase) {\n        this.runApplicableValidations(runner, canDismiss, phase);\n        return;\n      }\n      if (phase === \"load\") {\n        this.currentPhase = \"load\";\n        this.applicableValidations = [...this.validationsByState.load];\n      } else if (phase === \"change\" && this.currentPhase === \"load\") {\n        this.currentPhase = \"change\";\n        this.applicableValidations = [\n          ...this.applicableValidations,\n          ...this.validationsByState.change\n        ];\n      } else if (phase === \"navigation\" && (this.currentPhase === \"load\" || this.currentPhase === \"change\")) {\n        this.applicableValidations.forEach((element) => {\n          if (!(element.type === \"error\" && element.state === \"active\" && element.isBlockingNavigation === false)) {\n            newApplicableValidations.push(element);\n          }\n        });\n        this.applicableValidations = [\n          ...newApplicableValidations,\n          ...this.validationsByState.navigation,\n          ...this.currentPhase === \"load\" ? this.validationsByState.change : []\n        ];\n        this.currentPhase = \"navigation\";\n      }\n      this.runApplicableValidations(runner, canDismiss, phase);\n    }\n  };\n  var ValidationController = class {\n    constructor(schema, options) {\n      this.hooks = {\n        /** A hook called to tap into the validator registry for adding more validators */\n        createValidatorRegistry: new SyncHook(),\n        /** A callback/event when a new validation is added to the view */\n        onAddValidation: new SyncWaterfallHook(),\n        /** The inverse of onAddValidation, this is called when a validation is removed from the list */\n        onRemoveValidation: new SyncWaterfallHook(),\n        resolveValidationProviders: new SyncWaterfallHook(),\n        /** A hook called when a binding is added to the tracker */\n        onTrackBinding: new SyncHook()\n      };\n      this.validations = /* @__PURE__ */ new Map();\n      this.weakBindingTracker = /* @__PURE__ */ new Set();\n      this.schema = schema;\n      this.options = options;\n      this.reset();\n    }\n    setOptions(options) {\n      this.options = options;\n    }\n    /** Return the middleware for the data-model to stop propagation of invalid data */\n    getDataMiddleware() {\n      return [\n        {\n          set: (transaction, options, next) => {\n            return next?.set(transaction, options) ?? [];\n          },\n          get: (binding, options, next) => {\n            return next?.get(binding, options);\n          },\n          delete: (binding, options, next) => {\n            this.validations = removeBindingAndChildrenFromMap(\n              this.validations,\n              binding\n            );\n            return next?.delete(binding, options);\n          }\n        },\n        new ValidationMiddleware(\n          (binding) => {\n            if (!this.options) {\n              return;\n            }\n            this.updateValidationsForBinding(binding, \"change\", this.options);\n            const strongValidation = this.getValidationForBinding(binding);\n            if (strongValidation?.get()?.severity === \"error\") {\n              return strongValidation.get();\n            }\n            const newInvalidBindings = /* @__PURE__ */ new Set();\n            this.validations.forEach((weakValidation, strongBinding) => {\n              if (caresAboutDataChanges(\n                /* @__PURE__ */ new Set([binding]),\n                weakValidation.weakBindings\n              ) && weakValidation?.get()?.severity === \"error\") {\n                weakValidation?.weakBindings.forEach((weakBinding) => {\n                  if (weakBinding === strongBinding) {\n                    newInvalidBindings.add({\n                      binding: weakBinding,\n                      isStrong: true\n                    });\n                  } else {\n                    newInvalidBindings.add({\n                      binding: weakBinding,\n                      isStrong: false\n                    });\n                  }\n                });\n              }\n            });\n            if (newInvalidBindings.size > 0) {\n              return newInvalidBindings;\n            }\n          },\n          { logger: new ProxyLogger(() => this.options?.logger) }\n        )\n      ];\n    }\n    getValidationProviders() {\n      if (this.providers) {\n        return this.providers;\n      }\n      this.providers = this.hooks.resolveValidationProviders.call([\n        {\n          source: SCHEMA_VALIDATION_PROVIDER_NAME,\n          provider: this.schema\n        },\n        {\n          source: VIEW_VALIDATION_PROVIDER_NAME,\n          provider: {\n            getValidationsForBinding: (binding) => {\n              return this.viewValidationProvider?.getValidationsForBinding?.(\n                binding\n              );\n            },\n            getValidationsForView: () => {\n              return this.viewValidationProvider?.getValidationsForView?.();\n            }\n          }\n        }\n      ]);\n      return this.providers;\n    }\n    reset() {\n      this.validations.clear();\n      this.tracker = void 0;\n    }\n    onView(view) {\n      this.validations.clear();\n      if (!this.options) {\n        return;\n      }\n      const bindingTrackerPlugin = new ValidationBindingTrackerViewPlugin({\n        ...this.options,\n        callbacks: {\n          onAdd: (binding) => {\n            if (!this.options || this.getValidationForBinding(binding) !== void 0) {\n              return;\n            }\n            const originalValue = this.options.model.get(binding);\n            const withoutDefault = this.options.model.get(binding, {\n              ignoreDefaultValue: true\n            });\n            if (originalValue !== withoutDefault) {\n              this.options.model.set([[binding, originalValue]], {\n                silent: true\n              });\n            }\n            this.updateValidationsForBinding(\n              binding,\n              \"load\",\n              this.options,\n              () => {\n                view.update(/* @__PURE__ */ new Set([binding]));\n              }\n            );\n            this.hooks.onTrackBinding.call(binding);\n          }\n        }\n      });\n      this.tracker = bindingTrackerPlugin;\n      this.viewValidationProvider = view;\n      bindingTrackerPlugin.apply(view);\n    }\n    updateValidationsForBinding(binding, trigger, validationContext, onDismiss) {\n      const context = validationContext ?? this.options;\n      if (!context) {\n        throw new Error(`Context is required for executing validations`);\n      }\n      if (trigger === \"load\") {\n        const possibleValidations = this.getValidationProviders().reduce((vals, provider) => {\n          vals.push(\n            ...provider.provider.getValidationsForBinding?.(binding)?.map((valObj) => ({\n              ...valObj,\n              [VALIDATION_PROVIDER_NAME_SYMBOL]: provider.source\n            })) ?? []\n          );\n          return vals;\n        }, []);\n        if (possibleValidations.length === 0) {\n          return;\n        }\n        this.validations.set(\n          binding,\n          new ValidatedBinding(\n            possibleValidations,\n            onDismiss,\n            this.options?.logger\n          )\n        );\n      }\n      const trackedValidations = this.validations.get(binding);\n      trackedValidations?.update(trigger, true, (validationObj) => {\n        const response = this.validationRunner(validationObj, binding, context);\n        if (this.weakBindingTracker.size > 0) {\n          const t2 = this.validations.get(binding);\n          this.weakBindingTracker.forEach((b) => t2.weakBindings.add(b));\n        }\n        return response ? { message: response.message } : void 0;\n      });\n      if (trigger !== \"load\") {\n        this.validations.forEach((validation, vBinding) => {\n          if (vBinding !== binding && caresAboutDataChanges(/* @__PURE__ */ new Set([binding]), validation.weakBindings)) {\n            validation.update(trigger, true, (validationObj) => {\n              const response = this.validationRunner(\n                validationObj,\n                vBinding,\n                context\n              );\n              return response ? { message: response.message } : void 0;\n            });\n          }\n        });\n      }\n    }\n    validationRunner(validationObj, binding, context = this.options) {\n      if (!context) {\n        throw new Error(\"No context provided to validation runner\");\n      }\n      const handler = validationObj.handler ?? this.getValidator(validationObj.type);\n      const weakBindings = /* @__PURE__ */ new Set();\n      const model = {\n        get(b, options) {\n          weakBindings.add(isBinding(b) ? binding : context.parseBinding(b));\n          return context.model.get(b, { ...options, includeInvalid: true });\n        },\n        set: context.model.set,\n        delete: context.model.delete\n      };\n      const result = handler?.(\n        {\n          ...context,\n          evaluate: (exp, options = { model }) => context.evaluate(exp, options),\n          model,\n          validation: validationObj,\n          schemaType: this.schema.getType(binding)\n        },\n        context.model.get(binding, {\n          includeInvalid: true,\n          formatted: validationObj.dataTarget === \"formatted\"\n        }),\n        validationObj\n      );\n      this.weakBindingTracker = weakBindings;\n      if (result) {\n        let { message } = result;\n        const { parameters } = result;\n        if (validationObj.message) {\n          message = resolveDataRefs(validationObj.message, {\n            model,\n            evaluate: context.evaluate\n          });\n          if (parameters) {\n            message = replaceParams(message, parameters);\n          }\n        }\n        return {\n          message\n        };\n      }\n    }\n    updateValidationsForView(trigger) {\n      const isNavigationTrigger = trigger === \"navigation\";\n      const lastActiveBindings = this.activeBindings;\n      const updateValidations = (dismissValidations) => {\n        this.getBindings().forEach((binding) => {\n          this.validations.get(binding)?.update(trigger, dismissValidations, (obj) => {\n            if (!this.options) {\n              return;\n            }\n            return this.validationRunner(obj, binding, this.options);\n          });\n        });\n      };\n      updateValidations(!isNavigationTrigger);\n      if (isNavigationTrigger) {\n        const { activeBindings } = this;\n        if (isSubset(activeBindings, lastActiveBindings)) {\n          updateValidations(true);\n        }\n      }\n    }\n    get activeBindings() {\n      return new Set(\n        Array.from(this.getBindings()).filter(\n          (b) => this.validations.get(b)?.get() !== void 0\n        )\n      );\n    }\n    getValidator(type) {\n      if (this.validatorRegistry) {\n        return this.validatorRegistry.get(type);\n      }\n      const registry = new ValidatorRegistry();\n      this.hooks.createValidatorRegistry.call(registry);\n      this.validatorRegistry = registry;\n      return registry.get(type);\n    }\n    getBindings() {\n      return this.tracker?.getBindings() ?? /* @__PURE__ */ new Set();\n    }\n    trackBinding(binding) {\n      this.tracker?.trackBinding(binding);\n    }\n    /** Executes all known validations for the tracked bindings using the given model */\n    validateView(trigger = \"navigation\") {\n      this.updateValidationsForView(trigger);\n      const validations = /* @__PURE__ */ new Map();\n      let canTransition = true;\n      this.getBindings().forEach((b) => {\n        const allValidations = this.getValidationForBinding(b)?.getAll();\n        allValidations?.forEach((v) => {\n          if (trigger === \"navigation\" && v.blocking) {\n            this.options?.logger.debug(\n              `Validation on binding: ${b.asString()} is preventing navigation. ${JSON.stringify(\n                v\n              )}`\n            );\n            canTransition = false;\n          }\n          if (!validations.has(b)) {\n            validations.set(b, v);\n          }\n        });\n      });\n      return {\n        canTransition,\n        validations: validations.size ? validations : void 0\n      };\n    }\n    /** Get the current tracked validation for the given binding */\n    getValidationForBinding(binding) {\n      return this.validations.get(binding);\n    }\n    forView(parser) {\n      return {\n        _getValidationForBinding: (binding) => {\n          return this.getValidationForBinding(\n            isBinding(binding) ? binding : parser(binding)\n          );\n        },\n        getAll: () => {\n          const bindings = this.getBindings();\n          if (bindings.size === 0) {\n            return void 0;\n          }\n          const validationMapping = /* @__PURE__ */ new Map();\n          bindings.forEach((b) => {\n            const validation = this.getValidationForBinding(b)?.get();\n            if (validation) {\n              validationMapping.set(b, validation);\n            }\n          });\n          return validationMapping.size === 0 ? void 0 : validationMapping;\n        },\n        get() {\n          throw new Error(\"Error Access be provided by the view plugin\");\n        },\n        getValidationsForBinding() {\n          throw new Error(\"Error rollup should be provided by the view plugin\");\n        },\n        getChildren() {\n          throw new Error(\"Error rollup should be provided by the view plugin\");\n        },\n        getValidationsForSection() {\n          throw new Error(\"Error rollup should be provided by the view plugin\");\n        },\n        track: () => {\n          throw new Error(\"Tracking should be provided by the view plugin\");\n        },\n        register: () => {\n          throw new Error(\n            \"Section functionality should be provided by the view plugin\"\n          );\n        },\n        type: (binding) => this.schema.getType(isBinding(binding) ? binding : parser(binding))\n      };\n    }\n  };\n  var ViewController = class {\n    constructor(initialViews, options) {\n      this.hooks = {\n        resolveView: new SyncWaterfallHook(),\n        view: new SyncHook()\n      };\n      this.transformRegistry = new Registry();\n      this.optimizeUpdates = true;\n      this.viewOptions = options;\n      this.viewMap = initialViews.reduce(\n        (viewMap, view) => {\n          viewMap[view.id] = view;\n          return viewMap;\n        },\n        {}\n      );\n      options.flowController.hooks.flow.tap(\n        \"viewController\",\n        (flow) => {\n          flow.hooks.transition.tap(\"viewController\", (_oldState, newState) => {\n            if (newState.value.state_type === \"VIEW\") {\n              this.onView(newState.value);\n            } else {\n              this.currentView = void 0;\n            }\n          });\n        }\n      );\n      const update = (updates, silent = false) => {\n        if (this.currentView) {\n          if (this.optimizeUpdates) {\n            this.queueUpdate(updates, silent);\n          } else {\n            this.currentView.update();\n          }\n        }\n      };\n      options.model.hooks.onUpdate.tap(\n        \"viewController\",\n        (updates, updateOptions) => {\n          update(\n            new Set(updates.map((t2) => t2.binding)),\n            updateOptions?.silent ?? false\n          );\n        }\n      );\n      options.model.hooks.onDelete.tap(\"viewController\", (binding) => {\n        const parentBinding = binding.parent();\n        const property = binding.key();\n        if (typeof property === \"number\" && parentBinding) {\n          update(/* @__PURE__ */ new Set([parentBinding]));\n        } else {\n          update(/* @__PURE__ */ new Set([binding]));\n        }\n      });\n      this.viewPlugins = this.createViewPlugins();\n    }\n    queueUpdate(bindings, silent = false) {\n      if (this.pendingUpdate?.changedBindings) {\n        this.pendingUpdate.changedBindings = /* @__PURE__ */ new Set([\n          ...this.pendingUpdate.changedBindings,\n          ...bindings\n        ]);\n      } else {\n        this.pendingUpdate = { changedBindings: bindings, scheduled: false };\n      }\n      if (!this.pendingUpdate.scheduled && !silent) {\n        this.pendingUpdate.scheduled = true;\n        (0, import_queue_microtask2.default)(() => {\n          const updates = this.pendingUpdate?.changedBindings;\n          this.pendingUpdate = void 0;\n          this.currentView?.update(updates);\n        });\n      }\n    }\n    getViewForRef(viewRef) {\n      if (this.viewMap[viewRef]) {\n        return this.viewMap[viewRef];\n      }\n      const matchingViewId = Object.keys(this.viewMap).find(\n        (possibleViewIdMatch) => viewRef === resolveDataRefsInString(possibleViewIdMatch, {\n          model: this.viewOptions.model,\n          evaluate: this.viewOptions.evaluator.evaluate\n        })\n      );\n      if (matchingViewId && this.viewMap[matchingViewId]) {\n        return this.viewMap[matchingViewId];\n      }\n    }\n    onView(state) {\n      const viewId = state.ref;\n      const source = this.hooks.resolveView.call(\n        this.getViewForRef(viewId),\n        viewId,\n        state\n      );\n      if (!source) {\n        throw new Error(`No view with id ${viewId}`);\n      }\n      const view = new ViewInstance(source, this.viewOptions);\n      this.currentView = view;\n      this.applyViewPlugins(view);\n      this.hooks.view.call(view);\n      view.update();\n    }\n    applyViewPlugins(view) {\n      for (const plugin of this.viewPlugins) {\n        plugin.apply(view);\n      }\n    }\n    createViewPlugins() {\n      const pluginOptions = toNodeResolveOptions(this.viewOptions);\n      return [\n        new AssetPlugin(),\n        new SwitchPlugin(pluginOptions),\n        new ApplicabilityPlugin(),\n        new AssetTransformCorePlugin(this.transformRegistry),\n        new StringResolverPlugin(),\n        new TemplatePlugin(pluginOptions),\n        new MultiNodePlugin()\n      ];\n    }\n  };\n  var ReadOnlyDataController = class {\n    constructor(controller, logger) {\n      this.controller = controller;\n      this.logger = logger;\n    }\n    get(binding, options) {\n      return this.controller.get(binding, options);\n    }\n    set(transaction, options) {\n      this.logger?.error(\n        \"Error: Tried to set in a read only instance of the DataController\"\n      );\n      return [];\n    }\n    delete(binding, options) {\n      this.logger?.error(\n        \"Error: Tried to delete in a read only instance of the DataController\"\n      );\n    }\n  };\n  var DataController = class {\n    constructor(model, options) {\n      this.hooks = {\n        resolve: new SyncWaterfallHook(),\n        resolveDataStages: new SyncWaterfallHook(),\n        // On any set or get of an undefined value, redirect the value to be the default\n        resolveDefaultValue: new SyncBailHook(),\n        onDelete: new SyncHook(),\n        onSet: new SyncHook(),\n        onGet: new SyncHook(),\n        onUpdate: new SyncHook(),\n        format: new SyncWaterfallHook(),\n        deformat: new SyncWaterfallHook(),\n        serialize: new SyncWaterfallHook()\n      };\n      this.logger = options.logger;\n      const middleware = options.middleware || [];\n      this.baseMiddleware = [new LocalModel(model), ...middleware];\n      this.trash = /* @__PURE__ */ new Set();\n      this.pathResolver = options.pathResolver;\n    }\n    getModel() {\n      if (!this.model) {\n        const stages = this.hooks.resolveDataStages.call(this.baseMiddleware);\n        const model = new PipelinedDataModel();\n        model.setMiddleware(stages);\n        this.model = model;\n      }\n      return this.model;\n    }\n    resolveDataValue(binding, value, deformat) {\n      if (deformat) {\n        return this.hooks.deformat.call(value, binding);\n      }\n      return value;\n    }\n    set(transaction, options) {\n      let normalizedTransaction = [];\n      if (Array.isArray(transaction)) {\n        normalizedTransaction = transaction.map(([binding, value]) => {\n          const parsed = this.pathResolver.parse(binding);\n          return [\n            parsed,\n            this.resolveDataValue(parsed, value, Boolean(options?.formatted))\n          ];\n        });\n      } else {\n        normalizedTransaction = Object.keys(transaction).map(\n          (binding) => {\n            const parsed = this.pathResolver.parse(binding);\n            const val = transaction[binding];\n            return [\n              parsed,\n              this.resolveDataValue(parsed, val, Boolean(options?.formatted))\n            ];\n          }\n        );\n      }\n      const setUpdates = normalizedTransaction.reduce(\n        (updates, [binding, newVal]) => {\n          const oldVal = this.get(binding, { includeInvalid: true });\n          const update = {\n            binding,\n            newValue: newVal,\n            oldValue: oldVal\n          };\n          if (dequal(oldVal, newVal)) {\n            this.logger?.debug(\n              `Skipping update for path: ${binding.asString()}. Value was unchanged: ${oldVal}`\n            );\n          } else {\n            updates.push(update);\n            this.logger?.debug(\n              `Setting path: ${binding.asString()} from: ${oldVal} to: ${newVal}`\n            );\n          }\n          return updates;\n        },\n        []\n      );\n      const result = this.getModel().set(normalizedTransaction, options);\n      const setUpdateBindings = new Set(setUpdates.map((su) => su.binding));\n      result.forEach((tr) => {\n        if (!setUpdateBindings.has(tr.binding) && (tr.force === true || !dequal(tr.oldValue, tr.newValue))) {\n          this.logger?.debug(\n            `Path: ${tr.binding.asString()} was changed from: ${tr.oldValue} to: ${tr.newValue}`\n          );\n          setUpdates.push(tr);\n        }\n      });\n      this.hooks.onSet.call(normalizedTransaction);\n      if (setUpdates.length > 0) {\n        this.hooks.onUpdate.call(setUpdates, options);\n      }\n      return result;\n    }\n    resolve(binding, readOnly) {\n      return Array.isArray(binding) || typeof binding === \"string\" ? this.pathResolver.parse(binding, { readOnly }) : binding;\n    }\n    get(binding, options) {\n      const resolved = binding instanceof BindingInstance ? binding : this.resolve(binding, true);\n      let result = this.getModel().get(resolved, options);\n      if (result === void 0 && !options?.ignoreDefaultValue) {\n        const defaultVal = this.hooks.resolveDefaultValue.call(resolved);\n        if (defaultVal !== result) {\n          result = defaultVal;\n        }\n      }\n      if (options?.formatted) {\n        result = this.hooks.format.call(result, resolved);\n      } else if (options?.formatted === false) {\n        result = this.hooks.deformat.call(result, resolved);\n      }\n      this.hooks.onGet.call(binding, result);\n      return result;\n    }\n    delete(binding, options) {\n      if (typeof binding !== \"string\" && !Array.isArray(binding) && !(binding instanceof BindingInstance)) {\n        throw new Error(\"Invalid arguments: delete expects a data path (string)\");\n      }\n      const resolved = binding instanceof BindingInstance ? binding : this.resolve(binding, false);\n      const parentBinding = resolved.parent();\n      const property = resolved.key();\n      const parentValue = this.get(parentBinding);\n      const existedBeforeDelete = typeof parentValue === \"object\" && parentValue !== null && Object.prototype.hasOwnProperty.call(parentValue, property);\n      this.getModel().delete(resolved, options);\n      if (existedBeforeDelete && !this.get(resolved)) {\n        this.trash.add(resolved);\n      }\n      this.hooks.onDelete.call(resolved);\n    }\n    serialize() {\n      return this.hooks.serialize.call(this.get(\"\"));\n    }\n    makeReadOnly() {\n      return new ReadOnlyDataController(this, this.logger);\n    }\n  };\n  function flatten(obj, roots = [], sep = \".\") {\n    return Object.keys(obj).reduce(\n      (memo, prop) => ({\n        // create a new object\n        // include previously returned object\n        ...memo,\n        ...Object.prototype.toString.call(obj[prop]) === \"[object Object]\" ? (\n          // keep working if value is an object\n          flatten(obj[prop], roots.concat([prop]))\n        ) : (\n          // include current prop and value and prefix prop with the roots\n          { [roots.concat([prop]).join(sep)]: obj[prop] }\n        )\n      }),\n      {}\n    );\n  }\n  function objectToBatchSet(obj) {\n    const flattenedObj = flatten(obj);\n    const batchTxn = [];\n    Object.keys(flattenedObj).forEach((key) => {\n      batchTxn.push([new BindingInstance(key), flattenedObj[key]]);\n    });\n    return batchTxn;\n  }\n  var ConstantsController = class {\n    constructor() {\n      this.store = /* @__PURE__ */ new Map();\n      this.tempStore = /* @__PURE__ */ new Map();\n    }\n    addConstants(data, namespace) {\n      if (this.store.has(namespace)) {\n        this.store.get(namespace)?.set(objectToBatchSet(data));\n      } else {\n        this.store.set(namespace, new LocalModel(data));\n      }\n    }\n    getConstants(key, namespace, fallback) {\n      const path = new BindingInstance(key);\n      return this.tempStore.get(namespace)?.get(path) ?? this.store.get(namespace)?.get(path) ?? fallback;\n    }\n    setTemporaryValues(data, namespace) {\n      if (this.tempStore.has(namespace)) {\n        this.tempStore.get(namespace)?.set(objectToBatchSet(data));\n      } else {\n        this.tempStore.set(namespace, new LocalModel(data));\n      }\n    }\n    clearTemporaryValues(namespace) {\n      if (namespace) {\n        this.tempStore.get(namespace)?.reset();\n      } else {\n        this.tempStore.forEach((value) => {\n          value.reset();\n        });\n      }\n    }\n  };\n  var FlowExpPlugin = class {\n    constructor() {\n      this.name = \"flow-exp-plugin\";\n    }\n    apply(player) {\n      let expressionEvaluator;\n      const handleEval = (exp) => {\n        if (exp) {\n          if (typeof exp === \"object\" && \"exp\" in exp) {\n            expressionEvaluator?.evaluate(exp.exp);\n          } else {\n            expressionEvaluator?.evaluate(exp);\n          }\n        }\n      };\n      player.hooks.expressionEvaluator.tap(this.name, (evaluator) => {\n        expressionEvaluator = evaluator;\n      });\n      player.hooks.flowController.tap(this.name, (fc) => {\n        fc.hooks.flow.tap(this.name, (flow) => {\n          flow.hooks.onStart.tap(this.name, (exp) => handleEval(exp));\n          flow.hooks.onEnd.tap(this.name, (exp) => handleEval(exp));\n          flow.hooks.resolveTransitionNode.intercept({\n            call: (nextState) => {\n              if (nextState?.onStart) {\n                handleEval(nextState.onStart);\n              }\n            }\n          });\n        });\n      });\n    }\n  };\n  var createFormatFunction = (schema) => {\n    const handler = (ctx, value, formatName) => {\n      return schema.getFormatterForType({ type: formatName })?.format(value) ?? value;\n    };\n    return handler;\n  };\n  var DefaultExpPlugin = class {\n    constructor() {\n      this.name = \"flow-exp-plugin\";\n    }\n    apply(player) {\n      let formatFunction;\n      player.hooks.schema.tap(this.name, (schemaController) => {\n        formatFunction = createFormatFunction(schemaController);\n      });\n      player.hooks.expressionEvaluator.tap(this.name, (expEvaluator) => {\n        if (formatFunction) {\n          expEvaluator.addExpressionFunction(\"format\", formatFunction);\n        }\n        expEvaluator.addExpressionFunction(\"log\", (ctx, ...args) => {\n          player.logger.info(...args);\n        });\n        expEvaluator.addExpressionFunction(\"debug\", (ctx, ...args) => {\n          player.logger.debug(...args);\n        });\n        expEvaluator.addExpressionFunction(\n          \"eval\",\n          (ctx, ...args) => {\n            return ctx.evaluate(...args);\n          }\n        );\n      });\n    }\n  };\n  var NOT_STARTED_STATE = {\n    ref: Symbol(\"not-started\"),\n    status: \"not-started\"\n  };\n  var PLAYER_VERSION = \"__VERSION__\";\n  var COMMIT = \"__GIT_COMMIT__\";\n  var _Player = class _Player2 {\n    constructor(config) {\n      this.logger = new TapableLogger();\n      this.constantsController = new ConstantsController();\n      this.state = NOT_STARTED_STATE;\n      this.hooks = {\n        flowController: new SyncHook(),\n        viewController: new SyncHook(),\n        view: new SyncHook(),\n        expressionEvaluator: new SyncHook(),\n        dataController: new SyncHook(),\n        schema: new SyncHook(),\n        validationController: new SyncHook(),\n        bindingParser: new SyncHook(),\n        state: new SyncHook(),\n        onStart: new SyncHook(),\n        onEnd: new SyncHook(),\n        resolveFlowContent: new SyncWaterfallHook()\n      };\n      if (config?.logger) {\n        this.logger.addHandler(config.logger);\n      }\n      this.config = config || {};\n      this.config.plugins = [\n        new DefaultExpPlugin(),\n        ...this.config.plugins || [],\n        new FlowExpPlugin()\n      ];\n      this.config.plugins?.forEach((plugin) => {\n        plugin.apply(this);\n      });\n    }\n    /**  Returns currently registered plugins */\n    getPlugins() {\n      return this.config.plugins ?? [];\n    }\n    /** Find instance of [Plugin] that has been registered to Player */\n    findPlugin(symbol) {\n      return this.config.plugins?.find((el) => el.symbol === symbol);\n    }\n    /** Retrieve an instance of [Plugin] and conditionally invoke [apply] if it exists */\n    applyTo(symbol, apply) {\n      const plugin = this.findPlugin(symbol);\n      if (plugin) {\n        apply(plugin);\n      }\n    }\n    /** Register and apply [Plugin] if one with the same symbol is not already registered. */\n    registerPlugin(plugin) {\n      plugin.apply(this);\n      this.config.plugins?.push(plugin);\n    }\n    /** Returns the current version of the running player */\n    getVersion() {\n      return _Player2.info.version;\n    }\n    /** Returns the git commit used to build Player version */\n    getCommit() {\n      return _Player2.info.commit;\n    }\n    /**\n     * Fetch the current state of Player.\n     * It will return either `not-started`, `in-progress`, `completed`\n     * with some extra data in each\n     */\n    getState() {\n      return this.state;\n    }\n    /**\n     * A private means of setting the state of Player\n     * Calls the hooks for subscribers to listen for this event\n     */\n    setState(state) {\n      this.state = state;\n      this.hooks.state.call(state);\n    }\n    /** Start Player with the given flow */\n    setupFlow(userContent) {\n      const userFlow = this.hooks.resolveFlowContent.call(userContent);\n      const flowController = new FlowController(userFlow.navigation, {\n        logger: this.logger\n      });\n      this.hooks.onStart.call(userFlow);\n      this.hooks.flowController.call(flowController);\n      let expressionEvaluator;\n      let dataController;\n      const pathResolver = new BindingParser({\n        get: (binding) => {\n          return dataController.get(binding);\n        },\n        set: (transaction) => {\n          return dataController.set(transaction);\n        },\n        evaluate: (expression) => {\n          return expressionEvaluator.evaluate(expression);\n        }\n      });\n      this.hooks.bindingParser.call(pathResolver);\n      const parseBinding = pathResolver.parse;\n      const flowResultDeferred = (0, import_p_defer.default)();\n      const schema = new SchemaController(userFlow.schema);\n      this.hooks.schema.call(schema);\n      const validationController = new ValidationController(schema);\n      this.hooks.validationController.call(validationController);\n      dataController = new DataController(userFlow.data, {\n        pathResolver,\n        middleware: validationController.getDataMiddleware(),\n        logger: this.logger\n      });\n      dataController.hooks.format.tap(\"player\", (value, binding) => {\n        const formatter = schema.getFormatter(binding);\n        return formatter ? formatter.format(value) : value;\n      });\n      dataController.hooks.deformat.tap(\"player\", (value, binding) => {\n        const formatter = schema.getFormatter(binding);\n        return formatter ? formatter.deformat(value) : value;\n      });\n      dataController.hooks.resolveDefaultValue.tap(\n        \"player\",\n        (binding) => schema.getApparentType(binding)?.default\n      );\n      let viewController;\n      expressionEvaluator = new ExpressionEvaluator({\n        model: dataController,\n        logger: this.logger\n      });\n      this.hooks.expressionEvaluator.call(expressionEvaluator);\n      expressionEvaluator.hooks.onError.tap(\"player\", (e) => {\n        flowResultDeferred.reject(e);\n        return true;\n      });\n      function resolveStrings(val, formatted) {\n        return resolveDataRefs(val, {\n          model: dataController,\n          evaluate: expressionEvaluator.evaluate,\n          formatted\n        });\n      }\n      flowController.hooks.flow.tap(\"player\", (flow) => {\n        flow.hooks.beforeTransition.tap(\"player\", (state, transitionVal) => {\n          const computedTransitionVal = state.transitions[transitionVal] ? transitionVal : \"*\";\n          if (state.onEnd && state.transitions[computedTransitionVal]) {\n            if (typeof state.onEnd === \"object\" && \"exp\" in state.onEnd) {\n              expressionEvaluator?.evaluate(state.onEnd.exp);\n            } else {\n              expressionEvaluator?.evaluate(state.onEnd);\n            }\n          }\n          if (!(\"transitions\" in state) || !state.transitions[computedTransitionVal]) {\n            return state;\n          }\n          return (0, import_timm8.setIn)(\n            state,\n            [\"transitions\", computedTransitionVal],\n            resolveStrings(state.transitions[computedTransitionVal])\n          );\n        });\n        flow.hooks.skipTransition.tap(\"validation\", (currentState) => {\n          if (currentState?.value.state_type === \"VIEW\") {\n            const { canTransition, validations } = validationController.validateView(\"navigation\");\n            if (!canTransition && validations) {\n              const bindings = new Set(validations.keys());\n              viewController?.currentView?.update(bindings);\n              return true;\n            }\n          }\n          return void 0;\n        });\n        flow.hooks.resolveTransitionNode.tap(\"player\", (state) => {\n          let newState = state;\n          if (\"ref\" in state) {\n            newState = (0, import_timm8.setIn)(state, [\"ref\"], resolveStrings(state.ref));\n          }\n          if (\"param\" in state) {\n            newState = (0, import_timm8.setIn)(\n              state,\n              [\"param\"],\n              resolveStrings(state.param, false)\n            );\n          }\n          return newState;\n        });\n        flow.hooks.transition.tap(\"player\", (_oldState, newState) => {\n          if (newState.value.state_type !== \"VIEW\") {\n            validationController.reset();\n          }\n        });\n        flow.hooks.afterTransition.tap(\"player-action-states\", (flowInstance) => {\n          const value = flowInstance.currentState?.value;\n          if (value && value.state_type === \"ASYNC_ACTION\") {\n            const { exp } = value;\n            try {\n              const result = expressionEvaluator.evaluateAsync(exp);\n              if (isPromiseLike(result)) {\n                if (value.await) {\n                  (0, import_queue_microtask.default)(() => {\n                    result.then((r) => flowController?.transition(String(r))).catch(flowResultDeferred.reject);\n                  });\n                } else {\n                  this.logger.warn(\n                    \"Unawaited promise used as return value in in non-async context, transitioning with '*' value\"\n                  );\n                  flowController?.transition(String(result));\n                }\n              } else {\n                this.logger.warn(\n                  \"Non async expression used in async action node\"\n                );\n                flowController?.transition(String(result));\n              }\n            } catch (e) {\n              flowResultDeferred.reject(e);\n            }\n          } else if (value && value.state_type === \"ACTION\") {\n            const { exp } = value;\n            const result = expressionEvaluator.evaluate(exp);\n            if (isPromiseLike(result)) {\n              this.logger.warn(\n                \"Async expression used as return value in in non-async context, transitioning with '*' value\"\n              );\n            }\n            flowController?.transition(String(result));\n          }\n          expressionEvaluator.reset();\n        });\n      });\n      this.hooks.dataController.call(dataController);\n      validationController.setOptions({\n        parseBinding,\n        model: dataController,\n        logger: this.logger,\n        evaluate: expressionEvaluator.evaluate,\n        constants: this.constantsController\n      });\n      viewController = new ViewController(userFlow.views || [], {\n        evaluator: expressionEvaluator,\n        parseBinding,\n        transition: flowController.transition,\n        model: dataController,\n        utils: {\n          findPlugin: (pluginSymbol) => {\n            return this.findPlugin(pluginSymbol);\n          }\n        },\n        logger: this.logger,\n        flowController,\n        schema,\n        format: (binding, value) => {\n          const formatter = schema.getFormatter(binding);\n          return formatter?.format ? formatter.format(value) : value;\n        },\n        formatValue: (ref, value) => {\n          const formatter = schema.getFormatterForType(ref);\n          return formatter?.format ? formatter.format(value) : value;\n        },\n        validation: {\n          ...validationController.forView(parseBinding),\n          type: (b) => schema.getType(parseBinding(b))\n        },\n        constants: this.constantsController\n      });\n      viewController.hooks.view.tap(\"player\", (view) => {\n        validationController.onView(view);\n        this.hooks.view.call(view);\n      });\n      this.hooks.viewController.call(viewController);\n      return {\n        start: () => {\n          flowController.start().then((endState) => {\n            const flowResult = {\n              endState: resolveStrings(endState, false),\n              data: dataController.serialize()\n            };\n            return flowResult;\n          }).then(flowResultDeferred.resolve).catch((e) => {\n            this.logger.error(`Something went wrong: ${e.message}`);\n            throw e;\n          }).catch(flowResultDeferred.reject).finally(() => this.hooks.onEnd.call());\n        },\n        state: {\n          status: \"in-progress\",\n          flowResult: flowResultDeferred.promise,\n          controllers: {\n            data: dataController,\n            view: viewController,\n            flow: flowController,\n            schema,\n            expression: expressionEvaluator,\n            binding: pathResolver,\n            validation: validationController\n          },\n          fail: flowResultDeferred.reject,\n          flow: userFlow,\n          logger: this.logger\n        }\n      };\n    }\n    async start(payload) {\n      const ref = Symbol(payload?.id ?? \"payload\");\n      const maybeUpdateState = (newState) => {\n        if (this.state.ref !== ref) {\n          this.logger.warn(\n            `Received update for a flow that's not the current one`\n          );\n          return newState;\n        }\n        this.setState(newState);\n        return newState;\n      };\n      this.setState({\n        status: \"not-started\",\n        ref\n      });\n      try {\n        const { state, start } = this.setupFlow(payload);\n        this.setState({\n          ref,\n          ...state\n        });\n        start();\n        const endProps = {\n          ref,\n          status: \"completed\",\n          flow: state.flow,\n          controllers: {\n            data: state.controllers.data.makeReadOnly()\n          }\n        };\n        return maybeUpdateState({\n          ...await state.flowResult,\n          ...endProps\n        });\n      } catch (error) {\n        const errorState = {\n          status: \"error\",\n          ref,\n          flow: payload,\n          error\n        };\n        maybeUpdateState(errorState);\n        throw error;\n      }\n    }\n  };\n  _Player.info = {\n    version: PLAYER_VERSION,\n    commit: COMMIT\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/check-path/core/src/symbols.ts\n  var CheckPathPluginSymbol = Symbol.for(\"CheckPathPlugin\");\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/check-path/core/src/index.ts\n  function createMatcher2(match) {\n    if (typeof match === \"string\" || typeof match === \"number\") {\n      return createMatcher({ type: match });\n    }\n    if (typeof match === \"function\") {\n      return match;\n    }\n    return createMatcher(match);\n  }\n  function getParent(node, viewInfo) {\n    let working = node;\n    while (working.parent && working.parent.type !== NodeType.Asset && working.parent.type !== NodeType.View) {\n      working = working.parent;\n    }\n    const { parent } = working;\n    if (parent && (parent.type === NodeType.Asset || parent.type === NodeType.View)) {\n      return parent;\n    }\n  }\n  var CheckPathPlugin = class {\n    constructor() {\n      this.name = \"check-path\";\n      this.symbol = CheckPathPluginSymbol;\n    }\n    apply(player) {\n      player.hooks.viewController.tap(this.name, (viewController) => {\n        viewController.hooks.view.tap(this.name, (view) => {\n          view.hooks.resolver.tap(this.name, (resolver) => {\n            const viewInfo = {\n              resolvedMap: /* @__PURE__ */ new Map(),\n              assetIdMap: /* @__PURE__ */ new Map(),\n              resolver\n            };\n            this.viewInfo = viewInfo;\n            resolver.hooks.afterResolve.tap(this.name, (value, node) => {\n              const sourceNode = this.getSourceAssetNode(node);\n              if (sourceNode) {\n                viewInfo.resolvedMap.set(sourceNode, {\n                  resolved: node,\n                  value\n                });\n                if (node.type === NodeType.Asset || node.type === NodeType.View) {\n                  const id = dlv_es_default(value, \"id\");\n                  if (id) {\n                    viewInfo.assetIdMap.set(id, node);\n                  }\n                }\n              }\n              return value;\n            });\n          });\n        });\n      });\n    }\n    /**\n     * Starts at the asset with the given id, and walks backwards _up_ the tree until it finds a match for the parent\n     *\n     * @param id - The id of the asset to _start_ at\n     * @param query - A means of matching a parent asset\n     * @returns - The parent object if a match is found, else undefined\n     */\n    getParent(id, query) {\n      const assetNode = this.viewInfo?.assetIdMap.get(id);\n      if (!assetNode || !this.viewInfo) {\n        return void 0;\n      }\n      let potentialMatch = getParent(assetNode);\n      if (query === void 0) {\n        if (potentialMatch) {\n          return this.getAssetFromAssetNode(potentialMatch);\n        }\n        return;\n      }\n      const queryArray = Array.isArray(query) ? [...query] : [query];\n      let parentQuery = queryArray.shift();\n      let depth = 0;\n      while (potentialMatch && parentQuery) {\n        if (depth++ >= 50) {\n          throw new Error(\n            \"Recursion depth exceeded. Check for cycles in the AST graph\"\n          );\n        }\n        const matcher = createMatcher2(parentQuery);\n        const resolved = this.getAssetFromAssetNode(potentialMatch);\n        if (resolved && matcher(resolved)) {\n          if (queryArray.length === 0) {\n            return resolved;\n          }\n          parentQuery = queryArray.shift();\n        }\n        potentialMatch = getParent(potentialMatch);\n      }\n      return void 0;\n    }\n    /**\n     * Returns the property that the asset resides on relative to it's parent\n     *\n     * @param id - The id of the asset to _start_ at\n     * @returns - The property name or undefined if no parent was found\n     */\n    getParentProp(id) {\n      const assetNode = this.viewInfo?.assetIdMap.get(id);\n      if (!assetNode || !this.viewInfo) {\n        return;\n      }\n      let working = assetNode;\n      let parent;\n      while (working) {\n        parent = working?.parent;\n        if (parent && (parent.type === NodeType.Asset || parent.type === NodeType.View)) {\n          break;\n        }\n        working = working?.parent;\n      }\n      if (parent && \"children\" in parent) {\n        const childProp = parent.children?.find(\n          (child) => child.value === working\n        );\n        return childProp?.path?.[0];\n      }\n      return void 0;\n    }\n    /** Given a node, return itself, or the nested asset if the node is an applicability node */\n    getSourceAssetNode(node) {\n      let sourceNode = this.viewInfo?.resolver.getSourceNode(node);\n      if (sourceNode?.type === \"applicability\") {\n        sourceNode = sourceNode.value;\n      }\n      return sourceNode;\n    }\n    /**\n     * Given the starting node, check to verify that the supplied queries are relevant to the current asset's parents.\n     *\n     * @param id - The id of the asset to _start_ at\n     * @returns - true if the context applies, false if it doesn't\n     */\n    hasParentContext(id, query) {\n      return Boolean(this.getParent(id, query));\n    }\n    /** Search the node for any matching paths in the graph that match the query  */\n    findChildPath(node, query, includeSelfMatch = true) {\n      if (query.length === 0) {\n        return true;\n      }\n      const [first, ...rest] = query;\n      const matcher = createMatcher2(first);\n      if (node.type === NodeType.Asset || node.type === NodeType.View || node.type === NodeType.Applicability) {\n        const resolvedValue = this.getResolvedValue(node);\n        const includesSelf = (includeSelfMatch && matcher(resolvedValue)) ?? false;\n        const childQuery = includesSelf ? rest : query;\n        if (childQuery.length === 0 && includesSelf) {\n          return true;\n        }\n        const children = node.type === NodeType.Applicability ? node.value.children : node.children;\n        if (childQuery.length && (!children || children.length === 0)) {\n          return false;\n        }\n        if (children?.some(\n          (childNode) => this.findChildPath(childNode.value, childQuery)\n        )) {\n          return true;\n        }\n      } else if (node.type === NodeType.MultiNode && node.values.some((childNode) => this.findChildPath(childNode, query))) {\n        return true;\n      } else if (\"children\" in node && node.children?.some(\n        (childNode) => this.findChildPath(childNode.value, query)\n      )) {\n        return true;\n      }\n      return false;\n    }\n    /**\n     * Given the starting node, check to verify that the supplied queries are relevant to the current asset's children.\n     *\n     * @param id - The id of the asset to _start_ at\n     * @returns - true if the context applies, false if it doesn't\n     */\n    hasChildContext(id, query) {\n      const assetNode = this.viewInfo?.assetIdMap.get(id);\n      const queryArray = Array.isArray(query) ? [...query] : [query];\n      if (!assetNode) {\n        return false;\n      }\n      return this.findChildPath(assetNode, queryArray, false);\n    }\n    /** Get the asset represented by id */\n    getAsset(id) {\n      const assetNode = this.viewInfo?.assetIdMap.get(id);\n      if (!assetNode)\n        return;\n      return this.getAssetFromAssetNode(assetNode);\n    }\n    /**\n     * Gets the value for an asset from an asset node\n     */\n    getAssetFromAssetNode(assetNode) {\n      const sourceNode = this.getSourceAssetNode(assetNode);\n      if (!sourceNode)\n        return;\n      return this.viewInfo?.resolvedMap.get(sourceNode)?.value;\n    }\n    /**\n     * Get the path of the asset in the view upto\n     * the asset that matches the query or to the view if no query is provided\n     */\n    getPath(id, query) {\n      const assetNode = this.viewInfo?.assetIdMap.get(id);\n      if (!assetNode || !this.viewInfo) {\n        return;\n      }\n      let path = [];\n      let queryArray = [];\n      if (query) {\n        queryArray = Array.isArray(query) ? [...query] : [query];\n      }\n      let parentQuery = queryArray.shift();\n      let working = assetNode;\n      const findWorkingChild = (parent) => {\n        return parent.children?.find((n) => n.value === working);\n      };\n      while (working !== void 0) {\n        const { parent } = working;\n        if (parent) {\n          if (parent.type === NodeType.MultiNode) {\n            const index = parent.values.indexOf(working);\n            if (index !== -1) {\n              const actualIndex = index - parent.values.slice(0, index).reduce(\n                (undefCount, next) => this.getResolvedValue(next) === void 0 ? undefCount + 1 : undefCount,\n                0\n              );\n              path = [actualIndex, ...path];\n            }\n          } else if (\"children\" in parent) {\n            const childProp = findWorkingChild(parent);\n            path = [...childProp?.path ?? [], ...path];\n          }\n          if (parentQuery) {\n            const matcher = createMatcher2(parentQuery);\n            if (matcher(this.getResolvedValue(parent))) {\n              parentQuery = queryArray.shift();\n              if (!parentQuery)\n                return path;\n            }\n          }\n        }\n        working = working.parent;\n      }\n      return parentQuery ? void 0 : path;\n    }\n    getResolvedValue(node) {\n      const sourceNode = this.getSourceAssetNode(node);\n      return this.viewInfo?.resolvedMap.get(sourceNode ?? node)?.value;\n    }\n  };\n  return __toCommonJS(src_exports);\n})();\n/*! Bundled license information:\n\ntimm/lib/timm.js:\n  (*!\n   * Timm\n   *\n   * Immutability helpers with fast reads and acceptable writes.\n   *\n   * @copyright Guillermo Grau Panea 2016\n   * @license MIT\n   *)\n\nqueue-microtask/index.js:\n  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n*/\n","/**\n * Checks if `value` is equal to `check` if `check` is a string or in `check` if check is an Array\n *\n * @param value - the value being searched for\n * @param check - the values to check against\n * @returns `boolean`\n */\nexport function equalToOrIn(value: string, check: string | Array<string>) {\n  if (Array.isArray(check)) {\n    return check.includes(value);\n  }\n\n  return check === value;\n}\n","import { equalToOrIn } from \"./utils\";\n\nexport type Interceptor<Args extends any[], ReturnType, ContextType> = {\n  /** An optional name for the interceptor */\n  name?: string;\n  /** Callback for each loop when used by the hook */\n  loop?: (...args: Args) => void;\n  /** Callback when an error occurs during the hook's call */\n  error?: (err: Error) => void;\n  /** Callback when a result is found for a hook's invocation */\n  result?: (\n    r: ReturnType extends Promise<infer AwaitedValue>\n      ? AwaitedValue\n      : ReturnType\n  ) => void;\n  /** Callback when a hook's call is complete */\n  done?: () => void;\n  /** Callback when a hook is tapped */\n  tap?: (tap: Tap<Args, ReturnType, ContextType>) => void;\n} & (\n  | {\n      /** If context should be omitted from the 'call'. This is the default */\n      context?: false;\n      /** Callback when the hook is tapped without context */\n      call?: (...args: Args) => void;\n    }\n  | {\n      /** If context should be included in the 'call' */\n      context: true;\n      /** Callback when the hook is tapped with context */\n      call?: (context: ContextType, ...args: Args) => void;\n    }\n);\n\nexport type Tap<Args extends any[], ReturnType, ContextType = unknown> = {\n  key: symbol;\n  name: string;\n  before?: string | Array<string>;\n} & (\n  | {\n      context: false;\n      callback: (...args: Args) => ReturnType;\n    }\n  | {\n      context: true;\n      callback: (context: ContextType, ...args: Args) => ReturnType;\n    }\n);\n\ntype BasicTap<Args extends any[], ReturnType, ContextType> = (\n  name: string,\n  callback: (...args: Args) => ReturnType,\n  before?: string | Array<string>\n) => Tap<Args, ReturnType, ContextType>;\n\ntype TapWithContext<Args extends any[], ReturnType, ContextType> =\n  | ((\n      options: {\n        name: string;\n        context?: false;\n        before?: string | Array<string>;\n      },\n      callback: (...args: Args) => ReturnType\n    ) => Tap<Args, ReturnType>)\n  | ((\n      options: {\n        name: string;\n        context: true;\n        before?: string | Array<string>;\n      },\n      callback: (context: ContextType, ...args: Args) => ReturnType\n    ) => Tap<Args, ReturnType>);\n\ninterface SyncBaseHookType<Args extends any[], ReturnType, ContextType> {\n  tap:\n    | BasicTap<Args, ReturnType, ContextType>\n    | TapWithContext<Args, ReturnType, ContextType>;\n  call(...args: Args): void;\n  untap(key: Tap<Args, ReturnType>): void;\n  isUsed(): boolean;\n  intercept(int: Interceptor<Args, ReturnType, ContextType>): void;\n}\n\nfunction callTap<Args extends any[], ReturnType, ContextType>(\n  tap: Tap<Args, ReturnType, ContextType>,\n  args: Args,\n  ctx: ContextType\n) {\n  if (tap.context) {\n    return tap.callback(ctx, ...args);\n  }\n\n  return tap.callback(...args);\n}\n\n/** A manager for all intercepts inside of a tap */\nclass InterceptionManager<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> {\n  protected interceptions: Array<Interceptor<Args, ReturnType, ContextType>>;\n  private interceptionKeySet: Set<\n    keyof Interceptor<Args, ReturnType, ContextType>\n  >;\n\n  constructor() {\n    this.interceptions = [];\n    this.interceptionKeySet = new Set();\n  }\n\n  isUsed() {\n    return this.interceptions.length > 0;\n  }\n\n  intercept(int: Interceptor<Args, ReturnType, ContextType>): void {\n    this.interceptions.push(int);\n    Object.keys(int).forEach((s) => {\n      this.interceptionKeySet.add(s as any);\n    });\n  }\n\n  tap(tap: Tap<Args, ReturnType, ContextType>): void {\n    if (this.interceptionKeySet.has(\"tap\")) {\n      this.interceptions.forEach((i) => {\n        i.tap?.(tap);\n      });\n    }\n  }\n\n  call(ctx: ContextType, ...args: Args): void {\n    if (this.interceptionKeySet.has(\"call\")) {\n      this.interceptions.forEach((i) => {\n        if (i.context) {\n          i.call?.(ctx, ...args);\n        } else {\n          i.call?.(...args);\n        }\n      });\n    }\n  }\n\n  loop(...args: Args): void {\n    if (this.interceptionKeySet.has(\"loop\")) {\n      this.interceptions.forEach((i) => {\n        i.loop?.(...args);\n      });\n    }\n  }\n\n  error(err: unknown): void {\n    if (this.interceptionKeySet.has(\"error\")) {\n      if (err instanceof Error) {\n        const asError: Error = err;\n        this.interceptions.forEach((i) => {\n          i.error?.(asError);\n        });\n      }\n    }\n  }\n\n  result(\n    r: ReturnType extends Promise<infer AwaitedValue>\n      ? AwaitedValue\n      : ReturnType\n  ): void {\n    if (this.interceptionKeySet.has(\"result\")) {\n      this.interceptions.forEach((i) => {\n        i.result?.(r);\n      });\n    }\n  }\n\n  done(): void {\n    if (this.interceptionKeySet.has(\"done\")) {\n      this.interceptions.forEach((i) => {\n        i.done?.();\n      });\n    }\n  }\n}\n\nabstract class Hook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> implements SyncBaseHookType<Args, ReturnType, ContextType>\n{\n  protected taps: Array<Tap<Args, ReturnType, ContextType>>;\n  protected interceptions: InterceptionManager<Args, ReturnType, ContextType>;\n\n  constructor() {\n    this.taps = [];\n    this.interceptions = new InterceptionManager<\n      Args,\n      ReturnType,\n      ContextType\n    >();\n  }\n\n  public tap(\n    options: { name: string; context?: false; before?: string | Array<string> },\n    callback: (...args: Args) => ReturnType\n  ): Tap<Args, ReturnType, ContextType>;\n\n  public tap(\n    options: { name: string; context: true; before?: string | Array<string> },\n    callback: (ctx: ContextType, ...args: Args) => ReturnType\n  ): Tap<Args, ReturnType, ContextType>;\n\n  public tap(\n    name: string,\n    callback: (...args: Args) => ReturnType\n  ): Tap<Args, ReturnType, ContextType>;\n\n  public tap(options: any, callback: any): Tap<Args, ReturnType, ContextType> {\n    const resolvedOptions =\n      typeof options === \"string\"\n        ? {\n            name: options,\n            context: false,\n          }\n        : {\n            context: false,\n            ...options,\n          };\n\n    const key = Symbol(resolvedOptions.name);\n    const tap: Tap<Args, ReturnType, ContextType> = {\n      key,\n      ...resolvedOptions,\n      callback,\n    };\n\n    if (tap.before) {\n      let insertionIndex = this.taps.length;\n      const beforeSet = new Set(\n        Array.isArray(tap.before) ? tap.before : [tap.before]\n      );\n      for (\n        insertionIndex;\n        insertionIndex > 0 && beforeSet.size > 0;\n        insertionIndex--\n      ) {\n        const t = this.taps[insertionIndex - 1];\n        if (beforeSet.has(t.name)) {\n          beforeSet.delete(t.name);\n        }\n\n        if (t.before && equalToOrIn(tap.name, t.before)) {\n          break;\n        }\n      }\n\n      this.taps.splice(insertionIndex, 0, tap);\n    } else {\n      this.taps.push(tap);\n    }\n\n    this.interceptions.tap(tap);\n\n    return tap;\n  }\n\n  abstract call(...args: Args): ReturnType;\n\n  public untap(tap: Tap<Args, ReturnType, ContextType>) {\n    this.taps = this.taps.filter((t) => t.key !== tap.key);\n  }\n\n  public isUsed() {\n    return this.taps.length > 0 || this.interceptions.isUsed();\n  }\n\n  public intercept(int: Interceptor<Args, ReturnType, ContextType>): void {\n    this.interceptions.intercept(int);\n  }\n}\n\nexport class SyncHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, void, ContextType> {\n  public call(...args: Args) {\n    if (!this.isUsed()) {\n      return;\n    }\n\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      this.taps.forEach((t) => {\n        callTap(t, args, ctx);\n      });\n    } catch (err: unknown) {\n      this.interceptions.error(err);\n\n      throw err;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class SyncBailHook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> extends Hook<Args, ReturnType | undefined | null, ContextType> {\n  public call(...args: Args): ReturnType | undefined | null {\n    if (!this.isUsed()) {\n      return;\n    }\n\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n      const rtn = callTap(this.taps[tapIndex], args, ctx);\n      if (rtn !== undefined) {\n        this.interceptions.result(rtn as any);\n        return rtn;\n      }\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class SyncWaterfallHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Args[0], ContextType> {\n  public call(...args: Args): Args[0] {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    // eslint-disable-next-line prefer-const\n    let [rtn, ...rest] = args;\n\n    for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n      const tapValue = callTap(this.taps[tapIndex], [rtn, ...rest] as any, ctx);\n      if (tapValue !== undefined) {\n        rtn = tapValue;\n      }\n    }\n\n    this.interceptions.result(rtn);\n\n    return rtn;\n  }\n}\n\nexport class SyncLoopHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, void, ContextType> {\n  public call(...args: Args) {\n    let finished = false;\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      while (finished !== true) {\n        finished = true;\n        this.interceptions.loop(...args);\n        for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n          const rtn = callTap(this.taps[tapIndex], args, ctx);\n\n          if (rtn !== undefined) {\n            finished = false;\n            break;\n          }\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncParallelHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<void>, ContextType> {\n  public async call(...args: Args): Promise<void> {\n    const ctx: ContextType = {} as any;\n    this.interceptions.call(ctx, ...args);\n\n    await Promise.allSettled(this.taps.map((tap) => callTap(tap, args, ctx)));\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncParallelBailHook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<ReturnType>, ContextType> {\n  public async call(...args: Args): Promise<ReturnType> {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      const rtn = await Promise.race(\n        this.taps.map((tap) => callTap(tap, args, ctx))\n      );\n\n      this.interceptions.result(rtn as any);\n      return rtn;\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n  }\n}\n\nexport class AsyncSeriesHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<void>, ContextType> {\n  public async call(...args: Args): Promise<void> {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        await callTap(this.taps[tapIndex], args, ctx);\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncSeriesBailHook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<ReturnType | undefined | null>, ContextType> {\n  public async call(...args: Args): Promise<ReturnType | undefined | null> {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        const rtn = await callTap(this.taps[tapIndex], args, ctx);\n        if (rtn !== undefined) {\n          this.interceptions.result(rtn);\n          return rtn;\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncSeriesWaterfallHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<Args[0]>, ContextType> {\n  public async call(...args: Args): Promise<Args[0]> {\n    // eslint-disable-next-line prefer-const\n    let [rtn, ...rest] = args;\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        const tapValue = await callTap(\n          this.taps[tapIndex],\n          [rtn, ...rest] as any,\n          ctx\n        );\n        if (tapValue !== undefined) {\n          rtn = tapValue;\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.result(rtn);\n\n    return rtn;\n  }\n}\n\nexport class AsyncSeriesLoopHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<void>, ContextType> {\n  public async call(...args: Args): Promise<void> {\n    let finished = false;\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      while (finished !== true) {\n        finished = true;\n        this.interceptions.loop(...args);\n        for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n          const rtn = await callTap(this.taps[tapIndex], args, ctx);\n\n          if (rtn !== undefined) {\n            finished = false;\n            break;\n          }\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n","export default function dlv(obj, key, def, p, undef) {\n\tkey = key.split ? key.split('.') : key;\n\tfor (p = 0; p < key.length; p++) {\n\t\tobj = obj ? obj[key[p]] : undef;\n\t}\n\treturn obj === undef ? def : obj;\n}\n","var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import dlv from \"dlv\";\n\n/** A function that checks overlapping properties against a reference value */\nexport type Matcher = ((searchObj: object) => boolean) & {\n  /** The count represents the specificity of this matcher */\n  count: number;\n};\n\n/** Traverse an object and collect any key/value pairs including nested keys */\nfunction traverseObj(\n  object: Record<any, any>,\n  path: string[] = [],\n  pairs: Map<string[], any> = new Map(),\n): Map<string[], any> {\n  for (const key of Object.keys(object)) {\n    const val: any = object[key];\n    const nestedPath = [...path, key];\n\n    if (typeof val === \"object\") {\n      traverseObj(val, nestedPath, pairs);\n    } else {\n      pairs.set(nestedPath, val);\n    }\n  }\n\n  return pairs;\n}\n\n/** Given an object, create a function that compares any set key/value pairs in the given object against a new value */\nexport default function createMatcher(partialObj: object): Matcher {\n  // Convert the partial object into a list of [key, value] pairs;\n  const pairs = traverseObj(partialObj);\n\n  /** Generate a function to match against all of the properties we care about */\n  const matchFunction = (searchObj: object) => {\n    for (const entry of Array.from(pairs)) {\n      const [path, value] = entry;\n\n      if (dlv(searchObj, path) !== value) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  // Keep track of the specificity of the comparator\n  matchFunction.count = pairs.size;\n\n  return matchFunction;\n}\n","import SortedArray from \"sorted-array\";\nimport type { Matcher } from \"./deep-partial-matcher\";\nimport createObjectMatcher from \"./deep-partial-matcher\";\n\nexport { default as createObjectMatcher } from \"./deep-partial-matcher\";\n\n/** create a matcher function that matches exactly */\nfunction createBasicMatcher(seed: any): Matcher {\n  /** a simple matcher function that only matches itself */\n  const matcher = (match: any) => seed === match;\n  matcher.count = 1;\n\n  return matcher;\n}\n\ninterface RegistryIndex<V> {\n  /** The original object we wanted to match on  */\n  key: object;\n\n  /** The value to return */\n  value: V;\n\n  /** The matcher function for this entry */\n  matcher: Matcher;\n}\n\n/** create an empty sorted array using the matcher count */\nconst createSortedArray = <V>() =>\n  new SortedArray<RegistryIndex<V>>([], (c) => c.matcher.count);\n\n/**\n * A partial match registry is a map that uses an object to \"match\" against keys.\n * More specific matches take precedence over less specific ones.\n */\nexport class Registry<V> {\n  private store = createSortedArray<V>();\n\n  constructor(initialSet?: Array<[any, V]>) {\n    initialSet?.forEach(([match, value]) => {\n      this.set(match, value);\n    });\n  }\n\n  /** Add match -> value mapping to the registry */\n  set(match: any, value: V) {\n    const matcher =\n      typeof match === \"object\"\n        ? createObjectMatcher(match)\n        : createBasicMatcher(match);\n\n    this.store.insert({\n      key: match,\n      value,\n      matcher,\n    });\n  }\n\n  /** Fetch the best match in the registry */\n  get(query: any): V | undefined {\n    for (const entry of this.store.array) {\n      if (entry.matcher(query)) {\n        return entry.value;\n      }\n    }\n  }\n\n  /** Loop over all entries and run callback */\n  forEach(callbackfn: (value: RegistryIndex<V>) => void): void {\n    for (const entry of this.store.array) {\n      callbackfn(entry);\n    }\n  }\n\n  /** Reset the items in the registry */\n  clear() {\n    this.store = createSortedArray<V>();\n  }\n\n  /** Check if the registry is empty*/\n  isRegistryEmpty() {\n    return this.store.array.length === 0;\n  }\n}\n","import type { BindingLike, BindingInstance } from \"./binding\";\n\n/** Check if the parameter representing a binding is already of the Binding class */\nexport function isBinding(binding: BindingLike): binding is BindingInstance {\n  return !(typeof binding === \"string\" || Array.isArray(binding));\n}\n\n/** Convert the string to an int if you can, otherwise just return the original string */\nexport function maybeConvertToNum(i: string): string | number {\n  const asInt = parseInt(i, 10);\n\n  if (isNaN(asInt)) {\n    return i;\n  }\n\n  return asInt;\n}\n\n/**\n * utility to convert binding into binding segments.\n */\nexport function getBindingSegments(\n  binding: BindingLike,\n): Array<string | number> {\n  if (Array.isArray(binding)) {\n    return binding;\n  }\n\n  if (typeof binding === \"string\") {\n    return binding.split(\".\");\n  }\n\n  return binding.asArray();\n}\n\n/** Like _.findIndex, but ignores types */\nexport function findInArray<T extends Record<string | number, object>>(\n  array: Array<T>,\n  key: string | number,\n  value: T,\n): number | undefined {\n  return array.findIndex((obj) => {\n    if (obj && typeof obj === \"object\") {\n      // Intentional double-equals because we want '4' to be coerced to 4\n      return obj[key] == value;\n    }\n\n    return false;\n  });\n}\n","import { SyncHook } from \"tapable-ts\";\nimport type { BindingLike, BindingFactory } from \"../binding\";\nimport { BindingInstance, isBinding } from \"../binding\";\nimport { NOOP_MODEL } from \"./noop-model\";\n\nexport const ROOT_BINDING = new BindingInstance([]);\nexport type BatchSetTransaction = [BindingInstance, any][];\n\nexport type Updates = Array<{\n  /** The updated binding */\n  binding: BindingInstance;\n\n  /** The old value */\n  oldValue: any;\n\n  /** The new value */\n  newValue: any;\n\n  /** Force the Update to be included even if no data changed */\n  force?: boolean;\n}>;\n\n/** Options to use when getting or setting data */\nexport interface DataModelOptions {\n  /**\n   * The data (either to set or get) should represent a formatted value\n   * For setting data, the data will be de-formatted before continuing in the pipeline\n   * For getting data, the data will be formatted before returning\n   */\n  formatted?: boolean;\n\n  /**\n   * By default, fetching data will ignore any invalid data.\n   * You can choose to grab the queued invalid data if you'd like\n   * This is usually the case for user-inputs\n   */\n  includeInvalid?: boolean;\n\n  /**\n   * A flag to set to ignore any default value in the schema, and just use the raw value\n   */\n  ignoreDefaultValue?: boolean;\n\n  /**\n   * A flag to indicate that this update should happen silently\n   */\n  silent?: boolean;\n\n  /** Other context associated with this request */\n  context?: {\n    /** The data model to use when getting other data from the context of this request */\n    model: DataModelWithParser;\n  };\n}\n\nexport interface DataModelWithParser<Options = DataModelOptions> {\n  get(binding: BindingLike, options?: Options): any;\n  set(transaction: [BindingLike, any][], options?: Options): Updates;\n  delete(binding: BindingLike, options?: Options): void;\n}\n\nexport interface DataModelImpl<Options = DataModelOptions> {\n  get(binding: BindingInstance, options?: Options): any;\n  set(transaction: BatchSetTransaction, options?: Options): Updates;\n  delete(binding: BindingInstance, options?: Options): void;\n}\n\nexport interface DataModelMiddleware {\n  /** The name of the middleware */\n  name?: string;\n\n  set(\n    transaction: BatchSetTransaction,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ): Updates;\n\n  get(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ): any;\n\n  delete?(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ): void;\n\n  reset?(): void;\n}\n\n/** Wrap the inputs of the DataModel with calls to parse raw binding inputs */\nexport function withParser<Options = unknown>(\n  model: DataModelImpl<Options>,\n  parseBinding: BindingFactory,\n): DataModelWithParser<Options> {\n  /** Parse something into a binding if it requires it */\n  function maybeParse(\n    binding: BindingLike,\n    readOnly: boolean,\n  ): BindingInstance {\n    const parsed = isBinding(binding)\n      ? binding\n      : parseBinding(binding, {\n          get: model.get,\n          set: model.set,\n          readOnly,\n        });\n\n    if (!parsed) {\n      throw new Error(\"Unable to parse binding\");\n    }\n\n    return parsed;\n  }\n\n  return {\n    get(binding, options?: Options) {\n      return model.get(maybeParse(binding, true), options);\n    },\n    set(transaction, options?: Options) {\n      return model.set(\n        transaction.map(([key, val]) => [maybeParse(key, false), val]),\n        options,\n      );\n    },\n    delete(binding, options?: Options) {\n      return model.delete(maybeParse(binding, false), options);\n    },\n  };\n}\n\n/** Wrap a middleware instance in a DataModel compliant API */\nexport function toModel(\n  middleware: DataModelMiddleware,\n  defaultOptions?: DataModelOptions,\n  next?: DataModelImpl,\n): DataModelImpl {\n  if (!next) {\n    return middleware as DataModelImpl;\n  }\n\n  return {\n    get: (binding: BindingInstance, options?: DataModelOptions) => {\n      const resolvedOptions = options ?? defaultOptions;\n\n      if (middleware.get) {\n        return middleware.get(binding, resolvedOptions, next);\n      }\n\n      return next?.get(binding, resolvedOptions);\n    },\n    set: (transaction: BatchSetTransaction, options?: DataModelOptions) => {\n      const resolvedOptions = options ?? defaultOptions;\n\n      if (middleware.set) {\n        return middleware.set(transaction, resolvedOptions, next);\n      }\n\n      return next?.set(transaction, resolvedOptions);\n    },\n    delete: (binding: BindingInstance, options?: DataModelOptions) => {\n      const resolvedOptions = options ?? defaultOptions;\n\n      if (middleware.delete) {\n        return middleware.delete(binding, resolvedOptions, next);\n      }\n\n      return next?.delete(binding, resolvedOptions);\n    },\n  };\n}\n\nexport type DataPipeline = Array<DataModelMiddleware | DataModelImpl>;\n\n/**\n * Given a set of steps in a pipeline, create the effective data-model\n */\nexport function constructModelForPipeline(\n  pipeline: DataPipeline,\n): DataModelImpl {\n  if (pipeline.length === 0) {\n    return NOOP_MODEL;\n  }\n\n  if (pipeline.length === 1) {\n    return toModel(pipeline[0]);\n  }\n\n  /** Default and propagate the options into the nested calls */\n  function createModelWithOptions(options?: DataModelOptions) {\n    const model: DataModelImpl =\n      pipeline.reduce<DataModelImpl | undefined>(\n        (nextModel, middleware) => toModel(middleware, options, nextModel),\n        undefined,\n      ) ?? NOOP_MODEL;\n\n    return model;\n  }\n\n  return {\n    get: (binding: BindingInstance, options?: DataModelOptions) => {\n      return createModelWithOptions(options)?.get(binding, options);\n    },\n    set: (transaction, options) => {\n      return createModelWithOptions(options)?.set(transaction, options);\n    },\n    delete: (binding, options) => {\n      return createModelWithOptions(options)?.delete(binding, options);\n    },\n  };\n}\n\n/** A DataModel that manages middleware data handlers  */\nexport class PipelinedDataModel implements DataModelImpl {\n  private pipeline: DataPipeline;\n  private effectiveDataModel: DataModelImpl;\n\n  public readonly hooks = {\n    onSet: new SyncHook<[BatchSetTransaction]>(),\n  };\n\n  constructor(pipeline: DataPipeline = []) {\n    this.pipeline = pipeline;\n    this.effectiveDataModel = constructModelForPipeline(this.pipeline);\n  }\n\n  public setMiddleware(handlers: DataPipeline) {\n    this.pipeline = handlers;\n    this.effectiveDataModel = constructModelForPipeline(handlers);\n  }\n\n  public addMiddleware(handler: DataModelMiddleware) {\n    this.pipeline = [...this.pipeline, handler];\n    this.effectiveDataModel = constructModelForPipeline(this.pipeline);\n  }\n\n  public reset(model = {}) {\n    this.pipeline.forEach((middleware) => {\n      if (\"reset\" in middleware) {\n        middleware.reset?.();\n      }\n    });\n\n    this.set([[ROOT_BINDING, model]]);\n  }\n\n  public set(\n    transaction: BatchSetTransaction,\n    options?: DataModelOptions,\n  ): Updates {\n    const appliedTransaction = this.effectiveDataModel.set(\n      transaction,\n      options,\n    );\n    this.hooks.onSet.call(transaction);\n    return appliedTransaction;\n  }\n\n  public get(binding: BindingInstance, options?: DataModelOptions): any {\n    return this.effectiveDataModel.get(binding, options);\n  }\n\n  public delete(binding: BindingInstance, options?: DataModelOptions): void {\n    return this.effectiveDataModel.delete(binding, options);\n  }\n}\n","import type { DataModelWithParser } from \"../data\";\nimport type { Logger } from \"../logger\";\n\nexport type ExpressionObjectType = {\n  /** The expression to eval */\n  value: BasicExpressionTypes;\n};\n\nexport type ExpressionLiteralType =\n  | string\n  | number\n  | boolean\n  | undefined\n  | null;\n\nexport type BasicExpressionTypes =\n  | ExpressionLiteralType\n  | ExpressionObjectType\n  | Array<ExpressionLiteralType | ExpressionObjectType>;\n\nexport type ExpressionType = BasicExpressionTypes | ExpressionNode;\n\nexport interface OperatorProcessingOptions {\n  /**\n   * When set to a falsy value, the arguments passed to the handler will be raw AST Nodes\n   * This enables lazy evaluation of arguments\n   */\n  resolveParams: boolean;\n\n  /**\n   * Whether the expression should be allowed to be evaluated asynchronously\n   */\n  async?: boolean;\n}\n\nexport type BinaryOperatorBasic = (\n  left: any,\n  right: any,\n  async: boolean,\n) => unknown;\nexport type BinaryOperatorAdvanced = OperatorProcessingOptions &\n  ((ctx: ExpressionContext, left: any, right: any, async: boolean) => unknown);\n\nexport type BinaryOperator = BinaryOperatorAdvanced | BinaryOperatorBasic;\n\nexport type UnaryOperator =\n  | ((arg: any, async: boolean) => unknown)\n  | (((ctx: ExpressionContext, arg: any, async: boolean) => unknown) &\n      OperatorProcessingOptions);\n\nexport interface ExpressionContext {\n  /** A means of executing an expression */\n  evaluate: (expr: ExpressionType) => unknown;\n\n  /** The data model that expression handlers can use when fetching data */\n  model: DataModelWithParser;\n\n  /** A logger to use */\n  logger?: Logger;\n}\n\nexport type ExpressionHandler<\n  T extends readonly unknown[] = unknown[],\n  R = void,\n> = ((context: ExpressionContext, ...args: T) => R) &\n  Partial<OperatorProcessingOptions>;\n\nexport const ExpNodeOpaqueIdentifier: unique symbol =\n  Symbol(\"Expression Node ID\");\n\n/** Checks if the input is an already processed Expression node */\nexport function isExpressionNode(x: any): x is ExpressionNode {\n  return (\n    typeof x === \"object\" &&\n    x !== null &&\n    !Array.isArray(x) &&\n    x.__id === ExpNodeOpaqueIdentifier\n  );\n}\n\nexport interface NodePosition {\n  /** The character location */\n  character: number;\n}\n\nexport interface NodeLocation {\n  // We only care about the character offset, not the line/column for now\n  // But making these objects allows us to add more (like line number) later\n\n  /** The start of the node */\n  start: NodePosition;\n\n  /** The end of the node */\n  end: NodePosition;\n}\n\nexport interface BaseNode<T> {\n  /** The thing to discriminate the AST type on */\n  type: T;\n\n  /** How to tell this apart from other objects */\n  __id: typeof ExpNodeOpaqueIdentifier;\n\n  /** The location of the node in the source expression string */\n  location?: NodeLocation;\n\n  /**\n   * The error that occurred while parsing this node\n   * This is only set if the parsing mode is set to non-strict\n   */\n  error?: Error;\n}\n\n/** A helper interface for nodes that container left and right children */\nexport interface DirectionalNode {\n  /** The left node. Often for the left hand side of an expression */\n  left: ExpressionNode;\n\n  /** The right child. Often for the right hand side of an expression */\n  right: ExpressionNode;\n}\n\nexport interface LiteralNode extends BaseNode<\"Literal\"> {\n  /** A node that holds a literal value */\n  value: string | number;\n\n  /** The unprocessed value */\n  raw?: any;\n}\n\nexport interface BinaryNode\n  extends BaseNode<\"BinaryExpression\">,\n    DirectionalNode {\n  /** The operation to perform on the nodes */\n  operator: string;\n}\n\nexport interface LogicalNode\n  extends BaseNode<\"LogicalExpression\">,\n    DirectionalNode {\n  /** The logical operation to perform on the nodes */\n  operator: string;\n}\n\nexport interface UnaryNode extends BaseNode<\"UnaryExpression\"> {\n  /** The operation to perform on the node */\n  operator: string;\n\n  /** The single argument that the operation should be performed on */\n  argument: ExpressionNode;\n}\n\nexport type ThisNode = BaseNode<\"ThisExpression\">;\n\nexport interface ModelRefNode extends BaseNode<\"ModelRef\"> {\n  /** The binding that the model reference points to */\n  ref: string;\n}\n\nexport interface ObjectNode extends BaseNode<\"Object\"> {\n  /**  */\n  attributes: Array<{\n    /** The property name of the object */\n    key: ExpressionNode;\n\n    /** the associated value */\n    value: ExpressionNode;\n  }>;\n}\n\nexport interface MemberExpressionNode extends BaseNode<\"MemberExpression\"> {\n  /** The object to be introspected */\n  object: ExpressionNode;\n\n  /** If the property uses . or open-bracket */\n  computed: boolean;\n\n  /** The property to access on the object */\n  property: ExpressionNode;\n}\n\nexport interface ConditionalExpressionNode\n  extends BaseNode<\"ConditionalExpression\"> {\n  /** The test for the ternary */\n  test: ExpressionNode;\n\n  /** The truthy case for the ternary */\n  consequent: ExpressionNode;\n\n  /** The falsy case for the ternary */\n  alternate: ExpressionNode;\n}\n\nexport interface CompoundNode extends BaseNode<\"Compound\"> {\n  /** The contents of the compound expression */\n  body: ExpressionNode[];\n}\n\nexport interface CallExpressionNode extends BaseNode<\"CallExpression\"> {\n  /** The arguments to the function */\n  args: ExpressionNode[];\n\n  /** The function name */\n  callTarget: IdentifierNode;\n}\n\nexport interface ArrayExpressionNode extends BaseNode<\"ArrayExpression\"> {\n  /** The items in an array */\n  elements: ExpressionNode[];\n}\n\nexport interface IdentifierNode extends BaseNode<\"Identifier\"> {\n  /** The variable name */\n  name: string;\n}\n\nexport type AssignmentNode = BaseNode<\"Assignment\"> & DirectionalNode;\n\nexport interface ModificationNode\n  extends BaseNode<\"Modification\">,\n    DirectionalNode {\n  /** The operator for the modification */\n  operator: string;\n}\n\nexport type ExpressionNode =\n  | LiteralNode\n  | BinaryNode\n  | LogicalNode\n  | UnaryNode\n  | ThisNode\n  | ModelRefNode\n  | MemberExpressionNode\n  | ConditionalExpressionNode\n  | CompoundNode\n  | CallExpressionNode\n  | ArrayExpressionNode\n  | IdentifierNode\n  | AssignmentNode\n  | ModificationNode\n  | ObjectNode;\n\nexport type ExpressionNodeType = ExpressionNode[\"type\"];\n\nexport interface ErrorWithLocation extends Error {\n  /** The place in the string where the error occurs */\n  index: number;\n\n  /** a helpful description */\n  description: string;\n}\n","/**\n * An expression to AST parser based on JSEP: http://jsep.from.so/\n */\nimport type {\n  ErrorWithLocation,\n  ExpressionNode,\n  ExpressionNodeType,\n  NodeLocation,\n} from \"./types\";\nimport { ExpNodeOpaqueIdentifier } from \"./types\";\n\nconst PERIOD_CODE = 46; // '.'\nconst COMMA_CODE = 44; // ','\nconst SQUOTE_CODE = 39; // Single quote\nconst DQUOTE_CODE = 34; // Double quotes\nconst OPAREN_CODE = 40; // (\nconst CPAREN_CODE = 41; // )\nconst OBRACK_CODE = 91; // [\nconst CBRACK_CODE = 93; // ]\nconst QUMARK_CODE = 63; // ?\nconst SEMCOL_CODE = 59; // ;\nconst COLON_CODE = 58; // :\nconst OCURL_CODE = 123; // {\nconst CCURL_CODE = 125; // }\n\n// Operations\n// ----------\n\n// Set `t` to `true` to save space (when minified, not gzipped)\nconst t = true;\n\n// Use a quickly-accessible map to store all of the unary operators\n// Values are set to `true` (it really doesn't matter)\nconst unaryOps = { \"-\": t, \"!\": t, \"~\": t, \"+\": t };\n\n// Also use a map for the binary operations but set their values to their\n// binary precedence for quick reference:\n// see [Operator precedence](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\nconst binaryOps: Record<string, number> = {\n  \"=\": 3,\n  \"+=\": 3,\n  \"-=\": 3,\n  \"&=\": 3,\n  \"|=\": 3,\n  // Conditional: 4,\n  \"||\": 5,\n  \"&&\": 6,\n  \"|\": 7,\n  \"^\": 8,\n  \"&\": 9,\n  \"==\": 10,\n  \"!=\": 10,\n  \"===\": 10,\n  \"!==\": 10,\n  \"<\": 11,\n  \">\": 11,\n  \"<=\": 11,\n  \">=\": 11,\n  \"<<\": 12,\n  \">>\": 12,\n  \">>>\": 12,\n  \"+\": 13,\n  \"-\": 13,\n  \"*\": 14,\n  \"/\": 14,\n  \"%\": 14,\n};\n\n/** Wrap the message and index in an error and throw it */\nfunction throwError(message: string, index: number): ErrorWithLocation {\n  const err = new Error(`${message} at character ${index}`);\n\n  (err as ErrorWithLocation).index = index;\n  (err as ErrorWithLocation).description = message;\n\n  throw err;\n}\n\n/** Create a new location marker that spans both nodes */\nfunction createSpanningLocation(start?: NodeLocation, end?: NodeLocation) {\n  if (!start || !end) {\n    return;\n  }\n\n  return {\n    start: start.start,\n    end: end.end,\n  };\n}\n\n/** Get return the longest key length of any object */\nfunction getMaxKeyLen(obj: object): number {\n  let maxLen = 0;\n\n  Object.keys(obj).forEach((key) => {\n    if (key.length > maxLen && Object.prototype.hasOwnProperty.call(obj, key)) {\n      maxLen = key.length;\n    }\n  });\n\n  return maxLen;\n}\n\nconst maxUnopLen = getMaxKeyLen(unaryOps);\nconst maxBinopLen = getMaxKeyLen(binaryOps);\n\n// Literals\n// ----------\n// Store the values to return for the various literals we may encounter\nconst literals = {\n  true: true,\n  false: false,\n  null: null,\n  undefined,\n} as const;\n\n// Except for `this`, which is special. This could be changed to something like `'self'` as well\nconst thisStr = \"this\";\n\n/** Returns the precedence of a binary operator or `0` if it isn't a binary operator */\nfunction binaryPrecedence(opVal: string): number {\n  return binaryOps[opVal] || 0;\n}\n\n/**\n * Utility function (gets called from multiple places)\n * Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions\n */\nfunction createBinaryExpression(\n  operator: string | boolean,\n  left: string,\n  right: string,\n  location?: NodeLocation,\n) {\n  let type: ExpressionNodeType;\n\n  if (operator === \"||\" || operator === \"&&\") {\n    type = \"LogicalExpression\";\n  } else if (operator === \"=\") {\n    type = \"Assignment\";\n  } else if (\n    operator === \"+=\" ||\n    operator === \"-=\" ||\n    operator === \"&=\" ||\n    operator === \"|=\"\n  ) {\n    type = \"Modification\";\n  } else {\n    type = \"BinaryExpression\";\n  }\n\n  return {\n    __id: ExpNodeOpaqueIdentifier,\n    type,\n    operator,\n    left,\n    right,\n    location,\n  };\n}\n\n/** `ch` is a character code in the next three functions */\nfunction isDecimalDigit(ch: number) {\n  return ch >= 48 && ch <= 57; // 0...9\n}\n\n/** Check if the char is the character code for the start of an identifier */\nfunction isIdentifierStart(ch: number) {\n  return (\n    ch === 36 ||\n    ch === 95 || // `$` and `_`\n    (ch >= 65 && ch <= 90) || // A...Z\n    (ch >= 97 && ch <= 122)\n  ); // A...z\n}\n\n/** Check if the char code is still a valid identifier portion */\nfunction isIdentifierPart(ch: number) {\n  return (\n    ch === 36 ||\n    ch === 95 || // `$` and `_`\n    (ch >= 65 && ch <= 90) || // A...Z\n    (ch >= 97 && ch <= 122) || // A...z\n    (ch >= 48 && ch <= 57)\n  ); // 0...9\n}\n\n/** Check if the 2 chars are the start of a model reference */\nfunction isModelRefStart(ch0: number, ch1: number) {\n  return ch0 === OCURL_CODE && ch1 === OCURL_CODE; // '{{'\n}\n\n/** Parse out an expression from the string */\nexport function parseExpression(\n  expr: string,\n  options?: {\n    /** If true (the default), will throw on invalid expressions */\n    strict?: boolean;\n  },\n): ExpressionNode {\n  const strictMode = options?.strict ?? true;\n\n  // `index` stores the character number we are currently at while `length` is a constant\n  // All of the gobbles below will modify `index` as we move along\n  const charAtFunc = expr.charAt;\n  const charCodeAtFunc = expr.charCodeAt;\n  const { length } = expr;\n\n  let index = 0;\n\n  /** Create a location object  */\n  const getLocation = (startChar: number) => {\n    return {\n      start: {\n        character: startChar,\n      },\n      end: {\n        character: index,\n      },\n    };\n  };\n\n  /** Grab the char at the index from the expression */\n  function exprI(i: number) {\n    return charAtFunc.call(expr, i);\n  }\n\n  /** Grab the unicode char at the index in the expression */\n  function exprICode(i: number) {\n    return charCodeAtFunc.call(expr, i);\n  }\n\n  /**\n   * Gobble an object and store the object in an attributes array\n   */\n  function gobbleObjects() {\n    const attributes: Array<{\n      /** The property name of the object */\n      key: any;\n\n      /** the associated value */\n      value: any;\n    }> = [];\n    let closed = false;\n\n    let shouldDefineKey = true;\n    let key;\n    let value;\n    let chCode;\n    const startCharIndex = index;\n\n    // get rid of OCURL_CODE\n    ++index;\n\n    while (index < length) {\n      gobbleSpaces();\n      chCode = exprICode(index);\n      // check for end\n      if (chCode === CCURL_CODE) {\n        // if we are at the end but a key was defined\n        if (key) {\n          throwError(\"A key was defined but a value was not\", index);\n        }\n\n        index++;\n        closed = true;\n        break;\n      } else if (shouldDefineKey) {\n        // check for key\n        if (chCode !== SQUOTE_CODE && chCode !== DQUOTE_CODE) {\n          throwError(\"An object must start wtih a key\", index);\n        }\n\n        // get key\n        key = gobbleStringLiteral();\n        // remove spaces\n        gobbleSpaces();\n        // remove colon\n        if (exprICode(index) === COLON_CODE) {\n          index++;\n          shouldDefineKey = false;\n        } else {\n          throwError(\"A colon must follow an object key\", index);\n        }\n      } else {\n        value = gobbleExpression();\n\n        attributes.push({ key, value });\n        gobbleSpaces();\n        chCode = exprICode(index);\n        if (chCode === COMMA_CODE) {\n          index++;\n        } else if (chCode !== CCURL_CODE) {\n          throwError(\"Please add a comma to add another key\", index);\n        }\n\n        shouldDefineKey = true;\n        key = undefined;\n        value = undefined;\n      }\n\n      chCode = exprICode(index);\n    }\n\n    // throw error if object is not closed\n    if (!closed) {\n      throwError(`Unclosed brace in object`, index);\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Object\",\n      attributes,\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  /**\n   * Push `index` up to the next non-space character\n   */\n  function gobbleSpaces() {\n    let ch = exprICode(index);\n    // Space or tab\n    while (ch === 32 || ch === 9) {\n      ch = exprICode(++index);\n    }\n  }\n\n  /**\n   * The main parsing function. Much of this code is dedicated to ternary expressions\n   */\n  function gobbleExpression(): ExpressionNode {\n    const test = gobbleBinaryExpression();\n    gobbleSpaces();\n    const startCharIndex = index;\n\n    if (index < length && exprICode(index) === QUMARK_CODE) {\n      // Ternary expression: test ? consequent : alternate\n      index++;\n      const consequent = gobbleExpression();\n\n      if (!consequent) {\n        throwError(\"Expected expression\", index);\n      }\n\n      gobbleSpaces();\n\n      if (exprICode(index) === COLON_CODE) {\n        index++;\n        const alternate = gobbleExpression();\n\n        if (!alternate) {\n          throwError(\"Expected expression\", index);\n        }\n\n        return {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"ConditionalExpression\",\n          test,\n          consequent,\n          alternate,\n          location: getLocation(startCharIndex),\n        };\n      }\n\n      throwError(\"Expected :\", index);\n    }\n\n    return test;\n  }\n\n  /**\n   * Search for the operation portion of the string (e.g. `+`, `===`)\n   * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n   * and move down from 3 to 2 to 1 character until a matching binary operation is found\n   * then, return that binary operation\n   */\n  function gobbleBinaryOp() {\n    gobbleSpaces();\n\n    let toCheck = expr.substr(index, maxBinopLen);\n    let tcLen = toCheck.length;\n\n    while (tcLen > 0) {\n      if (Object.prototype.hasOwnProperty.call(binaryOps, toCheck)) {\n        index += tcLen;\n        return toCheck;\n      }\n\n      toCheck = toCheck.substr(0, --tcLen);\n    }\n\n    return false;\n  }\n\n  /**\n   * This function is responsible for gobbling an individual expression,\n   * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n   */\n  function gobbleBinaryExpression() {\n    let node;\n    let prec;\n    let i;\n\n    // First, try to get the leftmost thing\n    // Then, check to see if there's a binary operator operating on that leftmost thing\n    let left = gobbleToken();\n    let biop = gobbleBinaryOp();\n\n    // If there wasn't a binary operator, just return the leftmost node\n    if (!biop) {\n      return left;\n    }\n\n    // Otherwise, we need to start a stack to properly place the binary operations in their\n    // precedence structure\n    let biopInfo = { value: biop, prec: binaryPrecedence(biop) };\n    let right = gobbleToken();\n\n    if (!right) {\n      throwError(`Expected expression after ${biop}`, index);\n    }\n\n    const stack = [left, biopInfo, right];\n\n    // Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n    biop = gobbleBinaryOp();\n    while (biop) {\n      prec = binaryPrecedence(biop);\n\n      if (prec === 0) {\n        break;\n      }\n\n      biopInfo = { value: biop, prec };\n\n      // Reduce: make a binary expression from the three topmost entries.\n      while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n        right = stack.pop();\n        biop = stack.pop().value;\n        left = stack.pop();\n        node = createBinaryExpression(\n          biop,\n          left,\n          right,\n          createSpanningLocation(left.location, right.location),\n        );\n        stack.push(node);\n      }\n\n      node = gobbleToken();\n\n      if (!node) {\n        throwError(`Expected expression after ${biop}`, index);\n      }\n\n      stack.push(biopInfo, node);\n      biop = gobbleBinaryOp();\n    }\n\n    i = stack.length - 1;\n    node = stack[i];\n\n    while (i > 1) {\n      node = createBinaryExpression(\n        stack[i - 1].value,\n        stack[i - 2],\n        node,\n        createSpanningLocation(stack[i - 2].location, node.location),\n      );\n      i -= 2;\n    }\n\n    return node;\n  }\n\n  /**\n   * An individual part of a binary expression:\n   * e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n   */\n  function gobbleToken(): any {\n    gobbleSpaces();\n    const ch = exprICode(index);\n    const startCharIndex = index;\n\n    if (isDecimalDigit(ch) || ch === PERIOD_CODE) {\n      // Char code 46 is a dot `.` which can start off a numeric literal\n      return gobbleNumericLiteral();\n    }\n\n    if (ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\n      // Single or double quotes\n      return gobbleStringLiteral();\n    }\n\n    if (isIdentifierStart(ch) || ch === OPAREN_CODE) {\n      // Open parenthesis\n      // `foo`, `bar.baz`\n      return gobbleVariable();\n    }\n\n    if (ch === OBRACK_CODE) {\n      return gobbleArray();\n    }\n\n    if (isModelRefStart(ch, exprICode(index + 1))) {\n      return gobbleModelRef();\n    }\n\n    // not a double bracket: {{}} but if its a single {}\n    if (ch === OCURL_CODE) {\n      return gobbleObjects();\n    }\n\n    let toCheck = expr.substr(index, maxUnopLen);\n    let tcLen = toCheck.length;\n\n    while (tcLen > 0) {\n      if (Object.prototype.hasOwnProperty.call(unaryOps, toCheck)) {\n        index += tcLen;\n        return {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"UnaryExpression\",\n          operator: toCheck,\n          argument: gobbleToken(),\n          prefix: true,\n          location: getLocation(startCharIndex),\n        };\n      }\n\n      toCheck = toCheck.substr(0, --tcLen);\n    }\n\n    return false;\n  }\n\n  /**\n   * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n   * keep track of everything in the numeric literal and then calling `parseFloat` on that string\n   */\n  function gobbleNumericLiteral() {\n    let num = \"\";\n    const startCharIndex = index;\n\n    while (isDecimalDigit(exprICode(index))) {\n      num += exprI(index++);\n    }\n\n    if (exprICode(index) === PERIOD_CODE) {\n      // Can start with a decimal marker\n      num += exprI(index++);\n\n      while (isDecimalDigit(exprICode(index))) {\n        num += exprI(index++);\n      }\n    }\n\n    let ch = exprI(index);\n    if (ch === \"e\" || ch === \"E\") {\n      // Exponent marker\n      num += exprI(index++);\n      ch = exprI(index);\n\n      if (ch === \"+\" || ch === \"-\") {\n        // Exponent sign\n        num += exprI(index++);\n      }\n\n      while (isDecimalDigit(exprICode(index))) {\n        // Exponent itself\n        num += exprI(index++);\n      }\n\n      if (!isDecimalDigit(exprICode(index - 1))) {\n        throwError(`Expected exponent (${num}${exprI(index)})`, index);\n      }\n    }\n\n    const chCode = exprICode(index);\n    // Check to make sure this isn't a variable name that start with a number (123abc)\n    if (isIdentifierStart(chCode)) {\n      throwError(\n        `Variable names cannot start with a number (${num}${exprI(index)})`,\n        index,\n      );\n    } else if (chCode === PERIOD_CODE) {\n      throwError(\"Unexpected period\", index);\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Literal\",\n      value: parseFloat(num),\n      raw: num,\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  /**\n   * Parses a string literal, staring with single or double quotes with basic support for escape codes\n   * e.g. `\"hello world\"`, `'this is\\nJSEP'`\n   */\n  function gobbleStringLiteral() {\n    const quote = exprI(index++);\n    let str = \"\";\n    let closed = false;\n    const startCharIndex = index;\n\n    while (index < length) {\n      let ch = exprI(index++);\n\n      if (ch === quote) {\n        closed = true;\n        break;\n      }\n\n      if (ch !== \"\\\\\") {\n        str += ch;\n        continue;\n      }\n\n      // Check for all of the common escape codes\n      ch = exprI(index++);\n\n      switch (ch) {\n        case \"n\":\n          str += \"\\n\";\n          break;\n        case \"r\":\n          str += \"\\r\";\n          break;\n        case \"t\":\n          str += \"\\t\";\n          break;\n        case \"b\":\n          str += \"\\b\";\n          break;\n        case \"f\":\n          str += \"\\f\";\n          break;\n        case \"v\":\n          str += \"\\u000B\";\n          break;\n        default:\n      }\n    }\n\n    if (!closed) {\n      throwError(`Unclosed quote after \"${str}\"`, index);\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Literal\",\n      value: str,\n      raw: `${quote}${str}${quote}`,\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  /**\n   * Model refs are bindings wrapped in 2 sets of double curlys\n   * e.g. {{foo.bar.ref}}\n   */\n  function gobbleModelRef() {\n    let str = \"\";\n    let closed = false;\n    let openBraceCount = 1;\n    const startCharIndex = index;\n\n    index += 2; // Skip the {{\n    while (index < length) {\n      const ch = exprI(index++);\n\n      if (ch === \"}\" && exprICode(index) === CCURL_CODE) {\n        index++;\n        openBraceCount--;\n\n        if (openBraceCount === 0) {\n          closed = true;\n          break;\n        }\n\n        str += \"}}\";\n      } else if (ch === \"{\" && exprICode(index) === OCURL_CODE) {\n        openBraceCount++;\n        str += \"{{\";\n        index++;\n      } else {\n        str += ch;\n      }\n    }\n\n    if (!closed) {\n      throwError(`Unclosed brace after \"${str}\"`, index);\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"ModelRef\",\n      ref: str,\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  /**\n   * Gobbles only identifiers\n   * e.g.: `foo`, `_value`, `$x1`\n   * Also, this function checks if that identifier is a literal:\n   * (e.g. `true`, `false`, `null`) or `this`\n   */\n  function gobbleIdentifier() {\n    const start = index;\n    let ch = exprICode(start);\n\n    if (isIdentifierStart(ch)) {\n      index++;\n    } else {\n      throwError(`Unexpected ${exprI(index)}`, index);\n    }\n\n    while (index < length) {\n      ch = exprICode(index);\n      if (isIdentifierPart(ch)) {\n        index++;\n      } else {\n        break;\n      }\n    }\n\n    const identifier = expr.slice(start, index);\n\n    if (Object.prototype.hasOwnProperty.call(literals, identifier)) {\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Literal\",\n        value: (literals as any)[identifier],\n        raw: identifier,\n        location: getLocation(start),\n      };\n    }\n\n    if (identifier === thisStr) {\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"ThisExpression\",\n        location: getLocation(start),\n      };\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Identifier\",\n      name: identifier,\n      location: getLocation(start),\n    };\n  }\n\n  /**\n   * Gobbles a list of arguments within the context of a function call\n   * or array literal. This function also assumes that the opening character\n   * `(` or `[` has already been gobbled, and gobbles expressions and commas\n   * until the terminator character `)` or `]` is encountered.\n   * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n   */\n  function gobbleArguments(termination: number) {\n    const args = [];\n    let charIndex;\n    let node;\n\n    while (index < length) {\n      gobbleSpaces();\n      charIndex = exprICode(index);\n\n      if (charIndex === termination) {\n        // Done parsing\n        index++;\n        break;\n      }\n\n      if (charIndex === COMMA_CODE) {\n        // Between expressions\n        index++;\n        continue;\n      }\n\n      node = gobbleExpression();\n\n      if (!node || node.type === \"Compound\") {\n        throwError(\"Expected comma\", index);\n      }\n\n      args.push(node);\n    }\n\n    if (strictMode && charIndex !== termination) {\n      throwError(`Expected ${String.fromCharCode(termination)}`, index);\n    }\n\n    return args;\n  }\n\n  /**\n   * Gobble a non-literal variable name. This variable name may include properties\n   * e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n   * It also gobbles function calls:\n   * e.g. `Math.acos(obj.angle)`\n   */\n  function gobbleVariable(): ExpressionNode {\n    let charIndex = exprICode(index);\n    let node: any =\n      charIndex === OPAREN_CODE ? gobbleGroup() : gobbleIdentifier();\n    const startCharIndex = index;\n    gobbleSpaces();\n    charIndex = exprICode(index);\n\n    while (\n      charIndex === PERIOD_CODE ||\n      charIndex === OBRACK_CODE ||\n      charIndex === OPAREN_CODE\n    ) {\n      index++;\n\n      if (charIndex === PERIOD_CODE) {\n        gobbleSpaces();\n\n        node = {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"MemberExpression\",\n          computed: false,\n          object: node,\n          property: gobbleIdentifier(),\n          location: getLocation(startCharIndex),\n        };\n      } else if (charIndex === OBRACK_CODE) {\n        node = {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"MemberExpression\",\n          computed: true,\n          object: node,\n          property: gobbleExpression(),\n          location: getLocation(startCharIndex),\n        };\n\n        gobbleSpaces();\n        charIndex = exprICode(index);\n\n        if (charIndex !== CBRACK_CODE) {\n          throwError(\"Unclosed [\", index);\n        }\n\n        index++;\n      } else if (charIndex === OPAREN_CODE) {\n        // A function call is being made; gobble all the arguments\n        node = {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"CallExpression\",\n          args: gobbleArguments(CPAREN_CODE),\n          callTarget: node,\n          location: getLocation(startCharIndex),\n        };\n      }\n\n      gobbleSpaces();\n      charIndex = exprICode(index);\n    }\n\n    return node;\n  }\n\n  /**\n   * Responsible for parsing a group of things within parentheses `()`\n   * This function assumes that it needs to gobble the opening parenthesis\n   * and then tries to gobble everything within that parenthesis, assuming\n   * that the next thing it should see is the close parenthesis. If not,\n   * then the expression probably doesn't have a `)`\n   */\n  function gobbleGroup() {\n    index++;\n    const node = gobbleExpression();\n    gobbleSpaces();\n\n    if (exprICode(index) === CPAREN_CODE) {\n      index++;\n      return node;\n    }\n\n    throwError(\"Unclosed (\", index);\n  }\n\n  /**\n   * Responsible for parsing Array literals `[1, 2, 3]`\n   * This function assumes that it needs to gobble the opening bracket\n   * and then tries to gobble the expressions as arguments.\n   */\n  function gobbleArray() {\n    const startCharIndex = index;\n    index++;\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"ArrayExpression\",\n      elements: gobbleArguments(CBRACK_CODE),\n      location: getLocation(startCharIndex),\n    };\n  }\n\n  const nodes = [];\n\n  try {\n    while (index < length) {\n      const chIndex = exprICode(index);\n\n      // Expressions can be separated by semicolons, commas, or just inferred without any\n      // separators\n      if (chIndex === SEMCOL_CODE || chIndex === COMMA_CODE) {\n        index++; // ignore separators\n        continue;\n      }\n\n      const node = gobbleExpression();\n\n      // Try to gobble each expression individually\n      if (node) {\n        nodes.push(node);\n        // If we weren't able to find a binary expression and are out of room, then\n        // the expression passed in probably has too much\n      } else if (strictMode && index < length) {\n        throwError(`Unexpected \"${exprI(index)}\"`, index);\n      }\n    }\n\n    // If there's only one expression just try returning the expression\n    if (nodes.length === 1) {\n      return nodes[0];\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Compound\",\n      body: nodes,\n      location: getLocation(0),\n    };\n  } catch (e) {\n    if (strictMode || !(e instanceof Error)) {\n      throw e;\n    }\n\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Compound\",\n      body: nodes,\n      location: getLocation(0),\n      error: e,\n    };\n  }\n}\n","/**\n * Promise detection that handles various Promise implementations\n * and reduces false positives from objects with coincidental 'then' methods\n */\nexport function isPromiseLike(value: any): value is Promise<any> {\n  return (\n    value != null &&\n    typeof value === \"object\" &&\n    typeof value.then === \"function\" &&\n    // Additional safeguards against false positives\n    (value instanceof Promise ||\n      // Check for standard Promise constructor name\n      value.constructor?.name === \"Promise\" ||\n      // Verify it has other Promise-like methods to reduce false positives\n      (typeof value.catch === \"function\" &&\n        typeof value.finally === \"function\"))\n  );\n}\n\n/** Unique private symbol to indicate async functions wrapped in Player's await function */\nexport const AwaitableSymbol: unique symbol = Symbol(\"Awaitable\");\n\n/**\n * Wrapper for Promises that are generated from the `await` function with a unique symbol so we can\n * determine when a promise should be awaited by us (as its returned by await) or a promise thats\n * generated from any async function\n */\nexport interface Awaitable<T> extends Promise<T> {\n  /** Prevent unwrapped then from being exposed from underlying promise */\n  then: never;\n  /** Internalally awaitable wrapper around underlying then function */\n  awaitableThen<TResult1 = T, TResult2 = never>(\n    onfulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?:\n      | ((reason: any) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null,\n  ): Promise<TResult1 | TResult2>;\n  /** Symbol to identify this as something returned by await */\n  [AwaitableSymbol]: symbol;\n}\n\n/** Typeguard for AwaitableResult */\nexport function isAwaitable(val: unknown): val is Awaitable<any> {\n  return (\n    isPromiseLike(val) && (val as Awaitable<any>)[AwaitableSymbol] !== undefined\n  );\n}\n\n/**\n * Wraps Promise.all in AwaitableResult wrapper to allow internal functions to await internally produced promises\n */\nexport function collateAwaitable<T extends readonly unknown[] | []>(\n  promises: T,\n): Awaitable<any> {\n  const result = Promise.all(promises) as Promise<any>;\n  return makeAwaitable(result);\n}\n\n/**\n * Add AwaitableSymbol to base promise and promise returned by then() function\n */\nexport function makeAwaitable(promise: Promise<any>): Awaitable<any> {\n  (promise as Awaitable<any>)[AwaitableSymbol] = AwaitableSymbol;\n  (promise as any).awaitableThen = (arg: any) => {\n    return makeAwaitable(promise.then(arg));\n  };\n  return promise as Awaitable<any>;\n}\n","import { isExpressionNode } from \"./types\";\nimport type {\n  ErrorWithLocation,\n  ExpressionHandler,\n  ExpressionNode,\n  ExpressionObjectType,\n  ExpressionType,\n  NodeLocation,\n  NodePosition,\n} from \"./types\";\n\n/** Generates a function by removing the first context argument */\nexport function withoutContext<T extends unknown[], Return>(\n  fn: (...args: T) => Return,\n): ExpressionHandler<T, Return> {\n  return (_context, ...args) => fn(...args);\n}\n\n/** Checks if the location includes the target position  */\nfunction isInRange(position: NodePosition, location: NodeLocation) {\n  return (\n    position.character >= location.start.character &&\n    position.character <= location.end.character\n  );\n}\n\n/** Get the node in the expression that's closest to the desired position */\nexport function findClosestNodeAtPosition(\n  node: ExpressionNode,\n  position: NodePosition,\n): ExpressionNode | undefined {\n  // This is just mapping recursively over nodes in the tree\n\n  switch (node.type) {\n    case \"Modification\":\n    case \"Assignment\":\n    case \"LogicalExpression\":\n    case \"BinaryExpression\": {\n      const check =\n        findClosestNodeAtPosition(node.left, position) ??\n        findClosestNodeAtPosition(node.right, position);\n      if (check) {\n        return check;\n      }\n\n      break;\n    }\n\n    case \"UnaryExpression\": {\n      const checkArg = findClosestNodeAtPosition(node.argument, position);\n      if (checkArg) {\n        return checkArg;\n      }\n\n      break;\n    }\n\n    case \"MemberExpression\": {\n      const checkObject =\n        findClosestNodeAtPosition(node.object, position) ??\n        findClosestNodeAtPosition(node.property, position);\n      if (checkObject) {\n        return checkObject;\n      }\n\n      break;\n    }\n\n    case \"ConditionalExpression\": {\n      const checkObject =\n        findClosestNodeAtPosition(node.test, position) ??\n        findClosestNodeAtPosition(node.consequent, position) ??\n        findClosestNodeAtPosition(node.alternate, position);\n      if (checkObject) {\n        return checkObject;\n      }\n\n      break;\n    }\n\n    case \"ArrayExpression\":\n    case \"Compound\": {\n      const elements =\n        node.type === \"ArrayExpression\" ? node.elements : node.body;\n\n      const anyElements = elements.find((e) =>\n        findClosestNodeAtPosition(e, position),\n      );\n\n      if (anyElements) {\n        return anyElements;\n      }\n\n      break;\n    }\n\n    case \"Object\": {\n      const checkObject = node.attributes.reduce<ExpressionNode | undefined>(\n        (found, next) => {\n          return (\n            found ??\n            findClosestNodeAtPosition(next.key, position) ??\n            findClosestNodeAtPosition(next.value, position)\n          );\n        },\n        undefined,\n      );\n\n      if (checkObject) {\n        return checkObject;\n      }\n\n      break;\n    }\n\n    case \"CallExpression\": {\n      const anyArgs =\n        node.args.find((arg) => {\n          return findClosestNodeAtPosition(arg, position);\n        }) ?? findClosestNodeAtPosition(node.callTarget, position);\n\n      if (anyArgs) {\n        return anyArgs;\n      }\n\n      break;\n    }\n  }\n\n  // Lastly check for yourself\n  if (node.location && isInRange(position, node.location)) {\n    return node;\n  }\n}\n\n/** Checks if the expression is a simple type */\nexport function isObjectExpression(\n  expr: ExpressionType,\n): expr is ExpressionObjectType {\n  if (isExpressionNode(expr)) {\n    return false;\n  }\n\n  return (\n    typeof expr === \"object\" &&\n    expr !== null &&\n    !Array.isArray(expr) &&\n    \"value\" in expr\n  );\n}\n\n/**\n * Type guard for ErrorWithLocation\n */\nexport function isErrorWithLocation(error: Error): error is ErrorWithLocation {\n  return (\n    (error as ErrorWithLocation).index !== undefined &&\n    (error as ErrorWithLocation).description !== undefined\n  );\n}\n","import { SyncWaterfallHook, SyncBailHook } from \"tapable-ts\";\nimport { NestedError } from \"ts-nested-error\";\nimport { parseExpression } from \"./parser\";\nimport * as DEFAULT_EXPRESSION_HANDLERS from \"./evaluator-functions\";\nimport { collateAwaitable, isAwaitable, isPromiseLike } from \"./async\";\nimport { isExpressionNode } from \"./types\";\nimport { isObjectExpression } from \"./utils\";\nimport type {\n  ExpressionNode,\n  BinaryOperator,\n  UnaryOperator,\n  ExpressionType,\n  ExpressionContext,\n  ExpressionHandler,\n} from \"./types\";\n\n/** a && b -- but handles short cutting if the first value is false */\nconst andandOperator: BinaryOperator = (ctx, a, b, async) => {\n  return LogicalOperators.and(ctx, a, b, async);\n};\nandandOperator.resolveParams = false;\n\n/** a || b -- but with short cutting if first value is true */\nconst ororOperator: BinaryOperator = (ctx, a, b, async) => {\n  return LogicalOperators.or(ctx, a, b, async);\n};\nororOperator.resolveParams = false;\n\nconst DEFAULT_BINARY_OPERATORS: Record<string, BinaryOperator> = {\n  // TODO: A lot of these functions used to do type coercion. Not sure if we want to keep that behavior or not.\n  \"+\": (a: any, b: any) => a + b,\n  \"-\": (a: any, b: any) => a - b,\n  \"*\": (a: any, b: any) => a * b,\n  \"/\": (a: any, b: any) => a / b,\n  \"%\": (a: any, b: any) => a % b,\n\n  // Promise-aware comparison operators\n  // eslint-disable-next-line\n  \"==\": makePromiseAwareBinaryOp((a: any, b: any) => a == b),\n  // eslint-disable-next-line\n  \"!=\": makePromiseAwareBinaryOp((a: any, b: any) => a != b),\n  \">\": makePromiseAwareBinaryOp((a: any, b: any) => a > b),\n  \">=\": makePromiseAwareBinaryOp((a: any, b: any) => a >= b),\n  \"<\": makePromiseAwareBinaryOp((a: any, b: any) => a < b),\n  \"<=\": makePromiseAwareBinaryOp((a: any, b: any) => a <= b),\n  \"!==\": makePromiseAwareBinaryOp((a: any, b: any) => a !== b),\n  \"===\": makePromiseAwareBinaryOp((a: any, b: any) => a === b),\n\n  \"&&\": andandOperator,\n  \"||\": ororOperator,\n\n  // eslint-disable-next-line\n  \"|\": (a: any, b: any) => a | b,\n\n  // eslint-disable-next-line\n  \"&\": (a: any, b: any) => a & b,\n  \"+=\": (a: any, b: any) => a + b,\n  \"-=\": (a: any, b: any) => a - b,\n\n  // eslint-disable-next-line\n  \"&=\": (a: any, b: any) => a & b,\n\n  // eslint-disable-next-line\n  \"|=\": (a: any, b: any) => a | b,\n};\n\nconst DEFAULT_UNARY_OPERATORS: Record<string, UnaryOperator> = {\n  \"-\": (a: any) => -a,\n  \"+\": (a: any) => Number(a),\n  \"!\": makePromiseAwareUnaryOp((a: any) => !a),\n};\n\n/**\n * Higher-order function that makes any binary operation Promise-aware\n */\nfunction makePromiseAwareBinaryOp<T>(\n  operation: (a: any, b: any) => T,\n): (a: any, b: any, async: boolean) => T | Promise<T> {\n  return (a: any, b: any, async: boolean) => {\n    //async handler\n    if (async && (isAwaitable(a) || isAwaitable(b))) {\n      return collateAwaitable([\n        Promise.resolve(a),\n        Promise.resolve(b),\n      ]).awaitableThen(([resolvedA, resolvedB]) =>\n        operation(resolvedA, resolvedB),\n      );\n    }\n    //sync handler\n    return operation(a, b);\n  };\n}\n\n/**\n * Higher-order function that makes any unary operation Promise-aware\n */\nfunction makePromiseAwareUnaryOp<T>(\n  operation: (a: any) => T,\n): (a: any, async: boolean) => T | Promise<T> {\n  return (a: any, async: boolean) => {\n    //async handler\n    if (async && isAwaitable(a)) {\n      return a.awaitableThen((resolved: any) => operation(resolved));\n    }\n    //sync handler\n    return operation(a);\n  };\n}\n\n/**\n * Utility for handling conditional branching with Promises\n */\nfunction handleConditionalBranching(\n  testValue: any,\n  getTrueBranch: () => any,\n  getFalseBranch: () => any,\n  resolveNode: (node: any) => any,\n  async: boolean,\n): any {\n  //async handler\n  if (async && isAwaitable(testValue)) {\n    return testValue.awaitableThen((resolved: boolean) => {\n      const branch = resolved ? getTrueBranch() : getFalseBranch();\n      const branchResult = resolveNode(branch);\n      return isAwaitable(branchResult)\n        ? Promise.resolve(branchResult)\n        : branchResult;\n    });\n  }\n\n  // sync handler\n  const branch = testValue ? getTrueBranch() : getFalseBranch();\n  return resolveNode(branch);\n}\n\n/**\n * Utility for handling collections (arrays/objects) with potential Promises\n */\nconst PromiseCollectionHandler = {\n  /**\n   * Handle array with potential Promise elements\n   */\n  handleArray<T>(items: T[], async: boolean): T[] | Promise<T[]> {\n    if (!async) {\n      return items;\n    }\n    const hasPromises = items.some((item) => isAwaitable(item));\n    return hasPromises ? collateAwaitable(items) : items;\n  },\n\n  /**\n   * Handle object with potential Promise keys/values\n   */\n  handleObject(\n    attributes: Array<{ key: any; value: any }>,\n    resolveNode: (node: any) => any,\n    async: boolean,\n  ): Record<string, any> | Promise<Record<string, any>> {\n    const resolvedAttributes: Record<string, any> = {};\n    const promises: Promise<void>[] = [];\n    let hasPromises = false;\n\n    attributes.forEach((attr) => {\n      const key = resolveNode(attr.key);\n      const value = resolveNode(attr.value);\n\n      //async handler\n      if (async && (isAwaitable(key) || isAwaitable(value))) {\n        hasPromises = true;\n        const keyPromise = Promise.resolve(key);\n        const valuePromise = Promise.resolve(value);\n\n        promises.push(\n          collateAwaitable([keyPromise, valuePromise]).awaitableThen(\n            ([resolvedKey, resolvedValue]) => {\n              resolvedAttributes[resolvedKey] = resolvedValue;\n            },\n          ),\n        );\n      } else {\n        resolvedAttributes[key] = value;\n      }\n    });\n\n    return hasPromises\n      ? collateAwaitable(promises).awaitableThen(() => resolvedAttributes)\n      : resolvedAttributes;\n  },\n};\n\n/**\n * Smart logical operators that handle short-circuiting with Promises\n */\nconst LogicalOperators = {\n  and: (ctx: any, leftNode: any, rightNode: any, async: boolean) => {\n    const leftResult = ctx.evaluate(leftNode);\n\n    if (async && isAwaitable(leftResult)) {\n      return leftResult.awaitableThen((awaitedLeft: any) => {\n        if (!awaitedLeft) return awaitedLeft; // Short circuit\n        const rightResult = ctx.evaluate(rightNode);\n        return isAwaitable(rightResult)\n          ? rightResult\n          : Promise.resolve(rightResult);\n      });\n    }\n\n    // Sync short-circuiting\n    return leftResult && ctx.evaluate(rightNode);\n  },\n\n  or: (ctx: any, leftNode: any, rightNode: any, async: boolean) => {\n    const leftResult = ctx.evaluate(leftNode);\n\n    if (async && isAwaitable(leftResult)) {\n      return leftResult.awaitableThen((awaitedLeft: any) => {\n        if (awaitedLeft) return awaitedLeft; // Short circuit\n        const rightResult = ctx.evaluate(rightNode);\n        return isAwaitable(rightResult)\n          ? rightResult\n          : Promise.resolve(rightResult);\n      });\n    }\n\n    // Sync short-circuiting\n    return leftResult || ctx.evaluate(rightNode);\n  },\n};\n\nexport interface HookOptions extends ExpressionContext {\n  /** Given an expression node  */\n  resolveNode: (node: ExpressionNode) => any;\n\n  /** Enabling this flag skips calling the onError hook, and just throws errors back to the caller.\n   * The caller is responsible for handling the error.\n   */\n  throwErrors?: boolean;\n\n  /** Whether expressions should be parsed strictly or not */\n  strict?: boolean;\n\n  /** Whether the expression should be evaluated asynchronously */\n  async?: boolean;\n}\n\nexport type ExpressionEvaluatorOptions = Omit<\n  HookOptions,\n  \"resolveNode\" | \"evaluate\"\n>;\n\nexport type ExpressionEvaluatorFunction = (\n  exp: ExpressionType,\n  options?: ExpressionEvaluatorOptions,\n) => any;\n\n/**\n * The expression evaluator is responsible for parsing and executing anything in the custom expression language\n * */\nexport class ExpressionEvaluator {\n  private readonly vars: Record<string, any> = {};\n  public readonly hooks: {\n    resolve: SyncWaterfallHook<[any, ExpressionNode, HookOptions]>;\n    resolveOptions: SyncWaterfallHook<[HookOptions]>;\n    beforeEvaluate: SyncWaterfallHook<[ExpressionType, HookOptions]>;\n    onError: SyncBailHook<[Error], true>;\n  } = {\n    /** Resolve an AST node for an expression to a value */\n    resolve: new SyncWaterfallHook<[any, ExpressionNode, HookOptions]>(),\n    /** Gets the options that will be passed in calls to the resolve hook */\n    resolveOptions: new SyncWaterfallHook<[HookOptions]>(),\n    /** Allows users to change the expression to be evaluated before processing */\n    beforeEvaluate: new SyncWaterfallHook<[ExpressionType, HookOptions]>(),\n    /**\n     * An optional means of handling an error in the expression execution\n     * Return true if handled, to stop propagation of the error\n     */\n    onError: new SyncBailHook<[Error], true>(),\n  };\n\n  private readonly expressionsCache: Map<string, ExpressionNode> = new Map();\n\n  private readonly defaultHookOptions: HookOptions;\n\n  public readonly operators: {\n    binary: Map<string, BinaryOperator>;\n    unary: Map<string, UnaryOperator>;\n    expressions: Map<string, ExpressionHandler<any, any>>;\n  } = {\n    binary: new Map<string, BinaryOperator>(\n      Object.entries(DEFAULT_BINARY_OPERATORS),\n    ),\n    unary: new Map<string, UnaryOperator>(\n      Object.entries(DEFAULT_UNARY_OPERATORS),\n    ),\n    expressions: new Map<string, ExpressionHandler<any, any>>([\n      ...Object.entries(DEFAULT_EXPRESSION_HANDLERS),\n      [\"await\", DEFAULT_EXPRESSION_HANDLERS.waitFor],\n    ]),\n  };\n\n  public reset(): void {\n    this.expressionsCache.clear();\n  }\n\n  constructor(defaultOptions: ExpressionEvaluatorOptions) {\n    this.defaultHookOptions = {\n      ...defaultOptions,\n      evaluate: (expr) => this.evaluate(expr, this.defaultHookOptions),\n      resolveNode: (node: ExpressionNode) =>\n        this._execAST(node, this.defaultHookOptions),\n    };\n\n    this.hooks.resolve.tap(\"ExpressionEvaluator\", (result, node, options) => {\n      return this._resolveNode(result, node, options);\n    });\n    this.evaluate = this.evaluate.bind(this);\n  }\n\n  public evaluate(\n    expr: ExpressionType,\n    options?: ExpressionEvaluatorOptions,\n  ): any {\n    const resolvedOpts = this.hooks.resolveOptions.call({\n      ...this.defaultHookOptions,\n      ...options,\n      resolveNode: (node: ExpressionNode) => this._execAST(node, resolvedOpts),\n    });\n\n    let expression = this.hooks.beforeEvaluate.call(expr, resolvedOpts) ?? expr;\n\n    // Unwrap any returned expression type\n    // Since this could also be an object type, we need to recurse through it until we find the end\n    while (isObjectExpression(expression)) {\n      expression = expression.value;\n    }\n\n    // Check for literals\n    if (\n      typeof expression === \"number\" ||\n      typeof expression === \"boolean\" ||\n      expression === undefined ||\n      expression === null\n    ) {\n      return expression;\n    }\n\n    // Skip doing anything with objects that are _actually_ just parsed expression nodes\n    if (isExpressionNode(expression)) {\n      return this._execAST(expression, resolvedOpts);\n    }\n\n    if (Array.isArray(expression)) {\n      return expression.reduce(\n        (_nothing, exp) => this.evaluate(exp, options),\n        null,\n      );\n    }\n\n    return this._execString(String(expression), resolvedOpts);\n  }\n\n  /**\n   * Evaluate functions in an async context\n   * @experimental These Player APIs are in active development and may change. Use with caution\n   */\n  public evaluateAsync(\n    expr: ExpressionType,\n    options?: ExpressionEvaluatorOptions,\n  ): Promise<any> {\n    // handle async expression block\n    if (Array.isArray(expr)) {\n      return collateAwaitable(\n        expr.map(async (exp) =>\n          this.evaluate(exp, { ...options, async: true } as any),\n        ),\n      ).awaitableThen((values) => {\n        return values.pop();\n      });\n    } else {\n      return this.evaluate(expr, { ...options, async: true } as any);\n    }\n  }\n\n  public addExpressionFunction<T extends readonly unknown[], R>(\n    name: string,\n    handler: ExpressionHandler<T, R>,\n  ): void {\n    this.operators.expressions.set(name, handler);\n  }\n\n  public addBinaryOperator(operator: string, handler: BinaryOperator): void {\n    this.operators.binary.set(operator, handler);\n  }\n\n  public addUnaryOperator(operator: string, handler: UnaryOperator): void {\n    this.operators.unary.set(operator, handler);\n  }\n\n  public setExpressionVariable(name: string, value: unknown): void {\n    this.vars[name] = value;\n  }\n\n  public getExpressionVariable(name: string): unknown {\n    return this.vars[name];\n  }\n\n  private _execAST(node: ExpressionNode, options: HookOptions): any {\n    return this.hooks.resolve.call(undefined, node, options);\n  }\n\n  private _execString(exp: string, options: HookOptions) {\n    if (exp === \"\") {\n      return exp;\n    }\n\n    const matches = exp.match(/^@\\[(.*)\\]@$/);\n    let matchedExp = exp;\n    if (matches) {\n      const [, matched] = Array.from(matches); // In case the expression was surrounded by @[ ]@\n      if (matched) {\n        matchedExp = matched;\n      }\n    }\n\n    let storedAST: ExpressionNode;\n\n    try {\n      storedAST =\n        this.expressionsCache.get(matchedExp) ??\n        parseExpression(matchedExp, { strict: options.strict });\n      this.expressionsCache.set(matchedExp, storedAST);\n    } catch (e: any) {\n      if (options.throwErrors || !this.hooks.onError.call(e)) {\n        // Only throw the error if it's not handled by the hook, or throwErrors is true\n        throw new NestedError(`Error parsing expression: ${exp}`, e);\n      }\n\n      return;\n    }\n\n    try {\n      return this._execAST(storedAST, options);\n    } catch (e: any) {\n      if (options.throwErrors || !this.hooks.onError.call(e)) {\n        // Only throw the error if it's not handled by the hook, or throwErrors is true\n        throw new NestedError(`Error evaluating expression: ${exp}`, e);\n      }\n    }\n  }\n\n  private _resolveNode(\n    _currentValue: any,\n    node: ExpressionNode,\n    options: HookOptions,\n  ): unknown {\n    const { resolveNode, model } = options;\n    const isAsync = options.async ?? false;\n\n    const expressionContext: ExpressionContext = {\n      ...options,\n      evaluate: (expr) => this.evaluate(expr, options),\n    };\n\n    if (node.type === \"Literal\") {\n      return node.value;\n    }\n\n    if (node.type === \"Identifier\") {\n      return this.vars[node.name];\n    }\n\n    if (node.type === \"Compound\" || node.type === \"ThisExpression\") {\n      throw new Error(`Expression type: ${node.type} is not supported`);\n    }\n\n    if (node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\") {\n      const operator = this.operators.binary.get(node.operator);\n\n      if (operator) {\n        if (\"resolveParams\" in operator) {\n          if (operator.resolveParams === false) {\n            return operator(expressionContext, node.left, node.right, isAsync);\n          }\n\n          const left = resolveNode(node.left);\n          const right = resolveNode(node.right);\n\n          // Handle promises in binary operations\n          if (options.async && (isAwaitable(left) || isAwaitable(right))) {\n            return collateAwaitable([left, right]).awaitableThen(\n              ([leftVal, rightVal]) =>\n                operator(expressionContext, leftVal, rightVal, isAsync),\n            );\n          }\n\n          return operator(expressionContext, left, right, isAsync);\n        }\n\n        const left = resolveNode(node.left);\n        const right = resolveNode(node.right);\n\n        if (options.async && (isAwaitable(left) || isAwaitable(right))) {\n          return collateAwaitable([left, right]).awaitableThen(\n            ([leftVal, rightVal]) => operator(leftVal, rightVal, isAsync),\n          );\n        }\n\n        return operator(left, right, isAsync);\n      }\n\n      return;\n    }\n\n    if (node.type === \"UnaryExpression\") {\n      const operator = this.operators.unary.get(node.operator);\n\n      if (operator) {\n        if (\"resolveParams\" in operator) {\n          if (operator.resolveParams === false) {\n            return operator(expressionContext, node.argument, isAsync);\n          }\n\n          const arg = resolveNode(node.argument);\n\n          if (options.async && isAwaitable(arg)) {\n            return arg.awaitableThen((argVal) =>\n              operator(expressionContext, argVal, isAsync),\n            );\n          }\n\n          return operator(expressionContext, arg, isAsync);\n        }\n\n        const arg = resolveNode(node.argument);\n\n        if (options.async && isAwaitable(arg)) {\n          return arg.awaitableThen((argVal) => operator(argVal, isAsync));\n        }\n\n        return operator(arg, isAsync);\n      }\n\n      return;\n    }\n\n    if (node.type === \"Object\") {\n      return PromiseCollectionHandler.handleObject(\n        node.attributes,\n        resolveNode,\n        options.async || false,\n      );\n    }\n\n    if (node.type === \"CallExpression\") {\n      const expressionName = node.callTarget.name;\n\n      const operator = this.operators.expressions.get(expressionName);\n\n      if (!operator) {\n        throw new Error(`Unknown expression function: ${expressionName}`);\n      }\n\n      if (\n        operator.name === DEFAULT_EXPRESSION_HANDLERS.waitFor.name &&\n        !options.async\n      ) {\n        throw new Error(\"Usage of await outside of async context\");\n      }\n\n      if (\"resolveParams\" in operator && operator.resolveParams === false) {\n        return operator(expressionContext, ...node.args);\n      }\n\n      const args = node.args.map((n) => resolveNode(n));\n\n      // Check if any arguments are promises\n      if (options.async) {\n        const hasPromises = args.some(isAwaitable);\n\n        if (hasPromises) {\n          return collateAwaitable(args).awaitableThen((resolvedArgs) =>\n            operator(expressionContext, ...resolvedArgs),\n          );\n        }\n      }\n\n      return operator(expressionContext, ...args);\n    }\n\n    if (node.type === \"ModelRef\") {\n      return model.get(node.ref, { context: { model: options.model } });\n    }\n\n    if (node.type === \"MemberExpression\") {\n      const obj = resolveNode(node.object);\n      const prop = resolveNode(node.property);\n\n      if (options.async && (isAwaitable(obj) || isAwaitable(prop))) {\n        return collateAwaitable([obj, prop]).awaitableThen(\n          ([objVal, propVal]) => objVal[propVal],\n        );\n      }\n\n      return obj[prop];\n    }\n\n    if (node.type === \"Assignment\") {\n      if (node.left.type === \"ModelRef\") {\n        const value = resolveNode(node.right);\n\n        if (isPromiseLike(value)) {\n          if (options.async && isAwaitable(value)) {\n            return value.awaitableThen((resolvedValue) => {\n              model.set([[(node.left as any).ref, resolvedValue]]);\n              return resolvedValue;\n            });\n          } else {\n            options.logger?.warn(\n              \"Unawaited promise written to mode, this behavior is undefined and may change in future releases\",\n            );\n          }\n        }\n\n        model.set([[(node.left as any).ref, value]]);\n        return value;\n      }\n\n      if (node.left.type === \"Identifier\") {\n        const value = resolveNode(node.right);\n\n        if (options.async && isAwaitable(value)) {\n          return value.awaitableThen((resolvedValue) => {\n            this.vars[(node.left as any).name] = resolvedValue;\n            return resolvedValue;\n          });\n        }\n\n        this.vars[(node.left as any).name] = value;\n        return value;\n      }\n\n      return;\n    }\n\n    if (node.type === \"ConditionalExpression\") {\n      const testResult = resolveNode(node.test);\n\n      return handleConditionalBranching(\n        testResult,\n        () => node.consequent,\n        () => node.alternate,\n        resolveNode,\n        isAsync,\n      );\n    }\n\n    if (node.type === \"ArrayExpression\") {\n      const results = node.elements.map((ele) => resolveNode(ele));\n      return PromiseCollectionHandler.handleArray(results, isAsync);\n    }\n\n    if (node.type === \"Modification\") {\n      const operation = this.operators.binary.get(node.operator);\n\n      if (operation) {\n        let newValue;\n\n        if (\"resolveParams\" in operation) {\n          if (operation.resolveParams === false) {\n            newValue = operation(\n              expressionContext,\n              node.left,\n              node.right,\n              isAsync,\n            );\n          } else {\n            const left = resolveNode(node.left);\n            const right = resolveNode(node.right);\n\n            if (options.async && (isAwaitable(left) || isAwaitable(right))) {\n              newValue = collateAwaitable([left, right]).awaitableThen(\n                ([leftVal, rightVal]) =>\n                  operation(expressionContext, leftVal, rightVal, isAsync),\n              );\n            } else {\n              newValue = operation(expressionContext, left, right, isAsync);\n            }\n          }\n        } else {\n          const left = resolveNode(node.left);\n          const right = resolveNode(node.right);\n\n          if (options.async && (isAwaitable(left) || isAwaitable(right))) {\n            newValue = collateAwaitable([left, right]).awaitableThen(\n              ([leftVal, rightVal]) => operation(leftVal, rightVal, isAsync),\n            );\n          } else {\n            newValue = operation(left, right, isAsync);\n          }\n        }\n\n        if (node.left.type === \"ModelRef\") {\n          if (options.async && isAwaitable(newValue)) {\n            return newValue.awaitableThen((resolvedValue) => {\n              model.set([[(node.left as any).ref, resolvedValue]]);\n              return resolvedValue;\n            });\n          }\n          model.set([[(node.left as any).ref, newValue]]);\n        } else if (node.left.type === \"Identifier\") {\n          if (options.async && isAwaitable(newValue)) {\n            return newValue.awaitableThen((resolvedValue) => {\n              this.vars[(node.left as any).name] = resolvedValue;\n              return resolvedValue;\n            });\n          }\n          this.vars[(node.left as any).name] = newValue;\n        }\n\n        return newValue;\n      }\n\n      return resolveNode(node.left);\n    }\n  }\n}\n","import { SyncWaterfallHook } from \"tapable-ts\";\nimport type { Schema as SchemaType, Formatting } from \"@player-ui/types\";\n\nimport type { BindingInstance } from \"../binding\";\nimport type { ValidationProvider, ValidationObject } from \"../validator\";\nimport type { FormatDefinition, FormatOptions, FormatType } from \"./types\";\n\n/** A function that returns itself */\nconst identify = (val: any) => val;\n\n/** Expand the authored schema into a set of paths -> DataTypes */\nexport function parse(\n  schema: SchemaType.Schema,\n): Map<string, SchemaType.DataTypes> {\n  const expandedPaths = new Map<string, SchemaType.DataTypes>();\n\n  if (!schema.ROOT) {\n    return expandedPaths;\n  }\n\n  const parseQueue: Array<{\n    /** The node to process */\n    node: SchemaType.Node;\n\n    /** The path in the data-model this node represents */\n    path: Array<string>;\n\n    /** A set of visited DataTypes to prevent loops */\n    visited: Set<string>;\n  }> = [{ node: schema.ROOT, path: [], visited: new Set() }];\n\n  while (parseQueue.length > 0) {\n    const next = parseQueue.shift();\n\n    if (!next) {\n      break;\n    }\n\n    const { node, path, visited } = next;\n\n    Object.entries(node).forEach(([prop, type]) => {\n      const nestedPath = [...path, prop];\n\n      const nestedPathStr = nestedPath.join(\".\");\n\n      if (expandedPaths.has(nestedPathStr)) {\n        // We've gone in a loop. Panic\n        throw new Error(\n          \"Path has already been processed. There's either a loop somewhere or a bug\",\n        );\n      }\n\n      if (visited.has(type.type)) {\n        throw new Error(\n          `Path already contained type: ${type.type}. This likely indicates a loop in the schema`,\n        );\n      }\n\n      expandedPaths.set(nestedPathStr, type);\n\n      if (type.isArray) {\n        nestedPath.push(\"[]\");\n      }\n\n      if (type.isRecord) {\n        nestedPath.push(\"{}\");\n      }\n\n      if (type.type && schema[type.type]) {\n        parseQueue.push({\n          path: nestedPath,\n          node: schema[type.type],\n          visited: new Set([...visited, type.type]),\n        });\n      }\n    });\n  }\n\n  return expandedPaths;\n}\n\n/**\n * The Schema is the central hub for all data invariants, and metaData associated with the data-model itself\n * Outside of the types defined in the JSON payload, it doesn't manage or keep any state.\n * It simply servers as an orchestrator for other modules to interface w/ the schema.\n */\nexport class SchemaController implements ValidationProvider {\n  private formatters: Map<string, FormatType<any, any, FormatOptions>> =\n    new Map();\n\n  private types: Map<string, SchemaType.DataType<any>> = new Map();\n  public readonly schema: Map<string, SchemaType.DataTypes> = new Map();\n\n  private bindingSchemaNormalizedCache: Map<BindingInstance, string> =\n    new Map();\n\n  public readonly hooks = {\n    resolveTypeForBinding: new SyncWaterfallHook<\n      [SchemaType.DataTypes | undefined, BindingInstance]\n    >(),\n  };\n\n  constructor(schema?: SchemaType.Schema) {\n    this.schema = schema ? parse(schema) : new Map();\n  }\n\n  public addFormatters(fns: Array<FormatType<any, any, FormatOptions>>) {\n    fns.forEach((def) => {\n      this.formatters.set(def.name, def);\n    });\n  }\n\n  public addDataTypes(types: Array<SchemaType.DataType<any>>) {\n    types.forEach((t) => {\n      this.types.set(t.type, t);\n    });\n  }\n\n  getValidationsForBinding(\n    binding: BindingInstance,\n  ): Array<ValidationObject> | undefined {\n    const typeDef = this.getApparentType(binding);\n\n    if (!typeDef?.validation?.length) {\n      return undefined;\n    }\n\n    // Set the defaults for schema-level validations\n    return typeDef.validation.map((vRef) => ({\n      severity: \"error\",\n      trigger: \"change\",\n      ...vRef,\n    }));\n  }\n\n  private normalizeBinding(binding: BindingInstance): string {\n    const cached = this.bindingSchemaNormalizedCache.get(binding);\n    if (cached) {\n      return cached;\n    }\n\n    let bindingArray = binding.asArray();\n    let normalized = bindingArray\n      .map((p) => (typeof p === \"number\" ? \"[]\" : p))\n      .join(\".\");\n\n    if (normalized) {\n      this.bindingSchemaNormalizedCache.set(binding, normalized);\n      bindingArray = normalized.split(\".\");\n    }\n\n    bindingArray.forEach((item) => {\n      const recordBinding = bindingArray\n        .map((p) => (p === item ? \"{}\" : p))\n        .join(\".\");\n\n      if (this.schema.get(recordBinding)) {\n        this.bindingSchemaNormalizedCache.set(binding, recordBinding);\n        bindingArray = recordBinding.split(\".\");\n        normalized = recordBinding;\n      }\n    });\n\n    return normalized;\n  }\n\n  public getType(binding: BindingInstance): SchemaType.DataTypes | undefined {\n    return this.hooks.resolveTypeForBinding.call(\n      this.schema.get(this.normalizeBinding(binding)),\n      binding,\n    );\n  }\n\n  public getApparentType(\n    binding: BindingInstance,\n  ): SchemaType.DataTypes | undefined {\n    const schemaType = this.getType(binding);\n\n    if (schemaType === undefined) {\n      return undefined;\n    }\n\n    const baseType = this.getTypeDefinition(schemaType?.type);\n\n    if (baseType === undefined) {\n      return schemaType;\n    }\n\n    return {\n      ...baseType,\n      ...schemaType,\n      validation: [\n        ...(schemaType.validation ?? []),\n        ...(baseType.validation ?? []),\n      ],\n    };\n  }\n\n  public getTypeDefinition(dataType: string) {\n    return this.types.get(dataType);\n  }\n\n  public getFormatterForType(\n    formatReference: Formatting.Reference,\n  ): FormatDefinition<unknown, unknown> | undefined {\n    const { type: formatType, ...options } = formatReference;\n\n    const formatter = this.formatters.get(formatType);\n\n    if (!formatter) {\n      return;\n    }\n\n    return {\n      format: formatter.format\n        ? (val) => formatter.format?.(val, options)\n        : identify,\n      deformat: formatter.deformat\n        ? (val) => formatter.deformat?.(val, options)\n        : identify,\n    };\n  }\n\n  /**\n   * Given a binding, fetch a function that's responsible for formatting, and/or de-formatting the data\n   * If no formatter is registered, it will return undefined\n   */\n  public getFormatter(\n    binding: BindingInstance,\n  ): FormatDefinition<unknown, unknown> | undefined {\n    const type = this.getApparentType(binding);\n\n    if (!type?.format) {\n      return undefined;\n    }\n\n    return this.getFormatterForType(type.format);\n  }\n}\n","import { setIn } from \"timm\";\nimport type { Expression } from \"@player-ui/types\";\nimport type { DataModelWithParser } from \"../data\";\n\nconst DOUBLE_OPEN_CURLY = \"{{\";\nconst DOUBLE_CLOSE_CURLY = \"}}\";\n\nexport interface Options {\n  /**\n   * The model to use when resolving refs\n   * Passing `false` will skip trying to resolve any direct model refs ({{foo}})\n   */\n  model: false | DataModelWithParser;\n\n  /**\n   * A function to evaluate an expression\n   * Passing `false` will skip trying to evaluate any expressions (@[ foo() ]@)\n   */\n  evaluate: false | ((exp: Expression) => any);\n\n  /**\n   * Optionaly resolve binding without formatting in case Type format applies\n   */\n  formatted?: boolean;\n}\n\n/** Search the given string for the coordinates of the next expression to resolve */\nexport function findNextExp(str: string) {\n  const expStart = str.indexOf(DOUBLE_OPEN_CURLY);\n\n  if (expStart === -1) {\n    return undefined;\n  }\n\n  let count = 1;\n  let offset = expStart + DOUBLE_OPEN_CURLY.length;\n  let workingString = str.substring(expStart + DOUBLE_OPEN_CURLY.length);\n\n  while (count > 0 && workingString.length > 0) {\n    // Find the next open or close curly\n    const nextCloseCurly = workingString.indexOf(DOUBLE_CLOSE_CURLY);\n\n    // We can't close anything, so there's no point in going on with life.\n    if (nextCloseCurly === -1) {\n      break;\n    }\n\n    const nextOpenCurly = workingString.indexOf(DOUBLE_OPEN_CURLY);\n\n    if (nextOpenCurly !== -1 && nextOpenCurly < nextCloseCurly) {\n      // We've hit another open bracket before closing out the one we want\n      // Move everything over and bump our close count by 1\n      count++;\n      workingString = workingString.substring(\n        nextOpenCurly + DOUBLE_OPEN_CURLY.length,\n      );\n      offset += nextOpenCurly + DOUBLE_OPEN_CURLY.length;\n    } else {\n      // We've hit another closing bracket\n      // Decrement our count and updates offsets\n      count--;\n      workingString = workingString.substring(\n        nextCloseCurly + DOUBLE_CLOSE_CURLY.length,\n      );\n      offset += nextCloseCurly + DOUBLE_CLOSE_CURLY.length;\n    }\n  }\n\n  if (count !== 0) {\n    throw new Error(`Unbalanced {{ and }} in exp: ${str}`);\n  }\n\n  return {\n    start: expStart,\n    end: offset,\n  };\n}\n\n/** Finds any subset of the string wrapped in @[]@ and evaluates it as an expression */\nexport function resolveExpressionsInString(\n  val: string,\n  { evaluate }: Options,\n): string {\n  if (!evaluate) {\n    return val;\n  }\n\n  const expMatch = /@\\[.*?\\]@/;\n  let newVal = val;\n  let match = newVal.match(expMatch);\n\n  while (match !== null) {\n    const expStrWithBrackets = match[0];\n    const matchStart = newVal.indexOf(expStrWithBrackets);\n\n    const expString = expStrWithBrackets.substr(\n      \"@[\".length,\n      expStrWithBrackets.length - \"@[\".length - \"]@\".length,\n    );\n    const expValue = evaluate(expString);\n\n    // The string is only the expression, return the raw value.\n    if (\n      matchStart === 0 &&\n      expStrWithBrackets === val &&\n      typeof expValue !== \"string\"\n    ) {\n      return expValue;\n    }\n\n    newVal =\n      newVal.substr(0, matchStart) +\n      expValue +\n      newVal.substr(matchStart + expStrWithBrackets.length);\n    // remove the surrounding @[]@ to get the expression\n    match = newVal.match(expMatch);\n  }\n\n  return newVal;\n}\n\n/** Return a string with all data model references resolved */\nexport function resolveDataRefsInString(val: string, options: Options): string {\n  const { model, formatted = true } = options;\n  let workingString = resolveExpressionsInString(val, options);\n\n  if (\n    !model ||\n    typeof workingString !== \"string\" ||\n    workingString.indexOf(DOUBLE_OPEN_CURLY) === -1\n  ) {\n    return workingString;\n  }\n\n  while (workingString.indexOf(DOUBLE_OPEN_CURLY) !== -1) {\n    const expLocation = findNextExp(workingString);\n\n    if (!expLocation) {\n      return workingString;\n    }\n\n    const { start, end } = expLocation;\n\n    // Strip out the wrapping curlies from {{binding}} before passing to the model\n    const binding = workingString\n      .substring(\n        start + DOUBLE_OPEN_CURLY.length,\n        end - DOUBLE_OPEN_CURLY.length,\n      )\n      .trim();\n\n    const evaledVal = model.get(binding, { formatted });\n\n    // Exit early if the string is _just_ a model lookup\n    // If the result is a string, we may need further processing for nested bindings\n    if (\n      start === 0 &&\n      end === workingString.length &&\n      typeof evaledVal !== \"string\"\n    ) {\n      return evaledVal;\n    }\n\n    workingString =\n      workingString.substr(0, start) + evaledVal + workingString.substr(end);\n  }\n\n  return workingString;\n}\n\n/** Traverse the thing and replace any model refs */\nfunction traverseObject<T>(val: T, options: Options): T {\n  switch (typeof val) {\n    case \"string\": {\n      return resolveDataRefsInString(val as string, options) as unknown as T;\n    }\n\n    case \"object\": {\n      if (!val) return val;\n      // TODO: Do we care refs in keys?\n      const keys = Object.keys(val);\n      let newVal = val;\n\n      if (keys.length > 0) {\n        keys.forEach((key) => {\n          newVal = setIn(\n            newVal as any,\n            [key],\n            traverseObject((val as any)[key], options),\n          ) as any;\n        });\n      }\n\n      return newVal;\n    }\n\n    default:\n      return val;\n  }\n}\n\n/** Recursively resolve all model refs in whatever you pass in */\nexport function resolveDataRefs<T>(val: T, options: Options): T {\n  return traverseObject(val, options);\n}\n","import type { BindingInstance } from \"../binding\";\n\n/**\n * Remove a binding, and any children from from the map\n * If the binding is an array-item, then it will be spliced from the array and the others will be shifted down\n *\n * @param sourceMap - A map of bindings to values\n * @param binding - The binding to remove from the map\n */\nexport function removeBindingAndChildrenFromMap<T>(\n  sourceMap: Map<BindingInstance, T>,\n  binding: BindingInstance,\n): Map<BindingInstance, T> {\n  const targetMap = new Map(sourceMap);\n\n  const parentBinding = binding.parent();\n  const property = binding.key();\n\n  // Clear out any that are sub-bindings of this binding\n\n  targetMap.forEach((_value, trackedBinding) => {\n    if (binding === trackedBinding || binding.contains(trackedBinding)) {\n      targetMap.delete(trackedBinding);\n    }\n  });\n\n  if (typeof property === \"number\") {\n    // Splice out this index from the rest\n\n    // Order matters here b/c we are shifting items in the array\n    // Start with the smallest index and work our way down\n    const bindingsToRewrite = Array.from(sourceMap.keys())\n      .filter((b) => {\n        if (parentBinding.contains(b)) {\n          const [childIndex] = b.relative(parentBinding);\n          return typeof childIndex === \"number\" && childIndex > property;\n        }\n\n        return false;\n      })\n      .sort();\n\n    bindingsToRewrite.forEach((trackedBinding) => {\n      // If the tracked binding is a sub-binding of the parent binding, then we need to\n      // update the path to reflect the new index\n\n      const [childIndex, ...childPath] = trackedBinding.relative(parentBinding);\n\n      if (typeof childIndex === \"number\") {\n        const newSegments = [childIndex - 1, ...childPath];\n        const newChildBinding = parentBinding.descendent(newSegments);\n        targetMap.set(newChildBinding, targetMap.get(trackedBinding) as T);\n        targetMap.delete(trackedBinding);\n      }\n    });\n  }\n\n  return targetMap;\n}\n","import type { Node } from \"./types\";\n\n/**\n * Checks if there are templated values in the object\n *\n * @param obj - The Parsed Object to check to see if we have a template array type for\n * @param localKey - The key being checked\n */\nexport function hasTemplateValues(obj: any, localKey: string) {\n  return (\n    Object.hasOwnProperty.call(obj, \"template\") &&\n    Array.isArray(obj?.template) &&\n    obj.template.length &&\n    obj.template.find((tmpl: any) => tmpl.output === localKey)\n  );\n}\n\n/** Check to see if the string is a valid switch key */\nexport function hasSwitchKey(localKey: string) {\n  return localKey === \"staticSwitch\" || localKey === \"dynamicSwitch\";\n}\n\n/** Check to see if the string is a valid template key */\nexport function hasTemplateKey(localKey: string) {\n  return localKey === \"template\";\n}\n\n/** Get the ID of the Node if there is one */\nexport function getNodeID(node?: Node.Node | null): string | undefined {\n  if (!node) {\n    return;\n  }\n\n  if (\n    \"value\" in node &&\n    typeof node.value === \"object\" &&\n    typeof node.value?.id === \"string\"\n  ) {\n    return node.value.id;\n  }\n}\n","import type { BindingInstance, BindingLike } from \"../../binding\";\nimport { isBinding } from \"../../binding\";\nimport type { ExpressionType } from \"../../expressions\";\nimport type { Resolve } from \"./types\";\n\n/** Check to see if and of the data-changes affect the given dependencies  */\nexport function caresAboutDataChanges(\n  dataChanges?: Set<BindingInstance>,\n  dependencies?: Set<BindingInstance>,\n) {\n  if (!dataChanges || !dependencies) {\n    return true;\n  }\n\n  const depArray = Array.from(dependencies.values());\n  const dataChangeArray = Array.from(dataChanges.values());\n\n  return (\n    depArray.find(\n      (dep) =>\n        !!dataChangeArray.find(\n          (change) =>\n            change === dep || change.contains(dep) || dep.contains(change),\n        ),\n    ) !== undefined\n  );\n}\n\n/** Convert the options object for a resolver to one for a node */\nexport function toNodeResolveOptions(\n  resolverOptions: Resolve.ResolverOptions,\n): Resolve.NodeResolveOptions {\n  return {\n    ...resolverOptions,\n    data: {\n      model: resolverOptions.model,\n      formatValue: (ref, value) => {\n        if (resolverOptions.formatValue) {\n          return resolverOptions.formatValue(ref, value);\n        }\n\n        return value;\n      },\n      format: (bindingLike: BindingLike, value: any) =>\n        resolverOptions.format\n          ? resolverOptions.format(\n              isBinding(bindingLike)\n                ? bindingLike\n                : resolverOptions.parseBinding(bindingLike),\n              value,\n            )\n          : value,\n    },\n    evaluate: (exp: ExpressionType) =>\n      resolverOptions.evaluator.evaluate(exp, resolverOptions),\n  };\n}\n","import { set } from \"timm\";\nimport { resolveDataRefs } from \"../../string-resolver\";\nimport type { Options } from \"./options\";\nimport type { Node } from \"../parser\";\nimport { NodeType } from \"../parser\";\nimport type { Resolver } from \"../resolver\";\nimport { ViewInstance, ViewPlugin } from \"../view\";\n\n/** Create a function that checks for a start/end sequence in a string */\nconst createPatternMatcher = (start: string, end: string) => {\n  return (testStr: string) => {\n    const startLocation = testStr.indexOf(start);\n\n    if (startLocation === -1) {\n      return false;\n    }\n\n    const endLocation = testStr.indexOf(end);\n\n    if (endLocation === -1) {\n      return false;\n    }\n\n    return startLocation < endLocation;\n  };\n};\n\nconst bindingResolveLookup = createPatternMatcher(\"{{\", \"}}\");\nconst expressionResolveLookup = createPatternMatcher(\"@[\", \"]@\");\n\n/** Check to see if a string contains a reference to dynamic content */\nfunction hasSomethingToResolve(str: string) {\n  return bindingResolveLookup(str) || expressionResolveLookup(str);\n}\n\n/** Resolve data refs in a string if necessary. */\nfunction resolveString(str: string, resolveOptions: Options) {\n  return hasSomethingToResolve(str)\n    ? resolveDataRefs(str, {\n        model: resolveOptions.data.model,\n        evaluate: resolveOptions.evaluate,\n      })\n    : str;\n}\n\n/** Recursively resolve all string references in an object or array */\nexport function resolveAllRefs(\n  node: any,\n  resolveOptions: Options,\n  propertiesToSkip: Set<string | number>,\n): any {\n  if (\n    node === null ||\n    node === undefined ||\n    (typeof node !== \"object\" && typeof node !== \"string\")\n  ) {\n    return node;\n  }\n\n  if (typeof node === \"string\") {\n    return resolveString(node, resolveOptions);\n  }\n\n  let newNode = node;\n\n  Object.keys(node).forEach((key: string | number) => {\n    if (propertiesToSkip.has(key)) {\n      return;\n    }\n\n    const val = node[key];\n\n    let newVal = val;\n\n    if (typeof val === \"object\") {\n      newVal = resolveAllRefs(val, resolveOptions, propertiesToSkip);\n    } else if (typeof val === \"string\") {\n      newVal = resolveString(val, resolveOptions);\n    }\n\n    if (newVal !== val) {\n      newNode = set(newNode, key as any, newVal);\n    }\n  });\n\n  return newNode;\n}\n\n/** Traverse up the node tree finding the first available 'path' */\nconst findBasePath = (\n  node: Node.Node,\n  resolver: Resolver,\n): Node.PathSegment[] => {\n  const parentNode = node.parent;\n  if (!parentNode) {\n    return [];\n  }\n\n  if (\"children\" in parentNode) {\n    const original = resolver.getSourceNode(node);\n    return (\n      parentNode.children?.find((child) => child.value === original)?.path ?? []\n    );\n  }\n\n  if (parentNode.type !== NodeType.MultiNode) {\n    return [];\n  }\n\n  return findBasePath(parentNode, resolver);\n};\n\n/** A plugin that resolves all string references for each node */\nexport default class StringResolverPlugin implements ViewPlugin {\n  private propertiesToSkipCache: Map<string, Set<string>>;\n\n  constructor() {\n    this.propertiesToSkipCache = new Map();\n  }\n\n  applyResolver(resolver: Resolver) {\n    resolver.hooks.resolve.tap(\"string-resolver\", (value, node, options) => {\n      if (node.type === NodeType.Empty || node.type === NodeType.Unknown) {\n        return null;\n      }\n\n      if (\n        node.type === NodeType.Value ||\n        node.type === NodeType.Asset ||\n        node.type === NodeType.View\n      ) {\n        /** Use specified properties to skip during string resolution, or default */\n        let propsToSkip: Set<string>;\n        if (node.type === NodeType.Asset || node.type === NodeType.View) {\n          propsToSkip = new Set(\n            node.plugins?.stringResolver?.propertiesToSkip ?? [\"exp\"],\n          );\n          if (node.value?.id) {\n            this.propertiesToSkipCache.set(node.value.id, propsToSkip);\n          }\n        } else if (\n          node.parent?.type === NodeType.MultiNode &&\n          (node.parent?.parent?.type === NodeType.Asset ||\n            node.parent?.parent?.type === NodeType.View) &&\n          node.parent.parent.value?.id &&\n          this.propertiesToSkipCache.has(node.parent.parent.value.id)\n        ) {\n          propsToSkip = this.propertiesToSkipCache.get(\n            node.parent.parent.value.id,\n          ) as Set<string>;\n        } else {\n          propsToSkip = new Set([\"exp\"]);\n        }\n\n        const nodePath = findBasePath(node, resolver);\n\n        /** If the path includes something that is supposed to be skipped, this node should be skipped too. */\n        if (\n          nodePath.length > 0 &&\n          nodePath.some((segment) => propsToSkip.has(segment.toString()))\n        ) {\n          return node.value;\n        }\n\n        return resolveAllRefs(node.value, options, propsToSkip);\n      }\n\n      return value;\n    });\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.resolver.tap(\"string-resolver\", this.applyResolver.bind(this));\n  }\n}\n","const ANY_CHAR_REGEX = /%([a-zA-Z]+)/g;\n\n/**\n * Replaces %num in message with the provided parameters in order.\n *\n * @param message - Parameterized string like \"This is a %1\"\n * @param params - Parameters to replace in message E.g. ['tax2021.amount']\n * @returns A message with the parameters replaced.\n */\nexport function replaceParams(\n  message: string,\n  params: Record<string, any>,\n): string {\n  return message\n    .slice()\n    .replace(ANY_CHAR_REGEX, (keyExpr) => params[keyExpr.slice(1)] || keyExpr);\n}\n","import type { Validation } from \"@player-ui/types\";\nimport { SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport { setIn } from \"timm\";\n\nimport type { BindingInstance, BindingFactory } from \"../../binding\";\nimport { isBinding } from \"../../binding\";\nimport type { DataModelWithParser, DataModelMiddleware } from \"../../data\";\nimport type { SchemaController } from \"../../schema\";\nimport type {\n  ErrorValidationResponse,\n  ValidationObject,\n  ValidationObjectWithHandler,\n  ValidatorContext,\n  ValidationProvider,\n  ValidationResponse,\n  WarningValidationResponse,\n  StrongOrWeakBinding,\n} from \"../../validator\";\nimport {\n  ValidationMiddleware,\n  ValidatorRegistry,\n  removeBindingAndChildrenFromMap,\n} from \"../../validator\";\nimport type { Logger } from \"../../logger\";\nimport { ProxyLogger } from \"../../logger\";\nimport type { Resolve, ViewInstance } from \"../../view\";\nimport { caresAboutDataChanges } from \"../../view\";\nimport { replaceParams } from \"../../utils\";\nimport { resolveDataRefs } from \"../../string-resolver\";\nimport type {\n  ExpressionEvaluatorOptions,\n  ExpressionType,\n} from \"../../expressions\";\nimport type { BindingTracker } from \"./binding-tracker\";\nimport { ValidationBindingTrackerViewPlugin } from \"./binding-tracker\";\n\nexport const SCHEMA_VALIDATION_PROVIDER_NAME = \"schema\";\nexport const VIEW_VALIDATION_PROVIDER_NAME = \"view\";\n\nexport const VALIDATION_PROVIDER_NAME_SYMBOL: unique symbol = Symbol.for(\n  \"validation-provider-name\",\n);\n\nexport type ValidationObjectWithSource = ValidationObjectWithHandler & {\n  /** The name of the validation */\n  [VALIDATION_PROVIDER_NAME_SYMBOL]: string;\n};\n\ntype SimpleValidatorContext = Omit<\n  ValidatorContext,\n  \"validation\" | \"schemaType\"\n>;\n\ninterface BaseActiveValidation<T> {\n  /** The validation is being actively shown */\n  state: \"active\";\n\n  /** The validation response */\n  response: T;\n}\n\ntype ActiveWarning = BaseActiveValidation<WarningValidationResponse> & {\n  /** Warnings track if they can be dismissed automatically (by navigating) */\n  dismissable: boolean;\n};\ntype ActiveError = BaseActiveValidation<ErrorValidationResponse>;\n\n/**\n * warnings that keep track of their active state\n */\ntype StatefulWarning = {\n  /** A common key to differentiate between errors and warnings */\n  type: \"warning\";\n\n  /** The underlying validation this tracks */\n  value: ValidationObjectWithSource;\n\n  /** If this is currently preventing navigation from continuing */\n  isBlockingNavigation: boolean;\n} & (\n  | {\n      /** warnings start with no state, but can active or dismissed */\n      state: \"none\" | \"dismissed\";\n    }\n  | ActiveWarning\n);\n\n/** Errors that keep track of their state */\ntype StatefulError = {\n  /** A common key to differentiate between errors and warnings */\n  type: \"error\";\n\n  /** The underlying validation this tracks */\n  value: ValidationObjectWithSource;\n\n  /** If this is currently preventing navigation from continuing */\n  isBlockingNavigation: boolean;\n} & (\n  | {\n      /** Errors start with no state an can be activated */\n      state: \"none\";\n    }\n  | ActiveError\n);\n\nexport type StatefulValidationObject = StatefulWarning | StatefulError;\n\n/** Helper function to determin if the subset is within the containingSet */\nfunction isSubset<T>(subset: Set<T>, containingSet: Set<T>): boolean {\n  if (subset.size > containingSet.size) return false;\n  for (const entry of subset) if (!containingSet.has(entry)) return false;\n  return true;\n}\n\n/** Helper for initializing a validation object that tracks state */\nfunction createStatefulValidationObject(\n  obj: ValidationObjectWithSource,\n): StatefulValidationObject {\n  return {\n    value: obj,\n    type: obj.severity,\n    state: \"none\",\n    isBlockingNavigation: false,\n  };\n}\n\ntype ValidationRunner = (obj: ValidationObjectWithHandler) =>\n  | {\n      /** A validation message */\n      message: string;\n    }\n  | undefined;\n\n/** A class that manages validating bindings across phases */\nclass ValidatedBinding {\n  public currentPhase?: Validation.Trigger;\n  private applicableValidations: Array<StatefulValidationObject> = [];\n  private validationsByState: Record<\n    Validation.Trigger,\n    Array<StatefulValidationObject>\n  > = {\n    load: [],\n    change: [],\n    navigation: [],\n  };\n\n  public get allValidations(): Array<StatefulValidationObject> {\n    return Object.values(this.validationsByState).flat();\n  }\n\n  public weakBindings: Set<BindingInstance>;\n\n  private onDismiss?: () => void;\n\n  constructor(\n    possibleValidations: Array<ValidationObjectWithSource>,\n    onDismiss?: () => void,\n    log?: Logger,\n    weakBindings?: Set<BindingInstance>,\n  ) {\n    this.onDismiss = onDismiss;\n    possibleValidations.forEach((vObj) => {\n      const { trigger } = vObj;\n\n      if (this.validationsByState[trigger]) {\n        const statefulValidationObject = createStatefulValidationObject(vObj);\n        this.validationsByState[trigger].push(statefulValidationObject);\n      } else {\n        log?.warn(`Unknown validation trigger: ${trigger}`);\n      }\n    });\n    this.weakBindings = weakBindings ?? new Set();\n  }\n\n  private checkIfBlocking(statefulObj: StatefulValidationObject) {\n    if (statefulObj.state === \"active\") {\n      const { isBlockingNavigation } = statefulObj;\n      return isBlockingNavigation;\n    }\n\n    return false;\n  }\n\n  public getAll(): Array<ValidationResponse> {\n    return this.applicableValidations.reduce((all, statefulObj) => {\n      if (statefulObj.state === \"active\" && statefulObj.response) {\n        all.push({\n          ...statefulObj.response,\n          blocking: this.checkIfBlocking(statefulObj),\n        });\n      }\n\n      return all;\n    }, [] as Array<ValidationResponse>);\n  }\n\n  public get(): ValidationResponse | undefined {\n    const firstInvalid = this.applicableValidations.find((statefulObj) => {\n      return statefulObj.state === \"active\" && statefulObj.response;\n    });\n\n    if (firstInvalid?.state === \"active\") {\n      return {\n        ...firstInvalid.response,\n        blocking: this.checkIfBlocking(firstInvalid),\n      };\n    }\n  }\n\n  private runApplicableValidations(\n    runner: ValidationRunner,\n    canDismiss: boolean,\n    phase: Validation.Trigger,\n  ) {\n    // If the currentState is not load, skip those\n    this.applicableValidations = this.applicableValidations.map(\n      (originalValue) => {\n        if (originalValue.state === \"dismissed\") {\n          // Don't rerun any dismissed warnings\n          return originalValue;\n        }\n\n        // treat all warnings the same and block it once (unless blocking is true)\n        const blocking =\n          originalValue.value.blocking ??\n          ((originalValue.value.severity === \"warning\" && \"once\") || true);\n\n        const obj = setIn(\n          originalValue,\n          [\"value\", \"blocking\"],\n          blocking,\n        ) as StatefulValidationObject;\n\n        const isBlockingNavigation =\n          blocking === true || (blocking === \"once\" && !canDismiss);\n\n        if (\n          phase === \"navigation\" &&\n          obj.state === \"active\" &&\n          obj.value.blocking !== true\n        ) {\n          if (obj.value.severity === \"warning\") {\n            const warn = obj as ActiveWarning;\n            if (\n              warn.dismissable &&\n              warn.response.dismiss &&\n              (warn.response.blocking !== \"once\" || !warn.response.blocking)\n            ) {\n              warn.response.dismiss();\n            } else {\n              if (warn?.response.blocking === \"once\") {\n                warn.response.blocking = false;\n              }\n\n              warn.dismissable = true;\n            }\n\n            return warn as StatefulValidationObject;\n          }\n        }\n\n        const response = runner(obj.value);\n\n        const newState = {\n          type: obj.type,\n          value: obj.value,\n          state: response ? \"active\" : \"none\",\n          isBlockingNavigation,\n          dismissable:\n            obj.value.severity === \"warning\" && phase === \"navigation\",\n          response: response\n            ? {\n                ...obj.value,\n                message: response.message ?? \"Something is broken\",\n                severity: obj.value.severity,\n                displayTarget: obj.value.displayTarget ?? \"field\",\n              }\n            : undefined,\n        } as StatefulValidationObject;\n\n        if (newState.state === \"active\" && obj.value.severity === \"warning\") {\n          (newState.response as WarningValidationResponse).dismiss = () => {\n            (newState as StatefulWarning).state = \"dismissed\";\n            this.onDismiss?.();\n          };\n        }\n\n        return newState;\n      },\n    );\n  }\n\n  public update(\n    phase: Validation.Trigger,\n    canDismiss: boolean,\n    runner: ValidationRunner,\n  ) {\n    const newApplicableValidations: StatefulValidationObject[] = [];\n\n    if (phase === \"load\" && this.currentPhase !== undefined) {\n      // Tried to run the 'load' phase twice. Aborting\n      return;\n    }\n\n    if (this.currentPhase === \"navigation\" || phase === this.currentPhase) {\n      // Already added all the types. No need to continue adding new validations\n      this.runApplicableValidations(runner, canDismiss, phase);\n      return;\n    }\n\n    if (phase === \"load\") {\n      this.currentPhase = \"load\";\n      this.applicableValidations = [...this.validationsByState.load];\n    } else if (phase === \"change\" && this.currentPhase === \"load\") {\n      this.currentPhase = \"change\";\n      // The transition to the 'change' type can only come from a 'load' type\n      this.applicableValidations = [\n        ...this.applicableValidations,\n        ...this.validationsByState.change,\n      ];\n    } else if (\n      phase === \"navigation\" &&\n      (this.currentPhase === \"load\" || this.currentPhase === \"change\")\n    ) {\n      // Can transition to a nav state from a change or load\n\n      // if there is an non-blocking error that is active then remove the error from applicable validations so it can no longer be shown\n      // which is needed if there are additional warnings to become active for that binding after the error is shown\n      this.applicableValidations.forEach((element) => {\n        if (\n          !(\n            element.type === \"error\" &&\n            element.state === \"active\" &&\n            element.isBlockingNavigation === false\n          )\n        ) {\n          newApplicableValidations.push(element);\n        }\n      });\n\n      this.applicableValidations = [\n        ...newApplicableValidations,\n        ...this.validationsByState.navigation,\n        ...(this.currentPhase === \"load\" ? this.validationsByState.change : []),\n      ];\n      this.currentPhase = \"navigation\";\n    }\n\n    this.runApplicableValidations(runner, canDismiss, phase);\n  }\n}\n\n/**\n * A controller for orchestrating validation within a running player\n *\n * The current validation flow is as follows:\n *\n *   - When a binding is first seen, gather all of the possible validations for it from the providers\n *     - Schema and Crossfield (view) are both providers of possible validations\n *     - Run all of the applicable validations for that binding for the `load` trigger\n *\n *   - When a change occurs, set the phase of the binding to `change`.\n *     - Run all of the `change` triggered validations for that binding.\n *\n *   - When a navigation event occurs, set the phase of the binding to `navigate`.\n *     - Run all `change` and `navigate` validations for each tracked binding.\n *     - For any warnings, also keep a state of `shown` or `dismissed`.\n *       - Set all non-dismissed warnings to `shown`.\n *       - Set all `shown` warnings to `dismissed`.\n *     - Allow navigation forward if there are no non-dismissed warnings and no valid errors.\n */\nexport class ValidationController implements BindingTracker {\n  public readonly hooks = {\n    /** A hook called to tap into the validator registry for adding more validators */\n    createValidatorRegistry: new SyncHook<[ValidatorRegistry]>(),\n\n    /** A callback/event when a new validation is added to the view */\n    onAddValidation: new SyncWaterfallHook<\n      [ValidationResponse, BindingInstance]\n    >(),\n\n    /** The inverse of onAddValidation, this is called when a validation is removed from the list */\n    onRemoveValidation: new SyncWaterfallHook<\n      [ValidationResponse, BindingInstance]\n    >(),\n\n    resolveValidationProviders: new SyncWaterfallHook<\n      [\n        Array<{\n          /** The name of the provider */\n          source: string;\n          /** The provider itself */\n          provider: ValidationProvider;\n        }>,\n      ],\n      {\n        /** The view this is triggered for  */\n        view?: ViewInstance;\n      }\n    >(),\n\n    /** A hook called when a binding is added to the tracker */\n    onTrackBinding: new SyncHook<[BindingInstance]>(),\n  };\n\n  private tracker: BindingTracker | undefined;\n  private validations = new Map<BindingInstance, ValidatedBinding>();\n  private validatorRegistry?: ValidatorRegistry;\n  private schema: SchemaController;\n\n  private providers:\n    | Array<{\n        /** The name of the provider */\n        source: string;\n        /** The provider itself */\n        provider: ValidationProvider;\n      }>\n    | undefined;\n\n  private viewValidationProvider?: ValidationProvider;\n  private options?: SimpleValidatorContext;\n  private weakBindingTracker = new Set<BindingInstance>();\n\n  constructor(schema: SchemaController, options?: SimpleValidatorContext) {\n    this.schema = schema;\n    this.options = options;\n    this.reset();\n  }\n\n  setOptions(options: SimpleValidatorContext) {\n    this.options = options;\n  }\n\n  /** Return the middleware for the data-model to stop propagation of invalid data */\n  public getDataMiddleware(): Array<DataModelMiddleware> {\n    return [\n      {\n        set: (transaction, options, next) => {\n          return next?.set(transaction, options) ?? [];\n        },\n        get: (binding, options, next) => {\n          return next?.get(binding, options);\n        },\n        delete: (binding, options, next) => {\n          this.validations = removeBindingAndChildrenFromMap(\n            this.validations,\n            binding,\n          );\n\n          return next?.delete(binding, options);\n        },\n      },\n      new ValidationMiddleware(\n        (binding) => {\n          if (!this.options) {\n            return;\n          }\n\n          this.updateValidationsForBinding(binding, \"change\", this.options);\n          const strongValidation = this.getValidationForBinding(binding);\n\n          // return validation issues directly on bindings first\n          if (strongValidation?.get()?.severity === \"error\") {\n            return strongValidation.get();\n          }\n\n          // if none, check to see any validations this binding may be a weak ref of and return\n          const newInvalidBindings: Set<StrongOrWeakBinding> = new Set();\n          this.validations.forEach((weakValidation, strongBinding) => {\n            if (\n              caresAboutDataChanges(\n                new Set([binding]),\n                weakValidation.weakBindings,\n              ) &&\n              weakValidation?.get()?.severity === \"error\"\n            ) {\n              weakValidation?.weakBindings.forEach((weakBinding) => {\n                if (weakBinding === strongBinding) {\n                  newInvalidBindings.add({\n                    binding: weakBinding,\n                    isStrong: true,\n                  });\n                } else {\n                  newInvalidBindings.add({\n                    binding: weakBinding,\n                    isStrong: false,\n                  });\n                }\n              });\n            }\n          });\n\n          if (newInvalidBindings.size > 0) {\n            return newInvalidBindings;\n          }\n        },\n        { logger: new ProxyLogger(() => this.options?.logger) },\n      ),\n    ];\n  }\n\n  private getValidationProviders() {\n    if (this.providers) {\n      return this.providers;\n    }\n\n    this.providers = this.hooks.resolveValidationProviders.call([\n      {\n        source: SCHEMA_VALIDATION_PROVIDER_NAME,\n        provider: this.schema,\n      },\n      {\n        source: VIEW_VALIDATION_PROVIDER_NAME,\n        provider: {\n          getValidationsForBinding: (\n            binding: BindingInstance,\n          ): Array<ValidationObject> | undefined => {\n            return this.viewValidationProvider?.getValidationsForBinding?.(\n              binding,\n            );\n          },\n\n          getValidationsForView: (): Array<ValidationObject> | undefined => {\n            return this.viewValidationProvider?.getValidationsForView?.();\n          },\n        },\n      },\n    ]);\n\n    return this.providers;\n  }\n\n  public reset() {\n    this.validations.clear();\n    this.tracker = undefined;\n  }\n\n  public onView(view: ViewInstance): void {\n    this.validations.clear();\n    if (!this.options) {\n      return;\n    }\n\n    const bindingTrackerPlugin = new ValidationBindingTrackerViewPlugin({\n      ...this.options,\n      callbacks: {\n        onAdd: (binding) => {\n          if (\n            !this.options ||\n            this.getValidationForBinding(binding) !== undefined\n          ) {\n            return;\n          }\n\n          // Set the default value for the binding if we need to\n          const originalValue = this.options.model.get(binding);\n          const withoutDefault = this.options.model.get(binding, {\n            ignoreDefaultValue: true,\n          });\n\n          if (originalValue !== withoutDefault) {\n            // Don't trigger updates when setting the default value\n            this.options.model.set([[binding, originalValue]], {\n              silent: true,\n            });\n          }\n\n          this.updateValidationsForBinding(\n            binding,\n            \"load\",\n            this.options,\n            () => {\n              view.update(new Set([binding]));\n            },\n          );\n\n          this.hooks.onTrackBinding.call(binding);\n        },\n      },\n    });\n\n    this.tracker = bindingTrackerPlugin;\n    this.viewValidationProvider = view;\n\n    bindingTrackerPlugin.apply(view);\n  }\n\n  updateValidationsForBinding(\n    binding: BindingInstance,\n    trigger: Validation.Trigger,\n    validationContext?: SimpleValidatorContext,\n    onDismiss?: () => void,\n  ): void {\n    const context = validationContext ?? this.options;\n\n    if (!context) {\n      throw new Error(`Context is required for executing validations`);\n    }\n\n    if (trigger === \"load\") {\n      // Get all of the validations from each provider\n      const possibleValidations = this.getValidationProviders().reduce<\n        Array<ValidationObjectWithSource>\n      >((vals, provider) => {\n        vals.push(\n          ...(provider.provider\n            .getValidationsForBinding?.(binding)\n            ?.map((valObj) => ({\n              ...valObj,\n              [VALIDATION_PROVIDER_NAME_SYMBOL]: provider.source,\n            })) ?? []),\n        );\n\n        return vals;\n      }, []);\n\n      if (possibleValidations.length === 0) {\n        return;\n      }\n\n      this.validations.set(\n        binding,\n        new ValidatedBinding(\n          possibleValidations,\n          onDismiss,\n          this.options?.logger,\n        ),\n      );\n    }\n\n    const trackedValidations = this.validations.get(binding);\n    trackedValidations?.update(trigger, true, (validationObj) => {\n      const response = this.validationRunner(validationObj, binding, context);\n\n      if (this.weakBindingTracker.size > 0) {\n        const t = this.validations.get(binding) as ValidatedBinding;\n        this.weakBindingTracker.forEach((b) => t.weakBindings.add(b));\n      }\n\n      return response ? { message: response.message } : undefined;\n    });\n\n    // Also run any validations that binding or sub-binding is a weak binding of\n    if (trigger !== \"load\") {\n      this.validations.forEach((validation, vBinding) => {\n        if (\n          vBinding !== binding &&\n          caresAboutDataChanges(new Set([binding]), validation.weakBindings)\n        ) {\n          validation.update(trigger, true, (validationObj) => {\n            const response = this.validationRunner(\n              validationObj,\n              vBinding,\n              context,\n            );\n            return response ? { message: response.message } : undefined;\n          });\n        }\n      });\n    }\n  }\n\n  validationRunner(\n    validationObj: ValidationObjectWithHandler,\n    binding: BindingInstance,\n    context: SimpleValidatorContext | undefined = this.options,\n  ) {\n    if (!context) {\n      throw new Error(\"No context provided to validation runner\");\n    }\n\n    const handler =\n      validationObj.handler ?? this.getValidator(validationObj.type);\n\n    const weakBindings = new Set<BindingInstance>();\n\n    // For any data-gets in the validation runner, default to using the _invalid_ value (since that's what we're testing against)\n    const model: DataModelWithParser = {\n      get(b, options) {\n        weakBindings.add(isBinding(b) ? binding : context.parseBinding(b));\n        return context.model.get(b, { ...options, includeInvalid: true });\n      },\n      set: context.model.set,\n      delete: context.model.delete,\n    };\n\n    const result = handler?.(\n      {\n        ...context,\n        evaluate: (\n          exp: ExpressionType,\n          options: ExpressionEvaluatorOptions = { model },\n        ) => context.evaluate(exp, options),\n        model,\n        validation: validationObj,\n        schemaType: this.schema.getType(binding),\n      },\n      context.model.get(binding, {\n        includeInvalid: true,\n        formatted: validationObj.dataTarget === \"formatted\",\n      }),\n      validationObj,\n    );\n\n    this.weakBindingTracker = weakBindings;\n\n    if (result) {\n      let { message } = result;\n      const { parameters } = result;\n\n      if (validationObj.message) {\n        message = resolveDataRefs(validationObj.message, {\n          model,\n          evaluate: context.evaluate,\n        });\n        if (parameters) {\n          message = replaceParams(message, parameters);\n        }\n      }\n\n      return {\n        message,\n      };\n    }\n  }\n\n  private updateValidationsForView(trigger: Validation.Trigger): void {\n    const isNavigationTrigger = trigger === \"navigation\";\n    const lastActiveBindings = this.activeBindings;\n\n    /** Run validations for all bindings in view */\n    const updateValidations = (dismissValidations: boolean) => {\n      this.getBindings().forEach((binding) => {\n        this.validations\n          .get(binding)\n          ?.update(trigger, dismissValidations, (obj) => {\n            if (!this.options) {\n              return;\n            }\n\n            return this.validationRunner(obj, binding, this.options);\n          });\n      });\n    };\n\n    // Should dismiss for non-navigation triggers.\n    updateValidations(!isNavigationTrigger);\n\n    if (isNavigationTrigger) {\n      // If validations didn't change since last update, dismiss all dismissible validations.\n      const { activeBindings } = this;\n      if (isSubset(activeBindings, lastActiveBindings)) {\n        updateValidations(true);\n      }\n    }\n  }\n\n  private get activeBindings(): Set<BindingInstance> {\n    return new Set(\n      Array.from(this.getBindings()).filter(\n        (b) => this.validations.get(b)?.get() !== undefined,\n      ),\n    );\n  }\n\n  public getValidator(type: string) {\n    if (this.validatorRegistry) {\n      return this.validatorRegistry.get(type);\n    }\n\n    const registry = new ValidatorRegistry();\n    this.hooks.createValidatorRegistry.call(registry);\n    this.validatorRegistry = registry;\n\n    return registry.get(type);\n  }\n\n  getBindings(): Set<BindingInstance> {\n    return this.tracker?.getBindings() ?? new Set();\n  }\n\n  trackBinding(binding: BindingInstance): void {\n    this.tracker?.trackBinding(binding);\n  }\n\n  /** Executes all known validations for the tracked bindings using the given model */\n  validateView(trigger: Validation.Trigger = \"navigation\"): {\n    /** Indicating if the view can proceed without error */\n    canTransition: boolean;\n\n    /** the validations that are preventing the view from continuing */\n    validations?: Map<BindingInstance, ValidationResponse>;\n  } {\n    this.updateValidationsForView(trigger);\n\n    const validations = new Map<BindingInstance, ValidationResponse>();\n\n    let canTransition = true;\n\n    this.getBindings().forEach((b) => {\n      const allValidations = this.getValidationForBinding(b)?.getAll();\n\n      allValidations?.forEach((v) => {\n        if (trigger === \"navigation\" && v.blocking) {\n          this.options?.logger.debug(\n            `Validation on binding: ${b.asString()} is preventing navigation. ${JSON.stringify(\n              v,\n            )}`,\n          );\n\n          canTransition = false;\n        }\n\n        if (!validations.has(b)) {\n          validations.set(b, v);\n        }\n      });\n    });\n\n    return {\n      canTransition,\n      validations: validations.size ? validations : undefined,\n    };\n  }\n\n  /** Get the current tracked validation for the given binding */\n  public getValidationForBinding(\n    binding: BindingInstance,\n  ): ValidatedBinding | undefined {\n    return this.validations.get(binding);\n  }\n\n  forView(parser: BindingFactory): Resolve.Validation {\n    return {\n      _getValidationForBinding: (binding) => {\n        return this.getValidationForBinding(\n          isBinding(binding) ? binding : parser(binding),\n        );\n      },\n      getAll: () => {\n        const bindings = this.getBindings();\n        if (bindings.size === 0) {\n          return undefined;\n        }\n\n        const validationMapping = new Map<\n          BindingInstance,\n          ValidationResponse\n        >();\n\n        bindings.forEach((b) => {\n          const validation = this.getValidationForBinding(b)?.get();\n\n          if (validation) {\n            validationMapping.set(b, validation);\n          }\n        });\n\n        return validationMapping.size === 0 ? undefined : validationMapping;\n      },\n      get() {\n        throw new Error(\"Error Access be provided by the view plugin\");\n      },\n      getValidationsForBinding() {\n        throw new Error(\"Error rollup should be provided by the view plugin\");\n      },\n      getChildren() {\n        throw new Error(\"Error rollup should be provided by the view plugin\");\n      },\n      getValidationsForSection() {\n        throw new Error(\"Error rollup should be provided by the view plugin\");\n      },\n      track: () => {\n        throw new Error(\"Tracking should be provided by the view plugin\");\n      },\n      register: () => {\n        throw new Error(\n          \"Section functionality should be provided by the view plugin\",\n        );\n      },\n      type: (binding) =>\n        this.schema.getType(isBinding(binding) ? binding : parser(binding)),\n    };\n  }\n}\n","import { BindingInstance } from \"../../binding\";\n\n/** Recursively flattens a nested object to be an object of depth 1 with keys being the full path in the orginal object */\nexport function flatten(obj: any, roots: [string][] = [], sep = \".\"): any {\n  return (\n    Object\n      // find props of given object\n      .keys(obj)\n      // return an object by iterating props\n      .reduce(\n        (memo, prop) => ({\n          // create a new object\n\n          // include previously returned object\n          ...memo,\n          ...(Object.prototype.toString.call(obj[prop]) === \"[object Object]\"\n            ? // keep working if value is an object\n              flatten(obj[prop], roots.concat([prop]))\n            : // include current prop and value and prefix prop with the roots\n              { [roots.concat([prop]).join(sep)]: obj[prop] }),\n        }),\n        {},\n      )\n  );\n}\n\n/** Converts an object into a list of binding/value tuples to use with a LocalModel object */\nexport function objectToBatchSet(obj: any): [BindingInstance, any][] {\n  const flattenedObj = flatten(obj);\n  const batchTxn: [BindingInstance, any][] = [];\n\n  Object.keys(flattenedObj).forEach((key) => {\n    batchTxn.push([new BindingInstance(key), flattenedObj[key]]);\n  });\n\n  return batchTxn;\n}\n","import { NodeType } from \"@player-ui/player\";\nimport type {\n  Player,\n  Asset,\n  PlayerPlugin,\n  Node,\n  Resolver,\n} from \"@player-ui/player\";\nimport { createObjectMatcher } from \"@player-ui/partial-match-registry\";\nimport dlv from \"dlv\";\nimport { CheckPathPluginSymbol } from \"./symbols\";\n\nexport type QueryFunction = (asset: Asset) => boolean;\nexport type Query = QueryFunction | string | object;\n\n/** Generate a function that matches on the given input */\nfunction createMatcher(\n  match: number | string | object | QueryFunction,\n): QueryFunction {\n  if (typeof match === \"string\" || typeof match === \"number\") {\n    return createObjectMatcher({ type: match });\n  }\n\n  if (typeof match === \"function\") {\n    return match as QueryFunction;\n  }\n\n  return createObjectMatcher(match);\n}\n\ninterface ViewInfo {\n  /** The root of the view graph */\n  root?: Node.Node;\n\n  /** A cache of an asset or view's id to it's node */\n  assetIdMap: Map<string, Node.Asset | Node.View>;\n\n  /** A map of a node to it's resolved node and value */\n  resolvedMap: Map<\n    Node.Node,\n    {\n      /** The final resolved AST node */\n      resolved: Node.Node;\n\n      /** The final, resolved value of the node */\n      value: any;\n    }\n  >;\n\n  /** The resolver instance tied to this view. Used to map back to original nodes */\n  resolver: Resolver;\n}\n\n/**\n * Traverse up the tree until reaching the first asset or view\n * Returns undefined if no matching parent is found\n */\nfunction getParent(\n  node: Node.Node,\n  viewInfo?: ViewInfo,\n): Node.ViewOrAsset | undefined {\n  let working = node;\n\n  while (\n    working.parent &&\n    working.parent.type !== NodeType.Asset &&\n    working.parent.type !== NodeType.View\n  ) {\n    working = working.parent;\n  }\n\n  const { parent } = working;\n\n  if (\n    parent &&\n    (parent.type === NodeType.Asset || parent.type === NodeType.View)\n  ) {\n    return parent;\n  }\n}\n\n/**\n * The `check-path-plugin` enables developers to query segments of the view tree for contextual rendering or behavior.\n * This is best suited to be referenced during the UI rendering phase, where one can make decisions about the rendering of an asset based on where it lies in the tree.\n */\nexport class CheckPathPlugin implements PlayerPlugin {\n  name = \"check-path\";\n  private viewInfo?: ViewInfo;\n  public readonly symbol = CheckPathPluginSymbol;\n\n  apply(player: Player) {\n    player.hooks.viewController.tap(this.name, (viewController) => {\n      viewController.hooks.view.tap(this.name, (view) => {\n        view.hooks.resolver.tap(this.name, (resolver: Resolver) => {\n          const viewInfo: ViewInfo = {\n            resolvedMap: new Map(),\n            assetIdMap: new Map(),\n            resolver,\n          };\n          this.viewInfo = viewInfo;\n\n          resolver.hooks.afterResolve.tap(this.name, (value, node) => {\n            const sourceNode = this.getSourceAssetNode(node);\n\n            if (sourceNode) {\n              viewInfo.resolvedMap.set(sourceNode, {\n                resolved: node,\n                value,\n              });\n\n              if (node.type === NodeType.Asset || node.type === NodeType.View) {\n                const id = dlv(value, \"id\");\n\n                if (id) {\n                  viewInfo.assetIdMap.set(id, node);\n                }\n              }\n            }\n\n            return value;\n          });\n        });\n      });\n    });\n  }\n\n  /**\n   * Starts at the asset with the given id, and walks backwards _up_ the tree until it finds a match for the parent\n   *\n   * @param id - The id of the asset to _start_ at\n   * @param query - A means of matching a parent asset\n   * @returns - The parent object if a match is found, else undefined\n   */\n  public getParent(\n    id: string,\n    query?: Query | Array<Query>,\n  ): Asset | undefined {\n    const assetNode = this.viewInfo?.assetIdMap.get(id);\n\n    if (!assetNode || !this.viewInfo) {\n      return undefined;\n    }\n\n    let potentialMatch = getParent(assetNode);\n\n    // Handle the case of an empty query (just get the immediate parent)\n    if (query === undefined) {\n      if (potentialMatch) {\n        return this.getAssetFromAssetNode(potentialMatch);\n      }\n\n      return;\n    }\n\n    const queryArray = Array.isArray(query) ? [...query] : [query];\n    let parentQuery = queryArray.shift();\n\n    // Keep track of the recursive depth in case we loop forever\n    let depth = 0;\n\n    while (potentialMatch && parentQuery) {\n      if (depth++ >= 50) {\n        throw new Error(\n          \"Recursion depth exceeded. Check for cycles in the AST graph\",\n        );\n      }\n\n      const matcher = createMatcher(parentQuery);\n      const resolved = this.getAssetFromAssetNode(potentialMatch);\n\n      if (resolved && matcher(resolved)) {\n        // This is the last match.\n        if (queryArray.length === 0) {\n          return resolved;\n        }\n\n        parentQuery = queryArray.shift();\n      }\n\n      potentialMatch = getParent(potentialMatch);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Returns the property that the asset resides on relative to it's parent\n   *\n   * @param id - The id of the asset to _start_ at\n   * @returns - The property name or undefined if no parent was found\n   */\n  public getParentProp(id: string): string | number | undefined {\n    const assetNode = this.viewInfo?.assetIdMap.get(id);\n\n    if (!assetNode || !this.viewInfo) {\n      return;\n    }\n\n    let working: Node.Node | undefined = assetNode;\n    let parent;\n\n    while (working) {\n      parent = working?.parent;\n\n      if (\n        parent &&\n        (parent.type === NodeType.Asset || parent.type === NodeType.View)\n      ) {\n        break;\n      }\n\n      working = working?.parent;\n    }\n\n    if (parent && \"children\" in parent) {\n      const childProp = parent.children?.find(\n        (child) => child.value === working,\n      );\n\n      return childProp?.path?.[0];\n    }\n\n    return undefined;\n  }\n\n  /** Given a node, return itself, or the nested asset if the node is an applicability node */\n  private getSourceAssetNode(node: Node.Node) {\n    let sourceNode = this.viewInfo?.resolver.getSourceNode(node);\n    if (sourceNode?.type === \"applicability\") {\n      sourceNode = sourceNode.value;\n    }\n\n    return sourceNode;\n  }\n\n  /**\n   * Given the starting node, check to verify that the supplied queries are relevant to the current asset's parents.\n   *\n   * @param id - The id of the asset to _start_ at\n   * @returns - true if the context applies, false if it doesn't\n   */\n  public hasParentContext(id: string, query: Query | Array<Query>): boolean {\n    return Boolean(this.getParent(id, query));\n  }\n\n  /** Search the node for any matching paths in the graph that match the query  */\n  private findChildPath(\n    node: Node.Node,\n    query: Array<Query>,\n    includeSelfMatch = true,\n  ): boolean {\n    if (query.length === 0) {\n      return true;\n    }\n\n    const [first, ...rest] = query;\n    const matcher = createMatcher(first);\n\n    if (\n      node.type === NodeType.Asset ||\n      node.type === NodeType.View ||\n      node.type === NodeType.Applicability\n    ) {\n      const resolvedValue = this.getResolvedValue(node);\n      const includesSelf =\n        (includeSelfMatch && matcher(resolvedValue)) ?? false;\n      const childQuery = includesSelf ? rest : query;\n\n      if (childQuery.length === 0 && includesSelf) {\n        return true;\n      }\n\n      const children =\n        node.type === NodeType.Applicability\n          ? (node.value as Node.ViewOrAsset).children\n          : node.children;\n      if (childQuery.length && (!children || children.length === 0)) {\n        return false;\n      }\n\n      if (\n        children?.some((childNode) =>\n          this.findChildPath(childNode.value, childQuery),\n        )\n      ) {\n        return true;\n      }\n    } else if (\n      node.type === NodeType.MultiNode &&\n      node.values.some((childNode) => this.findChildPath(childNode, query))\n    ) {\n      return true;\n    } else if (\n      \"children\" in node &&\n      node.children?.some((childNode) =>\n        this.findChildPath(childNode.value, query),\n      )\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Given the starting node, check to verify that the supplied queries are relevant to the current asset's children.\n   *\n   * @param id - The id of the asset to _start_ at\n   * @returns - true if the context applies, false if it doesn't\n   */\n  public hasChildContext(id: string, query: Query | Array<Query>): boolean {\n    const assetNode = this.viewInfo?.assetIdMap.get(id);\n    const queryArray = Array.isArray(query) ? [...query] : [query];\n\n    if (!assetNode) {\n      return false;\n    }\n\n    return this.findChildPath(assetNode, queryArray, false);\n  }\n\n  /** Get the asset represented by id */\n  public getAsset(id: string): Asset | undefined {\n    const assetNode = this.viewInfo?.assetIdMap.get(id);\n    if (!assetNode) return;\n\n    return this.getAssetFromAssetNode(assetNode);\n  }\n\n  /**\n   * Gets the value for an asset from an asset node\n   */\n  public getAssetFromAssetNode(\n    assetNode: Node.Asset | Node.View,\n  ): Asset | undefined {\n    const sourceNode = this.getSourceAssetNode(assetNode);\n    if (!sourceNode) return;\n\n    return this.viewInfo?.resolvedMap.get(sourceNode)?.value;\n  }\n\n  /**\n   * Get the path of the asset in the view upto\n   * the asset that matches the query or to the view if no query is provided\n   */\n  public getPath(\n    id: string,\n    query?: Query | Array<Query>,\n  ): Array<string | number> | undefined {\n    const assetNode = this.viewInfo?.assetIdMap.get(id);\n\n    if (!assetNode || !this.viewInfo) {\n      return;\n    }\n\n    let path: Array<string | number> = [];\n\n    let queryArray: Query[] = [];\n\n    if (query) {\n      queryArray = Array.isArray(query) ? [...query] : [query];\n    }\n\n    let parentQuery = queryArray.shift();\n\n    let working: Node.Node | undefined = assetNode;\n\n    /** Find the child value for the working value from the given parent */\n    const findWorkingChild = (parent: Node.ViewOrAsset | Node.Value) => {\n      return parent.children?.find((n) => n.value === working);\n    };\n\n    while (working !== undefined) {\n      const { parent } = working;\n\n      if (parent) {\n        if (parent.type === NodeType.MultiNode) {\n          const index = parent.values.indexOf(working);\n\n          if (index !== -1) {\n            const actualIndex =\n              index -\n              parent.values\n                .slice(0, index)\n                .reduce(\n                  (undefCount, next) =>\n                    this.getResolvedValue(next) === undefined\n                      ? undefCount + 1\n                      : undefCount,\n                  0,\n                );\n\n            path = [actualIndex, ...path];\n          }\n        } else if (\"children\" in parent) {\n          const childProp = findWorkingChild(parent);\n          path = [...(childProp?.path ?? []), ...path];\n        }\n\n        if (parentQuery) {\n          const matcher = createMatcher(parentQuery);\n          if (matcher(this.getResolvedValue(parent))) {\n            parentQuery = queryArray.shift();\n            if (!parentQuery) return path;\n          }\n        }\n      }\n\n      working = working.parent;\n    }\n\n    /* if at the end all queries haven't been consumed, \n       it means we couldn't find a path till the matching query */\n    return parentQuery ? undefined : path;\n  }\n\n  private getResolvedValue(node: Node.Node) {\n    const sourceNode = this.getSourceAssetNode(node);\n    return this.viewInfo?.resolvedMap.get(sourceNode ?? node)?.value;\n  }\n}\n","/**\n * Subclass of standard `Error` that eagerly collects the callstack of the error\n * that caused it. This way you can investigate the core problem that happened\n * by looking at the callstack from up to bottom (from higher level errors to\n * lower level).\n */\nexport class NestedError extends Error {\n    /**\n     * Combined callstack of this error and the errors that it wraps.\n     * If the JavaScript runtime doesn't support `Error::stack` property\n     * this will contain only the concatenated messages.\n     */\n    readonly stack: string;\n\n    /**\n     * The list of lower-level errors wrapped by this error.\n     */\n    readonly innerErrors: Error[];\n\n    /**\n     * Provides the first `Error` of the `innerErrors` (if it exists);\n     * otherwise, `null`.\n     *\n     * @deprecated Please shift to using the `innerErrors` (with an 's') property.\n     */\n    get innerError(): Error | null {\n        return this.innerErrors.length === 0\n            ? null\n            : this.innerErrors[0];\n    }\n\n    private static readonly getErrorReport = typeof new Error().stack === 'string'\n        ? (err: Error) => err.stack!\n        : (err: Error) => `${err.name}: ${err.message}`;\n\n    /**\n     * Returns the function that accepts any value that was thrown as the first argument and\n     * throws it wrapped into `NestedError` or class derived from `NestedError` (provided\n     * this method was called directly in the context of that dervied class constructor)\n     * with the given `message`.\n     * Returned function will pass accepted `Error` object directly to `NestedError`\n     * as `innerErrors` by invoking `toError(err)` on it.\n     *\n     * You'll most likely want to use this method with promises:\n     *\n     * ```ts\n     * userService.getPage().then(\n     *     data => console.log(`Hooray! data: ${data}`),\n     *     NestedError.rethrow('failed to fetch users page')\n     * );\n     * ```\n     *\n     * @param message Message to attach `NestedError` created by the returned function.\n     */\n    static rethrow(message: string) {\n        return (...errs: unknown[]) => { throw new this(message, ...errs); };\n    }\n\n    /**\n     * Allocates an instance of `NestedError` with the given error `message` and\n     * optional `innerError` (which will be automatically coerced using `toError()`).\n     *\n     * @param message     Laconic error message to attach to the created `NestedError`.\n     * @param innerErrors Optional errors that will be wrapped by this higher level\n     *                    error. This value will be automatically coerced using `toError()`.\n     */\n    constructor(message?: string, ...innerErrors: unknown[]) {\n        super(message);\n        const thisErrorReport = NestedError.getErrorReport(this);\n        if (innerErrors.length === 1) {\n            const innerError = toError(innerErrors[0]);\n            this.innerErrors = [innerError];\n            const errReport = NestedError.getErrorReport(innerError);\n            this.stack = `${thisErrorReport}\\n\\n======= INNER ERROR =======\\n\\n${errReport}`;\n            return;\n        }\n        this.innerErrors = innerErrors.map(err => toError(err));\n        const innerErrorReports = this.innerErrors\n            .map((error, idx) => {\n                const errReport = NestedError.getErrorReport(error);\n                return `======= INNER ERROR (${idx + 1} of ${innerErrors.length}) =======\\n\\n${errReport}`;\n            })\n            .join(\"\\n\\n\");\n        this.stack = `${thisErrorReport}\\n\\n${innerErrorReports}`;\n    }\n}\n\nNestedError.prototype.name = nameof(NestedError);\n\n/**\n * @deprecated You should not call this function on an object of statically assumed `Error` type,\n *             because it is intended to be used in a dynamic context where the type of thrown value\n *             is not known ahead of time (during the compile time).\n */\nexport function toError(err: Error): Error;\n\n/**\n * Returns `err` itself if `err instanceof Error === true`, otherwise attemts to\n * stringify it and wrap into `Error` object to be returned.\n *\n * **This function is guaranteed never to throw.**\n *\n * @param err Possbile `instanceof Error` to return or value of any type that will\n *            be wrapped into a fully-fledged `Error` object.\n */\nexport function toError(err: unknown): Error;\n\nexport function toError(err: unknown) {\n    try {\n        return err instanceof Error\n            ? err\n            : new Error(`Value that is not an instance of Error was thrown: ${err}`);\n    } catch {\n        return new Error(\n            \"Failed to stringify non-instance of Error that was thrown.\" +\n            \"This is possibly due to the fact that toString() method of the value\" +\n            \"doesn't return a primitive value.\"\n        );\n    }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clone = clone;\nexports.addLast = addLast;\nexports.addFirst = addFirst;\nexports.removeLast = removeLast;\nexports.removeFirst = removeFirst;\nexports.insert = insert;\nexports.removeAt = removeAt;\nexports.replaceAt = replaceAt;\nexports.getIn = getIn;\nexports.set = set;\nexports.setIn = setIn;\nexports.update = update;\nexports.updateIn = updateIn;\nexports.merge = merge;\nexports.mergeDeep = mergeDeep;\nexports.mergeIn = mergeIn;\nexports.omit = omit;\nexports.addDefaults = addDefaults;\nexports.default = void 0;\n\n/* eslint-disable @typescript-eslint/ban-types */\n\n/*!\n * Timm\n *\n * Immutability helpers with fast reads and acceptable writes.\n *\n * @copyright Guillermo Grau Panea 2016\n * @license MIT\n */\nconst INVALID_ARGS = 'INVALID_ARGS';\nconst IS_DEV = process.env.NODE_ENV !== 'production';\n\n// ===============================================\n// ### Helpers\n// ===============================================\nfunction throwStr(msg) {\n  throw new Error(msg);\n}\n\nfunction getKeysAndSymbols(obj) {\n  const keys = Object.keys(obj);\n\n  if (Object.getOwnPropertySymbols) {\n    // @ts-ignore\n    return keys.concat(Object.getOwnPropertySymbols(obj));\n  }\n\n  return keys;\n}\n\nconst hasOwnProperty = {}.hasOwnProperty;\n\nfunction clone(obj0) {\n  // As array\n  if (Array.isArray(obj0)) return obj0.slice(); // As object\n\n  const obj = obj0;\n  const keys = getKeysAndSymbols(obj);\n  const out = {};\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    out[key] = obj[key];\n  } // @ts-ignore (see type tests)\n\n\n  return out;\n} // Custom guard\n\n\nfunction isObject(o) {\n  return o != null && typeof o === 'object';\n} // _deepFreeze = (obj) ->\n//   Object.freeze obj\n//   for key in Object.getOwnPropertyNames obj\n//     val = obj[key]\n//     if isObject(val) and not Object.isFrozen val\n//       _deepFreeze val\n//   obj\n// ===============================================\n// -- ### Arrays\n// ===============================================\n// -- #### addLast()\n// -- Returns a new array with an appended item or items.\n// --\n// -- Usage: `addLast(array, val)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = addLast(arr, 'c')\n// -- // ['a', 'b', 'c']\n// -- arr2 === arr\n// -- // false\n// -- arr3 = addLast(arr, ['c', 'd'])\n// -- // ['a', 'b', 'c', 'd']\n// -- ```\n// `array.concat(val)` also handles the scalar case,\n// but is apparently very slow\n\n\nfunction addLast(array, val) {\n  if (Array.isArray(val)) return array.concat(val);\n  return array.concat([val]);\n} // -- #### addFirst()\n// -- Returns a new array with a prepended item or items.\n// --\n// -- Usage: `addFirst(array, val)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = addFirst(arr, 'c')\n// -- // ['c', 'a', 'b']\n// -- arr2 === arr\n// -- // false\n// -- arr3 = addFirst(arr, ['c', 'd'])\n// -- // ['c', 'd', 'a', 'b']\n// -- ```\n\n\nfunction addFirst(array, val) {\n  if (Array.isArray(val)) return val.concat(array);\n  return [val].concat(array);\n} // -- #### removeLast()\n// -- Returns a new array removing the last item.\n// --\n// -- Usage: `removeLast(array)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = removeLast(arr)\n// -- // ['a']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- arr3 = []\n// -- removeLast(arr3) === arr3\n// -- // true\n// -- ```\n\n\nfunction removeLast(array) {\n  if (!array.length) return array;\n  return array.slice(0, array.length - 1);\n} // -- #### removeFirst()\n// -- Returns a new array removing the first item.\n// --\n// -- Usage: `removeFirst(array)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = removeFirst(arr)\n// -- // ['b']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- arr3 = []\n// -- removeFirst(arr3) === arr3\n// -- // true\n// -- ```\n\n\nfunction removeFirst(array) {\n  if (!array.length) return array;\n  return array.slice(1);\n} // -- #### insert()\n// -- Returns a new array obtained by inserting an item or items\n// -- at a specified index.\n// --\n// -- Usage: `insert(array, idx, val)`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = insert(arr, 1, 'd')\n// -- // ['a', 'd', 'b', 'c']\n// -- arr2 === arr\n// -- // false\n// -- insert(arr, 1, ['d', 'e'])\n// -- // ['a', 'd', 'e', 'b', 'c']\n// -- ```\n\n\nfunction insert(array, idx, val) {\n  return array.slice(0, idx).concat(Array.isArray(val) ? val : [val]).concat(array.slice(idx));\n} // -- #### removeAt()\n// -- Returns a new array obtained by removing an item at\n// -- a specified index.\n// --\n// -- Usage: `removeAt(array, idx)`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = removeAt(arr, 1)\n// -- // ['a', 'c']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- removeAt(arr, 4) === arr\n// -- // true\n// -- ```\n\n\nfunction removeAt(array, idx) {\n  if (idx >= array.length || idx < 0) return array;\n  return array.slice(0, idx).concat(array.slice(idx + 1));\n} // -- #### replaceAt()\n// -- Returns a new array obtained by replacing an item at\n// -- a specified index. If the provided item is the same as\n// -- (*referentially equal to*) the previous item at that position,\n// -- the original array is returned.\n// --\n// -- Usage: `replaceAt(array, idx, newItem)`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = replaceAt(arr, 1, 'd')\n// -- // ['a', 'd', 'c']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- replaceAt(arr, 1, 'b') === arr\n// -- // true\n// -- ```\n\n\nfunction replaceAt(array, idx, newItem) {\n  if (array[idx] === newItem) return array;\n  const len = array.length;\n  const result = Array(len);\n\n  for (let i = 0; i < len; i++) {\n    result[i] = array[i];\n  }\n\n  result[idx] = newItem;\n  return result;\n} // ===============================================\n// -- ### Collections (objects and arrays)\n// ===============================================\n// -- #### getIn()\n// -- Returns a value from an object at a given path. Works with\n// -- nested arrays and objects. If the path does not exist, it returns\n// -- `undefined`.\n// --\n// -- Usage: `getIn(obj, path)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: ['a', 'b', 'c'] }\n// -- getIn(obj, ['d', 'd1'])\n// -- // 3\n// -- getIn(obj, ['e', 1])\n// -- // 'b'\n// -- ```\n\n\nfunction getIn(obj, path) {\n  if (!Array.isArray(path)) {\n    throwStr(IS_DEV ? 'A path array should be provided when calling getIn()' : INVALID_ARGS);\n  }\n\n  if (obj == null) return undefined;\n  let ptr = obj;\n\n  for (let i = 0; i < path.length; i++) {\n    const key = path[i];\n    ptr = ptr != null ? ptr[key] : undefined;\n    if (ptr === undefined) return ptr;\n  }\n\n  return ptr;\n} // -- #### set()\n// -- Returns a new object with a modified attribute.\n// -- If the provided value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `set(obj, key, val)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3 }\n// -- obj2 = set(obj, 'b', 5)\n// -- // { a: 1, b: 5, c: 3 }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- set(obj, 'b', 2) === obj\n// -- // true\n// -- ```\n// When called with an undefined/null `obj`, `set()` returns either\n// a single-element array, or a single-key object\n\n\n// Implementation\nfunction set(obj0, key, val) {\n  let obj = obj0;\n  if (obj == null) obj = typeof key === 'number' ? [] : {};\n  if (obj[key] === val) return obj;\n  const obj2 = clone(obj);\n  obj2[key] = val;\n  return obj2;\n} // -- #### setIn()\n// -- Returns a new object with a modified **nested** attribute.\n// --\n// -- Notes:\n// --\n// -- * If the provided value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// -- * If the path does not exist, it will be created before setting\n// -- the new value.\n// --\n// -- Usage: `setIn(obj, path, val)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj2 = setIn(obj, ['d', 'd1'], 4)\n// -- // { a: 1, b: 2, d: { d1: 4, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj2 === obj\n// -- // false\n// -- obj2.d === obj.d\n// -- // false\n// -- obj2.e === obj.e\n// -- // true\n// --\n// -- // The same object is returned if there are no changes:\n// -- obj3 = setIn(obj, ['d', 'd1'], 3)\n// -- // { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj3 === obj\n// -- // true\n// -- obj3.d === obj.d\n// -- // true\n// -- obj3.e === obj.e\n// -- // true\n// --\n// -- // ... unknown paths create intermediate keys. Numeric segments are treated as array indices:\n// -- setIn({ a: 3 }, ['unknown', 0, 'path'], 4)\n// -- // { a: 3, unknown: [{ path: 4 }] }\n// -- ```\n\n\nfunction setIn(obj, path, val) {\n  if (!path.length) return val;\n  return doSetIn(obj, path, val, 0);\n}\n\nfunction doSetIn(obj, path, val, idx) {\n  let newValue;\n  const key = path[idx];\n\n  if (idx === path.length - 1) {\n    newValue = val;\n  } else {\n    const nestedObj = isObject(obj) && isObject(obj[key]) ? obj[key] : typeof path[idx + 1] === 'number' ? [] : {};\n    newValue = doSetIn(nestedObj, path, val, idx + 1);\n  }\n\n  return set(obj, key, newValue);\n} // -- #### update()\n// -- Returns a new object with a modified attribute,\n// -- calculated via a user-provided callback based on the current value.\n// -- If the calculated value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `update(obj, key, fnUpdate)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3 }\n// -- obj2 = update(obj, 'b', (val) => val + 1)\n// -- // { a: 1, b: 3, c: 3 }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- update(obj, 'b', (val) => val) === obj\n// -- // true\n// -- ```\n\n\nfunction update(obj, key, fnUpdate) {\n  const prevVal = obj == null ? undefined : obj[key];\n  const nextVal = fnUpdate(prevVal);\n  return set(obj, key, nextVal);\n} // -- #### updateIn()\n// -- Returns a new object with a modified **nested** attribute,\n// -- calculated via a user-provided callback based on the current value.\n// -- If the calculated value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `updateIn<T: ArrayOrObject>(obj: T, path: Array<Key>,\n// -- fnUpdate: (prevValue: any) => any): T`\n// --\n// -- ```js\n// -- obj = { a: 1, d: { d1: 3, d2: 4 } }\n// -- obj2 = updateIn(obj, ['d', 'd1'], (val) => val + 1)\n// -- // { a: 1, d: { d1: 4, d2: 4 } }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- obj3 = updateIn(obj, ['d', 'd1'], (val) => val)\n// -- // { a: 1, d: { d1: 3, d2: 4 } }\n// -- obj3 === obj\n// -- // true\n// -- ```\n\n\nfunction updateIn(obj, path, fnUpdate) {\n  const prevVal = getIn(obj, path);\n  const nextVal = fnUpdate(prevVal);\n  return setIn(obj, path, nextVal);\n} // -- #### merge()\n// -- Returns a new object built as follows: the overlapping keys from the\n// -- second one overwrite the corresponding entries from the first one.\n// -- Similar to `Object.assign()`, but immutable.\n// --\n// -- Usage:\n// --\n// -- * `merge(obj1, obj2)`\n// -- * `merge(obj1, ...objects)`\n// --\n// -- The unmodified `obj1` is returned if `obj2` does not *provide something\n// -- new to* `obj1`, i.e. if either of the following\n// -- conditions are true:\n// --\n// -- * `obj2` is `null` or `undefined`\n// -- * `obj2` is an object, but it is empty\n// -- * All attributes of `obj2` are `undefined`\n// -- * All attributes of `obj2` are referentially equal to the\n// --   corresponding attributes of `obj1`\n// --\n// -- Note that `undefined` attributes in `obj2` do not modify the\n// -- corresponding attributes in `obj1`.\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: 3 }\n// -- obj2 = { c: 4, d: 5 }\n// -- obj3 = merge(obj1, obj2)\n// -- // { a: 1, b: 2, c: 4, d: 5 }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- merge(obj1, { c: 3 }) === obj1\n// -- // true\n// -- ```\n// Signatures:\n// - 1 arg\n\n\n// Implementation\nfunction merge(a, b, c, d, e, f, ...rest) {\n  return rest.length ? doMerge.call(null, false, false, a, b, c, d, e, f, ...rest) : doMerge(false, false, a, b, c, d, e, f);\n} // -- #### mergeDeep()\n// -- Returns a new object built as follows: the overlapping keys from the\n// -- second one overwrite the corresponding entries from the first one.\n// -- If both the first and second entries are objects they are merged recursively.\n// -- Similar to `Object.assign()`, but immutable, and deeply merging.\n// --\n// -- Usage:\n// --\n// -- * `mergeDeep(obj1, obj2)`\n// -- * `mergeDeep(obj1, ...objects)`\n// --\n// -- The unmodified `obj1` is returned if `obj2` does not *provide something\n// -- new to* `obj1`, i.e. if either of the following\n// -- conditions are true:\n// --\n// -- * `obj2` is `null` or `undefined`\n// -- * `obj2` is an object, but it is empty\n// -- * All attributes of `obj2` are `undefined`\n// -- * All attributes of `obj2` are referentially equal to the\n// --   corresponding attributes of `obj1`\n// --\n// -- Note that `undefined` attributes in `obj2` do not modify the\n// -- corresponding attributes in `obj1`.\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: { a: 1 } }\n// -- obj2 = { b: 3, c: { b: 2 } }\n// -- obj3 = mergeDeep(obj1, obj2)\n// -- // { a: 1, b: 3, c: { a: 1, b: 2 }  }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- mergeDeep(obj1, { c: { a: 1 } }) === obj1\n// -- // true\n// -- ```\n\n\nfunction mergeDeep(a, b, c, d, e, f, ...rest) {\n  return rest.length ? doMerge.call(null, false, true, a, b, c, d, e, f, ...rest) : doMerge(false, true, a, b, c, d, e, f);\n} // -- #### mergeIn()\n// -- Similar to `merge()`, but merging the value at a given nested path.\n// --\n// -- Usage examples:\n// --\n// -- * `mergeIn(obj1, path, obj2)`\n// -- * `mergeIn(obj1, path, ...objects)`\n// --\n// -- ```js\n// -- obj1 = { a: 1, d: { b: { d1: 3, d2: 4 } } }\n// -- obj2 = { d3: 5 }\n// -- obj3 = mergeIn(obj1, ['d', 'b'], obj2)\n// -- // { a: 1, d: { b: { d1: 3, d2: 4, d3: 5 } } }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- mergeIn(obj1, ['d', 'b'], { d2: 4 }) === obj1\n// -- // true\n// -- ```\n\n\nfunction mergeIn(a, path, b, c, d, e, f, ...rest) {\n  let prevVal = getIn(a, path);\n  if (prevVal == null) prevVal = {};\n  let nextVal;\n\n  if (rest.length) {\n    nextVal = doMerge.call(null, false, false, prevVal, b, c, d, e, f, ...rest);\n  } else {\n    nextVal = doMerge(false, false, prevVal, b, c, d, e, f);\n  }\n\n  return setIn(a, path, nextVal);\n} // -- #### omit()\n// -- Returns an object excluding one or several attributes.\n// --\n// -- Usage: `omit(obj, attrs)`\n//\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3, d: 4 }\n// -- omit(obj, 'a')\n// -- // { b: 2, c: 3, d: 4 }\n// -- omit(obj, ['b', 'c'])\n// -- // { a: 1, d: 4 }\n// --\n// -- // The same object is returned if there are no changes:\n// -- omit(obj, 'z') === obj1\n// -- // true\n// -- ```\n\n\nfunction omit(obj, attrs) {\n  const omitList = Array.isArray(attrs) ? attrs : [attrs];\n  let fDoSomething = false;\n\n  for (let i = 0; i < omitList.length; i++) {\n    if (hasOwnProperty.call(obj, omitList[i])) {\n      fDoSomething = true;\n      break;\n    }\n  }\n\n  if (!fDoSomething) return obj;\n  const out = {};\n  const keys = getKeysAndSymbols(obj);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (omitList.indexOf(key) >= 0) continue;\n    out[key] = obj[key];\n  }\n\n  return out;\n} // -- #### addDefaults()\n// -- Returns a new object built as follows: `undefined` keys in the first one\n// -- are filled in with the corresponding values from the second one\n// -- (even if they are `null`).\n// --\n// -- Usage:\n// --\n// -- * `addDefaults(obj, defaults)`\n// -- * `addDefaults(obj, ...defaultObjects)`\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: 3 }\n// -- obj2 = { c: 4, d: 5, e: null }\n// -- obj3 = addDefaults(obj1, obj2)\n// -- // { a: 1, b: 2, c: 3, d: 5, e: null }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- addDefaults(obj1, { c: 4 }) === obj1\n// -- // true\n// -- ```\n// Signatures:\n// - 2 args\n\n\n// Implementation and catch-all\nfunction addDefaults(a, b, c, d, e, f, ...rest) {\n  return rest.length ? doMerge.call(null, true, false, a, b, c, d, e, f, ...rest) : doMerge(true, false, a, b, c, d, e, f);\n}\n\nfunction doMerge(fAddDefaults, fDeep, first, ...rest) {\n  let out = first;\n\n  if (!(out != null)) {\n    throwStr(IS_DEV ? 'At least one object should be provided to merge()' : INVALID_ARGS);\n  }\n\n  let fChanged = false;\n\n  for (let idx = 0; idx < rest.length; idx++) {\n    const obj = rest[idx];\n    if (obj == null) continue;\n    const keys = getKeysAndSymbols(obj);\n    if (!keys.length) continue;\n\n    for (let j = 0; j <= keys.length; j++) {\n      const key = keys[j];\n      if (fAddDefaults && out[key] !== undefined) continue;\n      let nextVal = obj[key];\n\n      if (fDeep && isObject(out[key]) && isObject(nextVal)) {\n        nextVal = doMerge(fAddDefaults, fDeep, out[key], nextVal);\n      }\n\n      if (nextVal === undefined || nextVal === out[key]) continue;\n\n      if (!fChanged) {\n        fChanged = true;\n        out = clone(out);\n      }\n\n      out[key] = nextVal;\n    }\n  }\n\n  return out;\n} // ===============================================\n// ### Public API\n// ===============================================\n\n\nconst timm = {\n  clone,\n  addLast,\n  addFirst,\n  removeLast,\n  removeFirst,\n  insert,\n  removeAt,\n  replaceAt,\n  getIn,\n  set,\n  setIn,\n  update,\n  updateIn,\n  merge,\n  mergeDeep,\n  mergeIn,\n  omit,\n  addDefaults\n};\nvar _default = timm;\nexports.default = _default;","'use strict';\n\nconst pDefer = () => {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n};\n\nmodule.exports = pDefer;\n","/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n","var SortedArray = (function () {\n    var SortedArray = defclass({\n\n        constructor: function (array, compare) {\n            this.array   = [];\n            this.compare = compare || compareDefault;\n            var length   = array.length,\n                index    = 0;\n            while (index < length) this.insert(array[index++]);\n        },\n        insert: function (element) {\n            var array   = this.array,\n                compare = this.compare,\n                high    = array.length-1,\n                low     = 0,\n                pos = -1,\n                index,\n                ordering;\n\n            // The array is sorted. You must find the position of new element in O(log(n)), not O(n).\n            while (high >= low) {\n                index    = (high + low) / 2 >>> 0;\n                ordering = compare(array[index], element);                \n                if (ordering < 0) low  = index + 1;\n                else if (ordering > 0) high = index - 1;\n                else {\n                    pos = index;\n                    break;\n                };\n            }\n\n            if (pos === -1) {\n                // if element was not found, high < low.\n                pos = high;\n            }\n            // This assures that equal elements inserted after will be in a higher position in array.\n            // They can be equal for comparison purposes, but different objects with different data.\n            // Respecting the chronological order can be important for many applications.\n            pos++;\n            high = array.length-1;\n            while ((pos < high) && (compare(element, array[pos]) === 0)){\n                pos++;\n            }\n            index = array.length;\n            // Just to increase array size.\n            array.push(element);            \n            // Much faster. No need to elements swap.\n            while (index > pos) {\n                array[index] = array[--index];\n            }\n            // Set the new element on its correct position.\n            array[pos] = element;\n\n            return this;\n        },\n        search: function (element) {\n            var array   = this.array,\n                compare = this.compare,\n                high    = array.length-1,\n                low     = 0,\n                // In most languages, inner variable declaration makes the code slower.\n                index,\n                ordering;\n\n            while (high >= low) {\n                index    = (high + low) / 2 >>> 0;\n                ordering = compare(array[index], element);\n\n                     if (ordering < 0) low  = index + 1;\n                else if (ordering > 0) high = index - 1;\n                else return index;\n            }\n\n            return -1;\n        },\n        remove: function (element) {\n            var index = this.search(element);\n            if (index >= 0) this.array.splice(index, 1);\n            return this;\n        }\n    });\n\n    SortedArray.comparing = function (property, array) {\n        return new SortedArray(array, function (a, b) {\n            // This should be faster than calling functions.\n            // Besides, this way it is not needed to create useless function to return property value.\n            return compareDefault(a[property], b[property]);\n        });\n    };\n\n    return SortedArray;\n\n    function defclass(prototype) {\n        var constructor = prototype.constructor;\n        constructor.prototype = prototype;\n        return constructor;\n    }\n\n    function compareDefault(a, b) {\n        // Equality has a very low chance to happen. It should be the last option.\n        if (a < b)\n            return -1;\n        else if (a > b)\n            return 1;\n        else\n            return 0;\n    }\n}());\n\nif (typeof module === \"object\") module.exports = SortedArray;\nif (typeof define === \"function\" && define.amd)\n    define(function () { return SortedArray; });\n","import { SyncBailHook, SyncWaterfallHook } from \"tapable-ts\";\nimport { NestedError } from \"ts-nested-error\";\nimport type { ParserResult, AnyNode } from \"../binding-grammar/index\";\nimport {\n  // We can swap this with whichever parser we want to use\n  parseCustom as parseBinding,\n} from \"../binding-grammar\";\nimport type { BindingParserOptions, BindingLike } from \"./binding\";\nimport { BindingInstance } from \"./binding\";\nimport { isBinding } from \"./utils\";\nimport type { NormalizedResult, ResolveBindingASTOptions } from \"./resolver\";\nimport { resolveBindingAST } from \"./resolver\";\n\nexport * from \"./utils\";\nexport * from \"./binding\";\n\nexport const SIMPLE_BINDING_REGEX = /^[\\w\\-@]+(\\.[\\w\\-@]+)*$/;\nexport const BINDING_BRACKETS_REGEX = /[\\s()*=`{}'\"[\\]]/;\nconst LAZY_BINDING_REGEX = /^[^.]+(\\..+)*$/;\n\nconst DEFAULT_OPTIONS: BindingParserOptions = {\n  get: () => {\n    throw new Error(\"Not Implemented\");\n  },\n  set: () => {\n    throw new Error(\"Not Implemented\");\n  },\n  evaluate: () => {\n    throw new Error(\"Not Implemented\");\n  },\n};\n\ntype BeforeResolveNodeContext = Required<NormalizedResult> &\n  ResolveBindingASTOptions;\n\n/** A parser for creating bindings from a string */\nexport class BindingParser {\n  private cache: Record<string, BindingInstance>;\n  private parseCache: Record<string, ParserResult>;\n  private parserOptions: BindingParserOptions;\n\n  public hooks = {\n    skipOptimization: new SyncBailHook<[string], boolean>(),\n    beforeResolveNode: new SyncWaterfallHook<\n      [AnyNode, BeforeResolveNodeContext]\n    >(),\n  };\n\n  constructor(options?: Partial<BindingParserOptions>) {\n    this.parserOptions = { ...DEFAULT_OPTIONS, ...options };\n    this.cache = {};\n    this.parseCache = {};\n    this.parse = this.parse.bind(this);\n  }\n\n  /**\n   * Takes a binding path, parses it, and returns an equivalent, normalized\n   * representation of that path.\n   */\n  private normalizePath(\n    path: string,\n    resolveOptions: ResolveBindingASTOptions,\n  ) {\n    /**\n     * Ensure no binding characters exist in path and the characters remaining\n     * look like a binding format.\n     */\n    if (\n      !BINDING_BRACKETS_REGEX.test(path) &&\n      LAZY_BINDING_REGEX.test(path) &&\n      this.hooks.skipOptimization.call(path) !== true\n    ) {\n      return { path: path.split(\".\"), updates: undefined } as NormalizedResult;\n    }\n\n    const ast = this.parseCache[path] ?? parseBinding(path);\n    this.parseCache[path] = ast;\n\n    if (typeof ast !== \"object\" || !ast?.status) {\n      throw new TypeError(\n        `Cannot normalize path \"${path}\": ${ast?.error ?? \"Unknown Error.\"}`,\n      );\n    }\n\n    try {\n      return resolveBindingAST(ast.path, resolveOptions, this.hooks);\n    } catch (e: any) {\n      throw new NestedError(`Cannot resolve binding: ${path}`, e);\n    }\n  }\n\n  private getBindingForNormalizedResult(\n    normalized: NormalizedResult,\n  ): BindingInstance {\n    const normalizedStr = normalized.path.join(\".\");\n\n    if (this.cache[normalizedStr]) {\n      return this.cache[normalizedStr];\n    }\n\n    const created = new BindingInstance(\n      normalizedStr === \"\" ? [] : normalized.path,\n      this.parse,\n    );\n    this.cache[normalizedStr] = created;\n\n    return created;\n  }\n\n  public parse(\n    rawBinding: BindingLike,\n    overrides: Partial<BindingParserOptions> = {},\n  ): BindingInstance {\n    if (isBinding(rawBinding)) {\n      return rawBinding;\n    }\n\n    const options = {\n      ...this.parserOptions,\n      ...overrides,\n    };\n\n    let updates: Record<string, any> = {};\n\n    const joined = Array.isArray(rawBinding)\n      ? rawBinding.join(\".\")\n      : String(rawBinding);\n\n    const normalizeConfig: ResolveBindingASTOptions = {\n      getValue: (path: Array<string | number>) => {\n        const normalized = this.normalizePath(path.join(\".\"), normalizeConfig);\n\n        return options.get(this.getBindingForNormalizedResult(normalized));\n      },\n      evaluate: (exp) => {\n        return options.evaluate(exp);\n      },\n      convertToPath: (path: any) => {\n        if (path === undefined) {\n          throw new Error(\n            \"Attempted to convert undefined value to binding path\",\n          );\n        }\n\n        if (\n          typeof path !== \"string\" &&\n          typeof path !== \"number\" &&\n          typeof path !== \"boolean\"\n        ) {\n          throw new Error(\n            `Attempting to convert ${typeof path} to a binding path.`,\n          );\n        }\n\n        const normalized = this.normalizePath(String(path), normalizeConfig);\n\n        if (normalized.updates) {\n          updates = {\n            ...updates,\n            ...normalized.updates,\n          };\n        }\n\n        const joinedNormalizedPath = normalized.path.join(\".\");\n\n        if (joinedNormalizedPath === \"\") {\n          throw new Error(\"Nested path resolved to an empty path\");\n        }\n\n        return joinedNormalizedPath;\n      },\n    };\n\n    const normalized = this.normalizePath(joined, normalizeConfig);\n\n    if (normalized.updates) {\n      updates = {\n        ...updates,\n        ...normalized.updates,\n      };\n    }\n\n    const updateKeys = Object.keys(updates);\n\n    if (!options.readOnly && updateKeys.length > 0) {\n      const updateTransaction = updateKeys.map<[BindingInstance, any]>(\n        (updatedBinding) => [\n          this.parse(updatedBinding),\n          updates[updatedBinding],\n        ],\n      );\n\n      options.set(updateTransaction);\n    }\n\n    return this.getBindingForNormalizedResult(normalized);\n  }\n}\n","import { NestedError } from \"ts-nested-error\";\nimport type { SyncWaterfallHook } from \"tapable-ts\";\nimport type { PathNode, AnyNode } from \"../binding-grammar\";\nimport { findInArray, maybeConvertToNum } from \"./utils\";\n\nexport interface NormalizedResult {\n  /** The normalized path */\n  path: Array<string | number>;\n\n  /** Any new updates that need to happen for this binding to be resolved */\n  updates?: Record<string, any>;\n}\n\nexport interface ResolveBindingASTOptions {\n  /** Get the value of the model at the given path */\n  getValue: (path: Array<string | number>) => any;\n\n  /** Convert the value into valid path segments */\n  convertToPath: (value: any) => string;\n\n  /** Convert the value into valid path segments */\n  evaluate: (exp: string) => any;\n}\n\nexport interface ResolveBindingASTHooks {\n  /** A hook for transforming a node before fully resolving it */\n  beforeResolveNode: SyncWaterfallHook<\n    [AnyNode, Required<NormalizedResult> & ResolveBindingASTOptions]\n  >;\n}\n\n/** Given a binding AST, resolve it */\nexport function resolveBindingAST(\n  bindingPathNode: PathNode,\n  options: ResolveBindingASTOptions,\n  hooks?: ResolveBindingASTHooks,\n): NormalizedResult {\n  const context: Required<NormalizedResult> = {\n    updates: {},\n    path: [],\n  };\n\n  // let updates: Record<string, any> = {};\n  // const path: Array<string | number> = [];\n\n  /** Get the value for any child node */\n  function getValueForNode(node: AnyNode): any {\n    if (node.name === \"Value\") {\n      return node.value;\n    }\n\n    if (node.name === \"PathNode\") {\n      const nestedResolvedValue = resolveBindingAST(node, options);\n\n      if (nestedResolvedValue.updates) {\n        context.updates = {\n          ...context.updates,\n          ...nestedResolvedValue.updates,\n        };\n      }\n\n      try {\n        return options.convertToPath(\n          options.getValue(nestedResolvedValue.path),\n        );\n      } catch (e: any) {\n        throw new NestedError(\n          `Unable to resolve path segment: ${nestedResolvedValue.path}`,\n          e,\n        );\n      }\n    }\n\n    if (node.name === \"Expression\") {\n      try {\n        const actualValue = options.evaluate(node.value);\n\n        return options.convertToPath(actualValue);\n      } catch (e: any) {\n        throw new NestedError(`Unable to resolve path: ${node.value}`, e);\n      }\n    }\n\n    throw new Error(`Unable to resolve value for node: ${node.name}`);\n  }\n\n  /** Handle when path segments are binding paths (foo.bar) or single segments (foo) */\n  function appendPathSegments(segment: string | number) {\n    if (typeof segment === \"string\" && segment.indexOf(\".\") > -1) {\n      segment.split(\".\").forEach((i) => {\n        context.path.push(maybeConvertToNum(i));\n      });\n    } else {\n      context.path.push(segment);\n    }\n  }\n\n  /** Compute the _actual_ binding val from the AST */\n  function resolveNode(_node: AnyNode) {\n    const resolvedNode =\n      hooks?.beforeResolveNode.call(_node, { ...context, ...options }) ?? _node;\n\n    switch (resolvedNode.name) {\n      case \"Expression\":\n      case \"PathNode\":\n        appendPathSegments(getValueForNode(resolvedNode));\n        break;\n\n      case \"Value\":\n        appendPathSegments(\n          typeof resolvedNode.value === \"boolean\"\n            ? String(resolvedNode.value)\n            : resolvedNode.value,\n        );\n        break;\n\n      case \"Query\": {\n        // Look for an object at the path with the given key/val criteria\n        const objToQuery: Record<string, any>[] =\n          options.getValue(context.path) ?? [];\n\n        const { key, value } = resolvedNode;\n\n        const resolvedKey = getValueForNode(key);\n        const resolvedValue = value && getValueForNode(value);\n\n        const index = findInArray(objToQuery, resolvedKey, resolvedValue);\n\n        if (index === undefined || index === -1) {\n          context.updates[\n            [...context.path, objToQuery.length, resolvedKey].join(\".\")\n          ] = resolvedValue;\n          context.path.push(objToQuery.length);\n        } else {\n          context.path.push(index);\n        }\n\n        break;\n      }\n\n      case \"Concatenated\":\n        context.path.push(resolvedNode.value.map(getValueForNode).join(\"\"));\n        break;\n\n      default:\n        throw new Error(`Unsupported node type: ${(resolvedNode as any).name}`);\n    }\n  }\n\n  bindingPathNode.path.forEach(resolveNode);\n\n  return {\n    path: context.path,\n    updates:\n      Object.keys(context.updates ?? {}).length > 0\n        ? context.updates\n        : undefined,\n  };\n}\n","import get from \"dlv\";\nimport { setIn, omit, removeAt } from \"timm\";\nimport type { BindingInstance } from \"../binding\";\nimport type { BatchSetTransaction, DataModelImpl, Updates } from \"./model\";\n\n/**\n * A data model that stores data in an in-memory JS object\n */\nexport class LocalModel implements DataModelImpl {\n  public model: {\n    [key: string]: any;\n  };\n\n  constructor(model = {}) {\n    this.model = model;\n    this.get = this.get.bind(this);\n    this.set = this.set.bind(this);\n  }\n\n  public reset(model = {}) {\n    this.model = model;\n  }\n\n  public get(binding?: BindingInstance) {\n    if (!binding || !binding.asString()) {\n      return this.model;\n    }\n\n    return get(this.model, binding.asArray() as string[]);\n  }\n\n  public set(transaction: BatchSetTransaction) {\n    const effectiveOperations: Updates = [];\n    transaction.forEach(([binding, value]) => {\n      const oldValue = this.get(binding);\n      this.model = setIn(this.model, binding.asArray(), value) as any;\n      effectiveOperations.push({ binding, oldValue, newValue: value });\n    });\n    return effectiveOperations;\n  }\n\n  public delete(binding: BindingInstance) {\n    const parentBinding = binding.parent();\n\n    if (parentBinding) {\n      const parentValue = this.get(parentBinding);\n\n      if (parentValue !== undefined) {\n        if (Array.isArray(parentValue)) {\n          this.model = setIn(\n            this.model,\n            parentBinding.asArray(),\n            removeAt(parentValue, binding.key() as number),\n          ) as any;\n        } else {\n          this.model = setIn(\n            this.model,\n            parentBinding.asArray(),\n            omit(parentValue, binding.key() as string),\n          ) as any;\n        }\n      }\n    }\n  }\n}\n","import { setIn } from \"timm\";\nimport type { BindingInstance } from \"../binding\";\nimport type {\n  BatchSetTransaction,\n  DataModelImpl,\n  DataModelOptions,\n  DataModelMiddleware,\n  Updates,\n} from \"../data\";\nimport { toModel } from \"../data\";\nimport type { Logger } from \"../logger\";\n\nimport type { ValidationResponse } from \"./types\";\nimport { removeBindingAndChildrenFromMap } from \"./binding-map-splice\";\n\n/**\n * A BindingInstance with an indicator of whether or not it's a strong binding\n */\nexport type StrongOrWeakBinding = {\n  /** BindingInstance in question */\n  binding: BindingInstance;\n  /** Boolean indicating whether the relevant BindingInstance is a strong binding */\n  isStrong: boolean;\n};\n\n/**\n * Returns a validation object if the data is invalid or an set of BindingsInstances if the binding itself is a weak ref of another invalid validation\n */\nexport type MiddlewareChecker = (\n  binding: BindingInstance,\n  model: DataModelImpl,\n) => ValidationResponse | Set<StrongOrWeakBinding> | undefined;\n\n/**\n * Middleware for the data-model that caches the results of invalid data\n */\nexport class ValidationMiddleware implements DataModelMiddleware {\n  public validator: MiddlewareChecker;\n  public shadowModelPaths: Map<BindingInstance, any>;\n  private logger?: Logger;\n  private shouldIncludeInvalid?: (options?: DataModelOptions) => boolean;\n\n  constructor(\n    validator: MiddlewareChecker,\n    options?: {\n      /** A logger instance */\n      logger?: Logger;\n      /** Optional function to include data staged in shadowModel */\n      shouldIncludeInvalid?: (options?: DataModelOptions) => boolean;\n    },\n  ) {\n    this.validator = validator;\n    this.shadowModelPaths = new Map();\n    this.logger = options?.logger;\n    this.shouldIncludeInvalid = options?.shouldIncludeInvalid;\n  }\n\n  public set(\n    transaction: BatchSetTransaction,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ): Updates {\n    const asModel = toModel(this, { ...options, includeInvalid: true }, next);\n    const nextTransaction: BatchSetTransaction = [];\n\n    const includedBindings = new Set<BindingInstance>();\n\n    transaction.forEach(([binding, value]) => {\n      this.shadowModelPaths.set(binding, value);\n      includedBindings.add(binding);\n    });\n\n    const invalidBindings: Array<BindingInstance> = [];\n\n    this.shadowModelPaths.forEach((value, binding) => {\n      const validations = this.validator(binding, asModel);\n\n      if (validations === undefined) {\n        nextTransaction.push([binding, value]);\n      } else if (validations instanceof Set) {\n        validations.forEach((validation) => {\n          invalidBindings.push(validation.binding);\n          if (\n            !validation.isStrong &&\n            validation.binding.asString() === binding.asString()\n          ) {\n            nextTransaction.push([validation.binding, value]);\n          }\n        });\n      } else if (includedBindings.has(binding)) {\n        invalidBindings.push(binding);\n        this.logger?.debug(\n          `Invalid value for path: ${binding.asString()} - ${\n            validations.severity\n          } - ${validations.message}`,\n        );\n      }\n    });\n\n    let validResults: Updates = [];\n\n    if (next && nextTransaction.length > 0) {\n      // defer clearing the shadow model to prevent validations that are run twice due to weak binding refs still needing the data\n      nextTransaction.forEach(([binding]) =>\n        this.shadowModelPaths.delete(binding),\n      );\n      const result = next.set(nextTransaction, options);\n      if (invalidBindings.length === 0) {\n        return result;\n      }\n\n      validResults = result;\n    }\n\n    const invalidResults = invalidBindings.map((binding) => {\n      return {\n        binding,\n        oldValue: asModel.get(binding),\n        newValue: asModel.get(binding),\n        force: true,\n      };\n    });\n\n    return [...validResults, ...invalidResults];\n  }\n\n  public get(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ) {\n    let val = next?.get(binding, options);\n\n    if (\n      this.shouldIncludeInvalid?.(options) ??\n      options?.includeInvalid === true\n    ) {\n      this.shadowModelPaths.forEach((shadowValue, shadowBinding) => {\n        if (shadowBinding === binding) {\n          val = shadowValue;\n\n          return;\n        }\n\n        if (binding.contains(shadowBinding)) {\n          val = setIn(val, shadowBinding.relative(binding), shadowValue);\n        }\n      });\n    }\n\n    return val;\n  }\n\n  public delete(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl,\n  ) {\n    this.shadowModelPaths = removeBindingAndChildrenFromMap(\n      this.shadowModelPaths,\n      binding,\n    );\n\n    return next?.delete(binding, options);\n  }\n}\n","import { SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport { addLast, clone, setIn } from \"timm\";\nimport dlv from \"dlv\";\nimport { dequal } from \"dequal\";\nimport type { BindingInstance, BindingLike } from \"../../binding\";\nimport type {\n  DataModelOptions,\n  DataModelWithParser,\n  Updates,\n} from \"../../data\";\nimport { DependencyModel, withParser } from \"../../data\";\nimport type { Logger } from \"../../logger\";\nimport { Node, NodeType } from \"../parser\";\nimport { caresAboutDataChanges, toNodeResolveOptions } from \"./utils\";\nimport type { Resolve } from \"./types\";\nimport { getNodeID } from \"../parser/utils\";\n\nexport * from \"./types\";\nexport * from \"./utils\";\n\ninterface NodeUpdate extends Resolve.ResolvedNode {\n  /** A flag to track if a node has changed since the last resolution */\n  updated: boolean;\n}\n\n/** Add model context to the data model */\nconst withContext = (model: DataModelWithParser): DataModelWithParser => {\n  return {\n    get: (binding: BindingLike, options?: DataModelOptions): any => {\n      return model.get(binding, {\n        context: { model },\n        ...options,\n      });\n    },\n\n    set: (\n      transaction: [BindingLike, any][],\n      options?: DataModelOptions,\n    ): Updates => {\n      return model.set(transaction, {\n        context: { model },\n        ...options,\n      });\n    },\n\n    delete: (binding: BindingLike, options?: DataModelOptions): void => {\n      return model.delete(binding, {\n        context: { model },\n        ...options,\n      });\n    },\n  };\n};\n\nexport type ResolverHooks = {\n  /** A hook to allow skipping of the resolution tree for a specific node */\n  skipResolve: SyncWaterfallHook<\n    [boolean, Node.Node, Resolve.NodeResolveOptions]\n  >;\n\n  /** An event emitted before calculating the next update */\n  beforeUpdate: SyncHook<[Set<BindingInstance> | undefined]>;\n\n  /** An event emitted after calculating the next update */\n  afterUpdate: SyncHook<[any]>;\n\n  /** The options passed to a node to resolve it to an object */\n  resolveOptions: SyncWaterfallHook<[Resolve.NodeResolveOptions, Node.Node]>;\n\n  /** A hook to transform the AST node into a new AST node before resolving it */\n  beforeResolve: SyncWaterfallHook<\n    [Node.Node | null, Resolve.NodeResolveOptions]\n  >;\n\n  /**\n   * A hook to transform an AST node into it's resolved value.\n   * This runs _before_ any children are resolved\n   */\n  resolve: SyncWaterfallHook<[any, Node.Node, Resolve.NodeResolveOptions]>;\n\n  /**\n   * A hook to transform the resolved value of an AST node.\n   * This runs _after_ all children nodes are resolved\n   */\n  afterResolve: SyncWaterfallHook<[any, Node.Node, Resolve.NodeResolveOptions]>;\n\n  /** Called at the very end of a node's tree being updated */\n  afterNodeUpdate: SyncHook<[Node.Node, Node.Node | undefined, NodeUpdate]>;\n};\n\n/**\n * The Resolver is the way to take a parsed AST graph of a view and resolve it to a concrete representation of the current user state\n * It combines the ability to mutate ast nodes before resolving, as well as the mutating the resolved objects while parsing\n */\nexport class Resolver {\n  public readonly hooks: ResolverHooks = {\n    skipResolve: new SyncWaterfallHook(),\n    beforeUpdate: new SyncHook(),\n    afterUpdate: new SyncHook(),\n    resolveOptions: new SyncWaterfallHook(),\n    beforeResolve: new SyncWaterfallHook(),\n    resolve: new SyncWaterfallHook(),\n    afterResolve: new SyncWaterfallHook(),\n    afterNodeUpdate: new SyncHook(),\n  };\n\n  /**\n   * The AST tree after beforeResolve is ran mapped to the AST before beforeResolve is ran\n   */\n  private readonly ASTMap: Map<Node.Node, Node.Node>;\n  /**\n   * The AST tree after beforeResolve is ran mapped to the AST before beforeResolve is ran\n   */\n  private AsyncIdMap: Map<string, Node.Node>;\n  /**\n   * The root node in the AST tree we want to resolve\n   */\n  public readonly root: Node.Node;\n\n  /**\n   * The cache of the last resolved values when walking the tree.\n   * This gets recycled every update to avoid stale data if a node is unused in an update\n   */\n  private resolveCache: Map<Node.Node, Resolve.ResolvedNode>;\n\n  /**\n   * Cache of node IDs that have been processed to track if nodes have duplicate IDs\n   */\n  private idCache: Set<string>;\n\n  /**\n   * The parameters required to resolve AST nodes\n   */\n  private readonly options: Resolve.ResolverOptions;\n\n  /**\n   * Tapable logger for logging errors encountered during view resolution\n   */\n  private logger?: Logger;\n\n  constructor(root: Node.Node, options: Resolve.ResolverOptions) {\n    this.root = root;\n    this.options = options;\n    this.resolveCache = new Map();\n    this.ASTMap = new Map();\n    this.logger = options.logger;\n    this.idCache = new Set();\n    this.AsyncIdMap = new Map();\n  }\n\n  public getSourceNode(convertedAST: Node.Node): Node.Node | undefined {\n    return this.ASTMap.get(convertedAST);\n  }\n\n  public update(\n    changes?: Set<BindingInstance>,\n    asyncChanges?: Set<string>,\n  ): any {\n    this.hooks.beforeUpdate.call(changes);\n    const resolveCache = new Map<Node.Node, Resolve.ResolvedNode>();\n    this.idCache.clear();\n    const prevASTMap = new Map(this.ASTMap);\n    this.ASTMap.clear();\n\n    const prevAsyncIdMap = new Map(this.AsyncIdMap);\n    const nextAsyncIdMap = new Map<string, Node.Node>();\n    asyncChanges?.forEach((id) => {\n      let current: Node.Node | undefined = prevAsyncIdMap.get(id);\n      while (current && prevASTMap.has(current)) {\n        const next = prevASTMap.get(current);\n        if (next && this.resolveCache.has(next)) {\n          this.resolveCache.delete(next);\n        }\n        current = current.parent;\n      }\n    });\n\n    const updated = this.computeTree(\n      this.root,\n      undefined,\n      changes,\n      resolveCache,\n      toNodeResolveOptions(this.options),\n      undefined,\n      prevASTMap,\n      nextAsyncIdMap,\n    );\n    this.AsyncIdMap = nextAsyncIdMap;\n    this.resolveCache = resolveCache;\n    this.hooks.afterUpdate.call(updated.value);\n    return updated.value;\n  }\n\n  public getResolveCache(): Map<Node.Node, Resolve.ResolvedNode> {\n    return new Map(this.resolveCache);\n  }\n\n  private getPreviousResult(node: Node.Node): Resolve.ResolvedNode | undefined {\n    if (!node) {\n      return;\n    }\n\n    const isFirstUpdate = this.resolveCache.size === 0;\n    const id = getNodeID(node);\n\n    if (id) {\n      if (this.idCache.has(id)) {\n        // Only log this conflict once to cut down on noise\n        // May want to swap this to logging when we first see the id -- which may not be the first render\n        if (isFirstUpdate) {\n          if (node.type === NodeType.Asset || node.type === NodeType.View) {\n            this.logger?.error(\n              `Cache conflict: Found Asset/View nodes that have conflicting ids: ${id}, may cause cache issues.`,\n            );\n          } else if (node.type === NodeType.Value) {\n            this.logger?.info(\n              `Cache conflict: Found Value nodes that have conflicting ids: ${id}, may cause cache issues. To improve performance make value node IDs globally unique.`,\n            );\n          }\n        }\n\n        // Don't use anything from a prev result if there's a duplicate id detected\n        return;\n      }\n\n      this.idCache.add(id);\n    }\n\n    return this.resolveCache.get(node);\n  }\n\n  private cloneNode(node: any) {\n    const clonedNode = clone(node);\n\n    Object.keys(clonedNode).forEach((key) => {\n      if (key === \"parent\") return;\n\n      const value = clonedNode[key];\n      if (typeof value === \"object\" && value !== null) {\n        clonedNode[key] = Array.isArray(value) ? [...value] : { ...value };\n      }\n    });\n\n    return clonedNode;\n  }\n\n  private computeTree(\n    node: Node.Node,\n    rawParent: Node.Node | undefined,\n    dataChanges: Set<BindingInstance> | undefined,\n    cacheUpdate: Map<Node.Node, Resolve.ResolvedNode>,\n    options: Resolve.NodeResolveOptions,\n    partiallyResolvedParent: Node.Node | undefined,\n    prevASTMap: Map<Node.Node, Node.Node>,\n    nextAsyncIdMap: Map<string, Node.Node>,\n  ): NodeUpdate {\n    const dependencyModel = new DependencyModel(options.data.model);\n\n    dependencyModel.trackSubset(\"core\");\n    const depModelWithParser = withContext(\n      withParser(dependencyModel, this.options.parseBinding),\n    );\n\n    const resolveOptions = this.hooks.resolveOptions.call(\n      {\n        ...options,\n        data: {\n          ...options.data,\n          model: depModelWithParser,\n        },\n        evaluate: (exp) =>\n          this.options.evaluator.evaluate(exp, { model: depModelWithParser }),\n        node,\n      },\n      node,\n    );\n\n    const previousResult = this.getPreviousResult(node);\n    const previousDeps = previousResult?.dependencies;\n\n    const dataChanged = caresAboutDataChanges(dataChanges, previousDeps);\n    const shouldUseLastValue = this.hooks.skipResolve.call(\n      !dataChanged,\n      node,\n      resolveOptions,\n    );\n\n    if (previousResult && shouldUseLastValue) {\n      const update = {\n        ...previousResult,\n        updated: false,\n      };\n\n      /** Recursively repopulate the AST map given some AST Node and it's resolved AST representation */\n      const repopulateASTMapFromCache = (\n        resolvedNode: Resolve.ResolvedNode,\n        AST: Node.Node,\n        ASTParent: Node.Node | undefined,\n      ) => {\n        const { node: resolvedASTLocal } = resolvedNode;\n        this.ASTMap.set(resolvedASTLocal, AST);\n        const resolvedUpdate = {\n          ...resolvedNode,\n          updated: false,\n        };\n        cacheUpdate.set(AST, resolvedUpdate);\n        if (resolvedUpdate.node.type === NodeType.Async) {\n          nextAsyncIdMap.set(resolvedUpdate.node.id, resolvedUpdate.node);\n        }\n        for (const key of resolvedUpdate.node.asyncNodesResolved ?? []) {\n          nextAsyncIdMap.set(key, resolvedUpdate.node);\n        }\n\n        /** Helper function for recursing over child node */\n        const handleChildNode = (childNode: Node.Node) => {\n          // In order to get the correct results, we need to use the node references from the last update.\n          const originalChildNode = prevASTMap.get(childNode) ?? childNode;\n          const previousChildResult = this.getPreviousResult(originalChildNode);\n          if (!previousChildResult) return;\n\n          repopulateASTMapFromCache(\n            previousChildResult,\n            originalChildNode,\n            AST,\n          );\n        };\n\n        if (\"children\" in resolvedASTLocal) {\n          resolvedASTLocal.children?.forEach(({ value: childAST }) =>\n            handleChildNode(childAST),\n          );\n        } else if (resolvedASTLocal.type === NodeType.MultiNode) {\n          resolvedASTLocal.values.forEach(handleChildNode);\n        }\n\n        this.hooks.afterNodeUpdate.call(AST, ASTParent, resolvedUpdate);\n      };\n\n      // Point the root of the cached node to the new resolved node.\n      previousResult.node.parent = partiallyResolvedParent;\n\n      repopulateASTMapFromCache(previousResult, node, rawParent);\n\n      return update;\n    }\n\n    // Shallow clone the node so that changes to it during the resolve steps don't impact the original.\n    // We are trusting that this becomes a deep clone once the whole node tree has been traversed.\n    const clonedNode: Node.Node = {\n      ...this.cloneNode(node),\n      parent: partiallyResolvedParent,\n    };\n    const resolvedAST = this.hooks.beforeResolve.call(\n      clonedNode,\n      resolveOptions,\n    ) ?? {\n      type: NodeType.Empty,\n    };\n\n    resolvedAST.parent = partiallyResolvedParent;\n\n    if (resolvedAST.type === NodeType.Async) {\n      nextAsyncIdMap.set(resolvedAST.id, resolvedAST);\n    }\n    for (const id of resolvedAST.asyncNodesResolved ?? []) {\n      nextAsyncIdMap.set(id, resolvedAST);\n    }\n\n    resolveOptions.node = resolvedAST;\n\n    this.ASTMap.set(resolvedAST, node);\n\n    let resolved = this.hooks.resolve.call(\n      undefined,\n      resolvedAST,\n      resolveOptions,\n    );\n\n    let updated = !dequal(previousResult?.value, resolved);\n\n    if (previousResult && !updated) {\n      resolved = previousResult?.value;\n    }\n\n    const childDependencies = new Set<BindingInstance>();\n    dependencyModel.trackSubset(\"children\");\n\n    if (\"children\" in resolvedAST) {\n      const newChildren = resolvedAST.children?.map((child) => {\n        const computedChildTree = this.computeTree(\n          child.value,\n          node,\n          dataChanges,\n          cacheUpdate,\n          resolveOptions,\n          resolvedAST,\n          prevASTMap,\n          nextAsyncIdMap,\n        );\n        const {\n          dependencies: childTreeDeps,\n          node: childNode,\n          updated: childUpdated,\n          value: childValue,\n        } = computedChildTree;\n\n        childTreeDeps.forEach((binding) => childDependencies.add(binding));\n\n        if (childValue) {\n          if (childNode.type === NodeType.MultiNode && !childNode.override) {\n            const arr = addLast(\n              dlv(resolved, child.path as any[], []),\n              childValue,\n            );\n            resolved = setIn(resolved, child.path, arr);\n          } else {\n            resolved = setIn(resolved, child.path, childValue);\n          }\n        }\n\n        updated = updated || childUpdated;\n\n        return { ...child, value: childNode };\n      });\n\n      resolvedAST.children = newChildren;\n    } else if (resolvedAST.type === NodeType.MultiNode) {\n      const childValue: any = [];\n      const rawParentToPassIn = node;\n\n      resolvedAST.values = resolvedAST.values.map((mValue) => {\n        const mTree = this.computeTree(\n          mValue,\n          rawParentToPassIn,\n          dataChanges,\n          cacheUpdate,\n          resolveOptions,\n          resolvedAST,\n          prevASTMap,\n          nextAsyncIdMap,\n        );\n\n        if (mTree.value !== undefined && mTree.value !== null) {\n          mTree.dependencies.forEach((bindingDep) =>\n            childDependencies.add(bindingDep),\n          );\n\n          updated = updated || mTree.updated;\n          childValue.push(mTree.value);\n        }\n\n        return mTree.node;\n      });\n\n      resolved = childValue;\n    }\n\n    childDependencies.forEach((bindingDep) =>\n      dependencyModel.addChildReadDep(bindingDep),\n    );\n\n    dependencyModel.trackSubset(\"core\");\n    if (previousResult && !updated) {\n      resolved = previousResult?.value;\n    }\n\n    resolved = this.hooks.afterResolve.call(resolved, resolvedAST, {\n      ...resolveOptions,\n      getDependencies: (scope?: \"core\" | \"children\") =>\n        dependencyModel.getDependencies(scope),\n    });\n\n    const update: NodeUpdate = {\n      node: resolvedAST,\n      updated,\n      value: resolved,\n      dependencies: new Set([\n        ...dependencyModel.getDependencies(),\n        ...childDependencies,\n      ]),\n    };\n\n    this.hooks.afterNodeUpdate.call(node, rawParent, update);\n    cacheUpdate.set(node, update);\n\n    return update;\n  }\n}\n","import { setIn } from \"timm\";\nimport { SyncBailHook, SyncWaterfallHook } from \"tapable-ts\";\nimport type { AnyAssetType, Node } from \"./types\";\nimport { NodeType } from \"./types\";\n\nexport * from \"./types\";\nexport * from \"./utils\";\n\nexport const EMPTY_NODE: Node.Empty = {\n  type: NodeType.Empty,\n};\n\nexport interface ParseObjectOptions {\n  /** how nested the templated is */\n  templateDepth?: number;\n}\n\nexport interface ParseObjectChildOptions {\n  key: string;\n  path: Node.PathSegment[];\n  parentObj: object;\n}\n\nexport type ParserHooks = {\n  /**\n   * A hook to interact with an object _before_ parsing it into an AST\n   *\n   * @param value - The object we're are about to parse\n   * @returns - A new value to parse.\n   *  If undefined, the original value is used.\n   *  If null, we stop parsing this node.\n   */\n  onParseObject: SyncWaterfallHook<[object, NodeType]>;\n  /**\n   * A callback to interact with an AST _after_ we parse it into the AST\n   *\n   * @param value - The object we parsed\n   * @param node - The AST node we generated\n   * @returns - A new AST node to use\n   *   If undefined, the original value is used.\n   *   If null, we ignore this node all together\n   */\n  onCreateASTNode: SyncWaterfallHook<[Node.Node | undefined | null, object]>;\n  /** A hook to call when parsing an object into an AST node\n   *\n   * @param obj - The object we're are about to parse\n   * @param nodeType - The type of node we're parsing\n   * @param parseOptions - Additional options when parsing\n   * @param childOptions - Additional options that are populated when the node being parsed is a child of another node\n   * @returns - A new AST node to use\n   *   If undefined, the original value is used.\n   *   If null, we ignore this node all together\n   */\n  parseNode: SyncBailHook<\n    [\n      obj: object,\n      nodeType: Node.ChildrenTypes,\n      parseOptions: ParseObjectOptions,\n      childOptions?: ParseObjectChildOptions,\n    ],\n    Node.Node | Node.Child[]\n  >;\n};\n\ninterface NestedObj {\n  /** The values of a nested local object */\n  children: Node.Child[];\n\n  value: any;\n}\n/**\n * The Parser is the way to take an incoming view from the user and parse it into an AST.\n * It provides a few ways to interact with the parsing, including mutating an object before and after creation of an AST node\n */\nexport class Parser {\n  public readonly hooks: ParserHooks = {\n    onParseObject: new SyncWaterfallHook(),\n    onCreateASTNode: new SyncWaterfallHook(),\n    parseNode: new SyncBailHook(),\n  };\n\n  public parseView(value: AnyAssetType): Node.View {\n    const viewNode = this.parseObject(value, NodeType.View);\n\n    if (!viewNode) {\n      throw new Error(\"Unable to parse object into a view\");\n    }\n\n    return viewNode as Node.View;\n  }\n\n  public createASTNode(node: Node.Node | null, value: any): Node.Node | null {\n    const tapped = this.hooks.onCreateASTNode.call(node, value);\n\n    if (tapped === undefined) {\n      return node;\n    }\n\n    return tapped;\n  }\n\n  public parseObject(\n    obj: object,\n    type: Node.ChildrenTypes = NodeType.Value,\n    options: ParseObjectOptions = { templateDepth: 0 },\n  ): Node.Node | null {\n    const parsedNode = this.hooks.parseNode.call(\n      obj,\n      type,\n      options,\n    ) as Node.Node | null;\n\n    if (parsedNode || parsedNode === null) {\n      return parsedNode;\n    }\n\n    const parseLocalObject = (\n      currentValue: any,\n      objToParse: unknown,\n      path: string[] = [],\n    ): NestedObj => {\n      if (typeof objToParse !== \"object\" || objToParse === null) {\n        return { value: objToParse, children: [] };\n      }\n\n      const localObj = this.hooks.onParseObject.call(objToParse, type);\n\n      if (!localObj) {\n        return currentValue;\n      }\n\n      const objEntries = Array.isArray(localObj)\n        ? localObj.map((v, i) => [i, v])\n        : [\n            ...Object.entries(localObj),\n            ...Object.getOwnPropertySymbols(localObj).map((s) => [\n              s,\n              (localObj as any)[s],\n            ]),\n          ];\n\n      const defaultValue: NestedObj = {\n        children: [],\n        value: currentValue,\n      };\n\n      const newValue = objEntries.reduce((accumulation, current): NestedObj => {\n        let { value } = accumulation;\n        const { children } = accumulation;\n        const [localKey, localValue] = current;\n\n        const newChildren = this.hooks.parseNode.call(\n          localValue,\n          NodeType.Value,\n          options,\n          {\n            path,\n            key: localKey,\n            parentObj: localObj,\n          },\n        ) as Node.Child[];\n\n        if (newChildren) {\n          children.push(...newChildren);\n        } else if (localValue && typeof localValue === \"object\") {\n          const result = parseLocalObject(accumulation.value, localValue, [\n            ...path,\n            localKey,\n          ]);\n\n          value = result.value;\n          children.push(...result.children);\n        } else {\n          value = setIn(accumulation.value, [...path, localKey], localValue);\n        }\n\n        return {\n          value,\n          children,\n        };\n      }, defaultValue);\n\n      return newValue;\n    };\n\n    const { value, children } = parseLocalObject(undefined, obj);\n\n    const baseAst =\n      value === undefined && !children.length\n        ? undefined\n        : {\n            type,\n            value,\n          };\n\n    if (baseAst && children.length) {\n      const parent: Node.BaseWithChildren<any> = baseAst;\n      parent.children = children;\n      children.forEach((child) => {\n        child.value.parent = parent;\n      });\n    }\n\n    return this.hooks.onCreateASTNode.call(baseAst, obj) ?? null;\n  }\n}\n","import { omit } from \"timm\";\nimport type { Options } from \"./options\";\nimport type { Resolver } from \"../resolver\";\nimport type {\n  Node,\n  ParseObjectOptions,\n  ParseObjectChildOptions,\n  Parser,\n} from \"../parser\";\nimport { NodeType } from \"../parser\";\nimport { ViewInstance, ViewPlugin } from \"../view\";\n\n/** A view plugin to remove inapplicable assets from the tree */\nexport default class ApplicabilityPlugin implements ViewPlugin {\n  private isApplicability(obj: any) {\n    return obj && Object.prototype.hasOwnProperty.call(obj, \"applicability\");\n  }\n\n  applyResolver(resolver: Resolver) {\n    resolver.hooks.beforeResolve.tap(\n      \"applicability\",\n      (node: Node.Node | null, options: Options) => {\n        let newNode = node;\n\n        if (node?.type === NodeType.Applicability) {\n          const isApplicable = options.evaluate(node.expression);\n\n          if (isApplicable === false) {\n            return null;\n          }\n\n          newNode = node.value;\n        }\n\n        return newNode;\n      },\n    );\n  }\n\n  applyParser(parser: Parser) {\n    parser.hooks.parseNode.tap(\n      \"applicability\",\n      (\n        obj: any,\n        nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        childOptions?: ParseObjectChildOptions,\n      ) => {\n        if (this.isApplicability(obj)) {\n          const parsedApplicability = parser.parseObject(\n            omit(obj, \"applicability\"),\n            nodeType,\n            options,\n          );\n\n          if (!parsedApplicability) {\n            return childOptions ? [] : null;\n          }\n\n          const applicabilityNode = parser.createASTNode(\n            {\n              type: NodeType.Applicability,\n              expression: (obj as any).applicability,\n              value: parsedApplicability,\n            },\n            obj,\n          );\n\n          if (!applicabilityNode) {\n            return childOptions ? [] : null;\n          }\n\n          if (applicabilityNode.type === NodeType.Applicability) {\n            applicabilityNode.value.parent = applicabilityNode;\n          }\n\n          return childOptions\n            ? [\n                {\n                  path: [...childOptions.path, childOptions.key],\n                  value: applicabilityNode,\n                },\n              ]\n            : applicabilityNode;\n        }\n      },\n    );\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.resolver.tap(\"applicability\", this.applyResolver.bind(this));\n    view.hooks.parser.tap(\"applicability\", this.applyParser.bind(this));\n  }\n}\n","import { setIn } from \"timm\";\nimport deferred from \"p-defer\";\nimport type { Flow, FlowResult } from \"@player-ui/types\";\nimport queueMicrotask from \"queue-microtask\";\n\nimport { SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport type { Logger } from \"./logger\";\nimport { TapableLogger } from \"./logger\";\nimport type { ExpressionType } from \"./expressions\";\nimport { ExpressionEvaluator, isPromiseLike } from \"./expressions\";\nimport { SchemaController } from \"./schema\";\nimport { BindingParser } from \"./binding\";\nimport type { ViewInstance } from \"./view\";\nimport { resolveDataRefs } from \"./string-resolver\";\nimport type { FlowInstance } from \"./controllers\";\nimport {\n  ConstantsController,\n  ViewController,\n  DataController,\n  ValidationController,\n  FlowController,\n} from \"./controllers\";\nimport { FlowExpPlugin } from \"./plugins/flow-exp-plugin\";\nimport { DefaultExpPlugin } from \"./plugins/default-exp-plugin\";\nimport type {\n  PlayerFlowState,\n  InProgressState,\n  CompletedState,\n  ErrorState,\n  PlayerHooks,\n} from \"./types\";\nimport { NOT_STARTED_STATE } from \"./types\";\n\n// Variables injected at build time\nconst PLAYER_VERSION = \"__VERSION__\";\nconst COMMIT = \"__GIT_COMMIT__\";\n\nexport interface PlayerPlugin {\n  /**\n   * Unique identifier of the plugin.\n   * Enables the plugin to be retrievable from Player.\n   */\n  symbol?: symbol;\n\n  /** The name of the plugin */\n  name: string;\n\n  /**\n   * Use this to tap into Player hooks\n   */\n  apply: (player: Player) => void;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface ExtendedPlayerPlugin<\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  Assets = void,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  Views = void,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  Expressions = void,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  DataTypes = void,\n> {}\n\nexport interface PlayerConfigOptions {\n  /** A set of plugins to load  */\n  plugins?: PlayerPlugin[];\n\n  /** A logger to use */\n  logger?: Logger;\n}\n\nexport interface PlayerInfo {\n  /** Version of the running player */\n  version: string;\n\n  /** Hash of the HEAD commit used to build the current version */\n  commit: string;\n}\n\n/**\n * This is it.\n */\nexport class Player {\n  public static readonly info: PlayerInfo = {\n    version: PLAYER_VERSION,\n    commit: COMMIT,\n  };\n\n  public readonly logger: TapableLogger = new TapableLogger();\n  public readonly constantsController: ConstantsController =\n    new ConstantsController();\n  private config: PlayerConfigOptions;\n  private state: PlayerFlowState = NOT_STARTED_STATE;\n\n  public readonly hooks: PlayerHooks = {\n    flowController: new SyncHook<[FlowController]>(),\n    viewController: new SyncHook<[ViewController]>(),\n    view: new SyncHook<[ViewInstance]>(),\n    expressionEvaluator: new SyncHook<[ExpressionEvaluator]>(),\n    dataController: new SyncHook<[DataController]>(),\n    schema: new SyncHook<[SchemaController]>(),\n    validationController: new SyncHook<[ValidationController]>(),\n    bindingParser: new SyncHook<[BindingParser]>(),\n    state: new SyncHook<[PlayerFlowState]>(),\n    onStart: new SyncHook<[Flow]>(),\n    onEnd: new SyncHook<[]>(),\n    resolveFlowContent: new SyncWaterfallHook<[Flow]>(),\n  };\n\n  constructor(config?: PlayerConfigOptions) {\n    if (config?.logger) {\n      this.logger.addHandler(config.logger);\n    }\n\n    this.config = config || {};\n    this.config.plugins = [\n      new DefaultExpPlugin(),\n      ...(this.config.plugins || []),\n      new FlowExpPlugin(),\n    ];\n    this.config.plugins?.forEach((plugin) => {\n      plugin.apply(this);\n    });\n  }\n\n  /**  Returns currently registered plugins */\n  public getPlugins(): PlayerPlugin[] {\n    return this.config.plugins ?? [];\n  }\n\n  /** Find instance of [Plugin] that has been registered to Player */\n  public findPlugin<Plugin extends PlayerPlugin>(\n    symbol: symbol,\n  ): Plugin | undefined {\n    return this.config.plugins?.find((el) => el.symbol === symbol) as Plugin;\n  }\n\n  /** Retrieve an instance of [Plugin] and conditionally invoke [apply] if it exists */\n  public applyTo<Plugin extends PlayerPlugin>(\n    symbol: symbol,\n    apply: (plugin: Plugin) => void,\n  ): void {\n    const plugin = this.findPlugin<Plugin>(symbol);\n\n    if (plugin) {\n      apply(plugin);\n    }\n  }\n\n  /** Register and apply [Plugin] if one with the same symbol is not already registered. */\n  public registerPlugin(plugin: PlayerPlugin): void {\n    plugin.apply(this);\n    this.config.plugins?.push(plugin);\n  }\n\n  /** Returns the current version of the running player */\n  public getVersion(): string {\n    return Player.info.version;\n  }\n\n  /** Returns the git commit used to build Player version */\n  public getCommit(): string {\n    return Player.info.commit;\n  }\n\n  /**\n   * Fetch the current state of Player.\n   * It will return either `not-started`, `in-progress`, `completed`\n   * with some extra data in each\n   */\n  public getState(): PlayerFlowState {\n    return this.state;\n  }\n\n  /**\n   * A private means of setting the state of Player\n   * Calls the hooks for subscribers to listen for this event\n   */\n  private setState(state: PlayerFlowState) {\n    this.state = state;\n    this.hooks.state.call(state);\n  }\n\n  /** Start Player with the given flow */\n  private setupFlow(userContent: Flow): {\n    /** a callback to _actually_ start the flow */\n    start: () => void;\n\n    /** the state object to kick if off */\n    state: Omit<InProgressState, \"ref\">;\n  } {\n    const userFlow = this.hooks.resolveFlowContent.call(userContent);\n\n    const flowController = new FlowController(userFlow.navigation, {\n      logger: this.logger,\n    });\n\n    this.hooks.onStart.call(userFlow);\n\n    this.hooks.flowController.call(flowController);\n\n    // eslint-disable-next-line prefer-const\n    let expressionEvaluator: ExpressionEvaluator;\n    // eslint-disable-next-line prefer-const\n    let dataController: DataController;\n\n    const pathResolver = new BindingParser({\n      get: (binding) => {\n        return dataController.get(binding);\n      },\n      set: (transaction) => {\n        return dataController.set(transaction);\n      },\n      evaluate: (expression) => {\n        return expressionEvaluator.evaluate(expression);\n      },\n    });\n\n    this.hooks.bindingParser.call(pathResolver);\n    const parseBinding = pathResolver.parse;\n    const flowResultDeferred = deferred<FlowResult>();\n\n    const schema = new SchemaController(userFlow.schema);\n    this.hooks.schema.call(schema);\n\n    const validationController = new ValidationController(schema);\n\n    this.hooks.validationController.call(validationController);\n\n    dataController = new DataController(userFlow.data, {\n      pathResolver,\n      middleware: validationController.getDataMiddleware(),\n      logger: this.logger,\n    });\n\n    dataController.hooks.format.tap(\"player\", (value, binding) => {\n      const formatter = schema.getFormatter(binding);\n\n      return formatter ? formatter.format(value) : value;\n    });\n\n    dataController.hooks.deformat.tap(\"player\", (value, binding) => {\n      const formatter = schema.getFormatter(binding);\n\n      return formatter ? formatter.deformat(value) : value;\n    });\n\n    dataController.hooks.resolveDefaultValue.tap(\n      \"player\",\n      (binding) => schema.getApparentType(binding)?.default,\n    );\n\n    // eslint-disable-next-line prefer-const\n    let viewController: ViewController;\n\n    expressionEvaluator = new ExpressionEvaluator({\n      model: dataController,\n      logger: this.logger,\n    });\n\n    this.hooks.expressionEvaluator.call(expressionEvaluator);\n\n    expressionEvaluator.hooks.onError.tap(\"player\", (e) => {\n      flowResultDeferred.reject(e);\n\n      return true;\n    });\n\n    /** Resolve any data references in a string */\n    function resolveStrings<T>(val: T, formatted?: boolean) {\n      return resolveDataRefs(val, {\n        model: dataController,\n        evaluate: expressionEvaluator.evaluate,\n        formatted,\n      });\n    }\n\n    flowController.hooks.flow.tap(\"player\", (flow: FlowInstance) => {\n      flow.hooks.beforeTransition.tap(\"player\", (state, transitionVal) => {\n        /** Checks to see if there are any transitions for a specific transition state (i.e. next, back). If not, it will default to * */\n        const computedTransitionVal = state.transitions[transitionVal]\n          ? transitionVal\n          : \"*\";\n        if (state.onEnd && state.transitions[computedTransitionVal]) {\n          if (typeof state.onEnd === \"object\" && \"exp\" in state.onEnd) {\n            expressionEvaluator?.evaluate(state.onEnd.exp);\n          } else {\n            expressionEvaluator?.evaluate(state.onEnd as ExpressionType);\n          }\n        }\n\n        /** If the transition does not exist, then do not resolve any expressions */\n        if (\n          !(\"transitions\" in state) ||\n          !state.transitions[computedTransitionVal]\n        ) {\n          return state;\n        }\n\n        /** resolves and sets the transition to the computed exp */\n        return setIn(\n          state,\n          [\"transitions\", computedTransitionVal],\n          resolveStrings(state.transitions[computedTransitionVal]),\n        ) as any;\n      });\n\n      flow.hooks.skipTransition.tap(\"validation\", (currentState) => {\n        if (currentState?.value.state_type === \"VIEW\") {\n          const { canTransition, validations } =\n            validationController.validateView(\"navigation\");\n\n          if (!canTransition && validations) {\n            const bindings = new Set(validations.keys());\n            viewController?.currentView?.update(bindings);\n\n            return true;\n          }\n        }\n\n        return undefined;\n      });\n\n      flow.hooks.resolveTransitionNode.tap(\"player\", (state) => {\n        let newState = state;\n\n        if (\"ref\" in state) {\n          newState = setIn(state, [\"ref\"], resolveStrings(state.ref)) as any;\n        }\n\n        if (\"param\" in state) {\n          newState = setIn(\n            state,\n            [\"param\"],\n            resolveStrings(state.param, false),\n          ) as any;\n        }\n\n        return newState;\n      });\n\n      flow.hooks.transition.tap(\"player\", (_oldState, newState) => {\n        if (newState.value.state_type !== \"VIEW\") {\n          validationController.reset();\n        }\n      });\n\n      // Tap for action states\n      flow.hooks.afterTransition.tap(\"player-action-states\", (flowInstance) => {\n        const value = flowInstance.currentState?.value;\n        if (value && value.state_type === \"ASYNC_ACTION\") {\n          const { exp } = value;\n          // defer async execution to next tick to allow transition to settle\n          try {\n            const result = expressionEvaluator.evaluateAsync(exp);\n            if (isPromiseLike(result)) {\n              if (value.await) {\n                queueMicrotask(() => {\n                  result\n                    .then((r) => flowController?.transition(String(r)))\n                    .catch(flowResultDeferred.reject);\n                });\n              } else {\n                this.logger.warn(\n                  \"Unawaited promise used as return value in in non-async context, transitioning with '*' value\",\n                );\n                flowController?.transition(String(result));\n              }\n            } else {\n              this.logger.warn(\n                \"Non async expression used in async action node\",\n              );\n              flowController?.transition(String(result));\n            }\n          } catch (e) {\n            flowResultDeferred.reject(e);\n          }\n        } else if (value && value.state_type === \"ACTION\") {\n          // handle sync actions\n          const { exp } = value;\n          const result = expressionEvaluator.evaluate(exp);\n          if (isPromiseLike(result)) {\n            this.logger.warn(\n              \"Async expression used as return value in in non-async context, transitioning with '*' value\",\n            );\n          }\n          flowController?.transition(String(result));\n        }\n\n        expressionEvaluator.reset();\n      });\n    });\n\n    this.hooks.dataController.call(dataController);\n\n    validationController.setOptions({\n      parseBinding,\n      model: dataController,\n      logger: this.logger,\n      evaluate: expressionEvaluator.evaluate,\n      constants: this.constantsController,\n    });\n\n    viewController = new ViewController(userFlow.views || [], {\n      evaluator: expressionEvaluator,\n      parseBinding,\n      transition: flowController.transition,\n      model: dataController,\n      utils: {\n        findPlugin: <Plugin = unknown>(pluginSymbol: symbol) => {\n          return this.findPlugin(pluginSymbol) as unknown as Plugin;\n        },\n      },\n      logger: this.logger,\n      flowController,\n      schema,\n      format: (binding, value) => {\n        const formatter = schema.getFormatter(binding);\n\n        return formatter?.format ? formatter.format(value) : value;\n      },\n      formatValue: (ref, value) => {\n        const formatter = schema.getFormatterForType(ref);\n\n        return formatter?.format ? formatter.format(value) : value;\n      },\n      validation: {\n        ...validationController.forView(parseBinding),\n        type: (b) => schema.getType(parseBinding(b)),\n      },\n      constants: this.constantsController,\n    });\n\n    viewController.hooks.view.tap(\"player\", (view) => {\n      validationController.onView(view);\n      this.hooks.view.call(view);\n    });\n    this.hooks.viewController.call(viewController);\n\n    return {\n      start: () => {\n        flowController\n          .start()\n          .then((endState) => {\n            const flowResult: FlowResult = {\n              endState: resolveStrings(endState, false),\n              data: dataController.serialize(),\n            };\n\n            return flowResult;\n          })\n          .then(flowResultDeferred.resolve)\n          .catch((e) => {\n            this.logger.error(`Something went wrong: ${e.message}`);\n            throw e;\n          })\n          .catch(flowResultDeferred.reject)\n          .finally(() => this.hooks.onEnd.call());\n      },\n      state: {\n        status: \"in-progress\",\n        flowResult: flowResultDeferred.promise,\n        controllers: {\n          data: dataController,\n          view: viewController,\n          flow: flowController,\n          schema,\n          expression: expressionEvaluator,\n          binding: pathResolver,\n          validation: validationController,\n        },\n        fail: flowResultDeferred.reject,\n        flow: userFlow,\n        logger: this.logger,\n      },\n    };\n  }\n\n  public async start(payload: Flow): Promise<CompletedState> {\n    const ref = Symbol(payload?.id ?? \"payload\");\n\n    /** A check to avoid updating the state for a flow that's not the current one */\n    const maybeUpdateState = <T extends PlayerFlowState>(newState: T) => {\n      if (this.state.ref !== ref) {\n        this.logger.warn(\n          `Received update for a flow that's not the current one`,\n        );\n\n        return newState;\n      }\n\n      this.setState(newState);\n\n      return newState;\n    };\n\n    this.setState({\n      status: \"not-started\",\n      ref,\n    });\n\n    try {\n      const { state, start } = this.setupFlow(payload);\n      this.setState({\n        ref,\n        ...state,\n      });\n\n      start();\n\n      // common data for the end state\n      // make sure to use the same ref as the starting one\n      const endProps = {\n        ref,\n        status: \"completed\",\n        flow: state.flow,\n        controllers: {\n          data: state.controllers.data.makeReadOnly(),\n        },\n      } as const;\n\n      return maybeUpdateState({\n        ...(await state.flowResult),\n        ...endProps,\n      });\n    } catch (error: any) {\n      const errorState: ErrorState = {\n        status: \"error\",\n        ref,\n        flow: payload,\n        error,\n      };\n\n      maybeUpdateState(errorState);\n\n      throw error;\n    }\n  }\n}\n","import { SyncBailHook, SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport type { DeferredPromise } from \"p-defer\";\nimport defer from \"p-defer\";\nimport type {\n  NavigationFlow,\n  NavigationFlowState,\n  NavigationFlowEndState,\n  NavigationFlowActionState,\n  NavigationFlowAsyncActionState,\n  NavigationFlowExternalState,\n  NavigationFlowFlowState,\n  NavigationFlowViewState,\n} from \"@player-ui/types\";\nimport type { Logger } from \"../../logger\";\n\nexport interface NamedState {\n  /** The name of the navigation node */\n  name: string;\n\n  /** The nav node */\n  value: NavigationFlowState;\n}\n\nexport interface TransitionOptions {\n  /** Ignore any validations or other signals preventing the transition from taking place  */\n  force?: boolean;\n}\nexport type TransitionFunction = (\n  name: string,\n  options?: TransitionOptions,\n) => void;\n\nexport interface FlowInstanceHooks {\n  beforeStart: SyncBailHook<\n    [NavigationFlow],\n    NavigationFlow,\n    Record<string, any>\n  >;\n  /** A callback when the onStart node was present */\n  onStart: SyncHook<[any], Record<string, any>>;\n  /** A callback when the onEnd node was present */\n  onEnd: SyncHook<[any], Record<string, any>>;\n  /** A hook to intercept and block a transition */\n  skipTransition: SyncBailHook<\n    [NamedState | undefined],\n    boolean | undefined,\n    Record<string, any>\n  >;\n  /** A chance to manipulate the flow-node used to calculate the given transition used  */\n  beforeTransition: SyncWaterfallHook<\n    [\n      (\n        | NavigationFlowViewState\n        | NavigationFlowFlowState\n        | NavigationFlowActionState\n        | NavigationFlowAsyncActionState\n        | NavigationFlowExternalState\n      ),\n      string,\n    ],\n    Record<string, any>\n  >;\n  /** A chance to manipulate the flow-node calculated after a transition */\n  resolveTransitionNode: SyncWaterfallHook<\n    [NavigationFlowState],\n    Record<string, any>\n  >;\n  /** A callback when a transition from 1 state to another was made */\n  transition: SyncHook<\n    [NamedState | undefined, NamedState],\n    Record<string, any>\n  >;\n  /** A callback to run actions after a transition occurs */\n  afterTransition: SyncHook<[FlowInstance], Record<string, any>>;\n}\n\n/** The Content navigation state machine */\nexport class FlowInstance {\n  private flow: NavigationFlow;\n  private log?: Logger;\n  private history: string[];\n  private isTransitioning = false;\n  private flowPromise?: DeferredPromise<NavigationFlowEndState>;\n  public readonly id: string;\n  public currentState?: NamedState;\n  public readonly hooks: FlowInstanceHooks = {\n    beforeStart: new SyncBailHook<[NavigationFlow], NavigationFlow>(),\n    onStart: new SyncHook<[any]>(),\n    onEnd: new SyncHook<[any]>(),\n    skipTransition: new SyncBailHook<\n      [NamedState | undefined],\n      boolean | undefined\n    >(),\n    beforeTransition: new SyncWaterfallHook<\n      [Exclude<NavigationFlowState, NavigationFlowEndState>, string]\n    >(),\n    resolveTransitionNode: new SyncWaterfallHook<[NavigationFlowState]>(),\n    transition: new SyncHook<[NamedState | undefined, NamedState]>(),\n    afterTransition: new SyncHook<[FlowInstance]>(),\n  };\n\n  constructor(\n    id: string,\n    flow: NavigationFlow,\n    options?: {\n      /** Logger instance to use */\n      logger?: Logger;\n    },\n  ) {\n    this.id = id;\n    this.flow = flow;\n    this.log = options?.logger;\n    this.history = [];\n\n    this.hooks.transition.tap(\n      \"startPromise\",\n      async (_oldState, nextState: NamedState) => {\n        const newState = nextState.value;\n\n        if (this.flowPromise && newState.state_type === \"END\") {\n          this.flowPromise.resolve(newState);\n        }\n      },\n    );\n  }\n\n  /** Start the state machine */\n  public async start(): Promise<NavigationFlowEndState> {\n    if (this.flowPromise) {\n      this.log?.warn(\"Already called start for flow\");\n\n      return this.flowPromise.promise;\n    }\n\n    this.flow = this.hooks.beforeStart.call(this.flow) || this.flow;\n\n    if (this.flow.onStart) {\n      this.hooks.onStart.call(this.flow.onStart);\n    }\n\n    const initialState = this.flow.startState;\n\n    if (!initialState) {\n      return Promise.reject(new Error(\"No 'startState' defined for flow\"));\n    }\n\n    this.flowPromise = defer();\n    this.pushHistory(initialState);\n\n    return this.flowPromise.promise;\n  }\n\n  public transition(\n    transitionValue: string,\n    options?: TransitionOptions,\n  ): void {\n    if (this.isTransitioning) {\n      throw new Error(\n        `Transitioning while ongoing transition from ${this.currentState?.name} is in progress is not supported`,\n      );\n    }\n\n    if (this.currentState?.value.state_type === \"END\") {\n      this.log?.warn(\n        `Skipping transition using ${transitionValue}. Already at and END state`,\n      );\n\n      return;\n    }\n\n    if (this.currentState === undefined) {\n      throw new Error(\"Cannot transition when there's no current state\");\n    }\n\n    if (options?.force) {\n      this.log?.debug(`Forced transition. Skipping validation checks`);\n    } else {\n      const skipTransition = this.hooks.skipTransition.call(this.currentState);\n\n      if (skipTransition) {\n        this.log?.debug(\n          `Skipping transition from ${this.currentState.name} b/c hook told us to`,\n        );\n        return;\n      }\n    }\n\n    const state = this.hooks.beforeTransition.call(\n      this.currentState.value,\n      transitionValue,\n    );\n\n    if (!(\"transitions\" in state)) {\n      throw new Error(`No transitions defined for ${this.currentState.value}`);\n    }\n\n    const { transitions } = state;\n    const nextState = transitions[transitionValue] || transitions[\"*\"];\n\n    if (nextState === undefined) {\n      this.log?.warn(\n        `No transition from ${this.currentState.name} using ${transitionValue} or *`,\n      );\n\n      return;\n    }\n\n    this.log?.debug(\n      `Transitioning from ${this.currentState.name} to ${nextState} using ${transitionValue} `,\n    );\n\n    return this.pushHistory(nextState, options);\n  }\n\n  private pushHistory(stateName: string, options?: TransitionOptions) {\n    if (!Object.prototype.hasOwnProperty.call(this.flow, stateName)) {\n      throw new Error(`No flow definition for: ${stateName} was found.`);\n    }\n\n    let nextState = this.flow[stateName];\n\n    if (\n      !this.flow[stateName] ||\n      typeof nextState !== \"object\" ||\n      !(\"state_type\" in nextState)\n    ) {\n      this.log?.error(`Flow doesn't contain any states named: ${stateName}`);\n\n      return;\n    }\n\n    const prevState = this.currentState;\n\n    this.isTransitioning = true;\n    nextState = this.hooks.resolveTransitionNode.call(nextState);\n\n    const newCurrentState = {\n      name: stateName,\n      value: nextState,\n    } as NamedState;\n    this.currentState = newCurrentState;\n    this.history.push(stateName);\n\n    // If the new state is an END state call the `onEnd` if it exists\n\n    if (newCurrentState.value.state_type === \"END\" && this.flow.onEnd) {\n      this.hooks.onEnd.call(this.flow.onEnd);\n    }\n\n    this.hooks.transition.call(prevState, {\n      ...newCurrentState,\n    });\n\n    this.isTransitioning = false;\n\n    this.hooks.afterTransition.call(this);\n  }\n}\n","import { SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport queueMicrotask from \"queue-microtask\";\nimport { Registry } from \"@player-ui/partial-match-registry\";\nimport type { View, NavigationFlowViewState } from \"@player-ui/types\";\n\nimport { resolveDataRefsInString } from \"../../string-resolver\";\nimport type { Resolve, ViewPlugin } from \"../../view\";\nimport {\n  ApplicabilityPlugin,\n  AssetPlugin,\n  AssetTransformCorePlugin,\n  MultiNodePlugin,\n  StringResolverPlugin,\n  SwitchPlugin,\n  TemplatePlugin,\n  toNodeResolveOptions,\n  ViewInstance,\n} from \"../../view\";\nimport type { Logger } from \"../../logger\";\nimport type { FlowInstance, FlowController } from \"../flow\";\nimport type { DataController } from \"../data/controller\";\nimport type { TransformRegistry } from \"./types\";\nimport type { BindingInstance } from \"../../binding\";\n\nexport interface ViewControllerOptions {\n  /** Where to get data from */\n  model: DataController;\n\n  /** Where to log data */\n  logger?: Logger;\n\n  /** A flow-controller instance to listen for view changes */\n  flowController: FlowController;\n}\n\nexport type ViewControllerHooks = {\n  /** Do any processing before the `View` instance is created */\n  resolveView: SyncWaterfallHook<\n    [View | undefined, string, NavigationFlowViewState]\n  >;\n\n  /** The hook right before the View starts resolving. Attach anything custom here */\n  view: SyncHook<[ViewInstance]>;\n};\n\n/** A controller to manage updating/switching views */\nexport class ViewController {\n  public readonly hooks: ViewControllerHooks = {\n    resolveView: new SyncWaterfallHook(),\n    view: new SyncHook(),\n  };\n\n  private readonly viewMap: Record<string, View>;\n  private readonly viewOptions: Resolve.ResolverOptions & ViewControllerOptions;\n  private pendingUpdate?: {\n    /** pending data binding changes */\n    changedBindings?: Set<BindingInstance>;\n    /** Whether we have a microtask queued to handle this pending update */\n    scheduled?: boolean;\n  };\n  private readonly viewPlugins: Array<ViewPlugin>;\n\n  public currentView?: ViewInstance;\n  public transformRegistry: TransformRegistry = new Registry();\n  public optimizeUpdates = true;\n\n  constructor(\n    initialViews: View[],\n    options: Resolve.ResolverOptions & ViewControllerOptions,\n  ) {\n    this.viewOptions = options;\n    this.viewMap = initialViews.reduce<Record<string, View>>(\n      (viewMap, view) => {\n        viewMap[view.id] = view;\n        return viewMap;\n      },\n      {},\n    );\n\n    options.flowController.hooks.flow.tap(\n      \"viewController\",\n      (flow: FlowInstance) => {\n        flow.hooks.transition.tap(\"viewController\", (_oldState, newState) => {\n          if (newState.value.state_type === \"VIEW\") {\n            this.onView(newState.value);\n          } else {\n            this.currentView = undefined;\n          }\n        });\n      },\n    );\n\n    /** Trigger a view update */\n    const update = (updates: Set<BindingInstance>, silent = false) => {\n      if (this.currentView) {\n        if (this.optimizeUpdates) {\n          this.queueUpdate(updates, silent);\n        } else {\n          this.currentView.update();\n        }\n      }\n    };\n\n    options.model.hooks.onUpdate.tap(\n      \"viewController\",\n      (updates, updateOptions) => {\n        update(\n          new Set(updates.map((t) => t.binding)),\n          updateOptions?.silent ?? false,\n        );\n      },\n    );\n\n    options.model.hooks.onDelete.tap(\"viewController\", (binding) => {\n      const parentBinding = binding.parent();\n      const property = binding.key();\n\n      // Deleting an array item will trigger an update for the entire array\n      if (typeof property === \"number\" && parentBinding) {\n        update(new Set([parentBinding]));\n      } else {\n        update(new Set([binding]));\n      }\n    });\n\n    this.viewPlugins = this.createViewPlugins();\n  }\n\n  private queueUpdate(bindings: Set<BindingInstance>, silent = false) {\n    if (this.pendingUpdate?.changedBindings) {\n      // If there's already a pending update, just add to it don't worry about silent updates here yet\n      this.pendingUpdate.changedBindings = new Set([\n        ...this.pendingUpdate.changedBindings,\n        ...bindings,\n      ]);\n    } else {\n      this.pendingUpdate = { changedBindings: bindings, scheduled: false };\n    }\n\n    // If there's no pending update, schedule one only if this one isn't silent\n    // otherwise if this is silent, we'll just wait for the next non-silent update and make sure our bindings are included\n    if (!this.pendingUpdate.scheduled && !silent) {\n      this.pendingUpdate.scheduled = true;\n      queueMicrotask(() => {\n        const updates = this.pendingUpdate?.changedBindings;\n        this.pendingUpdate = undefined;\n        this.currentView?.update(updates);\n      });\n    }\n  }\n\n  private getViewForRef(viewRef: string): View | undefined {\n    // First look for a 1:1 viewRef -> id mapping (this is most common)\n    if (this.viewMap[viewRef]) {\n      return this.viewMap[viewRef];\n    }\n\n    // The view ids saved may also contain model refs, resolve those and try again\n    const matchingViewId = Object.keys(this.viewMap).find(\n      (possibleViewIdMatch) =>\n        viewRef ===\n        resolveDataRefsInString(possibleViewIdMatch, {\n          model: this.viewOptions.model,\n          evaluate: this.viewOptions.evaluator.evaluate,\n        }),\n    );\n\n    if (matchingViewId && this.viewMap[matchingViewId]) {\n      return this.viewMap[matchingViewId];\n    }\n  }\n\n  public onView(state: NavigationFlowViewState): void {\n    const viewId = state.ref;\n\n    const source = this.hooks.resolveView.call(\n      this.getViewForRef(viewId),\n      viewId,\n      state,\n    );\n\n    if (!source) {\n      throw new Error(`No view with id ${viewId}`);\n    }\n\n    const view = new ViewInstance(source, this.viewOptions);\n    this.currentView = view;\n\n    // Give people a chance to attach their\n    // own listeners to the view before we resolve it\n    this.applyViewPlugins(view);\n    this.hooks.view.call(view);\n    view.update();\n  }\n\n  private applyViewPlugins(view: ViewInstance): void {\n    for (const plugin of this.viewPlugins) {\n      plugin.apply(view);\n    }\n  }\n\n  private createViewPlugins(): Array<ViewPlugin> {\n    const pluginOptions = toNodeResolveOptions(this.viewOptions);\n    return [\n      new AssetPlugin(),\n      new SwitchPlugin(pluginOptions),\n      new ApplicabilityPlugin(),\n      new AssetTransformCorePlugin(this.transformRegistry),\n      new StringResolverPlugin(),\n      new TemplatePlugin(pluginOptions),\n      new MultiNodePlugin(),\n    ];\n  }\n}\n","export interface Node<T extends string> {\n  /** The basic node type */\n  name: T;\n}\n\n/**\n * An AST node that represents a nested path in the model\n * foo.{{bar}}.baz (this is {{bar}})\n */\nexport interface PathNode extends Node<\"PathNode\"> {\n  /** The path in the model that this node represents */\n  path: Array<AnyNode>;\n}\n\n/**\n * A segment representing a query\n * [foo=bar]\n */\nexport interface QueryNode extends Node<\"Query\"> {\n  /** The key to query */\n  key: AnyNode;\n\n  /** The target value */\n  value?: AnyNode;\n}\n\n/** A simple segment */\nexport interface ValueNode extends Node<\"Value\"> {\n  /** The segment value */\n  value: string | number | boolean;\n}\n\n/** A nested expression */\nexport interface ExpressionNode extends Node<\"Expression\"> {\n  /** The expression */\n  value: string;\n}\n\n/** Helper to create a value node */\nexport const toValue = (value: string | number | boolean): ValueNode => ({\n  name: \"Value\",\n  value,\n});\n\n/** Helper to create an expression node */\nexport const toExpression = (value: string): ExpressionNode => ({\n  name: \"Expression\",\n  value,\n});\n\n/** Helper to create a nested path node */\nexport const toPath = (path: Array<AnyNode>): PathNode => ({\n  name: \"PathNode\",\n  path,\n});\n\n/** Helper to create a query node */\nexport const toQuery = (key: AnyNode, value?: AnyNode): QueryNode => ({\n  name: \"Query\",\n  key,\n  value,\n});\n\n/** Create a concat node */\nexport const toConcatenatedNode = (\n  values: Array<PathNode | ValueNode | ExpressionNode>,\n): PathNode | ValueNode | ConcatenatedNode | ExpressionNode => {\n  if (values.length === 1) {\n    return values[0];\n  }\n\n  return {\n    name: \"Concatenated\",\n    value: values,\n  };\n};\n\n/**\n * A binding segment that's multiple smaller ones\n * {{foo}}_bar_{{baz}}\n */\nexport interface ConcatenatedNode extends Node<\"Concatenated\"> {\n  /** A list of nested paths, or value nodes to concat together to form a segment */\n  value: Array<PathNode | ValueNode | ExpressionNode>;\n}\n\nexport type AnyNode =\n  | PathNode\n  | QueryNode\n  | ValueNode\n  | ConcatenatedNode\n  | ExpressionNode;\nexport type Path = Array<AnyNode>;\n\nexport interface ParserSuccessResult {\n  /** A successful parse result */\n  status: true;\n\n  /** The path the binding represents */\n  path: PathNode;\n}\n\nexport interface ParserFailureResult {\n  /** A failed parse result */\n  status: false;\n\n  /** The message representing the reason the parse result failed */\n  error: string;\n}\n\nexport type ParserResult = ParserSuccessResult | ParserFailureResult;\n\nexport type Parser = (raw: string) => ParserResult;\n","import type {\n  Parser,\n  AnyNode,\n  PathNode,\n  ConcatenatedNode,\n  ValueNode,\n  QueryNode,\n  ExpressionNode,\n} from \"../ast\";\nimport {\n  toValue,\n  toPath,\n  toConcatenatedNode,\n  toQuery,\n  toExpression,\n} from \"../ast\";\n\nconst SEGMENT_SEPARATOR = \".\";\nconst OPEN_CURL = \"{\";\nconst CLOSE_CURL = \"}\";\nconst OPEN_BRACKET = \"[\";\nconst CLOSE_BRACKET = \"]\";\nconst EQUALS = \"=\";\nconst SINGLE_QUOTE = \"'\";\nconst DOUBLE_QUOTE = '\"';\nconst BACK_TICK = \"`\";\n// const IDENTIFIER_REGEX = /[\\w\\-@]+/;\n\n/** A _faster_ way to match chars instead of a regex. */\nconst isIdentifierChar = (char?: string): boolean => {\n  if (!char) {\n    return false;\n  }\n\n  const charCode = char.charCodeAt(0);\n\n  const matches =\n    charCode === 32 || // ' '\n    charCode === 34 || // \"\n    charCode === 39 || // '\n    charCode === 40 || // (\n    charCode === 41 || // )\n    charCode === 42 || // *\n    charCode === 46 || // .\n    charCode === 61 || // =\n    charCode === 91 || // [\n    charCode === 93 || // ]\n    charCode === 96 || // `\n    charCode === 123 || // {\n    charCode === 125; // }\n\n  return !matches;\n};\n\n/** Parse out a binding AST from a path */\nexport const parse: Parser = (path) => {\n  let index = 1;\n  let ch = path.charAt(0);\n\n  /** get the next char in the string */\n  const next = (expected?: string) => {\n    if (expected && ch !== expected) {\n      throw new Error(`Expected char: ${expected} but got: ${ch}`);\n    }\n\n    ch = path.charAt(index);\n    index += 1;\n    return ch;\n  };\n\n  /** gobble all whitespace */\n  const whitespace = () => {\n    while (ch === \" \") {\n      next();\n    }\n  };\n\n  /** get an identifier if you can */\n  const identifier = (allowBoolValue = false): ValueNode | undefined => {\n    if (!isIdentifierChar(ch)) {\n      return;\n    }\n\n    let value: string | number = ch;\n\n    while (next()) {\n      if (!isIdentifierChar(ch)) {\n        break;\n      }\n\n      value += ch;\n    }\n\n    if (allowBoolValue) {\n      if (value === \"true\") {\n        return toValue(true);\n      }\n      if (value === \"false\") {\n        return toValue(false);\n      }\n    }\n\n    if (value) {\n      const maybeNumber = Number(value);\n      value = isNaN(maybeNumber) ? value : maybeNumber;\n      return toValue(value);\n    }\n  };\n\n  /** get an expression node if you can */\n  const expression = (): ExpressionNode | undefined => {\n    if (ch === BACK_TICK) {\n      next(BACK_TICK);\n\n      let exp = ch;\n\n      while (next()) {\n        if (ch === BACK_TICK) {\n          break;\n        }\n\n        exp += ch;\n      }\n\n      next(BACK_TICK);\n\n      if (exp) {\n        return toExpression(exp);\n      }\n    }\n  };\n\n  /** Grab a value using a regex */\n  const regex = (match: RegExp): ValueNode | undefined => {\n    if (!ch?.match(match)) {\n      return;\n    }\n\n    let value = ch;\n\n    while (next()) {\n      if (!ch?.match(match)) {\n        break;\n      }\n\n      value += ch;\n    }\n\n    if (value) {\n      return toValue(value);\n    }\n  };\n\n  /** parse out a nestedPath if you can */\n  const nestedPath = (): PathNode | undefined => {\n    if (ch === OPEN_CURL) {\n      next(OPEN_CURL);\n      next(OPEN_CURL);\n\n      const modelRef = parsePath();\n      next(CLOSE_CURL);\n      next(CLOSE_CURL);\n      return modelRef;\n    }\n  };\n\n  /** get a simple segment node */\n  const simpleSegment = (allowBoolValue = false) =>\n    nestedPath() ?? expression() ?? identifier(allowBoolValue);\n\n  /** Parse a segment */\n  const segment = ():\n    | ConcatenatedNode\n    | PathNode\n    | ValueNode\n    | ExpressionNode\n    | undefined => {\n    // Either a string, modelRef, or concatenated version (both)\n    const segments: Array<ValueNode | PathNode | ExpressionNode> = [];\n    let nextSegment = simpleSegment();\n\n    while (nextSegment !== undefined) {\n      segments.push(nextSegment);\n      nextSegment = simpleSegment();\n    }\n\n    if (segments.length === 0) {\n      return undefined;\n    }\n\n    return toConcatenatedNode(segments);\n  };\n\n  /** get an optionally quoted block */\n  const optionallyQuotedSegment = (\n    allowBoolValue = false,\n  ): ValueNode | PathNode | ExpressionNode | undefined => {\n    whitespace();\n\n    // see if we have a quote\n\n    if (ch === SINGLE_QUOTE || ch === DOUBLE_QUOTE) {\n      const singleQuote = ch === SINGLE_QUOTE;\n      next(singleQuote ? SINGLE_QUOTE : DOUBLE_QUOTE);\n      const id = regex(/[^'\"]+/);\n      next(singleQuote ? SINGLE_QUOTE : DOUBLE_QUOTE);\n      return id;\n    }\n\n    return simpleSegment(allowBoolValue);\n  };\n\n  /** eat equals signs */\n  const equals = (): boolean => {\n    if (ch !== EQUALS) {\n      return false;\n    }\n\n    while (ch === EQUALS) {\n      next();\n    }\n\n    return true;\n  };\n\n  /** Parse out a bracket */\n  const parseBracket = ():\n    | ValueNode\n    | QueryNode\n    | PathNode\n    | ExpressionNode\n    | undefined => {\n    if (ch === OPEN_BRACKET) {\n      next(OPEN_BRACKET);\n      whitespace();\n      let value: ValueNode | QueryNode | PathNode | ExpressionNode | undefined =\n        optionallyQuotedSegment();\n      if (value) {\n        whitespace();\n        if (equals()) {\n          whitespace();\n          const second = optionallyQuotedSegment(true);\n          value = toQuery(value, second);\n          whitespace();\n        }\n      } else {\n        throw new Error(`Expected identifier`);\n      }\n\n      if (value) {\n        next(CLOSE_BRACKET);\n      }\n\n      return value;\n    }\n  };\n\n  /** Parse a segment and any number of brackets following it */\n  const parseSegmentAndBrackets = (): Array<AnyNode> => {\n    // try to parse a segment first\n\n    const parsed: Array<AnyNode> = [];\n\n    const firstSegment = segment();\n\n    if (firstSegment) {\n      parsed.push(firstSegment);\n\n      let bracketSegment = parseBracket();\n\n      if (bracketSegment?.name === \"Value\") {\n        const maybeNumber = Number(bracketSegment.value);\n        bracketSegment.value =\n          isNaN(maybeNumber) || String(maybeNumber) !== bracketSegment.value\n            ? bracketSegment.value\n            : maybeNumber;\n      }\n\n      while (bracketSegment !== undefined) {\n        parsed.push(bracketSegment);\n        bracketSegment = parseBracket();\n      }\n    }\n\n    return parsed;\n  };\n\n  /** Parse out a path segment */\n  const parsePath = (): PathNode => {\n    const parts: AnyNode[] = [];\n\n    let nextSegment = parseSegmentAndBrackets();\n\n    while (nextSegment !== undefined) {\n      parts.push(...nextSegment);\n\n      if (!ch || ch === CLOSE_CURL) {\n        break;\n      }\n\n      if (nextSegment.length === 0 && ch) {\n        throw new Error(`Unexpected character: ${ch}`);\n      }\n\n      next(SEGMENT_SEPARATOR);\n      nextSegment = parseSegmentAndBrackets();\n    }\n\n    return toPath(parts);\n  };\n\n  try {\n    const result = parsePath();\n\n    return {\n      status: true,\n      path: result,\n    };\n  } catch (e: any) {\n    return {\n      status: false,\n      error: e.message,\n    };\n  }\n};\n","import { getBindingSegments } from \"./utils\";\n\nexport interface BindingParserOptions {\n  /** Get the value for a specific binding */\n  get: (binding: BindingInstance) => any;\n\n  /**\n   * Set the values for bindings.\n   * This is used when the query syntax needs to modify an object\n   */\n  set: (transaction: Array<[BindingInstance, any]>) => void;\n\n  /**\n   * Get the result of evaluating an expression\n   */\n  evaluate: (exp: string) => any;\n\n  /**\n   * Without readOnly, if a binding such as this is used: arr[key='does not exist'],\n   * then an object with that key will be created.\n   * This is done to make assignment such as arr[key='abc'].val = 'foo' work smoothly.\n   * Setting readOnly to true will prevent this behavior, avoiding unintended data changes.\n   */\n  readOnly?: boolean;\n}\n\nexport type Getter = (path: BindingInstance) => any;\n\nexport type RawBindingSegment = number | string;\nexport type RawBinding = string | RawBindingSegment[];\nexport type BindingLike = RawBinding | BindingInstance;\nexport type BindingFactory = (\n  raw: RawBinding,\n  options?: Partial<BindingParserOptions>,\n) => BindingInstance;\n\n/**\n * A path in the data model\n */\nexport class BindingInstance {\n  private split: RawBindingSegment[];\n  private joined: string;\n  private factory: BindingFactory;\n\n  constructor(\n    raw: RawBinding,\n    factory = (rawBinding: RawBinding) => new BindingInstance(rawBinding),\n  ) {\n    const split = Array.isArray(raw) ? raw : raw.split(\".\");\n    this.split = split.map((segment) => {\n      if (typeof segment === \"number\") {\n        return segment;\n      }\n\n      const tryNum = Number(segment);\n      // test to make sure turning a numerical string to a number doesn't change\n      // the actual value of the string by getting rid of a leading zero\n      return isNaN(tryNum) || String(tryNum) !== segment ? segment : tryNum;\n    });\n    Object.freeze(this.split);\n    this.joined = this.split.join(\".\");\n    this.factory = factory;\n  }\n\n  asArray(): RawBindingSegment[] {\n    return this.split;\n  }\n\n  asString(): string {\n    return this.joined;\n  }\n\n  /**\n   * Check to see if the given binding is a sub-path of the current one\n   */\n  contains(binding: BindingInstance): boolean {\n    // need to account for partial key matches\n    // [foo, bar] !== [foo, ba]\n    const bindingAsArray = binding.asArray();\n\n    if (bindingAsArray.length < this.split.length) {\n      return false;\n    }\n\n    // Check every overlapping index to make sure they're the same\n    // Intentionally use a for loop for speeeed\n    for (let i = 0; i < this.split.length; i++) {\n      if (this.split[i] !== bindingAsArray[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  relative(binding: BindingInstance): RawBindingSegment[] {\n    return this.asArray().slice(binding.asArray().length);\n  }\n\n  parent(): BindingInstance {\n    return this.factory(this.split.slice(0, -1));\n  }\n\n  key(): RawBindingSegment {\n    return this.split[this.split.length - 1];\n  }\n\n  /**\n   * This is a utility method to get a binding that is a descendent of this binding\n   *\n   * @param relative - The relative path to descend to\n   */\n  descendent(relative: BindingLike): BindingInstance {\n    const descendentSegments = getBindingSegments(relative);\n\n    return this.factory(this.split.concat(descendentSegments));\n  }\n}\n","import type { BindingInstance } from \"../binding\";\nimport type {\n  BatchSetTransaction,\n  DataModelImpl,\n  DataModelMiddleware,\n  DataModelOptions,\n  Updates,\n} from \"./model\";\n\nexport type DependencySets = \"core\" | \"children\";\n\n/** A class to track usage of read/writes to/from a data model */\nexport class DependencyTracker {\n  protected readDeps: Set<BindingInstance>;\n  protected writeDeps: Set<BindingInstance>;\n  protected namedSet: DependencySets;\n\n  private namedDependencySets: Partial<\n    Record<\n      DependencySets,\n      {\n        /** readDeps */\n        readDeps: Set<BindingInstance>;\n        /** writeDeps */\n        writeDeps: Set<BindingInstance>;\n      }\n    >\n  >;\n\n  constructor() {\n    this.readDeps = new Set();\n    this.writeDeps = new Set();\n    this.namedDependencySets = {};\n    this.namedSet = \"core\";\n\n    this.createSubset(\"core\");\n    this.createSubset(\"children\");\n  }\n\n  protected createSubset(name: DependencySets, force = false): void {\n    if (force || !this.namedDependencySets[name]) {\n      this.namedDependencySets[name] = {\n        readDeps: new Set(),\n        writeDeps: new Set(),\n      };\n    }\n  }\n\n  /** Grab all of the bindings that this depended on */\n  public getDependencies(name?: DependencySets): Set<BindingInstance> {\n    if (name !== undefined) {\n      return this.namedDependencySets?.[name]?.readDeps ?? new Set();\n    }\n\n    return this.readDeps;\n  }\n\n  public trackSubset(name: DependencySets) {\n    this.createSubset(name);\n    this.namedSet = name;\n  }\n\n  public trackDefault() {\n    this.namedSet = \"core\";\n  }\n\n  /** Grab all of the bindings this wrote to */\n  public getModified(name?: DependencySets): Set<BindingInstance> {\n    if (name !== undefined) {\n      return this.namedDependencySets?.[name]?.writeDeps ?? new Set();\n    }\n\n    return this.writeDeps;\n  }\n\n  /**\n   * Check to see if the dataModel has read the value at the given binding\n   *\n   * @param binding - The binding you want to check for\n   */\n  public readsBinding(binding: BindingInstance): boolean {\n    return this.readDeps.has(binding);\n  }\n\n  /**\n   * Check to see if the dataModel has written to the binding\n   */\n  public writesBinding(binding: BindingInstance): boolean {\n    return this.writeDeps.has(binding);\n  }\n\n  /** Reset all tracking of dependencies */\n  public reset() {\n    this.readDeps = new Set();\n    this.writeDeps = new Set();\n    this.namedDependencySets = {};\n    this.namedSet = \"core\";\n\n    this.createSubset(\"core\", true);\n    this.createSubset(\"children\", true);\n  }\n\n  protected addReadDep(\n    binding: BindingInstance,\n    namedSet = this.namedSet,\n  ): void {\n    if (namedSet) {\n      this.namedDependencySets?.[namedSet]?.readDeps.add(binding);\n    }\n\n    this.readDeps.add(binding);\n  }\n\n  protected addWriteDep(\n    binding: BindingInstance,\n    namedSet = this.namedSet,\n  ): void {\n    if (namedSet) {\n      this.namedDependencySets?.[namedSet]?.writeDeps.add(binding);\n    }\n\n    this.writeDeps.add(binding);\n  }\n\n  public addChildReadDep(binding: BindingInstance): void {\n    this.addReadDep(binding, \"children\");\n  }\n}\n\n/** Middleware that tracks dependencies of read/written data */\nexport class DependencyMiddleware\n  extends DependencyTracker\n  implements DataModelMiddleware\n{\n  constructor() {\n    super();\n    this.get = this.get.bind(this);\n    this.set = this.set.bind(this);\n  }\n\n  public set(\n    transaction: BatchSetTransaction,\n    options?: DataModelOptions,\n    next?: DataModelImpl | undefined,\n  ): Updates {\n    transaction.forEach(([binding]) => this.addWriteDep(binding));\n\n    return next?.set(transaction, options) ?? [];\n  }\n\n  public get(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl | undefined,\n  ) {\n    this.addReadDep(binding);\n\n    return next?.get(binding, options);\n  }\n\n  public delete(\n    binding: BindingInstance,\n    options?: DataModelOptions,\n    next?: DataModelImpl | undefined,\n  ) {\n    this.addWriteDep(binding);\n    return next?.delete(binding, options);\n  }\n}\n\n/** A data-model that tracks dependencies of read/written data */\nexport class DependencyModel<Options = DataModelOptions>\n  extends DependencyTracker\n  implements DataModelImpl<Options>\n{\n  private readonly rootModel: DataModelImpl<Options>;\n\n  constructor(rootModel: DataModelImpl<Options>) {\n    super();\n    this.rootModel = rootModel;\n    this.set = this.set.bind(this);\n    this.get = this.get.bind(this);\n  }\n\n  public set(transaction: BatchSetTransaction, options?: Options): Updates {\n    transaction.forEach(([binding]) => this.addWriteDep(binding));\n\n    return this.rootModel.set(transaction, options);\n  }\n\n  public get(binding: BindingInstance, options?: Options) {\n    this.addReadDep(binding);\n\n    return this.rootModel.get(binding, options);\n  }\n\n  public delete(binding: BindingInstance, options?: Options) {\n    this.addWriteDep(binding);\n    return this.rootModel.delete(binding, options);\n  }\n}\n","import type { DataModelImpl } from \"./model\";\n\n/**\n * A model that does nothing\n * Helpful for testing and other default DataModel applications\n */\nexport class NOOPDataModel implements DataModelImpl {\n  get() {\n    return undefined;\n  }\n\n  set() {\n    return [];\n  }\n\n  delete() {}\n}\n\n/** You only really need 1 instance of the NOOP model */\nexport const NOOP_MODEL = new NOOPDataModel();\n","import type { Binding } from \"@player-ui/types\";\n\nimport type { BindingLike } from \"../binding\";\nimport type {\n  ExpressionHandler,\n  ExpressionContext,\n  ExpressionNode,\n} from \"./types\";\nimport { Awaitable, isAwaitable, makeAwaitable } from \"./async\";\n\n/** Sets a value to the data-model */\nexport const setDataVal: ExpressionHandler<[Binding, any], any> = (\n  _context: ExpressionContext,\n  binding,\n  value,\n) => {\n  _context.model.set([[binding as BindingLike, value]]);\n};\n\n/** Fetches a valid from the data-model */\nexport const getDataVal: ExpressionHandler<[Binding], unknown> = (\n  _context: ExpressionContext,\n  binding,\n) => {\n  return _context.model.get(binding as BindingLike);\n};\n\n/** Deletes a value from the model */\nexport const deleteDataVal: ExpressionHandler<[Binding], void> = (\n  _context: ExpressionContext,\n  binding,\n) => {\n  return _context.model.delete(binding);\n};\n\n/** Conditional expression handler */\nexport const conditional: ExpressionHandler<\n  [ExpressionNode, ExpressionNode, ExpressionNode?]\n> = (ctx, condition, ifTrue, ifFalse) => {\n  const testResult = ctx.evaluate(condition);\n\n  // Handle Promise case automatically (same pattern as ternary operator)\n  if (isAwaitable(testResult)) {\n    return testResult.awaitableThen((resolvedTest: any) => {\n      if (resolvedTest) {\n        return ctx.evaluate(ifTrue);\n      }\n      if (ifFalse) {\n        return ctx.evaluate(ifFalse);\n      }\n      return null;\n    });\n  }\n\n  // Handle sync case\n  if (testResult) {\n    return ctx.evaluate(ifTrue);\n  }\n  if (ifFalse) {\n    return ctx.evaluate(ifFalse);\n  }\n  return null;\n};\n\nconditional.resolveParams = false;\n\n/**\n * Internal await function\n * This is technically registered as `await` but can't be called that due to conflicting with the keyword\n */\nexport const waitFor: ExpressionHandler<[Promise<any>], Awaitable<any>> = (\n  ctx,\n  promise,\n) => {\n  return makeAwaitable(promise);\n};\n","import { SyncHook } from \"tapable-ts\";\nimport type { Logger, Severity } from \"./types\";\n\n/** A logger that has a tapable subscriptions to callbacks */\nexport default class TapableLogger implements Logger {\n  public readonly hooks = {\n    trace: new SyncHook<[Array<any>]>(),\n    debug: new SyncHook<[Array<any>]>(),\n    info: new SyncHook<[Array<any>]>(),\n    warn: new SyncHook<[Array<any>]>(),\n    error: new SyncHook<[Array<any>]>(),\n    log: new SyncHook<[Severity, Array<any>]>(),\n  };\n\n  private logHandlers: Set<Logger> = new Set();\n\n  private createHandler(severity: Severity): (...args: any[]) => void {\n    return (...args: any[]) => {\n      this.hooks[severity].call(args);\n      this.hooks.log.call(severity, args);\n      this.logHandlers.forEach((logger) => logger[severity](...args));\n    };\n  }\n\n  public addHandler(logHandler: Logger) {\n    this.logHandlers.add(logHandler);\n  }\n\n  public removeHandler(logHandler: Logger) {\n    this.logHandlers.delete(logHandler);\n  }\n\n  public readonly trace = this.createHandler(\"trace\");\n  public readonly debug = this.createHandler(\"debug\");\n  public readonly info = this.createHandler(\"info\");\n  public readonly warn = this.createHandler(\"warn\");\n  public readonly error = this.createHandler(\"error\");\n}\n","import type { Logger, Severity, LoggerProvider } from \"./types\";\n\n/**\n * The ProxyLogger allows a user to log to another Logger instance that may not exist yet\n */\nexport default class ProxyLogger implements Logger {\n  private proxiedLoggerProvider: LoggerProvider;\n\n  constructor(loggerProvider: LoggerProvider) {\n    this.proxiedLoggerProvider = loggerProvider;\n  }\n\n  private createHandler(severity: Severity): (...args: any[]) => void {\n    return (...args: any[]) => {\n      const logger = this.proxiedLoggerProvider();\n      logger?.[severity](...args);\n    };\n  }\n\n  public readonly trace = this.createHandler(\"trace\");\n  public readonly debug = this.createHandler(\"debug\");\n  public readonly info = this.createHandler(\"info\");\n  public readonly warn = this.createHandler(\"warn\");\n  public readonly error = this.createHandler(\"error\");\n}\n","import type { ValidatorFunction } from \"./types\";\n\n/** A registry that tracks validators  */\nexport class ValidatorRegistry {\n  private registry: Map<string, ValidatorFunction<any>>;\n\n  constructor() {\n    this.registry = new Map();\n  }\n\n  /** Use the given validator name to fetch the handler */\n  public get(name: string): ValidatorFunction | undefined {\n    return this.registry.get(name);\n  }\n\n  /** Register a new validator */\n  public register<T>(name: string, handler: ValidatorFunction<T>) {\n    this.registry.set(name, handler);\n  }\n}\n","import type { Asset as AssetType, Expression, Binding } from \"@player-ui/types\";\n\nexport type AnyAssetType = AssetType<string>;\nexport enum NodeType {\n  Asset = \"asset\",\n  View = \"view\",\n  Applicability = \"applicability\",\n  Template = \"template\",\n  Value = \"value\",\n  MultiNode = \"multi-node\",\n  Switch = \"switch\",\n  Async = \"async\",\n  Unknown = \"unknown\",\n  Empty = \"empty\",\n}\nexport declare namespace Node {\n  export type ChildrenTypes = NodeType.Asset | NodeType.Value | NodeType.View;\n\n  export interface Base<T extends NodeType> {\n    /** Every node contains a type to distinguish it from other nodes */\n    type: T;\n\n    /** Every node (outside of the root) contains a reference to it's parent */\n    parent?: Node;\n\n    /** The ids of async nodes resolved within this node */\n    asyncNodesResolved?: string[];\n  }\n\n  export type PathSegment = string | number;\n\n  export interface Child {\n    /** The path of the child relative to the parent */\n    path: PathSegment[];\n\n    /** If true, the path points to an array, and the value will be appended to it result */\n    array?: boolean;\n\n    /** The child node */\n    value: Node;\n  }\n\n  export interface BaseWithChildren<T extends NodeType> extends Base<T> {\n    /** Any node that contains a list of children underneath it */\n    children?: Child[];\n  }\n\n  export interface Asset<T extends AnyAssetType = AnyAssetType>\n    extends BaseWithChildren<NodeType.Asset>,\n      PluginOptions {\n    /** Any asset nested within a view */\n    value: T;\n  }\n\n  export interface View<T extends AnyAssetType = AnyAssetType>\n    extends BaseWithChildren<NodeType.View>,\n      PluginOptions {\n    /** The root of the parsed view */\n    value: T;\n  }\n\n  export interface Applicability extends Base<NodeType.Applicability> {\n    /** The expression to execute that determines applicability of the target node */\n    expression: Expression;\n\n    /** The node to use if the expression is truthy */\n    value: Node;\n  }\n\n  export interface Template extends Base<NodeType.Template> {\n    /** The location of an array in the model */\n    data: Binding;\n\n    /** The template to use when mapping over the data */\n    template: unknown;\n\n    /** The number of nested templates so far */\n    depth: number;\n\n    /** Should the template recompute when data changes */\n    dynamic?: boolean;\n\n    /** Specifies the template placement in relation to existing elements*/\n    placement?: \"prepend\" | \"append\";\n  }\n\n  export interface Value\n    extends BaseWithChildren<NodeType.Value>,\n      PluginOptions {\n    /** A simple node representing a value */\n    value: any;\n  }\n\n  export interface MultiNode extends Base<NodeType.MultiNode> {\n    /**\n     * Should this list override the target node if they overlap?\n     * If not amend the existing list\n     */\n    override?: boolean;\n\n    /** A list of values that comprise this node */\n    values: Array<Node>;\n  }\n\n  export interface Switch extends Base<NodeType.Switch> {\n    /** Should this list be re-computed when data changes */\n    dynamic?: boolean;\n\n    /** A list of cases to evaluate in order */\n    cases: SwitchCase[];\n  }\n\n  export interface SwitchCase {\n    /** The expression to evaluate for a single case statement */\n    case: Expression | true;\n    /** The value to use if this case is true */\n    value: Value;\n  }\n\n  export interface Async extends Base<NodeType.Async> {\n    /** The unique id of the node */\n    id: string;\n    /** The value representing the node */\n    value: Node;\n    /**\n     * Should the content streamed in be flattened during resolving\n     */\n    flatten?: boolean;\n    /** Function to run against parsed content from the node to manipulate the content before resolving it. */\n    onValueReceived?: (node: Node.Node) => Node.Node;\n  }\n\n  export interface PluginOptions {\n    /** A list of plugins */\n    plugins?: {\n      /** StringResolverPlugin options */\n      stringResolver?: {\n        /**\n         * An optional array of node properties to skip during string resolution\n         * Specified in the AssetTransformPlugin\n         */\n        propertiesToSkip?: string[];\n      };\n    };\n  }\n\n  export type Unknown = Base<NodeType.Unknown>;\n  export type Empty = Base<NodeType.Empty>;\n  export type ViewOrAsset = View | Asset;\n\n  export type Node =\n    | Asset\n    | Applicability\n    | Template\n    | Value\n    | View\n    | MultiNode\n    | Switch\n    | Async\n    | Unknown\n    | Empty;\n}\n","import { SyncHook } from \"tapable-ts\";\nimport type { View as ViewType } from \"@player-ui/types\";\nimport type { BindingInstance, BindingFactory } from \"../binding\";\nimport type { ValidationProvider, ValidationObject } from \"../validator\";\nimport type { Logger } from \"../logger\";\nimport type { Resolve } from \"./resolver\";\nimport { Resolver } from \"./resolver\";\nimport type { Node } from \"./parser\";\nimport { Parser } from \"./parser\";\nimport { TemplatePlugin } from \"./plugins\";\n\n/**\n * Manages the view level validations\n */\nclass CrossfieldProvider implements ValidationProvider {\n  private allValidations = new Set<ValidationObject>();\n  private byBinding = new Map<BindingInstance, Array<ValidationObject>>();\n  private logger?: Logger;\n\n  constructor(initialView: ViewType, parser: BindingFactory, logger?: Logger) {\n    this.logger = logger;\n    this.parse(initialView, parser);\n  }\n\n  private parse(contentView: ViewType, parser: BindingFactory) {\n    const xfieldRefs = contentView.validation;\n\n    if (xfieldRefs === undefined) {\n      return;\n    }\n\n    if (!Array.isArray(xfieldRefs)) {\n      this.logger?.warn(\n        `Unable to register view validations for id: ${contentView.id}. 'validation' property must be an Array.`,\n      );\n\n      return;\n    }\n\n    // Grab the validations from the view (as authored) and parse out the ones that have a _ref_ (to a binding)\n    // Group them all by binding to make it easier to return than later\n\n    xfieldRefs.forEach((vRef) => {\n      // x-field validations by default are triggered by navigating away from the page\n      // the reference can also override that _or_ the severity\n      const withDefaults: ValidationObject = {\n        trigger: \"navigation\",\n        severity: \"error\",\n        ...vRef,\n      };\n\n      this.allValidations.add(withDefaults);\n\n      // The validation reference contains a _ref_ (a binding)\n      const { ref } = vRef;\n\n      if (ref) {\n        /** Group together validations by binding */\n        const parsed = parser(ref);\n\n        if (this.byBinding.has(parsed)) {\n          this.byBinding.get(parsed)?.push(withDefaults);\n        } else {\n          this.byBinding.set(parsed, [withDefaults]);\n        }\n      }\n    });\n  }\n\n  getValidationsForBinding(binding: BindingInstance) {\n    return this.byBinding.get(binding);\n  }\n}\n\nexport type ViewHooks = {\n  /** Hook every time there is an update to this view instance */\n  onUpdate: SyncHook<[ViewType]>;\n  /** Hook to retrieve the parser used for this view */\n  parser: SyncHook<[Parser]>;\n  /** Hook to retrieve the resolver used for this view */\n  resolver: SyncHook<[Resolver]>;\n  /** Hook to retrieve the template plugin used for this view */\n  templatePlugin: SyncHook<[TemplatePlugin]>;\n};\n\n/** A stateful view instance from an content */\nexport class ViewInstance implements ValidationProvider {\n  public hooks: ViewHooks = {\n    onUpdate: new SyncHook(),\n    parser: new SyncHook(),\n    resolver: new SyncHook(),\n    templatePlugin: new SyncHook(),\n  };\n\n  private resolver?: Resolver;\n  public readonly initialView: ViewType;\n  public readonly resolverOptions: Resolve.ResolverOptions;\n  private rootNode?: Node.Node;\n\n  private validationProvider?: CrossfieldProvider;\n\n  private templatePlugin: TemplatePlugin | undefined;\n\n  // TODO might want to add a version/timestamp to this to compare updates\n  public lastUpdate: Record<string, any> | undefined;\n\n  constructor(initialView: ViewType, resolverOptions: Resolve.ResolverOptions) {\n    this.initialView = initialView;\n    this.resolverOptions = resolverOptions;\n  }\n\n  public updateAsync(asyncNode: string): void {\n    const update = this.resolver?.update(new Set(), new Set([asyncNode]));\n    this.lastUpdate = update;\n    this.hooks.onUpdate.call(update);\n  }\n\n  public update(changes?: Set<BindingInstance>): any {\n    if (this.rootNode === undefined) {\n      /** On initialization of the view, also create a validation parser */\n      this.validationProvider = new CrossfieldProvider(\n        this.initialView,\n        this.resolverOptions.parseBinding,\n        this.resolverOptions.logger,\n      );\n\n      if (this.templatePlugin) {\n        this.hooks.templatePlugin.call(this.templatePlugin);\n      } else {\n        this.resolverOptions.logger?.warn(\n          \"templatePlugin not set for View, legacy templates may not work\",\n        );\n      }\n\n      const parser = new Parser();\n      this.hooks.parser.call(parser);\n      this.rootNode = parser.parseView(this.initialView);\n\n      this.resolver = new Resolver(this.rootNode, {\n        ...this.resolverOptions,\n        parseNode: parser.parseObject.bind(parser),\n      });\n      this.hooks.resolver.call(this.resolver);\n    }\n\n    const update = this.resolver?.update(changes);\n\n    if (this.lastUpdate === update) {\n      return this.lastUpdate;\n    }\n\n    this.lastUpdate = update;\n    this.hooks.onUpdate.call(update);\n\n    return update;\n  }\n\n  getValidationsForBinding(\n    binding: BindingInstance,\n  ): Array<ValidationObject> | undefined {\n    return this.validationProvider?.getValidationsForBinding(binding);\n  }\n\n  public setTemplatePlugin(plugin: TemplatePlugin): void {\n    this.templatePlugin = plugin;\n  }\n}\n\n/** A plugin for a view */\nexport interface ViewPlugin {\n  /** Called with a view instance */\n  apply(view: ViewInstance): void;\n}\n","import { SyncWaterfallHook } from \"tapable-ts\";\nimport type { Template } from \"@player-ui/types\";\nimport type {\n  Node,\n  ParseObjectOptions,\n  ParseObjectChildOptions,\n  Parser,\n} from \"../parser\";\nimport { NodeType } from \"../parser\";\nimport { ViewInstance, ViewPlugin } from \"../view\";\nimport type { Options } from \"./options\";\nimport type { Resolver } from \"../resolver\";\nimport { hasTemplateKey } from \"../parser/utils\";\n\nconst templateSymbol = Symbol(\"template\");\n\nexport interface TemplateItemInfo {\n  /** The index of the data for the current iteration of the template */\n  index: number;\n  /** The data for the current iteration of the template */\n  data: any;\n  /** The depth of the template node */\n  depth: number;\n}\n\nexport interface TemplateSubstitution {\n  /** Regular expression to find and replace. The global flag will be always be added to this expression. */\n  expression: string | RegExp;\n  /** The value to replace matches with. */\n  value: string;\n}\n\nexport type TemplateSubstitutionsFunc = (\n  baseSubstitutions: TemplateSubstitution[],\n  templateItemInfo: TemplateItemInfo,\n) => TemplateSubstitution[];\n\n/** A view plugin to resolve/manage templates */\nexport default class TemplatePlugin implements ViewPlugin {\n  private readonly options: Options;\n\n  hooks: {\n    resolveTemplateSubstitutions: SyncWaterfallHook<\n      [TemplateSubstitution[], TemplateItemInfo],\n      Record<string, any>\n    >;\n  } = {\n    resolveTemplateSubstitutions: new SyncWaterfallHook<\n      [TemplateSubstitution[], TemplateItemInfo]\n    >(),\n  };\n\n  constructor(options: Options) {\n    this.options = options;\n  }\n\n  private parseTemplate(\n    parseObject: any,\n    node: Node.Template,\n    options: Options,\n  ): Node.Node | null {\n    const { template, depth } = node;\n    const data = options.data.model.get(node.data);\n\n    if (!data) {\n      return null;\n    }\n\n    if (!Array.isArray(data)) {\n      throw new Error(`Template using '${node.data}' but is not an array`);\n    }\n\n    const values: Array<Node.Node> = [];\n\n    data.forEach((dataItem, index) => {\n      const templateSubstitutions =\n        this.hooks.resolveTemplateSubstitutions.call(\n          [\n            {\n              expression: new RegExp(`_index${depth || \"\"}_`),\n              value: String(index),\n            },\n          ],\n          {\n            depth,\n            data: dataItem,\n            index,\n          },\n        );\n      let templateStr = JSON.stringify(template);\n\n      for (const { expression, value } of templateSubstitutions) {\n        let flags = \"g\";\n        if (typeof expression === \"object\") {\n          flags = `${expression.flags}${expression.global ? \"\" : \"g\"}`;\n        }\n\n        templateStr = templateStr.replace(new RegExp(expression, flags), value);\n      }\n\n      const parsed = parseObject(JSON.parse(templateStr), NodeType.Value, {\n        templateDepth: node.depth + 1,\n      });\n\n      if (parsed) {\n        values.push(parsed);\n      }\n    });\n\n    const result: Node.MultiNode = {\n      type: NodeType.MultiNode,\n      override: false,\n      values,\n    };\n\n    // Removes undefined Symbol property\n    if (node.placement !== undefined) {\n      (result as any)[templateSymbol] = node.placement;\n    }\n\n    return result;\n  }\n\n  applyParser(parser: Parser): void {\n    parser.hooks.onCreateASTNode.tap(\"template\", (node) => {\n      if (node && node.type === NodeType.Template && !node.dynamic) {\n        return this.parseTemplate(\n          parser.parseObject.bind(parser),\n          node,\n          this.options,\n        );\n      }\n\n      return node;\n    });\n\n    parser.hooks.onCreateASTNode.tap(\"template\", (node) => {\n      function getTemplateSymbolValue(node: Node.Node): string | undefined {\n        if (node.type === NodeType.MultiNode) {\n          return (node as any)[templateSymbol];\n        } else if (node.type === NodeType.Template) {\n          return node.placement;\n        }\n        return undefined;\n      }\n\n      if (\n        node &&\n        (node.type === NodeType.View || node.type === NodeType.Asset) &&\n        Array.isArray(node.children)\n      ) {\n        node.children = node.children.sort((a, b) => {\n          // compare template output with static values\n          const aPath = a.path.join();\n          const bPath = b.path.join();\n\n          const pathsEqual = aPath === bPath;\n\n          if (pathsEqual) {\n            const aPlacement = getTemplateSymbolValue(a.value);\n            const bPlacement = getTemplateSymbolValue(b.value);\n\n            if (aPlacement !== undefined && bPlacement === undefined) {\n              return aPlacement === \"prepend\" ? -1 : 1;\n            } else if (bPlacement !== undefined && aPlacement === undefined) {\n              return bPlacement === \"prepend\" ? 1 : -1;\n            } else if (aPlacement !== undefined && bPlacement !== undefined) {\n              // Both have placement values\n              if (aPlacement === bPlacement) {\n                return 0; // Same placement, no preference\n              }\n              // \"prepend\" should come before \"append\"\n              return aPlacement === \"prepend\" ? -1 : 1;\n            }\n            return 0;\n          }\n\n          // Trigger more sorting for nested assets\n          return aPath > bPath ? 1 : -1;\n        });\n      }\n\n      return node;\n    });\n\n    parser.hooks.parseNode.tap(\n      \"template\",\n      (\n        obj: any,\n        _nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        childOptions?: ParseObjectChildOptions,\n      ) => {\n        if (childOptions && hasTemplateKey(childOptions.key)) {\n          return obj\n            .map((template: Template) => {\n              const templateAST = parser.createASTNode(\n                {\n                  type: NodeType.Template,\n                  depth: options.templateDepth ?? 0,\n                  data: template.data,\n                  template: template.value,\n                  dynamic: template.dynamic ?? false,\n                  placement: template.placement,\n                },\n                template,\n              );\n\n              if (!templateAST) return;\n\n              if (templateAST.type === NodeType.MultiNode) {\n                templateAST.values.forEach((v) => {\n                  v.parent = templateAST;\n                });\n              }\n\n              return {\n                path: [...childOptions.path, template.output],\n                value: templateAST,\n              };\n            })\n            .filter(Boolean);\n        }\n      },\n    );\n  }\n\n  applyResolverHooks(resolver: Resolver): void {\n    // Transform dynamic templates into MultiNodes\n    resolver.hooks.beforeResolve.tap(\"template\", (node, options) => {\n      if (node && node.type === NodeType.Template && node.dynamic) {\n        return this.parseTemplate(options.parseNode, node, options);\n      }\n\n      return node;\n    });\n  }\n\n  apply(view: ViewInstance): void {\n    view.hooks.parser.tap(\"template\", this.applyParser.bind(this));\n    view.hooks.resolver.tap(\"template\", this.applyResolverHooks.bind(this));\n    view.setTemplatePlugin(this);\n  }\n}\n","import { ViewInstance, ViewPlugin } from \"../view\";\nimport type { Options } from \"./options\";\nimport type {\n  Parser,\n  Node,\n  ParseObjectOptions,\n  ParseObjectChildOptions,\n} from \"../parser\";\nimport { EMPTY_NODE, NodeType } from \"../parser\";\nimport type { Resolver } from \"../resolver\";\nimport { hasSwitchKey } from \"../parser/utils\";\n\n/** A view plugin to resolve switches */\nexport default class SwitchPlugin implements ViewPlugin {\n  private readonly options: Options;\n\n  constructor(options: Options) {\n    this.options = options;\n  }\n\n  private resolveSwitch(node: Node.Switch, options: Options): Node.Node {\n    for (const switchCase of node.cases) {\n      const isApplicable = options.evaluate(switchCase.case);\n      if (isApplicable) {\n        return switchCase.value;\n      }\n    }\n\n    return EMPTY_NODE;\n  }\n\n  private isSwitch(obj: any) {\n    return (\n      obj &&\n      (Object.prototype.hasOwnProperty.call(obj, \"dynamicSwitch\") ||\n        Object.prototype.hasOwnProperty.call(obj, \"staticSwitch\"))\n    );\n  }\n\n  applyParser(parser: Parser) {\n    /** Switches resolved during the parsing phase are static */\n    parser.hooks.onCreateASTNode.tap(\"switch\", (node) => {\n      if (node && node.type === NodeType.Switch && !node.dynamic) {\n        return this.resolveSwitch(node, this.options);\n      }\n\n      return node;\n    });\n\n    parser.hooks.parseNode.tap(\n      \"switch\",\n      (\n        obj: any,\n        _nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        childOptions?: ParseObjectChildOptions,\n      ) => {\n        if (\n          this.isSwitch(obj) ||\n          (childOptions && hasSwitchKey(childOptions.key))\n        ) {\n          const objToParse =\n            childOptions && hasSwitchKey(childOptions.key)\n              ? { [childOptions.key]: obj }\n              : obj;\n          const dynamic = \"dynamicSwitch\" in objToParse;\n          const switchContent = dynamic\n            ? objToParse.dynamicSwitch\n            : objToParse.staticSwitch;\n\n          const cases: Node.SwitchCase[] = switchContent\n            .map(\n              (switchCase: {\n                [x: string]: any;\n                /**\n                 *\n                 */\n                case: any;\n              }) => {\n                const { case: switchCaseExpr, ...switchBody } = switchCase;\n                const value = parser.parseObject(\n                  switchBody,\n                  NodeType.Value,\n                  options,\n                );\n\n                if (value) {\n                  return {\n                    case: switchCaseExpr,\n                    value: value as Node.Value,\n                  };\n                }\n\n                return;\n              },\n            )\n            .filter(Boolean);\n\n          const switchAST = parser.createASTNode(\n            {\n              type: NodeType.Switch,\n              dynamic,\n              cases,\n            },\n            objToParse,\n          );\n\n          if (!switchAST || switchAST.type === NodeType.Empty) {\n            return childOptions ? [] : null;\n          }\n\n          if (switchAST.type === NodeType.Switch) {\n            switchAST.cases.forEach((sCase) => {\n              sCase.value.parent = switchAST;\n            });\n          }\n\n          if (childOptions) {\n            let path = [...childOptions.path, childOptions.key];\n            let value: any = switchAST;\n\n            if (\n              switchAST.type === NodeType.Value &&\n              switchAST.children?.length === 1 &&\n              switchAST.value === undefined\n            ) {\n              const firstChild = switchAST.children[0];\n              path = [...path, ...firstChild.path];\n              value = firstChild.value;\n            }\n\n            return [{ path, value }];\n          }\n\n          return switchAST;\n        }\n      },\n    );\n  }\n\n  applyResolver(resolver: Resolver) {\n    /** Switches resolved during the parsing phase are dynamic */\n    resolver.hooks.beforeResolve.tap(\"switch\", (node, options) => {\n      if (node && node.type === NodeType.Switch && node.dynamic) {\n        return this.resolveSwitch(node, options);\n      }\n\n      return node;\n    });\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.parser.tap(\"switch\", this.applyParser.bind(this));\n    view.hooks.resolver.tap(\"switch\", this.applyResolver.bind(this));\n  }\n}\n","import { ViewInstance, ViewPlugin } from \"../view\";\nimport type {\n  Parser,\n  Node,\n  ParseObjectOptions,\n  ParseObjectChildOptions,\n} from \"../parser\";\nimport { NodeType } from \"../parser\";\nimport { hasTemplateValues, hasTemplateKey } from \"../parser/utils\";\n\n/** A view plugin to resolve multi nodes */\nexport default class MultiNodePlugin implements ViewPlugin {\n  applyParser(parser: Parser): void {\n    parser.hooks.parseNode.tap(\n      \"multi-node\",\n      (\n        obj: any,\n        nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        childOptions?: ParseObjectChildOptions,\n      ) => {\n        if (\n          (childOptions === undefined || !hasTemplateKey(childOptions.key)) &&\n          Array.isArray(obj)\n        ) {\n          const values = obj\n            .map((childVal) =>\n              parser.parseObject(childVal, NodeType.Value, options),\n            )\n            .filter((child): child is Node.Node => !!child);\n\n          if (!values.length) {\n            return [];\n          }\n\n          const multiNode = parser.createASTNode(\n            {\n              type: NodeType.MultiNode,\n              override:\n                childOptions !== undefined &&\n                !hasTemplateValues(childOptions.parentObj, childOptions.key),\n              values,\n            },\n            obj,\n          );\n\n          if (!multiNode) {\n            return [];\n          }\n\n          if (multiNode.type === NodeType.MultiNode) {\n            multiNode.values.forEach((v) => {\n              v.parent = multiNode;\n            });\n          }\n\n          return childOptions === undefined\n            ? multiNode\n            : [\n                {\n                  path: [...childOptions.path, childOptions.key],\n                  value: multiNode,\n                },\n              ];\n        }\n      },\n    );\n  }\n\n  apply(view: ViewInstance): void {\n    view.hooks.parser.tap(\"multi-node\", this.applyParser.bind(this));\n  }\n}\n","import { ViewInstance, ViewPlugin } from \"../view\";\nimport type {\n  Parser,\n  Node,\n  ParseObjectOptions,\n  ParseObjectChildOptions,\n} from \"../parser\";\nimport { NodeType } from \"../parser\";\n\n/** A view plugin to resolve assets */\nexport default class AssetPlugin implements ViewPlugin {\n  applyParser(parser: Parser) {\n    parser.hooks.parseNode.tap(\n      \"asset\",\n      (\n        obj: any,\n        nodeType: Node.ChildrenTypes,\n        options: ParseObjectOptions,\n        childOptions?: ParseObjectChildOptions,\n      ) => {\n        if (childOptions?.key === \"asset\" && typeof obj === \"object\") {\n          const assetAST = parser.parseObject(obj, NodeType.Asset, options);\n\n          if (!assetAST) {\n            return [];\n          }\n\n          return [\n            {\n              path: [...childOptions.path, childOptions.key],\n              value: assetAST,\n            },\n          ];\n        }\n      },\n    );\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.parser.tap(\"asset\", this.applyParser.bind(this));\n  }\n}\n","export interface Store {\n  useLocalState<T>(initialState: T): readonly [T, (value: T) => void];\n  useSharedState<T>(\n    key: string | symbol,\n  ): (initialState: T) => readonly [T, (value: T) => void];\n}\n\ninterface SharedStore {\n  getLocalStateFunction<T>(\n    key: string | symbol,\n    countKey: symbol,\n  ): (initialState: T) => readonly [T, (value: T) => void];\n  useSharedState<T>(\n    key: string | symbol,\n  ): (initialState: T) => readonly [T, (value: T) => void];\n}\n\n/** A store that holds on to state for a transform */\nexport class LocalStateStore implements SharedStore {\n  private state: Map<string | symbol, any>;\n\n  private updateCallback?: () => void;\n\n  constructor(onUpdate?: () => void) {\n    this.updateCallback = onUpdate;\n\n    this.state = new Map();\n  }\n\n  public removeKey(key: symbol | string) {\n    this.state.delete(key);\n  }\n\n  public reset() {\n    this.state.clear();\n  }\n\n  useSharedState<T>(key: string | symbol) {\n    return (initialState: T) => {\n      if (!this.state.has(key)) {\n        this.state.set(key, initialState);\n      }\n\n      return [\n        this.state.get(key) as T,\n        (newState: T) => {\n          const current = this.state.get(key) as T;\n\n          this.state.set(key, newState);\n\n          if (current !== newState) {\n            this.updateCallback?.();\n          }\n        },\n      ] as const;\n    };\n  }\n\n  getLocalStateFunction<T>(key: symbol, countKey: symbol) {\n    return (initialState: T) => {\n      // initialize if not already created\n      if (!this.state.has(key)) {\n        this.state.set(key, []);\n      }\n\n      if (!this.state.has(countKey)) {\n        this.state.set(countKey, 0);\n      }\n\n      const localState = this.state.get(key);\n      const oldCount = this.state.get(countKey);\n\n      this.state.set(countKey, oldCount + 1);\n\n      if (localState.length <= oldCount) {\n        localState.push(initialState);\n      }\n\n      const value = localState[oldCount] as T;\n\n      return [\n        value,\n        (newState: T) => {\n          const oldValue = localState[oldCount] as T;\n          localState[oldCount] = newState;\n\n          if (oldValue !== newState) {\n            this.updateCallback?.();\n          }\n        },\n      ] as const;\n    };\n  }\n}\n","import type { Node, ViewInstance } from \"..\";\nimport { NodeType } from \"..\";\nimport { LocalStateStore } from \"../../controllers/view/store\";\nimport type { TransformRegistry } from \"../../controllers/view/types\";\n\n/** Traverse up the nodes until the target is found */\nfunction findUp(node: Node.Node, target: Node.Node): boolean {\n  if (node === target) {\n    return true;\n  }\n\n  if (node.parent) {\n    return findUp(node.parent, target);\n  }\n\n  return false;\n}\n\n/**\n * A plugin to register custom transforms on certain asset types\n * This allows users to embed stateful data into transforms.\n */\nexport default class AssetTransformCorePlugin {\n  public readonly stateStore: Map<Node.Node, LocalStateStore>;\n  private readonly registry: TransformRegistry;\n  private beforeResolveSymbol: symbol;\n  private resolveSymbol: symbol;\n  private beforeResolveCountSymbol: symbol;\n  private resolveCountSymbol: symbol;\n\n  constructor(registry: TransformRegistry) {\n    this.registry = registry;\n    this.stateStore = new Map();\n    this.beforeResolveSymbol = Symbol(\"before resolve\");\n    this.resolveSymbol = Symbol(\"resolve\");\n    this.beforeResolveCountSymbol = Symbol(\"before resolve count\");\n    this.resolveCountSymbol = Symbol(\"resolve count\");\n  }\n\n  apply(view: ViewInstance) {\n    // Clear out everything when we create a new view\n    this.stateStore.clear();\n\n    view.hooks.resolver.tap(\"asset-transform\", (resolver) => {\n      let lastUpdatedNode: Node.Node | undefined;\n\n      /** A function to update the state and trigger a view re-compute */\n      const updateState = (node: Node.Node) => {\n        lastUpdatedNode = node;\n        view.update(new Set());\n      };\n\n      /** Given a node and a transform step, fetch a local store */\n      const getStore = (node: Node.Node, stepKey: symbol) => {\n        let store: LocalStateStore;\n        const countKey =\n          stepKey === this.resolveSymbol\n            ? this.resolveCountSymbol\n            : this.beforeResolveCountSymbol;\n\n        const storedState = this.stateStore.get(node);\n\n        if (storedState) {\n          store = storedState;\n          store.removeKey(countKey);\n        } else {\n          store = new LocalStateStore(() => {\n            updateState(node);\n          });\n          this.stateStore.set(node, store);\n        }\n\n        return {\n          useSharedState: (\n            key: string | symbol,\n          ): (<T>(initialState: T) => readonly [T, (value: T) => void]) => {\n            return store.useSharedState(key);\n          },\n          useLocalState: <T>(initialState: T) => {\n            return store.getLocalStateFunction<T>(\n              stepKey,\n              countKey,\n            )(initialState);\n          },\n        };\n      };\n\n      resolver.hooks.beforeResolve.tap(\"asset-transform\", (node, options) => {\n        if (node && (node.type === \"asset\" || node.type === \"view\")) {\n          const transform = this.registry.get(node.value);\n\n          if (transform?.beforeResolve) {\n            const store = getStore(\n              options.node ?? node,\n              this.beforeResolveSymbol,\n            );\n\n            return transform.beforeResolve(node, options, store);\n          }\n        }\n\n        return node;\n      });\n\n      resolver.hooks.afterUpdate.tap(\"asset-transform\", () => {\n        lastUpdatedNode = undefined;\n      });\n\n      resolver.hooks.skipResolve.tap(\"asset-transform\", (skip, node) => {\n        if (!skip || !lastUpdatedNode) {\n          return skip;\n        }\n\n        const isParentOfUpdated = findUp(lastUpdatedNode, node);\n        const isChildOfUpdated = findUp(node, lastUpdatedNode);\n\n        return !isParentOfUpdated && !isChildOfUpdated;\n      });\n\n      resolver.hooks.afterResolve.tap(\n        \"asset-transform\",\n        (value, node, options) => {\n          if (node.type !== NodeType.Asset && node.type !== NodeType.View) {\n            return value;\n          }\n\n          const originalNode = resolver.getSourceNode(node);\n\n          if (!originalNode) {\n            return value;\n          }\n\n          const transform = this.registry.get(value);\n\n          if (transform?.resolve) {\n            const store = getStore(originalNode, this.resolveSymbol);\n\n            return transform?.resolve(value, options, store);\n          }\n\n          return value;\n        },\n      );\n    });\n  }\n}\n","import { SyncHook } from \"tapable-ts\";\nimport type { Navigation, NavigationFlowEndState } from \"@player-ui/types\";\nimport type { Logger } from \"../../logger\";\nimport type { TransitionOptions } from \"./flow\";\nimport { FlowInstance } from \"./flow\";\n\nexport interface FlowControllerHooks {\n  flow: SyncHook<[FlowInstance], Record<string, any>>;\n}\n\n/** A manager for the navigation section of a Content blob */\nexport class FlowController {\n  public readonly hooks: FlowControllerHooks = {\n    flow: new SyncHook<[FlowInstance]>(),\n  };\n\n  private readonly log?: Logger;\n  private navigation: Navigation;\n  private navStack: FlowInstance[];\n  public current?: FlowInstance;\n\n  constructor(\n    navigation: Navigation,\n    options?: {\n      /** A logger instance to use */\n      logger?: Logger;\n    },\n  ) {\n    this.navigation = navigation;\n    this.navStack = [];\n    this.log = options?.logger;\n\n    this.start = this.start.bind(this);\n    this.run = this.run.bind(this);\n    this.transition = this.transition.bind(this);\n    this.addNewFlow = this.addNewFlow.bind(this);\n  }\n\n  /** Navigate to another state in the state-machine */\n  public transition(\n    stateTransition: string,\n    options?: TransitionOptions,\n  ): void {\n    if (this.current === undefined) {\n      throw new Error(\"Not currently in a flow. Cannot transition.\");\n    }\n\n    this.current.transition(stateTransition, options);\n  }\n\n  private addNewFlow(flow: FlowInstance) {\n    this.navStack.push(flow);\n    this.current = flow;\n    this.hooks.flow.call(flow);\n  }\n\n  private async run(startState: string): Promise<NavigationFlowEndState> {\n    if (!Object.prototype.hasOwnProperty.call(this.navigation, startState)) {\n      return Promise.reject(new Error(`No flow defined for: ${startState}`));\n    }\n\n    const startFlow = this.navigation[startState];\n\n    if (startFlow === null || typeof startFlow !== \"object\") {\n      return Promise.reject(\n        new Error(`Flow: ${startState} needs to be an object`),\n      );\n    }\n\n    this.log?.debug(`Starting flow: ${startState}`);\n\n    const flow = new FlowInstance(startState, startFlow, { logger: this.log });\n    this.addNewFlow(flow);\n\n    flow.hooks.afterTransition.tap(\"flow-controller\", (flowInstance) => {\n      if (flowInstance.currentState?.value.state_type === \"FLOW\") {\n        const subflowId = flowInstance.currentState?.value.ref;\n        this.log?.debug(`Loading subflow ${subflowId}`);\n        this.run(subflowId).then((subFlowEndState) => {\n          this.log?.debug(\n            `Subflow ended. Using outcome: ${subFlowEndState.outcome}`,\n          );\n          flowInstance.transition(subFlowEndState?.outcome);\n        });\n      }\n    });\n\n    const end = await flow.start();\n    this.navStack.pop();\n\n    if (this.navStack.length > 0) {\n      const firstItem = 0;\n      this.current = this.navStack[firstItem];\n    }\n\n    return end;\n  }\n\n  public async start(): Promise<NavigationFlowEndState> {\n    if (!this.navigation.BEGIN) {\n      return Promise.reject(new Error(\"Must supply a BEGIN state\"));\n    }\n\n    return this.run(this.navigation.BEGIN);\n  }\n}\n","import type { Validation } from \"@player-ui/types\";\nimport type { ViewPlugin, Resolver, Node, ViewInstance } from \"../../view\";\nimport { NodeType } from \"../../view\";\nimport type {\n  BindingInstance,\n  BindingLike,\n  BindingFactory,\n} from \"../../binding\";\nimport { isBinding } from \"../../binding\";\nimport type { ValidationResponse } from \"../../validator\";\n\nconst CONTEXT = \"validation-binding-tracker\";\n\nexport interface BindingTracker {\n  /** Get the bindings currently being tracked for validation */\n  getBindings(): Set<BindingInstance>;\n\n  /** Add a binding to the tracked set */\n  trackBinding(binding: BindingInstance): void;\n}\ninterface Options {\n  /** Parse a binding from a view */\n  parseBinding: BindingFactory;\n\n  /** Callbacks when events happen */\n  callbacks?: {\n    /** Called when a binding is encountered for the first time in a view */\n    onAdd?: (binding: BindingInstance) => void;\n  };\n}\n\n/** A view plugin that manages bindings tracked across updates */\nexport class ValidationBindingTrackerViewPlugin\n  implements ViewPlugin, BindingTracker\n{\n  private options: Options;\n\n  private trackedBindings = new Set<BindingInstance>();\n\n  constructor(options: Options) {\n    this.options = options;\n  }\n\n  /** Fetch the tracked bindings in the current view */\n  getBindings(): Set<BindingInstance> {\n    return this.trackedBindings;\n  }\n\n  /** Add a binding to the tracked set */\n  trackBinding(binding: BindingInstance) {\n    if (this.trackedBindings.has(binding)) {\n      return;\n    }\n\n    this.trackedBindings.add(binding);\n    this.options.callbacks?.onAdd?.(binding);\n  }\n\n  /** Attach hooks to the given resolver */\n  applyResolver(resolver: Resolver) {\n    this.trackedBindings.clear();\n\n    /** Each node maps to a set of bindings that it directly tracks */\n    const tracked = new Map<Node.Node, Set<BindingInstance>>();\n\n    /** Each Node is a registered section or page that maps to a set of nodes in its section */\n    const sections = new Map<Node.Node, Set<Node.Node>>();\n\n    let lastViewUpdateChangeSet: Set<BindingInstance> | undefined;\n\n    /** Map of node to all bindings in children */\n    const lastComputedBindingTree = new Map<Node.Node, Set<BindingInstance>>();\n    let currentBindingTree = new Map<Node.Node, Set<BindingInstance>>();\n\n    /** Map of registered section nodes to bindings */\n    const lastSectionBindingTree = new Map<Node.Node, Set<BindingInstance>>();\n\n    /** Map of resolved nodes to their original nodes. */\n    const resolvedNodeMap: Map<Node.Node, Node.Node> = new Map();\n\n    resolver.hooks.beforeUpdate.tap(CONTEXT, (changes) => {\n      lastViewUpdateChangeSet = changes;\n    });\n\n    resolver.hooks.skipResolve.tap(CONTEXT, (shouldSkip, node) => {\n      const trackedBindingsForNode = lastComputedBindingTree.get(node);\n\n      if (!shouldSkip || !lastViewUpdateChangeSet || !trackedBindingsForNode) {\n        return shouldSkip;\n      }\n\n      const intersection = new Set(\n        [...lastViewUpdateChangeSet].filter((b) =>\n          trackedBindingsForNode.has(b),\n        ),\n      );\n\n      return intersection.size === 0;\n    });\n\n    resolver.hooks.resolveOptions.tap(CONTEXT, (options, node) => {\n      if (options.validation === undefined) {\n        return options;\n      }\n\n      // Clear out any old tracked bindings for this node since we're re-compiling it\n      tracked.delete(node);\n\n      /** Validation callback to track a binding */\n      const track = (binding: BindingLike) => {\n        const parsed = isBinding(binding)\n          ? binding\n          : this.options.parseBinding(binding);\n\n        if (tracked.has(node)) {\n          tracked.get(node)?.add(parsed);\n        } else {\n          tracked.set(node, new Set([parsed]));\n        }\n\n        /** find first parent registered as section and add self to its list */\n        let { parent } = node;\n\n        while (parent) {\n          if (sections.has(parent)) {\n            sections.get(parent)?.add(node);\n            break;\n          } else {\n            parent = parent.parent;\n          }\n        }\n\n        this.trackedBindings.add(parsed);\n        this.options.callbacks?.onAdd?.(parsed);\n      };\n\n      return {\n        ...options,\n        validation: {\n          ...options.validation,\n          get: (binding, getOptions) => {\n            if (getOptions?.track) {\n              track(binding);\n            }\n\n            const eows = options.validation\n              ?._getValidationForBinding(binding)\n              ?.getAll(getOptions);\n\n            const firstFieldEOW = eows?.find(\n              (eow) =>\n                eow.displayTarget === \"field\" ||\n                eow.displayTarget === undefined,\n            );\n\n            return firstFieldEOW;\n          },\n          getValidationsForBinding(binding, getOptions) {\n            if (getOptions?.track) {\n              track(binding);\n            }\n\n            return (\n              options.validation\n                ?._getValidationForBinding(binding)\n                ?.getAll(getOptions) ?? []\n            );\n          },\n          getChildren: (type?: Validation.DisplayTarget) => {\n            const validations = new Array<ValidationResponse>();\n            lastComputedBindingTree.get(node)?.forEach((binding) => {\n              const eow = options.validation\n                ?._getValidationForBinding(binding)\n                ?.get();\n\n              if (eow && (type === undefined || type === eow.displayTarget)) {\n                validations.push(eow);\n              }\n            });\n\n            return validations;\n          },\n          getValidationsForSection: () => {\n            const validations = new Array<ValidationResponse>();\n            lastSectionBindingTree.get(node)?.forEach((binding) => {\n              const eow = options.validation\n                ?._getValidationForBinding(binding)\n                ?.get();\n\n              if (eow && eow.displayTarget === \"section\") {\n                validations.push(eow);\n              }\n            });\n\n            return validations;\n          },\n          register: (registerOptions) => {\n            if (registerOptions?.type === \"section\") {\n              if (!sections.has(node)) {\n                sections.set(node, new Set());\n              }\n            }\n          },\n          track,\n        },\n      };\n    });\n\n    resolver.hooks.afterNodeUpdate.tap(\n      CONTEXT,\n      (originalNode, parent, update) => {\n        // Compute the new tree for this node\n        // If it's not-updated, use the last known value\n\n        const { updated, node: resolvedNode } = update;\n        resolvedNodeMap.set(resolvedNode, originalNode);\n\n        if (updated) {\n          const newlyComputed = new Set(tracked.get(originalNode));\n          if (resolvedNode.type === NodeType.MultiNode) {\n            resolvedNode.values.forEach((value) =>\n              currentBindingTree\n                .get(value)\n                ?.forEach((b) => newlyComputed.add(b)),\n            );\n          }\n\n          if (\"children\" in resolvedNode && resolvedNode.children) {\n            resolvedNode.children.forEach((child) => {\n              currentBindingTree\n                .get(child.value)\n                ?.forEach((b) => newlyComputed.add(b));\n            });\n          }\n\n          currentBindingTree.set(resolvedNode, newlyComputed);\n        } else {\n          currentBindingTree.set(\n            resolvedNode,\n            lastComputedBindingTree.get(originalNode) ?? new Set(),\n          );\n        }\n\n        if (originalNode === resolver.root) {\n          this.trackedBindings = new Set(currentBindingTree.get(resolvedNode));\n          lastComputedBindingTree.clear();\n          currentBindingTree.forEach((value, key) => {\n            const node = resolvedNodeMap.get(key);\n            if (node) {\n              lastComputedBindingTree.set(node, value);\n            }\n          });\n\n          lastSectionBindingTree.clear();\n          sections.forEach((nodeSet, sectionNode) => {\n            const temp = new Set<BindingInstance>();\n            nodeSet.forEach((n) => {\n              tracked.get(n)?.forEach(temp.add, temp);\n            });\n            lastSectionBindingTree.set(sectionNode, temp);\n          });\n\n          tracked.clear();\n          sections.clear();\n          currentBindingTree = new Map();\n        }\n      },\n    );\n  }\n\n  apply(view: ViewInstance) {\n    view.hooks.resolver.tap(CONTEXT, this.applyResolver.bind(this));\n  }\n}\n","import type { DataController } from \".\";\nimport type { Logger } from \"../../logger\";\nimport type { BindingLike } from \"../../binding\";\nimport type {\n  DataModelWithParser,\n  DataModelOptions,\n  Updates,\n} from \"../../data\";\n\n/** Wrapper for the Data Controller Class that prevents writes */\nexport class ReadOnlyDataController\n  implements DataModelWithParser<DataModelOptions>\n{\n  private controller: DataController;\n  private logger?: Logger;\n\n  constructor(controller: DataController, logger?: Logger) {\n    this.controller = controller;\n    this.logger = logger;\n  }\n\n  get(binding: BindingLike, options?: DataModelOptions | undefined) {\n    return this.controller.get(binding, options);\n  }\n\n  set(\n    transaction: [BindingLike, any][],\n    options?: DataModelOptions | undefined,\n  ): Updates {\n    this.logger?.error(\n      \"Error: Tried to set in a read only instance of the DataController\",\n    );\n    return [];\n  }\n\n  delete(binding: BindingLike, options?: DataModelOptions | undefined): void {\n    this.logger?.error(\n      \"Error: Tried to delete in a read only instance of the DataController\",\n    );\n  }\n}\n","import { SyncHook, SyncWaterfallHook, SyncBailHook } from \"tapable-ts\";\nimport { dequal } from \"dequal\";\nimport type { Logger } from \"../../logger\";\nimport type { BindingParser, BindingLike } from \"../../binding\";\nimport { BindingInstance } from \"../../binding\";\nimport type {\n  BatchSetTransaction,\n  Updates,\n  DataModelOptions,\n  DataModelWithParser,\n  DataPipeline,\n  DataModelMiddleware,\n} from \"../../data\";\nimport { PipelinedDataModel, LocalModel } from \"../../data\";\nimport type { RawSetTransaction } from \"../../types\";\nimport { ReadOnlyDataController } from \"./utils\";\n\n/** The orchestrator for player data */\nexport class DataController implements DataModelWithParser<DataModelOptions> {\n  public hooks = {\n    resolve: new SyncWaterfallHook(),\n    resolveDataStages: new SyncWaterfallHook<[DataPipeline]>(),\n\n    // On any set or get of an undefined value, redirect the value to be the default\n    resolveDefaultValue: new SyncBailHook<[BindingInstance], any>(),\n\n    onDelete: new SyncHook<[any]>(),\n\n    onSet: new SyncHook<[BatchSetTransaction]>(),\n\n    onGet: new SyncHook<[any, any]>(),\n\n    onUpdate: new SyncHook<[Updates, DataModelOptions | undefined]>(),\n\n    format: new SyncWaterfallHook<[any, BindingInstance]>(),\n\n    deformat: new SyncWaterfallHook<[any, BindingInstance]>(),\n\n    serialize: new SyncWaterfallHook<[any]>(),\n  };\n\n  private model?: PipelinedDataModel;\n  private trash: Set<BindingInstance>;\n  private pathResolver: BindingParser;\n  private baseMiddleware: Array<DataModelMiddleware>;\n  private logger?: Logger;\n\n  constructor(\n    model: Record<any, unknown> | undefined,\n    options: {\n      /** A means of parsing a raw binding to a Binding object */\n      pathResolver: BindingParser;\n\n      /** middleware to use. typically for validation */\n      middleware?: Array<DataModelMiddleware>;\n\n      /** A logger to use  */\n      logger?: Logger;\n    },\n  ) {\n    this.logger = options.logger;\n    const middleware = options.middleware || [];\n    this.baseMiddleware = [new LocalModel(model), ...middleware];\n\n    this.trash = new Set();\n    this.pathResolver = options.pathResolver;\n  }\n\n  public getModel(): PipelinedDataModel {\n    if (!this.model) {\n      const stages = this.hooks.resolveDataStages.call(this.baseMiddleware);\n      const model = new PipelinedDataModel();\n      model.setMiddleware(stages);\n      this.model = model;\n    }\n\n    return this.model;\n  }\n\n  private resolveDataValue(\n    binding: BindingInstance,\n    value: any,\n    deformat: boolean,\n  ) {\n    if (deformat) {\n      return this.hooks.deformat.call(value, binding);\n    }\n\n    return value;\n  }\n\n  public set(\n    transaction: RawSetTransaction,\n    options?: DataModelOptions,\n  ): Updates {\n    let normalizedTransaction: BatchSetTransaction = [];\n\n    if (Array.isArray(transaction)) {\n      normalizedTransaction = transaction.map(([binding, value]) => {\n        const parsed = this.pathResolver.parse(binding);\n\n        return [\n          parsed,\n          this.resolveDataValue(parsed, value, Boolean(options?.formatted)),\n        ];\n      }) as BatchSetTransaction;\n    } else {\n      normalizedTransaction = Object.keys(transaction).map(\n        (binding: string) => {\n          const parsed = this.pathResolver.parse(binding);\n          const val = transaction[binding];\n\n          return [\n            parsed,\n            this.resolveDataValue(parsed, val, Boolean(options?.formatted)),\n          ];\n        },\n      ) as BatchSetTransaction;\n    }\n\n    // Figure out what the base changes being applied are\n    const setUpdates = normalizedTransaction.reduce<Updates>(\n      (updates, [binding, newVal]) => {\n        const oldVal = this.get(binding, { includeInvalid: true });\n\n        const update = {\n          binding,\n          newValue: newVal,\n          oldValue: oldVal,\n        };\n\n        if (dequal(oldVal, newVal)) {\n          this.logger?.debug(\n            `Skipping update for path: ${binding.asString()}. Value was unchanged: ${oldVal}`,\n          );\n        } else {\n          updates.push(update);\n\n          this.logger?.debug(\n            `Setting path: ${binding.asString()} from: ${oldVal} to: ${newVal}`,\n          );\n        }\n\n        return updates;\n      },\n      [],\n    );\n\n    // Get the applied update\n    const result = this.getModel().set(normalizedTransaction, options);\n\n    // Add any extra bindings that were effected\n    const setUpdateBindings = new Set(setUpdates.map((su) => su.binding));\n    result.forEach((tr) => {\n      if (\n        !setUpdateBindings.has(tr.binding) &&\n        (tr.force === true || !dequal(tr.oldValue, tr.newValue))\n      ) {\n        this.logger?.debug(\n          `Path: ${tr.binding.asString()} was changed from: ${\n            tr.oldValue\n          } to: ${tr.newValue}`,\n        );\n        setUpdates.push(tr);\n      }\n    });\n\n    this.hooks.onSet.call(normalizedTransaction);\n\n    if (setUpdates.length > 0) {\n      this.hooks.onUpdate.call(setUpdates, options);\n    }\n\n    return result;\n  }\n\n  private resolve(binding: BindingLike, readOnly: boolean): BindingInstance {\n    return Array.isArray(binding) || typeof binding === \"string\"\n      ? this.pathResolver.parse(binding, { readOnly })\n      : binding;\n  }\n\n  public get(binding: BindingLike, options?: DataModelOptions) {\n    const resolved =\n      binding instanceof BindingInstance\n        ? binding\n        : this.resolve(binding, true);\n    let result = this.getModel().get(resolved, options);\n\n    if (result === undefined && !options?.ignoreDefaultValue) {\n      const defaultVal = this.hooks.resolveDefaultValue.call(resolved);\n\n      if (defaultVal !== result) {\n        result = defaultVal;\n      }\n    }\n\n    if (options?.formatted) {\n      result = this.hooks.format.call(result, resolved);\n    } else if (options?.formatted === false) {\n      result = this.hooks.deformat.call(result, resolved);\n    }\n\n    this.hooks.onGet.call(binding, result);\n\n    return result;\n  }\n\n  public delete(binding: BindingLike, options?: DataModelOptions) {\n    if (\n      typeof binding !== \"string\" &&\n      !Array.isArray(binding) &&\n      !(binding instanceof BindingInstance)\n    ) {\n      throw new Error(\"Invalid arguments: delete expects a data path (string)\");\n    }\n\n    const resolved =\n      binding instanceof BindingInstance\n        ? binding\n        : this.resolve(binding, false);\n\n    const parentBinding = resolved.parent();\n    const property = resolved.key();\n    const parentValue = this.get(parentBinding);\n\n    const existedBeforeDelete =\n      typeof parentValue === \"object\" &&\n      parentValue !== null &&\n      Object.prototype.hasOwnProperty.call(parentValue, property);\n\n    this.getModel().delete(resolved, options);\n\n    if (existedBeforeDelete && !this.get(resolved)) {\n      this.trash.add(resolved);\n    }\n\n    this.hooks.onDelete.call(resolved);\n  }\n\n  public serialize(): object {\n    return this.hooks.serialize.call(this.get(\"\"));\n  }\n\n  public makeReadOnly(): ReadOnlyDataController {\n    return new ReadOnlyDataController(this, this.logger);\n  }\n}\n","import { LocalModel } from \"../../data\";\nimport { BindingInstance } from \"../../binding\";\nimport { objectToBatchSet } from \"./utils\";\n\nexport interface ConstantsProvider {\n  /**\n   * Function to add constants to the providers store\n   * - @param data values to add to the constants store\n   */\n  addConstants(data: Record<string, any>, namespace: string): void;\n\n  /**\n   * Function to retrieve constants from the providers store\n   *  - @param key Key used for the store access\n   *  - @param namespace namespace values were loaded under (defined in the plugin)\n   *  - @param fallback Optional - if key doesn't exist in namespace what to return (will return unknown if not provided)\n   */\n  getConstants(key: any, namespace: string, fallback?: any): any;\n\n  /**\n   * Function to set values to temporarily override certain keys in the perminant store\n   * - @param data values to override store with\n   * - @param namespace namespace to override\n   */\n  setTemporaryValues(data: any, namespace: string): void;\n\n  /**\n   * Clears any temporary values that were previously set\n   */\n  clearTemporaryValues(): void;\n}\n\n/**\n * Key/Value store for constants and context for Player\n */\nexport class ConstantsController implements ConstantsProvider {\n  /**\n   * Data store is basically a map of namespaces to DataModels to provide some data isolation\n   */\n  private store: Map<string, LocalModel>;\n\n  /**\n   * Separate store for temporary flow specific overrides.\n   * They are kept in a separate data model to make clearing it easier between flows\n   * and so there is no confusion on what is static and what is temporary\n   */\n  private tempStore: Map<string, LocalModel>;\n\n  constructor() {\n    this.store = new Map();\n    this.tempStore = new Map();\n  }\n\n  addConstants(data: any, namespace: string): void {\n    if (this.store.has(namespace)) {\n      this.store.get(namespace)?.set(objectToBatchSet(data));\n    } else {\n      this.store.set(namespace, new LocalModel(data));\n    }\n  }\n\n  getConstants(key: string, namespace: string, fallback?: any): any {\n    const path = new BindingInstance(key);\n\n    return (\n      this.tempStore.get(namespace)?.get(path) ??\n      this.store.get(namespace)?.get(path) ??\n      fallback\n    );\n  }\n\n  setTemporaryValues(data: any, namespace: string): void {\n    if (this.tempStore.has(namespace)) {\n      this.tempStore.get(namespace)?.set(objectToBatchSet(data));\n    } else {\n      this.tempStore.set(namespace, new LocalModel(data));\n    }\n  }\n\n  clearTemporaryValues(namespace?: string): void {\n    if (namespace) {\n      this.tempStore.get(namespace)?.reset();\n    } else {\n      this.tempStore.forEach((value: LocalModel) => {\n        value.reset();\n      });\n    }\n  }\n}\n","import type {\n  Expression,\n  ExpressionObject,\n  NavigationFlowState,\n} from \"@player-ui/types\";\nimport type { ExpressionEvaluator, ExpressionType } from \"../expressions\";\nimport type { FlowInstance } from \"../controllers\";\nimport type { Player, PlayerPlugin } from \"../player\";\n\n/**\n * A plugin that taps into the flow controller to evaluate available expressions\n * Expressions can be exposed via lifecycle \"hooks\" in flow/state nodes\n * e.g: onStart, onEnd\n */\nexport class FlowExpPlugin implements PlayerPlugin {\n  name = \"flow-exp-plugin\";\n\n  apply(player: Player) {\n    let expressionEvaluator: ExpressionEvaluator | undefined;\n\n    /**\n     * Eval Helper\n     *\n     * @param exp - an expression to be evaluated\n     */\n    const handleEval = (exp: Expression | ExpressionObject) => {\n      if (exp) {\n        if (typeof exp === \"object\" && \"exp\" in exp) {\n          expressionEvaluator?.evaluate(exp.exp);\n        } else {\n          expressionEvaluator?.evaluate(exp as ExpressionType);\n        }\n      }\n    };\n\n    player.hooks.expressionEvaluator.tap(this.name, (evaluator) => {\n      expressionEvaluator = evaluator;\n    });\n\n    player.hooks.flowController.tap(this.name, (fc) => {\n      fc.hooks.flow.tap(this.name, (flow: FlowInstance) => {\n        // Eval flow nodes\n        flow.hooks.onStart.tap(this.name, (exp) => handleEval(exp));\n\n        flow.hooks.onEnd.tap(this.name, (exp) => handleEval(exp));\n        // Eval state nodes\n        flow.hooks.resolveTransitionNode.intercept({\n          call: (nextState: NavigationFlowState) => {\n            if (nextState?.onStart) {\n              handleEval(nextState.onStart);\n            }\n          },\n        });\n      });\n    });\n  }\n}\n","import type { ExpressionHandler, ExpressionType } from \"../expressions\";\nimport type { SchemaController } from \"../schema\";\nimport type { Player, PlayerPlugin } from \"../player\";\n\n/** Gets formatter for given formatName and formats value if found, returns value otherwise */\nconst createFormatFunction = (schema: SchemaController) => {\n  /**\n   * The generated handler for the given schema\n   */\n  const handler: ExpressionHandler<[unknown, string], any> = (\n    ctx,\n    value,\n    formatName,\n  ) => {\n    return (\n      schema.getFormatterForType({ type: formatName })?.format(value) ?? value\n    );\n  };\n\n  return handler;\n};\n\n/**\n * A plugin that provides the out-of-the-box expressions for player\n */\nexport class DefaultExpPlugin implements PlayerPlugin {\n  name = \"flow-exp-plugin\";\n\n  apply(player: Player) {\n    let formatFunction: ExpressionHandler<[unknown, string]> | undefined;\n\n    player.hooks.schema.tap(this.name, (schemaController) => {\n      formatFunction = createFormatFunction(schemaController);\n    });\n\n    player.hooks.expressionEvaluator.tap(this.name, (expEvaluator) => {\n      if (formatFunction) {\n        expEvaluator.addExpressionFunction(\"format\", formatFunction);\n      }\n\n      expEvaluator.addExpressionFunction(\"log\", (ctx, ...args) => {\n        player.logger.info(...args);\n      });\n\n      expEvaluator.addExpressionFunction(\"debug\", (ctx, ...args) => {\n        player.logger.debug(...args);\n      });\n\n      expEvaluator.addExpressionFunction(\n        \"eval\",\n        (ctx, ...args: [ExpressionType]) => {\n          return ctx.evaluate(...args);\n        },\n      );\n    });\n  }\n}\n","import type { Asset, Flow, FlowResult } from \"@player-ui/types\";\nimport type { BindingParser, BindingLike } from \"./binding\";\nimport type { SchemaController } from \"./schema\";\nimport type { ExpressionEvaluator } from \"./expressions\";\nimport type { Logger } from \"./logger\";\nimport type {\n  ViewController,\n  DataController,\n  ValidationController,\n  FlowController,\n} from \"./controllers\";\nimport type { ReadOnlyDataController } from \"./controllers/data/utils\";\nimport { SyncHook, SyncWaterfallHook } from \"tapable-ts\";\nimport { ViewInstance } from \"./view\";\n\n/**\n * Public Player Hooks\n */\nexport interface PlayerHooks {\n  /** The hook that fires every time we create a new flowController (a new Content blob is passed in) */\n  flowController: SyncHook<[FlowController], Record<string, any>>;\n  /** The hook that updates/handles views */\n  viewController: SyncHook<[ViewController], Record<string, any>>;\n  /** A hook called every-time there's a new view. This is equivalent to the view hook on the view-controller */\n  view: SyncHook<[ViewInstance], Record<string, any>>;\n  /** Called when an expression evaluator was created */\n  expressionEvaluator: SyncHook<[ExpressionEvaluator], Record<string, any>>;\n  /** The hook that creates and manages data */\n  dataController: SyncHook<[DataController], Record<string, any>>;\n  /** Called after the schema is created for a flow */\n  schema: SyncHook<[SchemaController], Record<string, any>>;\n  /** Manages validations (schema and x-field ) */\n  validationController: SyncHook<[ValidationController], Record<string, any>>;\n  /** Manages parsing binding */\n  bindingParser: SyncHook<[BindingParser], Record<string, any>>;\n  /** A that's called for state changes in the flow execution */\n  state: SyncHook<[PlayerFlowState], Record<string, any>>;\n  /** A hook to access the current flow */\n  onStart: SyncHook<[Flow<Asset<string>>], Record<string, any>>;\n  /** A hook for when the flow ends either in success or failure */\n  onEnd: SyncHook<[], Record<string, any>>;\n  /** Mutate the Content flow before starting */\n  resolveFlowContent: SyncWaterfallHook<\n    [Flow<Asset<string>>],\n    Record<string, any>\n  >;\n}\n\n/** The status for a flow's execution state */\nexport type PlayerFlowStatus =\n  | \"not-started\"\n  | \"in-progress\"\n  | \"completed\"\n  | \"error\";\n\n/** Common interface for the state of Player's flow execution */\nexport interface BaseFlowState<T extends PlayerFlowStatus> {\n  /** A unique reference for the life-cycle of a flow */\n  ref: symbol;\n\n  /** The status of the given flow */\n  status: T;\n}\n\n/** The beginning state of Player, before it's seen a flow  */\nexport type NotStartedState = BaseFlowState<\"not-started\">;\n\nexport const NOT_STARTED_STATE: NotStartedState = {\n  ref: Symbol(\"not-started\"),\n  status: \"not-started\",\n};\n\n/** Shared properties for a flow in any state of execution (in-progress, completed successfully, or errored out) */\nexport interface PlayerFlowExecutionData {\n  /** The currently executing flow */\n  flow: Flow;\n}\n\nexport interface ControllerState {\n  /** The manager for data for a flow */\n  data: DataController;\n\n  /** The view manager for a flow */\n  view: ViewController;\n\n  /** The schema manager for a flow */\n  schema: SchemaController;\n\n  /** The validation manager for a flow */\n  validation: ValidationController;\n\n  /** The expression evaluator for a flow */\n  expression: ExpressionEvaluator;\n\n  /** The manager for parsing and resolving bindings */\n  binding: BindingParser;\n\n  /** the manager for the flow state machine */\n  flow: FlowController;\n}\n\n/** A flow is currently executing */\nexport type InProgressState = BaseFlowState<\"in-progress\"> &\n  PlayerFlowExecutionData & {\n    /** A promise that resolves when the flow is completed */\n    flowResult: Promise<FlowResult>;\n\n    /** The underlying state controllers for the current flow */\n    controllers: ControllerState;\n\n    /** Allow other platforms to abort the current flow with an error  */\n    fail: (error: Error) => void;\n\n    /**\n     * The Logger for the current player instance\n     */\n    logger: Logger;\n  };\n\n/** The flow completed properly */\nexport type CompletedState = BaseFlowState<\"completed\"> &\n  PlayerFlowExecutionData &\n  FlowResult & {\n    /** Readonly Player controllers to provide Player functionality after the flow has ended */\n    controllers: {\n      /** A read only instance of the Data Controller */\n      data: ReadOnlyDataController;\n    };\n  };\n\n/** The flow finished but not successfully */\nexport type ErrorState = BaseFlowState<\"error\"> & {\n  /** The currently executing flow */\n  flow: Flow;\n\n  /** The error associated with the failed flow */\n  error: Error;\n};\n\n/** Any Player state  */\nexport type PlayerFlowState =\n  | NotStartedState\n  | InProgressState\n  | CompletedState\n  | ErrorState;\n\n// Model\n\nexport type RawSetType = [BindingLike, any];\nexport type RawSetTransaction = Record<string, any> | RawSetType[];\n","export const CheckPathPluginSymbol = Symbol.for(\"CheckPathPlugin\");\n"]}