{"version":3,"sources":["/home/circleci/.cache/bazel/_bazel_circleci/e8362d362e14c7d23506d1dfa3aea8b8/sandbox/processwrapper-sandbox/1847/execroot/_main/bazel-out/k8-fastbuild/bin/plugins/check-path/core/dist/index.global.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/tapable-ts@0.2.4/node_modules/tapable-ts/src/utils.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/tapable-ts@0.2.4/node_modules/tapable-ts/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dlv@1.1.3/node_modules/dlv/index.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dequal@2.0.3/node_modules/dequal/dist/index.mjs","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/partial-match-registry/src/deep-partial-matcher.ts","../../../../../../../../../../../../execroot/execroot/_main/bazel-out/k8-fastbuild/bin/core/partial-match-registry/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+player@0.0.0/node_modules/@player-ui/player/dist/index.mjs","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/check-path/core/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/ts-nested-error@1.2.1/node_modules/ts-nested-error/src/nested-error.ts","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/timm@1.7.1/node_modules/timm/lib/timm.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/p-defer@3.0.0/node_modules/p-defer/index.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/queue-microtask@1.2.3/node_modules/queue-microtask/index.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/sorted-array@2.0.4/node_modules/sorted-array/sorted-array.js","../../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/check-path/core/src/symbols.ts"],"names":["CheckPathPlugin","equalToOrIn","value","check","Array","isArray","includes","callTap","tap","args","ctx","context","callback","dlv_es_default","obj","key","def","p","undef","split","length","find","iter","tar","keys","dequal","createMatcher","partialObj","pairs","traverseObj","matchFunction","searchObj","from","entry","path","count","size","createBasicMatcher","seed","matcher","match","isBinding","binding","maybeConvertToNum","i","asInt","parseInt","isNaN","getBindingSegments","asArray","findInArray","array","findIndex","withParser","model","parseBinding","maybeParse","readOnly","parsed","get","set","Error","options","transaction","map","val","delete","toModel","middleware","defaultOptions","next","resolvedOptions","constructModelForPipeline","pipeline","NOOP_MODEL","createModelWithOptions","reduce","nextModel","isExpressionNode","x","__id","ExpNodeOpaqueIdentifier","throwError","message","index","err","description","createSpanningLocation","start","end","getMaxKeyLen","maxLen","Object","forEach","prototype","hasOwnProperty","call","binaryPrecedence","opVal","binaryOps","createBinaryExpression","operator","left","right","location","type","isDecimalDigit","ch","isIdentifierStart","isIdentifierPart","isModelRefStart","ch0","ch1","OCURL_CODE","parseExpression","expr","strictMode","strict","charAtFunc","charAt","charCodeAtFunc","charCodeAt","getLocation","startChar","character","exprI","exprICode","gobbleObjects","attributes","closed","shouldDefineKey","chCode","startCharIndex","gobbleSpaces","CCURL_CODE","SQUOTE_CODE","DQUOTE_CODE","gobbleStringLiteral","COLON_CODE","gobbleExpression","push","COMMA_CODE","test","gobbleBinaryExpression","QUMARK_CODE","consequent","alternate","gobbleBinaryOp","toCheck","substr","maxBinopLen","tcLen","node","prec","gobbleToken","biop","biopInfo","stack","pop","PERIOD_CODE","gobbleNumericLiteral","OPAREN_CODE","gobbleVariable","OBRACK_CODE","gobbleArray","gobbleModelRef","maxUnopLen","unaryOps","argument","prefix","num","parseFloat","raw","quote","str","openBraceCount","ref","gobbleIdentifier","identifier","slice","literals","thisStr","name","gobbleArguments","termination","charIndex","String","fromCharCode","gobbleGroup","computed","object","property","CBRACK_CODE","CPAREN_CODE","callTarget","elements","nodes","chIndex","SEMCOL_CODE","body","e","error","isObjectExpression","parse2","schema","parseQueue","shift","visited","entries","prop","nestedPath","nestedPathStr","join","expandedPaths","has","isRecord","Set","Map","ROOT","findNextExp","expStart","indexOf","DOUBLE_OPEN_CURLY","offset","workingString","substring","nextCloseCurly","DOUBLE_CLOSE_CURLY","nextOpenCurly","resolveExpressionsInString","evaluate","expMatch","newVal","expStrWithBrackets","matchStart","expString","expValue","resolveDataRefsInString","formatted","expLocation","trim","evaledVal","resolveDataRefs","traverseObject","removeBindingAndChildrenFromMap","sourceMap","targetMap","parentBinding","parent","_value","trackedBinding","contains","bindingsToRewrite","filter","b","relative","childIndex","sort","childPath","newSegments","newChildBinding","descendent","hasTemplateValues","localKey","template","tmpl","output","hasSwitchKey","hasTemplateKey","getNodeID","id","caresAboutDataChanges","dataChanges","dependencies","depArray","values","dataChangeArray","dep","change","toNodeResolveOptions","resolverOptions","data","formatValue","format","bindingLike","exp","evaluator","hasSomethingToResolve","bindingResolveLookup","expressionResolveLookup","resolveString","resolveOptions","replaceParams","params","replace","ANY_CHAR_REGEX","keyExpr","isSubset","subset","containingSet","createStatefulValidationObject","severity","state","isBlockingNavigation","objectToBatchSet","flattenedObj","flatten","batchTxn","BindingInstance","getParent","viewInfo","working","NodeType","Asset","View","__create","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","__commonJS","cb","mod","__require","exports","__export","target","all","enumerable","__copyProps","to","except","desc","__toESM","isNodeMode","__esModule","__toCommonJS","require_nested_error","toError","NestedError","_NestedError","innerErrors","thisErrorReport","getErrorReport","innerError","errReport","innerErrorReports","idx","rethrow","errs","require_timm","clone","addLast","addFirst","removeLast","removeFirst","insert","removeAt","replaceAt","getIn","setIn","update","updateIn","merge","mergeDeep","mergeIn","omit","addDefaults","default","INVALID_ARGS","IS_DEV","throwStr","msg","getKeysAndSymbols","getOwnPropertySymbols","concat","obj0","out","isObject","o","newItem","len","result","ptr","obj2","doSetIn","newValue","nestedObj","fnUpdate","prevVal","nextVal","a","c","d","f","rest","doMerge","attrs","omitList","fDoSomething","fAddDefaults","fDeep","first","fChanged","j","timm","_default","require_p_defer","module","pDefer","deferred","promise","Promise","resolve","reject","require_queue_microtask","queueMicrotask","bind","window","global","then","catch","setTimeout","require_sorted_array","SortedArray","defclass","constructor","compare","compareDefault","element","high","low","pos","ordering","search","remove","splice","comparing","define","amd","src_exports","InterceptionManager","interceptions","interceptionKeySet","isUsed","intercept","int","s","add","_a","_b","loop","asError","r","done","Hook","taps","Symbol","before","insertionIndex","beforeSet","t","untap","SyncHook","SyncBailHook","tapIndex","rtn","SyncWaterfallHook","tapValue","import_ts_nested_error","import_timm","foo","bar","ctor","tmp","Date","getTime","RegExp","toString","ArrayBuffer","Uint8Array","DataView","byteLength","getInt8","isView","import_p_defer","import_queue_microtask","import_sorted_array","createSortedArray","Registry","initialSet","store","query","callbackfn","clear","isRegistryEmpty","toValue","toExpression","toPath","toQuery","toConcatenatedNode","SEGMENT_SEPARATOR","OPEN_CURL","CLOSE_CURL","OPEN_BRACKET","CLOSE_BRACKET","EQUALS","SINGLE_QUOTE","DOUBLE_QUOTE","BACK_TICK","isIdentifierChar","char","charCode","matches","parse","expected","whitespace","maybeNumber","Number","expression","regex","modelRef","parsePath","simpleSegment","segment","segments","nextSegment","optionallyQuotedSegment","singleQuote","equals","parseBracket","second","parseSegmentAndBrackets","firstSegment","bracketSegment","parts","status","_BindingInstance","factory","rawBinding","tryNum","freeze","joined","asString","bindingAsArray","descendentSegments","resolveBindingAST","bindingPathNode","hooks","updates","getValueForNode","nestedResolvedValue","convertToPath","getValue","import_ts_nested_error2","actualValue","appendPathSegments","resolveNode","_node","resolvedNode","beforeResolveNode","objToQuery","resolvedKey","resolvedValue","BINDING_BRACKETS_REGEX","LAZY_BINDING_REGEX","DEFAULT_OPTIONS","BindingParser","skipOptimization","parserOptions","cache","parseCache","normalizePath","ast","TypeError","NestedError2","getBindingForNormalizedResult","normalized","normalizedStr","created","overrides","normalizeConfig","normalized2","joinedNormalizedPath","updateKeys","updateTransaction","updatedBinding","DependencyTracker","readDeps","writeDeps","namedDependencySets","namedSet","createSubset","force","getDependencies","trackSubset","trackDefault","getModified","readsBinding","writesBinding","reset","addReadDep","addWriteDep","addChildReadDep","DependencyModel","rootModel","NOOPDataModel","ROOT_BINDING","PipelinedDataModel","onSet","effectiveDataModel","setMiddleware","handlers","addMiddleware","handler","appliedTransaction","LocalModel","effectiveOperations","oldValue","parentValue","true","false","null","undefined","evaluator_functions_exports","conditional","deleteDataVal","getDataVal","setDataVal","_context","condition","ifTrue","ifFalse","resolution","resolveParams","andandOperator","ororOperator","DEFAULT_BINARY_OPERATORS","DEFAULT_UNARY_OPERATORS","ExpressionEvaluator","vars","beforeEvaluate","onError","expressionsCache","operators","binary","unary","expressions","defaultHookOptions","_execAST","_resolveNode","resolvedOpts","_nothing","_execString","addExpressionFunction","addBinaryOperator","addUnaryOperator","setExpressionVariable","getExpressionVariable","matchedExp","storedAST","throwErrors","import_ts_nested_error3","NestedError3","_currentValue","expressionContext","resolvedAttributes","attr","expressionName","n","ele","operation","TapableLogger","trace","debug","info","warn","log","logHandlers","createHandler","logger","addHandler","logHandler","removeHandler","ProxyLogger","loggerProvider","proxiedLoggerProvider","identify","SchemaController","formatters","types","bindingSchemaNormalizedCache","resolveTypeForBinding","addFormatters","fns","addDataTypes","t2","getValidationsForBinding","typeDef","getApparentType","validation","vRef","trigger","normalizeBinding","cached","bindingArray","item","recordBinding","getType","schemaType","baseType","getTypeDefinition","dataType","getFormatterForType","formatReference","formatType","formatter","deformat","getFormatter","import_timm2","setIn2","ValidationMiddleware","validator","shadowModelPaths","shouldIncludeInvalid","asModel","includeInvalid","nextTransaction","includedBindings","invalidBindings","validations","isStrong","validResults","invalidResults","shadowValue","shadowBinding","import_timm3","setIn3","ValidatorRegistry","registry","register","NodeType2","EMPTY_NODE","Parser","onParseObject","onCreateASTNode","parseNode","parseView","viewNode","parseObject","createASTNode","tapped","templateDepth","parsedNode","parseLocalObject","currentValue","objToParse","children","localObj","objEntries","v","defaultValue","accumulation","current","value2","children2","localValue","newChildren","parentObj","import_timm5","setIn4","baseAst","child","unpackAndPush","initial","asset","withContext","Resolver","root","skipResolve","beforeUpdate","afterUpdate","beforeResolve","afterResolve","afterNodeUpdate","resolveCache","ASTMap","idCache","getSourceNode","convertedAST","changes","prevASTMap","updated","computeTree","getResolveCache","getPreviousResult","isFirstUpdate","cloneNode","clonedNode","import_timm4","rawParent","cacheUpdate","partiallyResolvedParent","dependencyModel","depModelWithParser","previousResult","previousDeps","dataChanged","shouldUseLastValue","resolvedAST","isNestedMultiNode","update2","repopulateASTMapFromCache","AST","ASTParent","resolvedASTLocal","resolvedUpdate","handleChildNode","childNode","originalChildNode","previousChildResult","childAST","resolved","childDependencies","computedChildTree","childTreeDeps","childUpdated","childValue","override","arr","setIn5","rawParentToPassIn","newValues","mValue","mTree","bindingDep","scope","CrossfieldProvider","initialView","parser","allValidations","byBinding","contentView","xfieldRefs","withDefaults","ViewInstance","onUpdate","resolver","onTemplatePluginCreated","templatePlugin","updateAsync","lastUpdate","rootNode","validationProvider","templateSymbol","TemplatePlugin","resolveTemplateSubstitutions","parseTemplate","depth","dataItem","templateSubstitutions","templateStr","JSON","stringify","flags","placement","applyParser","dynamic","getTemplateSymbolValue","node2","aPath","bPath","pathsEqual","aPlacement","bPlacement","_nodeType","childOptions","templateAST","Boolean","applyResolverHooks","apply","view","createPatternMatcher","testStr","startLocation","endLocation","resolveAllRefs","propertiesToSkip","newNode","import_timm6","findBasePath","parentNode","original","StringResolverPlugin","propertiesToSkipCache","applyResolver","propsToSkip","plugins","stringResolver","nodePath","some","ApplicabilityPlugin","isApplicability","isApplicable","nodeType","parsedApplicability","import_timm7","omit2","applicabilityNode","applicability","SwitchPlugin","resolveSwitch","cases","switchCase","case","isSwitch","switchContent","dynamicSwitch","staticSwitch","switchCaseExpr","switchBody","switchAST","sCase","firstChild","MultiNodePlugin","childVal","multiNode","AssetPlugin","assetAST","FlowInstance","flow","isTransitioning","beforeStart","onStart","onEnd","skipTransition","beforeTransition","resolveTransitionNode","transition","afterTransition","history","_oldState","nextState","newState","flowPromise","state_type","initialState","startState","import_p_defer2","defer","pushHistory","transitionValue","currentState","transitions","stateName","prevState","newCurrentState","FlowController","navigation","navStack","run","addNewFlow","stateTransition","startFlow","firstItem","flowInstance","subflowId","subFlowEndState","outcome","BEGIN","CONTEXT","ValidationBindingTrackerViewPlugin","trackedBindings","getBindings","trackBinding","callbacks","onAdd","tracked","sections","lastViewUpdateChangeSet","lastComputedBindingTree","currentBindingTree","lastSectionBindingTree","resolvedNodeMap","shouldSkip","trackedBindingsForNode","intersection","track","getOptions","eows","_getValidationForBinding","getAll","firstFieldEOW","eow","displayTarget","getChildren","getValidationsForSection","registerOptions","originalNode","newlyComputed","nodeSet","sectionNode","temp","SCHEMA_VALIDATION_PROVIDER_NAME","VIEW_VALIDATION_PROVIDER_NAME","VALIDATION_PROVIDER_NAME_SYMBOL","for","ValidatedBinding","possibleValidations","onDismiss","weakBindings","applicableValidations","validationsByState","load","vObj","statefulValidationObject","flat","checkIfBlocking","statefulObj","response","blocking","firstInvalid","runApplicableValidations","runner","canDismiss","phase","originalValue","import_timm9","setIn6","dismissable","dismiss","newApplicableValidations","currentPhase","ValidationController","createValidatorRegistry","onAddValidation","onRemoveValidation","resolveValidationProviders","onTrackBinding","weakBindingTracker","setOptions","getDataMiddleware","strongValidation","updateValidationsForBinding","getValidationForBinding","newInvalidBindings","weakValidation","strongBinding","weakBinding","getValidationProviders","providers","source","provider","viewValidationProvider","getValidationsForView","tracker","onView","bindingTrackerPlugin","withoutDefault","ignoreDefaultValue","silent","validationContext","vals","valObj","trackedValidations","validationObj","validationRunner","vBinding","getValidator","dataTarget","parameters","updateValidationsForView","isNavigationTrigger","lastActiveBindings","activeBindings","updateValidations","dismissValidations","validatorRegistry","validateView","canTransition","forView","bindings","validationMapping","LocalStateStore","updateCallback","removeKey","useSharedState","getLocalStateFunction","countKey","localState","oldCount","findUp","AssetTransformCorePlugin","stateStore","beforeResolveSymbol","resolveSymbol","beforeResolveCountSymbol","resolveCountSymbol","viewController","lastUpdatedNode","updateState","getStore","stepKey","storedState","useLocalState","transform","skip","isParentOfUpdated","isChildOfUpdated","ViewController","initialViews","resolveView","transformRegistry","optimizeUpdates","viewOptions","viewMap","flowController","currentView","queueUpdate","updateOptions","onDelete","pendingUpdate","changedBindings","scheduled","getViewForRef","viewRef","matchingViewId","possibleViewIdMatch","viewId","ReadOnlyDataController","controller","DataController","resolveDataStages","resolveDefaultValue","onGet","serialize","baseMiddleware","trash","pathResolver","getModel","stages","resolveDataValue","normalizedTransaction","setUpdates","oldVal","setUpdateBindings","su","tr","defaultVal","existedBeforeDelete","makeReadOnly","roots","sep","memo","ConstantsController","tempStore","addConstants","namespace","getConstants","fallback","setTemporaryValues","clearTemporaryValues","FlowExpPlugin","player","expressionEvaluator","handleEval","fc","createFormatFunction","formatName","DefaultExpPlugin","formatFunction","schemaController","expEvaluator","NOT_STARTED_STATE","DefaultViewPlugin","pluginOptions","PLAYER_VERSION","COMMIT","_Player","config","constantsController","dataController","validationController","bindingParser","resolveFlowContent","plugin","getPlugins","findPlugin","symbol","el","applyTo","registerPlugin","getVersion","version","getCommit","commit","getState","setState","setupFlow","userContent","userFlow","flowResultDeferred","resolveStrings","transitionVal","computedTransitionVal","import_timm8","setIn7","param","constants","views","utils","pluginSymbol","endState","flowResult","finally","controllers","fail","payload","maybeUpdateState","endProps","errorState","CheckPathPluginSymbol","resolvedMap","assetIdMap","sourceNode","getSourceAssetNode","assetNode","potentialMatch","getAssetFromAssetNode","queryArray","parentQuery","getParentProp","childProp","hasParentContext","findChildPath","includeSelfMatch","Applicability","getResolvedValue","includesSelf","childQuery","MultiNode","hasChildContext","getAsset","getPath","findWorkingChild","actualIndex","undefCount"],"mappings":"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","sourcesContent":["\"use strict\";\nvar CheckPathPlugin = (() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __export = (target, all) => {\n    for (var name in all)\n      __defProp(target, name, { get: all[name], enumerable: true });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n  var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/ts-nested-error@1.2.1/node_modules/ts-nested-error/build/nested-error.js\n  var require_nested_error = __commonJS({\n    \"../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/ts-nested-error@1.2.1/node_modules/ts-nested-error/build/nested-error.js\"(exports) {\n      \"use strict\";\n      Object.defineProperty(exports, \"__esModule\", { value: true });\n      exports.toError = exports.NestedError = void 0;\n      var NestedError4 = class _NestedError extends Error {\n        /**\n         * Allocates an instance of `NestedError` with the given error `message` and\n         * optional `innerError` (which will be automatically coerced using `toError()`).\n         *\n         * @param message     Laconic error message to attach to the created `NestedError`.\n         * @param innerErrors Optional errors that will be wrapped by this higher level\n         *                    error. This value will be automatically coerced using `toError()`.\n         */\n        constructor(message, ...innerErrors) {\n          super(message);\n          const thisErrorReport = _NestedError.getErrorReport(this);\n          if (innerErrors.length === 1) {\n            const innerError = toError(innerErrors[0]);\n            this.innerErrors = [innerError];\n            const errReport = _NestedError.getErrorReport(innerError);\n            this.stack = `${thisErrorReport}\n\n======= INNER ERROR =======\n\n${errReport}`;\n            return;\n          }\n          this.innerErrors = innerErrors.map((err) => toError(err));\n          const innerErrorReports = this.innerErrors.map((error, idx) => {\n            const errReport = _NestedError.getErrorReport(error);\n            return `======= INNER ERROR (${idx + 1} of ${innerErrors.length}) =======\n\n${errReport}`;\n          }).join(\"\\n\\n\");\n          this.stack = `${thisErrorReport}\n\n${innerErrorReports}`;\n        }\n        /**\n         * Provides the first `Error` of the `innerErrors` (if it exists);\n         * otherwise, `null`.\n         *\n         * @deprecated Please shift to using the `innerErrors` (with an 's') property.\n         */\n        get innerError() {\n          return this.innerErrors.length === 0 ? null : this.innerErrors[0];\n        }\n        /**\n         * Returns the function that accepts any value that was thrown as the first argument and\n         * throws it wrapped into `NestedError` or class derived from `NestedError` (provided\n         * this method was called directly in the context of that dervied class constructor)\n         * with the given `message`.\n         * Returned function will pass accepted `Error` object directly to `NestedError`\n         * as `innerErrors` by invoking `toError(err)` on it.\n         *\n         * You'll most likely want to use this method with promises:\n         *\n         * ```ts\n         * userService.getPage().then(\n         *     data => console.log(`Hooray! data: ${data}`),\n         *     NestedError.rethrow('failed to fetch users page')\n         * );\n         * ```\n         *\n         * @param message Message to attach `NestedError` created by the returned function.\n         */\n        static rethrow(message) {\n          return (...errs) => {\n            throw new this(message, ...errs);\n          };\n        }\n      };\n      exports.NestedError = NestedError4;\n      NestedError4.getErrorReport = typeof new Error().stack === \"string\" ? (err) => err.stack : (err) => `${err.name}: ${err.message}`;\n      NestedError4.prototype.name = \"NestedError\";\n      function toError(err) {\n        try {\n          return err instanceof Error ? err : new Error(`Value that is not an instance of Error was thrown: ${err}`);\n        } catch {\n          return new Error(\"Failed to stringify non-instance of Error that was thrown.This is possibly due to the fact that toString() method of the valuedoesn't return a primitive value.\");\n        }\n      }\n      exports.toError = toError;\n    }\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/timm@1.7.1/node_modules/timm/lib/timm.js\n  var require_timm = __commonJS({\n    \"../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/timm@1.7.1/node_modules/timm/lib/timm.js\"(exports) {\n      \"use strict\";\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.clone = clone2;\n      exports.addLast = addLast2;\n      exports.addFirst = addFirst;\n      exports.removeLast = removeLast;\n      exports.removeFirst = removeFirst;\n      exports.insert = insert;\n      exports.removeAt = removeAt2;\n      exports.replaceAt = replaceAt;\n      exports.getIn = getIn;\n      exports.set = set2;\n      exports.setIn = setIn8;\n      exports.update = update;\n      exports.updateIn = updateIn;\n      exports.merge = merge;\n      exports.mergeDeep = mergeDeep;\n      exports.mergeIn = mergeIn;\n      exports.omit = omit3;\n      exports.addDefaults = addDefaults;\n      exports.default = void 0;\n      var INVALID_ARGS = \"INVALID_ARGS\";\n      var IS_DEV = false;\n      function throwStr(msg) {\n        throw new Error(msg);\n      }\n      function getKeysAndSymbols(obj) {\n        const keys = Object.keys(obj);\n        if (Object.getOwnPropertySymbols) {\n          return keys.concat(Object.getOwnPropertySymbols(obj));\n        }\n        return keys;\n      }\n      var hasOwnProperty = {}.hasOwnProperty;\n      function clone2(obj0) {\n        if (Array.isArray(obj0))\n          return obj0.slice();\n        const obj = obj0;\n        const keys = getKeysAndSymbols(obj);\n        const out = {};\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          out[key] = obj[key];\n        }\n        return out;\n      }\n      function isObject(o) {\n        return o != null && typeof o === \"object\";\n      }\n      function addLast2(array, val) {\n        if (Array.isArray(val))\n          return array.concat(val);\n        return array.concat([val]);\n      }\n      function addFirst(array, val) {\n        if (Array.isArray(val))\n          return val.concat(array);\n        return [val].concat(array);\n      }\n      function removeLast(array) {\n        if (!array.length)\n          return array;\n        return array.slice(0, array.length - 1);\n      }\n      function removeFirst(array) {\n        if (!array.length)\n          return array;\n        return array.slice(1);\n      }\n      function insert(array, idx, val) {\n        return array.slice(0, idx).concat(Array.isArray(val) ? val : [val]).concat(array.slice(idx));\n      }\n      function removeAt2(array, idx) {\n        if (idx >= array.length || idx < 0)\n          return array;\n        return array.slice(0, idx).concat(array.slice(idx + 1));\n      }\n      function replaceAt(array, idx, newItem) {\n        if (array[idx] === newItem)\n          return array;\n        const len = array.length;\n        const result = Array(len);\n        for (let i = 0; i < len; i++) {\n          result[i] = array[i];\n        }\n        result[idx] = newItem;\n        return result;\n      }\n      function getIn(obj, path) {\n        if (!Array.isArray(path)) {\n          throwStr(IS_DEV ? \"A path array should be provided when calling getIn()\" : INVALID_ARGS);\n        }\n        if (obj == null)\n          return void 0;\n        let ptr = obj;\n        for (let i = 0; i < path.length; i++) {\n          const key = path[i];\n          ptr = ptr != null ? ptr[key] : void 0;\n          if (ptr === void 0)\n            return ptr;\n        }\n        return ptr;\n      }\n      function set2(obj0, key, val) {\n        let obj = obj0;\n        if (obj == null)\n          obj = typeof key === \"number\" ? [] : {};\n        if (obj[key] === val)\n          return obj;\n        const obj2 = clone2(obj);\n        obj2[key] = val;\n        return obj2;\n      }\n      function setIn8(obj, path, val) {\n        if (!path.length)\n          return val;\n        return doSetIn(obj, path, val, 0);\n      }\n      function doSetIn(obj, path, val, idx) {\n        let newValue;\n        const key = path[idx];\n        if (idx === path.length - 1) {\n          newValue = val;\n        } else {\n          const nestedObj = isObject(obj) && isObject(obj[key]) ? obj[key] : typeof path[idx + 1] === \"number\" ? [] : {};\n          newValue = doSetIn(nestedObj, path, val, idx + 1);\n        }\n        return set2(obj, key, newValue);\n      }\n      function update(obj, key, fnUpdate) {\n        const prevVal = obj == null ? void 0 : obj[key];\n        const nextVal = fnUpdate(prevVal);\n        return set2(obj, key, nextVal);\n      }\n      function updateIn(obj, path, fnUpdate) {\n        const prevVal = getIn(obj, path);\n        const nextVal = fnUpdate(prevVal);\n        return setIn8(obj, path, nextVal);\n      }\n      function merge(a, b, c, d, e, f, ...rest) {\n        return rest.length ? doMerge.call(null, false, false, a, b, c, d, e, f, ...rest) : doMerge(false, false, a, b, c, d, e, f);\n      }\n      function mergeDeep(a, b, c, d, e, f, ...rest) {\n        return rest.length ? doMerge.call(null, false, true, a, b, c, d, e, f, ...rest) : doMerge(false, true, a, b, c, d, e, f);\n      }\n      function mergeIn(a, path, b, c, d, e, f, ...rest) {\n        let prevVal = getIn(a, path);\n        if (prevVal == null)\n          prevVal = {};\n        let nextVal;\n        if (rest.length) {\n          nextVal = doMerge.call(null, false, false, prevVal, b, c, d, e, f, ...rest);\n        } else {\n          nextVal = doMerge(false, false, prevVal, b, c, d, e, f);\n        }\n        return setIn8(a, path, nextVal);\n      }\n      function omit3(obj, attrs) {\n        const omitList = Array.isArray(attrs) ? attrs : [attrs];\n        let fDoSomething = false;\n        for (let i = 0; i < omitList.length; i++) {\n          if (hasOwnProperty.call(obj, omitList[i])) {\n            fDoSomething = true;\n            break;\n          }\n        }\n        if (!fDoSomething)\n          return obj;\n        const out = {};\n        const keys = getKeysAndSymbols(obj);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          if (omitList.indexOf(key) >= 0)\n            continue;\n          out[key] = obj[key];\n        }\n        return out;\n      }\n      function addDefaults(a, b, c, d, e, f, ...rest) {\n        return rest.length ? doMerge.call(null, true, false, a, b, c, d, e, f, ...rest) : doMerge(true, false, a, b, c, d, e, f);\n      }\n      function doMerge(fAddDefaults, fDeep, first, ...rest) {\n        let out = first;\n        if (!(out != null)) {\n          throwStr(IS_DEV ? \"At least one object should be provided to merge()\" : INVALID_ARGS);\n        }\n        let fChanged = false;\n        for (let idx = 0; idx < rest.length; idx++) {\n          const obj = rest[idx];\n          if (obj == null)\n            continue;\n          const keys = getKeysAndSymbols(obj);\n          if (!keys.length)\n            continue;\n          for (let j = 0; j <= keys.length; j++) {\n            const key = keys[j];\n            if (fAddDefaults && out[key] !== void 0)\n              continue;\n            let nextVal = obj[key];\n            if (fDeep && isObject(out[key]) && isObject(nextVal)) {\n              nextVal = doMerge(fAddDefaults, fDeep, out[key], nextVal);\n            }\n            if (nextVal === void 0 || nextVal === out[key])\n              continue;\n            if (!fChanged) {\n              fChanged = true;\n              out = clone2(out);\n            }\n            out[key] = nextVal;\n          }\n        }\n        return out;\n      }\n      var timm = {\n        clone: clone2,\n        addLast: addLast2,\n        addFirst,\n        removeLast,\n        removeFirst,\n        insert,\n        removeAt: removeAt2,\n        replaceAt,\n        getIn,\n        set: set2,\n        setIn: setIn8,\n        update,\n        updateIn,\n        merge,\n        mergeDeep,\n        mergeIn,\n        omit: omit3,\n        addDefaults\n      };\n      var _default = timm;\n      exports.default = _default;\n    }\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/p-defer@3.0.0/node_modules/p-defer/index.js\n  var require_p_defer = __commonJS({\n    \"../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/p-defer@3.0.0/node_modules/p-defer/index.js\"(exports, module) {\n      \"use strict\";\n      var pDefer = () => {\n        const deferred2 = {};\n        deferred2.promise = new Promise((resolve, reject) => {\n          deferred2.resolve = resolve;\n          deferred2.reject = reject;\n        });\n        return deferred2;\n      };\n      module.exports = pDefer;\n    }\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/queue-microtask@1.2.3/node_modules/queue-microtask/index.js\n  var require_queue_microtask = __commonJS({\n    \"../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/queue-microtask@1.2.3/node_modules/queue-microtask/index.js\"(exports, module) {\n      \"use strict\";\n      var promise;\n      module.exports = typeof queueMicrotask === \"function\" ? queueMicrotask.bind(typeof window !== \"undefined\" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {\n        throw err;\n      }, 0));\n    }\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/sorted-array@2.0.4/node_modules/sorted-array/sorted-array.js\n  var require_sorted_array = __commonJS({\n    \"../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/sorted-array@2.0.4/node_modules/sorted-array/sorted-array.js\"(exports, module) {\n      \"use strict\";\n      var SortedArray2 = function() {\n        var SortedArray3 = defclass({\n          constructor: function(array, compare) {\n            this.array = [];\n            this.compare = compare || compareDefault;\n            var length = array.length, index = 0;\n            while (index < length)\n              this.insert(array[index++]);\n          },\n          insert: function(element) {\n            var array = this.array, compare = this.compare, high = array.length - 1, low = 0, pos = -1, index, ordering;\n            while (high >= low) {\n              index = (high + low) / 2 >>> 0;\n              ordering = compare(array[index], element);\n              if (ordering < 0)\n                low = index + 1;\n              else if (ordering > 0)\n                high = index - 1;\n              else {\n                pos = index;\n                break;\n              }\n              ;\n            }\n            if (pos === -1) {\n              pos = high;\n            }\n            pos++;\n            high = array.length - 1;\n            while (pos < high && compare(element, array[pos]) === 0) {\n              pos++;\n            }\n            index = array.length;\n            array.push(element);\n            while (index > pos) {\n              array[index] = array[--index];\n            }\n            array[pos] = element;\n            return this;\n          },\n          search: function(element) {\n            var array = this.array, compare = this.compare, high = array.length - 1, low = 0, index, ordering;\n            while (high >= low) {\n              index = (high + low) / 2 >>> 0;\n              ordering = compare(array[index], element);\n              if (ordering < 0)\n                low = index + 1;\n              else if (ordering > 0)\n                high = index - 1;\n              else\n                return index;\n            }\n            return -1;\n          },\n          remove: function(element) {\n            var index = this.search(element);\n            if (index >= 0)\n              this.array.splice(index, 1);\n            return this;\n          }\n        });\n        SortedArray3.comparing = function(property, array) {\n          return new SortedArray3(array, function(a, b) {\n            return compareDefault(a[property], b[property]);\n          });\n        };\n        return SortedArray3;\n        function defclass(prototype) {\n          var constructor = prototype.constructor;\n          constructor.prototype = prototype;\n          return constructor;\n        }\n        function compareDefault(a, b) {\n          if (a < b)\n            return -1;\n          else if (a > b)\n            return 1;\n          else\n            return 0;\n        }\n      }();\n      if (typeof module === \"object\")\n        module.exports = SortedArray2;\n      if (typeof define === \"function\" && define.amd)\n        define(function() {\n          return SortedArray2;\n        });\n    }\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/check-path/core/src/index.ts\n  var src_exports = {};\n  __export(src_exports, {\n    CheckPathPlugin: () => CheckPathPlugin\n  });\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/tapable-ts@0.2.4/node_modules/tapable-ts/dist/hooks.mjs\n  function equalToOrIn(value, check) {\n    if (Array.isArray(check)) {\n      return check.includes(value);\n    }\n    return check === value;\n  }\n  function callTap(tap, args, ctx) {\n    if (tap.context) {\n      return tap.callback(ctx, ...args);\n    }\n    return tap.callback(...args);\n  }\n  var InterceptionManager = class {\n    constructor() {\n      this.interceptions = [];\n      this.interceptionKeySet = /* @__PURE__ */ new Set();\n    }\n    isUsed() {\n      return this.interceptions.length > 0;\n    }\n    intercept(int) {\n      this.interceptions.push(int);\n      Object.keys(int).forEach((s) => {\n        this.interceptionKeySet.add(s);\n      });\n    }\n    tap(tap) {\n      if (this.interceptionKeySet.has(\"tap\")) {\n        this.interceptions.forEach((i) => {\n          var _a;\n          (_a = i.tap) == null ? void 0 : _a.call(i, tap);\n        });\n      }\n    }\n    call(ctx, ...args) {\n      if (this.interceptionKeySet.has(\"call\")) {\n        this.interceptions.forEach((i) => {\n          var _a, _b;\n          if (i.context) {\n            (_a = i.call) == null ? void 0 : _a.call(i, ctx, ...args);\n          } else {\n            (_b = i.call) == null ? void 0 : _b.call(i, ...args);\n          }\n        });\n      }\n    }\n    loop(...args) {\n      if (this.interceptionKeySet.has(\"loop\")) {\n        this.interceptions.forEach((i) => {\n          var _a;\n          (_a = i.loop) == null ? void 0 : _a.call(i, ...args);\n        });\n      }\n    }\n    error(err) {\n      if (this.interceptionKeySet.has(\"error\")) {\n        if (err instanceof Error) {\n          const asError = err;\n          this.interceptions.forEach((i) => {\n            var _a;\n            (_a = i.error) == null ? void 0 : _a.call(i, asError);\n          });\n        }\n      }\n    }\n    result(r) {\n      if (this.interceptionKeySet.has(\"result\")) {\n        this.interceptions.forEach((i) => {\n          var _a;\n          (_a = i.result) == null ? void 0 : _a.call(i, r);\n        });\n      }\n    }\n    done() {\n      if (this.interceptionKeySet.has(\"done\")) {\n        this.interceptions.forEach((i) => {\n          var _a;\n          (_a = i.done) == null ? void 0 : _a.call(i);\n        });\n      }\n    }\n  };\n  var Hook = class {\n    constructor() {\n      this.taps = [];\n      this.interceptions = new InterceptionManager();\n    }\n    tap(options, callback) {\n      const resolvedOptions = typeof options === \"string\" ? {\n        name: options,\n        context: false\n      } : {\n        context: false,\n        ...options\n      };\n      const key = Symbol(resolvedOptions.name);\n      const tap = {\n        key,\n        ...resolvedOptions,\n        callback\n      };\n      if (tap.before) {\n        let insertionIndex = this.taps.length;\n        const beforeSet = new Set(Array.isArray(tap.before) ? tap.before : [tap.before]);\n        for (insertionIndex; insertionIndex > 0 && beforeSet.size > 0; insertionIndex--) {\n          const t2 = this.taps[insertionIndex - 1];\n          if (beforeSet.has(t2.name)) {\n            beforeSet.delete(t2.name);\n          }\n          if (t2.before && equalToOrIn(tap.name, t2.before)) {\n            break;\n          }\n        }\n        this.taps.splice(insertionIndex, 0, tap);\n      } else {\n        this.taps.push(tap);\n      }\n      this.interceptions.tap(tap);\n      return tap;\n    }\n    untap(tap) {\n      this.taps = this.taps.filter((t2) => t2.key !== tap.key);\n    }\n    isUsed() {\n      return this.taps.length > 0 || this.interceptions.isUsed();\n    }\n    intercept(int) {\n      this.interceptions.intercept(int);\n    }\n  };\n  var SyncHook = class extends Hook {\n    call(...args) {\n      if (!this.isUsed()) {\n        return;\n      }\n      const ctx = {};\n      this.interceptions.call(ctx, ...args);\n      try {\n        this.taps.forEach((t2) => {\n          callTap(t2, args, ctx);\n        });\n      } catch (err) {\n        this.interceptions.error(err);\n        throw err;\n      }\n      this.interceptions.done();\n    }\n  };\n  var SyncBailHook = class extends Hook {\n    call(...args) {\n      if (!this.isUsed()) {\n        return;\n      }\n      const ctx = {};\n      this.interceptions.call(ctx, ...args);\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        const rtn = callTap(this.taps[tapIndex], args, ctx);\n        if (rtn !== void 0) {\n          this.interceptions.result(rtn);\n          return rtn;\n        }\n      }\n      this.interceptions.done();\n    }\n  };\n  var SyncWaterfallHook = class extends Hook {\n    call(...args) {\n      const ctx = {};\n      this.interceptions.call(ctx, ...args);\n      let [rtn, ...rest] = args;\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        const tapValue = callTap(this.taps[tapIndex], [rtn, ...rest], ctx);\n        if (tapValue !== void 0) {\n          rtn = tapValue;\n        }\n      }\n      this.interceptions.result(rtn);\n      return rtn;\n    }\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+player@0.0.0/node_modules/@player-ui/player/dist/index.mjs\n  var import_ts_nested_error = __toESM(require_nested_error(), 1);\n  var import_ts_nested_error2 = __toESM(require_nested_error(), 1);\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dlv@1.1.3/node_modules/dlv/dist/dlv.es.js\n  function dlv_es_default(t2, e, l, n, r) {\n    for (e = e.split ? e.split(\".\") : e, n = 0; n < e.length; n++)\n      t2 = t2 ? t2[e[n]] : r;\n    return t2 === r ? l : t2;\n  }\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+player@0.0.0/node_modules/@player-ui/player/dist/index.mjs\n  var import_timm = __toESM(require_timm(), 1);\n  var import_ts_nested_error3 = __toESM(require_nested_error(), 1);\n  var import_timm2 = __toESM(require_timm(), 1);\n  var import_timm3 = __toESM(require_timm(), 1);\n  var import_timm4 = __toESM(require_timm(), 1);\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/dequal@2.0.3/node_modules/dequal/dist/index.mjs\n  var has = Object.prototype.hasOwnProperty;\n  function find(iter, tar, key) {\n    for (key of iter.keys()) {\n      if (dequal(key, tar))\n        return key;\n    }\n  }\n  function dequal(foo, bar) {\n    var ctor, len, tmp;\n    if (foo === bar)\n      return true;\n    if (foo && bar && (ctor = foo.constructor) === bar.constructor) {\n      if (ctor === Date)\n        return foo.getTime() === bar.getTime();\n      if (ctor === RegExp)\n        return foo.toString() === bar.toString();\n      if (ctor === Array) {\n        if ((len = foo.length) === bar.length) {\n          while (len-- && dequal(foo[len], bar[len]))\n            ;\n        }\n        return len === -1;\n      }\n      if (ctor === Set) {\n        if (foo.size !== bar.size) {\n          return false;\n        }\n        for (len of foo) {\n          tmp = len;\n          if (tmp && typeof tmp === \"object\") {\n            tmp = find(bar, tmp);\n            if (!tmp)\n              return false;\n          }\n          if (!bar.has(tmp))\n            return false;\n        }\n        return true;\n      }\n      if (ctor === Map) {\n        if (foo.size !== bar.size) {\n          return false;\n        }\n        for (len of foo) {\n          tmp = len[0];\n          if (tmp && typeof tmp === \"object\") {\n            tmp = find(bar, tmp);\n            if (!tmp)\n              return false;\n          }\n          if (!dequal(len[1], bar.get(tmp))) {\n            return false;\n          }\n        }\n        return true;\n      }\n      if (ctor === ArrayBuffer) {\n        foo = new Uint8Array(foo);\n        bar = new Uint8Array(bar);\n      } else if (ctor === DataView) {\n        if ((len = foo.byteLength) === bar.byteLength) {\n          while (len-- && foo.getInt8(len) === bar.getInt8(len))\n            ;\n        }\n        return len === -1;\n      }\n      if (ArrayBuffer.isView(foo)) {\n        if ((len = foo.byteLength) === bar.byteLength) {\n          while (len-- && foo[len] === bar[len])\n            ;\n        }\n        return len === -1;\n      }\n      if (!ctor || typeof foo === \"object\") {\n        len = 0;\n        for (ctor in foo) {\n          if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))\n            return false;\n          if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))\n            return false;\n        }\n        return Object.keys(bar).length === len;\n      }\n    }\n    return foo !== foo && bar !== bar;\n  }\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+player@0.0.0/node_modules/@player-ui/player/dist/index.mjs\n  var import_timm5 = __toESM(require_timm(), 1);\n  var import_timm6 = __toESM(require_timm(), 1);\n  var import_timm7 = __toESM(require_timm(), 1);\n  var import_timm8 = __toESM(require_timm(), 1);\n  var import_p_defer = __toESM(require_p_defer(), 1);\n  var import_p_defer2 = __toESM(require_p_defer(), 1);\n  var import_timm9 = __toESM(require_timm(), 1);\n  var import_queue_microtask = __toESM(require_queue_microtask(), 1);\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+partial-match-registry@0.0.0/node_modules/@player-ui/partial-match-registry/dist/index.mjs\n  var import_sorted_array = __toESM(require_sorted_array(), 1);\n  function traverseObj(object, path = [], pairs = /* @__PURE__ */ new Map()) {\n    for (const key of Object.keys(object)) {\n      const val = object[key];\n      const nestedPath = [...path, key];\n      if (typeof val === \"object\") {\n        traverseObj(val, nestedPath, pairs);\n      } else {\n        pairs.set(nestedPath, val);\n      }\n    }\n    return pairs;\n  }\n  function createMatcher(partialObj) {\n    const pairs = traverseObj(partialObj);\n    const matchFunction = (searchObj) => {\n      for (const entry of Array.from(pairs)) {\n        const [path, value] = entry;\n        if (dlv_es_default(searchObj, path) !== value) {\n          return false;\n        }\n      }\n      return true;\n    };\n    matchFunction.count = pairs.size;\n    return matchFunction;\n  }\n  function createBasicMatcher(seed) {\n    const matcher = (match) => seed === match;\n    matcher.count = 1;\n    return matcher;\n  }\n  var createSortedArray = () => new import_sorted_array.default([], (c) => c.matcher.count);\n  var Registry = class {\n    constructor(initialSet) {\n      this.store = createSortedArray();\n      initialSet?.forEach(([match, value]) => {\n        this.set(match, value);\n      });\n    }\n    /** Add match -> value mapping to the registry */\n    set(match, value) {\n      const matcher = typeof match === \"object\" ? createMatcher(match) : createBasicMatcher(match);\n      this.store.insert({\n        key: match,\n        value,\n        matcher\n      });\n    }\n    /** Fetch the best match in the registry */\n    get(query) {\n      for (const entry of this.store.array) {\n        if (entry.matcher(query)) {\n          return entry.value;\n        }\n      }\n    }\n    /** Loop over all entries and run callback */\n    forEach(callbackfn) {\n      for (const entry of this.store.array) {\n        callbackfn(entry);\n      }\n    }\n    /** Reset the items in the registry */\n    clear() {\n      this.store = createSortedArray();\n    }\n    /** Check if the registry is empty*/\n    isRegistryEmpty() {\n      return this.store.array.length === 0;\n    }\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/node_modules/.aspect_rules_js/@player-ui+player@0.0.0/node_modules/@player-ui/player/dist/index.mjs\n  var __defProp2 = Object.defineProperty;\n  var __export2 = (target, all) => {\n    for (var name in all)\n      __defProp2(target, name, { get: all[name], enumerable: true });\n  };\n  var toValue = (value) => ({\n    name: \"Value\",\n    value\n  });\n  var toExpression = (value) => ({\n    name: \"Expression\",\n    value\n  });\n  var toPath = (path) => ({\n    name: \"PathNode\",\n    path\n  });\n  var toQuery = (key, value) => ({\n    name: \"Query\",\n    key,\n    value\n  });\n  var toConcatenatedNode = (values) => {\n    if (values.length === 1) {\n      return values[0];\n    }\n    return {\n      name: \"Concatenated\",\n      value: values\n    };\n  };\n  var SEGMENT_SEPARATOR = \".\";\n  var OPEN_CURL = \"{\";\n  var CLOSE_CURL = \"}\";\n  var OPEN_BRACKET = \"[\";\n  var CLOSE_BRACKET = \"]\";\n  var EQUALS = \"=\";\n  var SINGLE_QUOTE = \"'\";\n  var DOUBLE_QUOTE = '\"';\n  var BACK_TICK = \"`\";\n  var isIdentifierChar = (char) => {\n    if (!char) {\n      return false;\n    }\n    const charCode = char.charCodeAt(0);\n    const matches = charCode === 32 || // ' '\n    charCode === 34 || // \"\n    charCode === 39 || // '\n    charCode === 40 || // (\n    charCode === 41 || // )\n    charCode === 42 || // *\n    charCode === 46 || // .\n    charCode === 61 || // =\n    charCode === 91 || // [\n    charCode === 93 || // ]\n    charCode === 96 || // `\n    charCode === 123 || // {\n    charCode === 125;\n    return !matches;\n  };\n  var parse = (path) => {\n    let index = 1;\n    let ch = path.charAt(0);\n    const next = (expected) => {\n      if (expected && ch !== expected) {\n        throw new Error(`Expected char: ${expected} but got: ${ch}`);\n      }\n      ch = path.charAt(index);\n      index += 1;\n      return ch;\n    };\n    const whitespace = () => {\n      while (ch === \" \") {\n        next();\n      }\n    };\n    const identifier = () => {\n      if (!isIdentifierChar(ch)) {\n        return;\n      }\n      let value = ch;\n      while (next()) {\n        if (!isIdentifierChar(ch)) {\n          break;\n        }\n        value += ch;\n      }\n      if (value) {\n        const maybeNumber = Number(value);\n        value = isNaN(maybeNumber) ? value : maybeNumber;\n        return toValue(value);\n      }\n    };\n    const expression = () => {\n      if (ch === BACK_TICK) {\n        next(BACK_TICK);\n        let exp = ch;\n        while (next()) {\n          if (ch === BACK_TICK) {\n            break;\n          }\n          exp += ch;\n        }\n        next(BACK_TICK);\n        if (exp) {\n          return toExpression(exp);\n        }\n      }\n    };\n    const regex = (match) => {\n      if (!ch?.match(match)) {\n        return;\n      }\n      let value = ch;\n      while (next()) {\n        if (!ch?.match(match)) {\n          break;\n        }\n        value += ch;\n      }\n      if (value) {\n        return toValue(value);\n      }\n    };\n    const nestedPath = () => {\n      if (ch === OPEN_CURL) {\n        next(OPEN_CURL);\n        next(OPEN_CURL);\n        const modelRef = parsePath();\n        next(CLOSE_CURL);\n        next(CLOSE_CURL);\n        return modelRef;\n      }\n    };\n    const simpleSegment = () => nestedPath() ?? expression() ?? identifier();\n    const segment = () => {\n      const segments = [];\n      let nextSegment = simpleSegment();\n      while (nextSegment !== void 0) {\n        segments.push(nextSegment);\n        nextSegment = simpleSegment();\n      }\n      if (segments.length === 0) {\n        return void 0;\n      }\n      return toConcatenatedNode(segments);\n    };\n    const optionallyQuotedSegment = () => {\n      whitespace();\n      if (ch === SINGLE_QUOTE || ch === DOUBLE_QUOTE) {\n        const singleQuote = ch === SINGLE_QUOTE;\n        next(singleQuote ? SINGLE_QUOTE : DOUBLE_QUOTE);\n        const id = regex(/[^'\"]+/);\n        next(singleQuote ? SINGLE_QUOTE : DOUBLE_QUOTE);\n        return id;\n      }\n      return simpleSegment();\n    };\n    const equals = () => {\n      if (ch !== EQUALS) {\n        return false;\n      }\n      while (ch === EQUALS) {\n        next();\n      }\n      return true;\n    };\n    const parseBracket = () => {\n      if (ch === OPEN_BRACKET) {\n        next(OPEN_BRACKET);\n        whitespace();\n        let value = optionallyQuotedSegment();\n        if (value) {\n          whitespace();\n          if (equals()) {\n            whitespace();\n            const second = optionallyQuotedSegment();\n            value = toQuery(value, second);\n            whitespace();\n          }\n        } else {\n          throw new Error(`Expected identifier`);\n        }\n        if (value) {\n          next(CLOSE_BRACKET);\n        }\n        return value;\n      }\n    };\n    const parseSegmentAndBrackets = () => {\n      const parsed = [];\n      const firstSegment = segment();\n      if (firstSegment) {\n        parsed.push(firstSegment);\n        let bracketSegment = parseBracket();\n        if (bracketSegment?.name === \"Value\") {\n          const maybeNumber = Number(bracketSegment.value);\n          bracketSegment.value = isNaN(maybeNumber) || String(maybeNumber) !== bracketSegment.value ? bracketSegment.value : maybeNumber;\n        }\n        while (bracketSegment !== void 0) {\n          parsed.push(bracketSegment);\n          bracketSegment = parseBracket();\n        }\n      }\n      return parsed;\n    };\n    const parsePath = () => {\n      const parts = [];\n      let nextSegment = parseSegmentAndBrackets();\n      while (nextSegment !== void 0) {\n        parts.push(...nextSegment);\n        if (!ch || ch === CLOSE_CURL) {\n          break;\n        }\n        if (nextSegment.length === 0 && ch) {\n          throw new Error(`Unexpected character: ${ch}`);\n        }\n        next(SEGMENT_SEPARATOR);\n        nextSegment = parseSegmentAndBrackets();\n      }\n      return toPath(parts);\n    };\n    try {\n      const result = parsePath();\n      return {\n        status: true,\n        path: result\n      };\n    } catch (e) {\n      return {\n        status: false,\n        error: e.message\n      };\n    }\n  };\n  function isBinding(binding) {\n    return !(typeof binding === \"string\" || Array.isArray(binding));\n  }\n  function maybeConvertToNum(i) {\n    const asInt = parseInt(i, 10);\n    if (isNaN(asInt)) {\n      return i;\n    }\n    return asInt;\n  }\n  function getBindingSegments(binding) {\n    if (Array.isArray(binding)) {\n      return binding;\n    }\n    if (typeof binding === \"string\") {\n      return binding.split(\".\");\n    }\n    return binding.asArray();\n  }\n  function findInArray(array, key, value) {\n    return array.findIndex((obj) => {\n      if (obj && typeof obj === \"object\") {\n        return obj[key] == value;\n      }\n      return false;\n    });\n  }\n  var BindingInstance = class _BindingInstance {\n    constructor(raw, factory = (rawBinding) => new _BindingInstance(rawBinding)) {\n      const split = Array.isArray(raw) ? raw : raw.split(\".\");\n      this.split = split.map((segment) => {\n        if (typeof segment === \"number\") {\n          return segment;\n        }\n        const tryNum = Number(segment);\n        return isNaN(tryNum) || String(tryNum) !== segment ? segment : tryNum;\n      });\n      Object.freeze(this.split);\n      this.joined = this.split.join(\".\");\n      this.factory = factory;\n    }\n    asArray() {\n      return this.split;\n    }\n    asString() {\n      return this.joined;\n    }\n    /**\n     * Check to see if the given binding is a sub-path of the current one\n     */\n    contains(binding) {\n      const bindingAsArray = binding.asArray();\n      if (bindingAsArray.length < this.split.length) {\n        return false;\n      }\n      for (let i = 0; i < this.split.length; i++) {\n        if (this.split[i] !== bindingAsArray[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    relative(binding) {\n      return this.asArray().slice(binding.asArray().length);\n    }\n    parent() {\n      return this.factory(this.split.slice(0, -1));\n    }\n    key() {\n      return this.split[this.split.length - 1];\n    }\n    /**\n     * This is a utility method to get a binding that is a descendent of this binding\n     *\n     * @param relative - The relative path to descend to\n     */\n    descendent(relative) {\n      const descendentSegments = getBindingSegments(relative);\n      return this.factory(this.split.concat(descendentSegments));\n    }\n  };\n  function resolveBindingAST(bindingPathNode, options, hooks) {\n    const context = {\n      updates: {},\n      path: []\n    };\n    function getValueForNode(node) {\n      if (node.name === \"Value\") {\n        return node.value;\n      }\n      if (node.name === \"PathNode\") {\n        const nestedResolvedValue = resolveBindingAST(node, options);\n        if (nestedResolvedValue.updates) {\n          context.updates = {\n            ...context.updates,\n            ...nestedResolvedValue.updates\n          };\n        }\n        try {\n          return options.convertToPath(\n            options.getValue(nestedResolvedValue.path)\n          );\n        } catch (e) {\n          throw new import_ts_nested_error2.NestedError(\n            `Unable to resolve path segment: ${nestedResolvedValue.path}`,\n            e\n          );\n        }\n      }\n      if (node.name === \"Expression\") {\n        try {\n          const actualValue = options.evaluate(node.value);\n          return options.convertToPath(actualValue);\n        } catch (e) {\n          throw new import_ts_nested_error2.NestedError(`Unable to resolve path: ${node.value}`, e);\n        }\n      }\n      throw new Error(`Unable to resolve value for node: ${node.name}`);\n    }\n    function appendPathSegments(segment) {\n      if (typeof segment === \"string\" && segment.indexOf(\".\") > -1) {\n        segment.split(\".\").forEach((i) => {\n          context.path.push(maybeConvertToNum(i));\n        });\n      } else {\n        context.path.push(segment);\n      }\n    }\n    function resolveNode(_node) {\n      const resolvedNode = hooks?.beforeResolveNode.call(_node, { ...context, ...options }) ?? _node;\n      switch (resolvedNode.name) {\n        case \"Expression\":\n        case \"PathNode\":\n          appendPathSegments(getValueForNode(resolvedNode));\n          break;\n        case \"Value\":\n          appendPathSegments(resolvedNode.value);\n          break;\n        case \"Query\": {\n          const objToQuery = options.getValue(context.path) ?? [];\n          const { key, value } = resolvedNode;\n          const resolvedKey = getValueForNode(key);\n          const resolvedValue = value && getValueForNode(value);\n          const index = findInArray(objToQuery, resolvedKey, resolvedValue);\n          if (index === void 0 || index === -1) {\n            context.updates[[...context.path, objToQuery.length, resolvedKey].join(\".\")] = resolvedValue;\n            context.path.push(objToQuery.length);\n          } else {\n            context.path.push(index);\n          }\n          break;\n        }\n        case \"Concatenated\":\n          context.path.push(resolvedNode.value.map(getValueForNode).join(\"\"));\n          break;\n        default:\n          throw new Error(`Unsupported node type: ${resolvedNode.name}`);\n      }\n    }\n    bindingPathNode.path.forEach(resolveNode);\n    return {\n      path: context.path,\n      updates: Object.keys(context.updates ?? {}).length > 0 ? context.updates : void 0\n    };\n  }\n  var BINDING_BRACKETS_REGEX = /[\\s()*=`{}'\"[\\]]/;\n  var LAZY_BINDING_REGEX = /^[^.]+(\\..+)*$/;\n  var DEFAULT_OPTIONS = {\n    get: () => {\n      throw new Error(\"Not Implemented\");\n    },\n    set: () => {\n      throw new Error(\"Not Implemented\");\n    },\n    evaluate: () => {\n      throw new Error(\"Not Implemented\");\n    }\n  };\n  var BindingParser = class {\n    constructor(options) {\n      this.hooks = {\n        skipOptimization: new SyncBailHook(),\n        beforeResolveNode: new SyncWaterfallHook()\n      };\n      this.parserOptions = { ...DEFAULT_OPTIONS, ...options };\n      this.cache = {};\n      this.parseCache = {};\n      this.parse = this.parse.bind(this);\n    }\n    /**\n     * Takes a binding path, parses it, and returns an equivalent, normalized\n     * representation of that path.\n     */\n    normalizePath(path, resolveOptions) {\n      if (!BINDING_BRACKETS_REGEX.test(path) && LAZY_BINDING_REGEX.test(path) && this.hooks.skipOptimization.call(path) !== true) {\n        return { path: path.split(\".\"), updates: void 0 };\n      }\n      const ast = this.parseCache[path] ?? parse(path);\n      this.parseCache[path] = ast;\n      if (typeof ast !== \"object\" || !ast?.status) {\n        throw new TypeError(\n          `Cannot normalize path \"${path}\": ${ast?.error ?? \"Unknown Error.\"}`\n        );\n      }\n      try {\n        return resolveBindingAST(ast.path, resolveOptions, this.hooks);\n      } catch (e) {\n        throw new import_ts_nested_error.NestedError(`Cannot resolve binding: ${path}`, e);\n      }\n    }\n    getBindingForNormalizedResult(normalized) {\n      const normalizedStr = normalized.path.join(\".\");\n      if (this.cache[normalizedStr]) {\n        return this.cache[normalizedStr];\n      }\n      const created = new BindingInstance(\n        normalizedStr === \"\" ? [] : normalized.path,\n        this.parse\n      );\n      this.cache[normalizedStr] = created;\n      return created;\n    }\n    parse(rawBinding, overrides = {}) {\n      if (isBinding(rawBinding)) {\n        return rawBinding;\n      }\n      const options = {\n        ...this.parserOptions,\n        ...overrides\n      };\n      let updates = {};\n      const joined = Array.isArray(rawBinding) ? rawBinding.join(\".\") : String(rawBinding);\n      const normalizeConfig = {\n        getValue: (path) => {\n          const normalized2 = this.normalizePath(path.join(\".\"), normalizeConfig);\n          return options.get(this.getBindingForNormalizedResult(normalized2));\n        },\n        evaluate: (exp) => {\n          return options.evaluate(exp);\n        },\n        convertToPath: (path) => {\n          if (path === void 0) {\n            throw new Error(\n              \"Attempted to convert undefined value to binding path\"\n            );\n          }\n          if (typeof path !== \"string\" && typeof path !== \"number\" && typeof path !== \"boolean\") {\n            throw new Error(\n              `Attempting to convert ${typeof path} to a binding path.`\n            );\n          }\n          const normalized2 = this.normalizePath(String(path), normalizeConfig);\n          if (normalized2.updates) {\n            updates = {\n              ...updates,\n              ...normalized2.updates\n            };\n          }\n          const joinedNormalizedPath = normalized2.path.join(\".\");\n          if (joinedNormalizedPath === \"\") {\n            throw new Error(\"Nested path resolved to an empty path\");\n          }\n          return joinedNormalizedPath;\n        }\n      };\n      const normalized = this.normalizePath(joined, normalizeConfig);\n      if (normalized.updates) {\n        updates = {\n          ...updates,\n          ...normalized.updates\n        };\n      }\n      const updateKeys = Object.keys(updates);\n      if (!options.readOnly && updateKeys.length > 0) {\n        const updateTransaction = updateKeys.map(\n          (updatedBinding) => [\n            this.parse(updatedBinding),\n            updates[updatedBinding]\n          ]\n        );\n        options.set(updateTransaction);\n      }\n      return this.getBindingForNormalizedResult(normalized);\n    }\n  };\n  var DependencyTracker = class {\n    constructor() {\n      this.readDeps = /* @__PURE__ */ new Set();\n      this.writeDeps = /* @__PURE__ */ new Set();\n      this.namedDependencySets = {};\n      this.namedSet = \"core\";\n      this.createSubset(\"core\");\n      this.createSubset(\"children\");\n    }\n    createSubset(name, force = false) {\n      if (force || !this.namedDependencySets[name]) {\n        this.namedDependencySets[name] = {\n          readDeps: /* @__PURE__ */ new Set(),\n          writeDeps: /* @__PURE__ */ new Set()\n        };\n      }\n    }\n    /** Grab all of the bindings that this depended on */\n    getDependencies(name) {\n      if (name !== void 0) {\n        return this.namedDependencySets?.[name]?.readDeps ?? /* @__PURE__ */ new Set();\n      }\n      return this.readDeps;\n    }\n    trackSubset(name) {\n      this.createSubset(name);\n      this.namedSet = name;\n    }\n    trackDefault() {\n      this.namedSet = \"core\";\n    }\n    /** Grab all of the bindings this wrote to */\n    getModified(name) {\n      if (name !== void 0) {\n        return this.namedDependencySets?.[name]?.writeDeps ?? /* @__PURE__ */ new Set();\n      }\n      return this.writeDeps;\n    }\n    /**\n     * Check to see if the dataModel has read the value at the given binding\n     *\n     * @param binding - The binding you want to check for\n     */\n    readsBinding(binding) {\n      return this.readDeps.has(binding);\n    }\n    /**\n     * Check to see if the dataModel has written to the binding\n     */\n    writesBinding(binding) {\n      return this.writeDeps.has(binding);\n    }\n    /** Reset all tracking of dependencies */\n    reset() {\n      this.readDeps = /* @__PURE__ */ new Set();\n      this.writeDeps = /* @__PURE__ */ new Set();\n      this.namedDependencySets = {};\n      this.namedSet = \"core\";\n      this.createSubset(\"core\", true);\n      this.createSubset(\"children\", true);\n    }\n    addReadDep(binding, namedSet = this.namedSet) {\n      if (namedSet) {\n        this.namedDependencySets?.[namedSet]?.readDeps.add(binding);\n      }\n      this.readDeps.add(binding);\n    }\n    addWriteDep(binding, namedSet = this.namedSet) {\n      if (namedSet) {\n        this.namedDependencySets?.[namedSet]?.writeDeps.add(binding);\n      }\n      this.writeDeps.add(binding);\n    }\n    addChildReadDep(binding) {\n      this.addReadDep(binding, \"children\");\n    }\n  };\n  var DependencyModel = class extends DependencyTracker {\n    constructor(rootModel) {\n      super();\n      this.rootModel = rootModel;\n      this.set = this.set.bind(this);\n      this.get = this.get.bind(this);\n    }\n    set(transaction, options) {\n      transaction.forEach(([binding]) => this.addWriteDep(binding));\n      return this.rootModel.set(transaction, options);\n    }\n    get(binding, options) {\n      this.addReadDep(binding);\n      return this.rootModel.get(binding, options);\n    }\n    delete(binding, options) {\n      this.addWriteDep(binding);\n      return this.rootModel.delete(binding, options);\n    }\n  };\n  var NOOPDataModel = class {\n    get() {\n      return void 0;\n    }\n    set() {\n      return [];\n    }\n    delete() {\n    }\n  };\n  var NOOP_MODEL = new NOOPDataModel();\n  var ROOT_BINDING = new BindingInstance([]);\n  function withParser(model, parseBinding) {\n    function maybeParse(binding, readOnly) {\n      const parsed = isBinding(binding) ? binding : parseBinding(binding, {\n        get: model.get,\n        set: model.set,\n        readOnly\n      });\n      if (!parsed) {\n        throw new Error(\"Unable to parse binding\");\n      }\n      return parsed;\n    }\n    return {\n      get(binding, options) {\n        return model.get(maybeParse(binding, true), options);\n      },\n      set(transaction, options) {\n        return model.set(\n          transaction.map(([key, val]) => [maybeParse(key, false), val]),\n          options\n        );\n      },\n      delete(binding, options) {\n        return model.delete(maybeParse(binding, false), options);\n      }\n    };\n  }\n  function toModel(middleware, defaultOptions, next) {\n    if (!next) {\n      return middleware;\n    }\n    return {\n      get: (binding, options) => {\n        const resolvedOptions = options ?? defaultOptions;\n        if (middleware.get) {\n          return middleware.get(binding, resolvedOptions, next);\n        }\n        return next?.get(binding, resolvedOptions);\n      },\n      set: (transaction, options) => {\n        const resolvedOptions = options ?? defaultOptions;\n        if (middleware.set) {\n          return middleware.set(transaction, resolvedOptions, next);\n        }\n        return next?.set(transaction, resolvedOptions);\n      },\n      delete: (binding, options) => {\n        const resolvedOptions = options ?? defaultOptions;\n        if (middleware.delete) {\n          return middleware.delete(binding, resolvedOptions, next);\n        }\n        return next?.delete(binding, resolvedOptions);\n      }\n    };\n  }\n  function constructModelForPipeline(pipeline) {\n    if (pipeline.length === 0) {\n      return NOOP_MODEL;\n    }\n    if (pipeline.length === 1) {\n      return toModel(pipeline[0]);\n    }\n    function createModelWithOptions(options) {\n      const model = pipeline.reduce(\n        (nextModel, middleware) => toModel(middleware, options, nextModel),\n        void 0\n      ) ?? NOOP_MODEL;\n      return model;\n    }\n    return {\n      get: (binding, options) => {\n        return createModelWithOptions(options)?.get(binding, options);\n      },\n      set: (transaction, options) => {\n        return createModelWithOptions(options)?.set(transaction, options);\n      },\n      delete: (binding, options) => {\n        return createModelWithOptions(options)?.delete(binding, options);\n      }\n    };\n  }\n  var PipelinedDataModel = class {\n    constructor(pipeline = []) {\n      this.hooks = {\n        onSet: new SyncHook()\n      };\n      this.pipeline = pipeline;\n      this.effectiveDataModel = constructModelForPipeline(this.pipeline);\n    }\n    setMiddleware(handlers) {\n      this.pipeline = handlers;\n      this.effectiveDataModel = constructModelForPipeline(handlers);\n    }\n    addMiddleware(handler) {\n      this.pipeline = [...this.pipeline, handler];\n      this.effectiveDataModel = constructModelForPipeline(this.pipeline);\n    }\n    reset(model = {}) {\n      this.pipeline.forEach((middleware) => {\n        if (\"reset\" in middleware) {\n          middleware.reset?.();\n        }\n      });\n      this.set([[ROOT_BINDING, model]]);\n    }\n    set(transaction, options) {\n      const appliedTransaction = this.effectiveDataModel.set(\n        transaction,\n        options\n      );\n      this.hooks.onSet.call(transaction);\n      return appliedTransaction;\n    }\n    get(binding, options) {\n      return this.effectiveDataModel.get(binding, options);\n    }\n    delete(binding, options) {\n      return this.effectiveDataModel.delete(binding, options);\n    }\n  };\n  var LocalModel = class {\n    constructor(model = {}) {\n      this.model = model;\n      this.get = this.get.bind(this);\n      this.set = this.set.bind(this);\n    }\n    reset(model = {}) {\n      this.model = model;\n    }\n    get(binding) {\n      if (!binding || !binding.asString()) {\n        return this.model;\n      }\n      return dlv_es_default(this.model, binding.asArray());\n    }\n    set(transaction) {\n      const effectiveOperations = [];\n      transaction.forEach(([binding, value]) => {\n        const oldValue = this.get(binding);\n        this.model = (0, import_timm.setIn)(this.model, binding.asArray(), value);\n        effectiveOperations.push({ binding, oldValue, newValue: value });\n      });\n      return effectiveOperations;\n    }\n    delete(binding) {\n      const parentBinding = binding.parent();\n      if (parentBinding) {\n        const parentValue = this.get(parentBinding);\n        if (parentValue !== void 0) {\n          if (Array.isArray(parentValue)) {\n            this.model = (0, import_timm.setIn)(\n              this.model,\n              parentBinding.asArray(),\n              (0, import_timm.removeAt)(parentValue, binding.key())\n            );\n          } else {\n            this.model = (0, import_timm.setIn)(\n              this.model,\n              parentBinding.asArray(),\n              (0, import_timm.omit)(parentValue, binding.key())\n            );\n          }\n        }\n      }\n    }\n  };\n  var ExpNodeOpaqueIdentifier = Symbol(\"Expression Node ID\");\n  function isExpressionNode(x) {\n    return typeof x === \"object\" && x !== null && !Array.isArray(x) && x.__id === ExpNodeOpaqueIdentifier;\n  }\n  var PERIOD_CODE = 46;\n  var COMMA_CODE = 44;\n  var SQUOTE_CODE = 39;\n  var DQUOTE_CODE = 34;\n  var OPAREN_CODE = 40;\n  var CPAREN_CODE = 41;\n  var OBRACK_CODE = 91;\n  var CBRACK_CODE = 93;\n  var QUMARK_CODE = 63;\n  var SEMCOL_CODE = 59;\n  var COLON_CODE = 58;\n  var OCURL_CODE = 123;\n  var CCURL_CODE = 125;\n  var t = true;\n  var unaryOps = { \"-\": t, \"!\": t, \"~\": t, \"+\": t };\n  var binaryOps = {\n    \"=\": 3,\n    \"+=\": 3,\n    \"-=\": 3,\n    \"&=\": 3,\n    \"|=\": 3,\n    // Conditional: 4,\n    \"||\": 5,\n    \"&&\": 6,\n    \"|\": 7,\n    \"^\": 8,\n    \"&\": 9,\n    \"==\": 10,\n    \"!=\": 10,\n    \"===\": 10,\n    \"!==\": 10,\n    \"<\": 11,\n    \">\": 11,\n    \"<=\": 11,\n    \">=\": 11,\n    \"<<\": 12,\n    \">>\": 12,\n    \">>>\": 12,\n    \"+\": 13,\n    \"-\": 13,\n    \"*\": 14,\n    \"/\": 14,\n    \"%\": 14\n  };\n  function throwError(message, index) {\n    const err = new Error(`${message} at character ${index}`);\n    err.index = index;\n    err.description = message;\n    throw err;\n  }\n  function createSpanningLocation(start, end) {\n    if (!start || !end) {\n      return;\n    }\n    return {\n      start: start.start,\n      end: end.end\n    };\n  }\n  function getMaxKeyLen(obj) {\n    let maxLen = 0;\n    Object.keys(obj).forEach((key) => {\n      if (key.length > maxLen && Object.prototype.hasOwnProperty.call(obj, key)) {\n        maxLen = key.length;\n      }\n    });\n    return maxLen;\n  }\n  var maxUnopLen = getMaxKeyLen(unaryOps);\n  var maxBinopLen = getMaxKeyLen(binaryOps);\n  var literals = {\n    true: true,\n    false: false,\n    null: null,\n    undefined: void 0\n  };\n  var thisStr = \"this\";\n  function binaryPrecedence(opVal) {\n    return binaryOps[opVal] || 0;\n  }\n  function createBinaryExpression(operator, left, right, location) {\n    let type;\n    if (operator === \"||\" || operator === \"&&\") {\n      type = \"LogicalExpression\";\n    } else if (operator === \"=\") {\n      type = \"Assignment\";\n    } else if (operator === \"+=\" || operator === \"-=\" || operator === \"&=\" || operator === \"|=\") {\n      type = \"Modification\";\n    } else {\n      type = \"BinaryExpression\";\n    }\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type,\n      operator,\n      left,\n      right,\n      location\n    };\n  }\n  function isDecimalDigit(ch) {\n    return ch >= 48 && ch <= 57;\n  }\n  function isIdentifierStart(ch) {\n    return ch === 36 || ch === 95 || // `$` and `_`\n    ch >= 65 && ch <= 90 || // A...Z\n    ch >= 97 && ch <= 122;\n  }\n  function isIdentifierPart(ch) {\n    return ch === 36 || ch === 95 || // `$` and `_`\n    ch >= 65 && ch <= 90 || // A...Z\n    ch >= 97 && ch <= 122 || // A...z\n    ch >= 48 && ch <= 57;\n  }\n  function isModelRefStart(ch0, ch1) {\n    return ch0 === OCURL_CODE && ch1 === OCURL_CODE;\n  }\n  function parseExpression(expr, options) {\n    const strictMode = options?.strict ?? true;\n    const charAtFunc = expr.charAt;\n    const charCodeAtFunc = expr.charCodeAt;\n    const { length } = expr;\n    let index = 0;\n    const getLocation = (startChar) => {\n      return {\n        start: {\n          character: startChar\n        },\n        end: {\n          character: index\n        }\n      };\n    };\n    function exprI(i) {\n      return charAtFunc.call(expr, i);\n    }\n    function exprICode(i) {\n      return charCodeAtFunc.call(expr, i);\n    }\n    function gobbleObjects() {\n      const attributes = [];\n      let closed = false;\n      let shouldDefineKey = true;\n      let key;\n      let value;\n      let chCode;\n      const startCharIndex = index;\n      ++index;\n      while (index < length) {\n        gobbleSpaces();\n        chCode = exprICode(index);\n        if (chCode === CCURL_CODE) {\n          if (key) {\n            throwError(\"A key was defined but a value was not\", index);\n          }\n          index++;\n          closed = true;\n          break;\n        } else if (shouldDefineKey) {\n          if (chCode !== SQUOTE_CODE && chCode !== DQUOTE_CODE) {\n            throwError(\"An object must start wtih a key\", index);\n          }\n          key = gobbleStringLiteral();\n          gobbleSpaces();\n          if (exprICode(index) === COLON_CODE) {\n            index++;\n            shouldDefineKey = false;\n          } else {\n            throwError(\"A colon must follow an object key\", index);\n          }\n        } else {\n          value = gobbleExpression();\n          attributes.push({ key, value });\n          gobbleSpaces();\n          chCode = exprICode(index);\n          if (chCode === COMMA_CODE) {\n            index++;\n          } else if (chCode !== CCURL_CODE) {\n            throwError(\"Please add a comma to add another key\", index);\n          }\n          shouldDefineKey = true;\n          key = void 0;\n          value = void 0;\n        }\n        chCode = exprICode(index);\n      }\n      if (!closed) {\n        throwError(`Unclosed brace in object`, index);\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Object\",\n        attributes,\n        location: getLocation(startCharIndex)\n      };\n    }\n    function gobbleSpaces() {\n      let ch = exprICode(index);\n      while (ch === 32 || ch === 9) {\n        ch = exprICode(++index);\n      }\n    }\n    function gobbleExpression() {\n      const test = gobbleBinaryExpression();\n      gobbleSpaces();\n      const startCharIndex = index;\n      if (index < length && exprICode(index) === QUMARK_CODE) {\n        index++;\n        const consequent = gobbleExpression();\n        if (!consequent) {\n          throwError(\"Expected expression\", index);\n        }\n        gobbleSpaces();\n        if (exprICode(index) === COLON_CODE) {\n          index++;\n          const alternate = gobbleExpression();\n          if (!alternate) {\n            throwError(\"Expected expression\", index);\n          }\n          return {\n            __id: ExpNodeOpaqueIdentifier,\n            type: \"ConditionalExpression\",\n            test,\n            consequent,\n            alternate,\n            location: getLocation(startCharIndex)\n          };\n        }\n        throwError(\"Expected :\", index);\n      }\n      return test;\n    }\n    function gobbleBinaryOp() {\n      gobbleSpaces();\n      let toCheck = expr.substr(index, maxBinopLen);\n      let tcLen = toCheck.length;\n      while (tcLen > 0) {\n        if (Object.prototype.hasOwnProperty.call(binaryOps, toCheck)) {\n          index += tcLen;\n          return toCheck;\n        }\n        toCheck = toCheck.substr(0, --tcLen);\n      }\n      return false;\n    }\n    function gobbleBinaryExpression() {\n      let node;\n      let prec;\n      let i;\n      let left = gobbleToken();\n      let biop = gobbleBinaryOp();\n      if (!biop) {\n        return left;\n      }\n      let biopInfo = { value: biop, prec: binaryPrecedence(biop) };\n      let right = gobbleToken();\n      if (!right) {\n        throwError(`Expected expression after ${biop}`, index);\n      }\n      const stack = [left, biopInfo, right];\n      biop = gobbleBinaryOp();\n      while (biop) {\n        prec = binaryPrecedence(biop);\n        if (prec === 0) {\n          break;\n        }\n        biopInfo = { value: biop, prec };\n        while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n          right = stack.pop();\n          biop = stack.pop().value;\n          left = stack.pop();\n          node = createBinaryExpression(\n            biop,\n            left,\n            right,\n            createSpanningLocation(left.location, right.location)\n          );\n          stack.push(node);\n        }\n        node = gobbleToken();\n        if (!node) {\n          throwError(`Expected expression after ${biop}`, index);\n        }\n        stack.push(biopInfo, node);\n        biop = gobbleBinaryOp();\n      }\n      i = stack.length - 1;\n      node = stack[i];\n      while (i > 1) {\n        node = createBinaryExpression(\n          stack[i - 1].value,\n          stack[i - 2],\n          node,\n          createSpanningLocation(stack[i - 2].location, node.location)\n        );\n        i -= 2;\n      }\n      return node;\n    }\n    function gobbleToken() {\n      gobbleSpaces();\n      const ch = exprICode(index);\n      const startCharIndex = index;\n      if (isDecimalDigit(ch) || ch === PERIOD_CODE) {\n        return gobbleNumericLiteral();\n      }\n      if (ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\n        return gobbleStringLiteral();\n      }\n      if (isIdentifierStart(ch) || ch === OPAREN_CODE) {\n        return gobbleVariable();\n      }\n      if (ch === OBRACK_CODE) {\n        return gobbleArray();\n      }\n      if (isModelRefStart(ch, exprICode(index + 1))) {\n        return gobbleModelRef();\n      }\n      if (ch === OCURL_CODE) {\n        return gobbleObjects();\n      }\n      let toCheck = expr.substr(index, maxUnopLen);\n      let tcLen = toCheck.length;\n      while (tcLen > 0) {\n        if (Object.prototype.hasOwnProperty.call(unaryOps, toCheck)) {\n          index += tcLen;\n          return {\n            __id: ExpNodeOpaqueIdentifier,\n            type: \"UnaryExpression\",\n            operator: toCheck,\n            argument: gobbleToken(),\n            prefix: true,\n            location: getLocation(startCharIndex)\n          };\n        }\n        toCheck = toCheck.substr(0, --tcLen);\n      }\n      return false;\n    }\n    function gobbleNumericLiteral() {\n      let num = \"\";\n      const startCharIndex = index;\n      while (isDecimalDigit(exprICode(index))) {\n        num += exprI(index++);\n      }\n      if (exprICode(index) === PERIOD_CODE) {\n        num += exprI(index++);\n        while (isDecimalDigit(exprICode(index))) {\n          num += exprI(index++);\n        }\n      }\n      let ch = exprI(index);\n      if (ch === \"e\" || ch === \"E\") {\n        num += exprI(index++);\n        ch = exprI(index);\n        if (ch === \"+\" || ch === \"-\") {\n          num += exprI(index++);\n        }\n        while (isDecimalDigit(exprICode(index))) {\n          num += exprI(index++);\n        }\n        if (!isDecimalDigit(exprICode(index - 1))) {\n          throwError(`Expected exponent (${num}${exprI(index)})`, index);\n        }\n      }\n      const chCode = exprICode(index);\n      if (isIdentifierStart(chCode)) {\n        throwError(\n          `Variable names cannot start with a number (${num}${exprI(index)})`,\n          index\n        );\n      } else if (chCode === PERIOD_CODE) {\n        throwError(\"Unexpected period\", index);\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Literal\",\n        value: parseFloat(num),\n        raw: num,\n        location: getLocation(startCharIndex)\n      };\n    }\n    function gobbleStringLiteral() {\n      const quote = exprI(index++);\n      let str = \"\";\n      let closed = false;\n      const startCharIndex = index;\n      while (index < length) {\n        let ch = exprI(index++);\n        if (ch === quote) {\n          closed = true;\n          break;\n        }\n        if (ch !== \"\\\\\") {\n          str += ch;\n          continue;\n        }\n        ch = exprI(index++);\n        switch (ch) {\n          case \"n\":\n            str += \"\\n\";\n            break;\n          case \"r\":\n            str += \"\\r\";\n            break;\n          case \"t\":\n            str += \"\t\";\n            break;\n          case \"b\":\n            str += \"\\b\";\n            break;\n          case \"f\":\n            str += \"\\f\";\n            break;\n          case \"v\":\n            str += \"\\v\";\n            break;\n          default:\n        }\n      }\n      if (!closed) {\n        throwError(`Unclosed quote after \"${str}\"`, index);\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Literal\",\n        value: str,\n        raw: `${quote}${str}${quote}`,\n        location: getLocation(startCharIndex)\n      };\n    }\n    function gobbleModelRef() {\n      let str = \"\";\n      let closed = false;\n      let openBraceCount = 1;\n      const startCharIndex = index;\n      index += 2;\n      while (index < length) {\n        const ch = exprI(index++);\n        if (ch === \"}\" && exprICode(index) === CCURL_CODE) {\n          index++;\n          openBraceCount--;\n          if (openBraceCount === 0) {\n            closed = true;\n            break;\n          }\n          str += \"}}\";\n        } else if (ch === \"{\" && exprICode(index) === OCURL_CODE) {\n          openBraceCount++;\n          str += \"{{\";\n          index++;\n        } else {\n          str += ch;\n        }\n      }\n      if (!closed) {\n        throwError(`Unclosed brace after \"${str}\"`, index);\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"ModelRef\",\n        ref: str,\n        location: getLocation(startCharIndex)\n      };\n    }\n    function gobbleIdentifier() {\n      const start = index;\n      let ch = exprICode(start);\n      if (isIdentifierStart(ch)) {\n        index++;\n      } else {\n        throwError(`Unexpected ${exprI(index)}`, index);\n      }\n      while (index < length) {\n        ch = exprICode(index);\n        if (isIdentifierPart(ch)) {\n          index++;\n        } else {\n          break;\n        }\n      }\n      const identifier = expr.slice(start, index);\n      if (Object.prototype.hasOwnProperty.call(literals, identifier)) {\n        return {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"Literal\",\n          value: literals[identifier],\n          raw: identifier,\n          location: getLocation(start)\n        };\n      }\n      if (identifier === thisStr) {\n        return {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"ThisExpression\",\n          location: getLocation(start)\n        };\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Identifier\",\n        name: identifier,\n        location: getLocation(start)\n      };\n    }\n    function gobbleArguments(termination) {\n      const args = [];\n      let charIndex;\n      let node;\n      while (index < length) {\n        gobbleSpaces();\n        charIndex = exprICode(index);\n        if (charIndex === termination) {\n          index++;\n          break;\n        }\n        if (charIndex === COMMA_CODE) {\n          index++;\n          continue;\n        }\n        node = gobbleExpression();\n        if (!node || node.type === \"Compound\") {\n          throwError(\"Expected comma\", index);\n        }\n        args.push(node);\n      }\n      if (strictMode && charIndex !== termination) {\n        throwError(`Expected ${String.fromCharCode(termination)}`, index);\n      }\n      return args;\n    }\n    function gobbleVariable() {\n      let charIndex = exprICode(index);\n      let node = charIndex === OPAREN_CODE ? gobbleGroup() : gobbleIdentifier();\n      const startCharIndex = index;\n      gobbleSpaces();\n      charIndex = exprICode(index);\n      while (charIndex === PERIOD_CODE || charIndex === OBRACK_CODE || charIndex === OPAREN_CODE) {\n        index++;\n        if (charIndex === PERIOD_CODE) {\n          gobbleSpaces();\n          node = {\n            __id: ExpNodeOpaqueIdentifier,\n            type: \"MemberExpression\",\n            computed: false,\n            object: node,\n            property: gobbleIdentifier(),\n            location: getLocation(startCharIndex)\n          };\n        } else if (charIndex === OBRACK_CODE) {\n          node = {\n            __id: ExpNodeOpaqueIdentifier,\n            type: \"MemberExpression\",\n            computed: true,\n            object: node,\n            property: gobbleExpression(),\n            location: getLocation(startCharIndex)\n          };\n          gobbleSpaces();\n          charIndex = exprICode(index);\n          if (charIndex !== CBRACK_CODE) {\n            throwError(\"Unclosed [\", index);\n          }\n          index++;\n        } else if (charIndex === OPAREN_CODE) {\n          node = {\n            __id: ExpNodeOpaqueIdentifier,\n            type: \"CallExpression\",\n            args: gobbleArguments(CPAREN_CODE),\n            callTarget: node,\n            location: getLocation(startCharIndex)\n          };\n        }\n        gobbleSpaces();\n        charIndex = exprICode(index);\n      }\n      return node;\n    }\n    function gobbleGroup() {\n      index++;\n      const node = gobbleExpression();\n      gobbleSpaces();\n      if (exprICode(index) === CPAREN_CODE) {\n        index++;\n        return node;\n      }\n      throwError(\"Unclosed (\", index);\n    }\n    function gobbleArray() {\n      const startCharIndex = index;\n      index++;\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"ArrayExpression\",\n        elements: gobbleArguments(CBRACK_CODE),\n        location: getLocation(startCharIndex)\n      };\n    }\n    const nodes = [];\n    try {\n      while (index < length) {\n        const chIndex = exprICode(index);\n        if (chIndex === SEMCOL_CODE || chIndex === COMMA_CODE) {\n          index++;\n          continue;\n        }\n        const node = gobbleExpression();\n        if (node) {\n          nodes.push(node);\n        } else if (strictMode && index < length) {\n          throwError(`Unexpected \"${exprI(index)}\"`, index);\n        }\n      }\n      if (nodes.length === 1) {\n        return nodes[0];\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Compound\",\n        body: nodes,\n        location: getLocation(0)\n      };\n    } catch (e) {\n      if (strictMode || !(e instanceof Error)) {\n        throw e;\n      }\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Compound\",\n        body: nodes,\n        location: getLocation(0),\n        error: e\n      };\n    }\n  }\n  var evaluator_functions_exports = {};\n  __export2(evaluator_functions_exports, {\n    conditional: () => conditional,\n    deleteDataVal: () => deleteDataVal,\n    getDataVal: () => getDataVal,\n    setDataVal: () => setDataVal\n  });\n  var setDataVal = (_context, binding, value) => {\n    _context.model.set([[binding, value]]);\n  };\n  var getDataVal = (_context, binding) => {\n    return _context.model.get(binding);\n  };\n  var deleteDataVal = (_context, binding) => {\n    return _context.model.delete(binding);\n  };\n  var conditional = (ctx, condition, ifTrue, ifFalse) => {\n    const resolution = ctx.evaluate(condition);\n    if (resolution) {\n      return ctx.evaluate(ifTrue);\n    }\n    if (ifFalse) {\n      return ctx.evaluate(ifFalse);\n    }\n    return null;\n  };\n  conditional.resolveParams = false;\n  function isObjectExpression(expr) {\n    if (isExpressionNode(expr)) {\n      return false;\n    }\n    return typeof expr === \"object\" && expr !== null && !Array.isArray(expr) && \"value\" in expr;\n  }\n  var andandOperator = (ctx, a, b) => {\n    return ctx.evaluate(a) && ctx.evaluate(b);\n  };\n  andandOperator.resolveParams = false;\n  var ororOperator = (ctx, a, b) => {\n    return ctx.evaluate(a) || ctx.evaluate(b);\n  };\n  ororOperator.resolveParams = false;\n  var DEFAULT_BINARY_OPERATORS = {\n    // TODO: A lot of these functions used to do type coercion. Not sure if we want to keep that behavior or not.\n    \"+\": (a, b) => a + b,\n    \"-\": (a, b) => a - b,\n    \"*\": (a, b) => a * b,\n    \"/\": (a, b) => a / b,\n    \"%\": (a, b) => a % b,\n    // eslint-disable-next-line\n    \"==\": (a, b) => a == b,\n    // eslint-disable-next-line\n    \"!=\": (a, b) => a != b,\n    \">\": (a, b) => a > b,\n    \">=\": (a, b) => a >= b,\n    \"<\": (a, b) => a < b,\n    \"<=\": (a, b) => a <= b,\n    \"&&\": andandOperator,\n    \"||\": ororOperator,\n    \"!==\": (a, b) => a !== b,\n    \"===\": (a, b) => a === b,\n    // eslint-disable-next-line\n    \"|\": (a, b) => a | b,\n    // eslint-disable-next-line\n    \"&\": (a, b) => a & b,\n    \"+=\": (a, b) => a + b,\n    \"-=\": (a, b) => a - b,\n    // eslint-disable-next-line\n    \"&=\": (a, b) => a & b,\n    // eslint-disable-next-line\n    \"|=\": (a, b) => a | b\n  };\n  var DEFAULT_UNARY_OPERATORS = {\n    \"-\": (a) => -a,\n    \"+\": (a) => Number(a),\n    \"!\": (a) => !a\n  };\n  var ExpressionEvaluator = class {\n    constructor(defaultOptions) {\n      this.vars = {};\n      this.hooks = {\n        /** Resolve an AST node for an expression to a value */\n        resolve: new SyncWaterfallHook(),\n        /** Gets the options that will be passed in calls to the resolve hook */\n        resolveOptions: new SyncWaterfallHook(),\n        /** Allows users to change the expression to be evaluated before processing */\n        beforeEvaluate: new SyncWaterfallHook(),\n        /**\n         * An optional means of handling an error in the expression execution\n         * Return true if handled, to stop propagation of the error\n         */\n        onError: new SyncBailHook()\n      };\n      this.expressionsCache = /* @__PURE__ */ new Map();\n      this.operators = {\n        binary: new Map(Object.entries(DEFAULT_BINARY_OPERATORS)),\n        unary: new Map(Object.entries(DEFAULT_UNARY_OPERATORS)),\n        expressions: new Map(\n          Object.entries(evaluator_functions_exports)\n        )\n      };\n      this.defaultHookOptions = {\n        ...defaultOptions,\n        evaluate: (expr) => this.evaluate(expr, this.defaultHookOptions),\n        resolveNode: (node) => this._execAST(node, this.defaultHookOptions)\n      };\n      this.hooks.resolve.tap(\"ExpressionEvaluator\", this._resolveNode.bind(this));\n      this.evaluate = this.evaluate.bind(this);\n    }\n    reset() {\n      this.expressionsCache.clear();\n    }\n    evaluate(expr, options) {\n      const resolvedOpts = this.hooks.resolveOptions.call({\n        ...this.defaultHookOptions,\n        ...options,\n        resolveNode: (node) => this._execAST(node, resolvedOpts)\n      });\n      let expression = this.hooks.beforeEvaluate.call(expr, resolvedOpts) ?? expr;\n      while (isObjectExpression(expression)) {\n        expression = expression.value;\n      }\n      if (typeof expression === \"number\" || typeof expression === \"boolean\" || expression === void 0 || expression === null) {\n        return expression;\n      }\n      if (isExpressionNode(expression)) {\n        return this._execAST(expression, resolvedOpts);\n      }\n      if (Array.isArray(expression)) {\n        return expression.reduce(\n          (_nothing, exp) => this.evaluate(exp, options),\n          null\n        );\n      }\n      return this._execString(String(expression), resolvedOpts);\n    }\n    addExpressionFunction(name, handler) {\n      this.operators.expressions.set(name, handler);\n    }\n    addBinaryOperator(operator, handler) {\n      this.operators.binary.set(operator, handler);\n    }\n    addUnaryOperator(operator, handler) {\n      this.operators.unary.set(operator, handler);\n    }\n    setExpressionVariable(name, value) {\n      this.vars[name] = value;\n    }\n    getExpressionVariable(name) {\n      return this.vars[name];\n    }\n    _execAST(node, options) {\n      return this.hooks.resolve.call(void 0, node, options);\n    }\n    _execString(exp, options) {\n      if (exp === \"\") {\n        return exp;\n      }\n      const matches = exp.match(/^@\\[(.*)\\]@$/);\n      let matchedExp = exp;\n      if (matches) {\n        [, matchedExp] = Array.from(matches);\n      }\n      let storedAST;\n      try {\n        storedAST = this.expressionsCache.get(matchedExp) ?? parseExpression(matchedExp, { strict: options.strict });\n        this.expressionsCache.set(matchedExp, storedAST);\n      } catch (e) {\n        if (options.throwErrors || !this.hooks.onError.call(e)) {\n          throw new import_ts_nested_error3.NestedError(`Error parsing expression: ${exp}`, e);\n        }\n        return;\n      }\n      try {\n        return this._execAST(storedAST, options);\n      } catch (e) {\n        if (options.throwErrors || !this.hooks.onError.call(e)) {\n          throw new import_ts_nested_error3.NestedError(`Error evaluating expression: ${exp}`, e);\n        }\n      }\n    }\n    _resolveNode(_currentValue, node, options) {\n      const { resolveNode, model } = options;\n      const expressionContext = {\n        ...options,\n        evaluate: (expr) => this.evaluate(expr, options)\n      };\n      if (node.type === \"Literal\") {\n        return node.value;\n      }\n      if (node.type === \"Identifier\") {\n        return this.vars[node.name];\n      }\n      if (node.type === \"Compound\" || node.type === \"ThisExpression\") {\n        throw new Error(`Expression type: ${node.type} is not supported`);\n      }\n      if (node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\") {\n        const operator = this.operators.binary.get(node.operator);\n        if (operator) {\n          if (\"resolveParams\" in operator) {\n            if (operator.resolveParams === false) {\n              return operator(expressionContext, node.left, node.right);\n            }\n            return operator(\n              expressionContext,\n              resolveNode(node.left),\n              resolveNode(node.right)\n            );\n          }\n          return operator(resolveNode(node.left), resolveNode(node.right));\n        }\n        return;\n      }\n      if (node.type === \"UnaryExpression\") {\n        const operator = this.operators.unary.get(node.operator);\n        if (operator) {\n          if (\"resolveParams\" in operator) {\n            return operator(\n              expressionContext,\n              operator.resolveParams === false ? node.argument : resolveNode(node.argument)\n            );\n          }\n          return operator(resolveNode(node.argument));\n        }\n        return;\n      }\n      if (node.type === \"Object\") {\n        const { attributes } = node;\n        const resolvedAttributes = {};\n        attributes.forEach((attr) => {\n          const key = resolveNode(attr.key);\n          const value = resolveNode(attr.value);\n          resolvedAttributes[key] = value;\n        });\n        return resolvedAttributes;\n      }\n      if (node.type === \"CallExpression\") {\n        const expressionName = node.callTarget.name;\n        const operator = this.operators.expressions.get(expressionName);\n        if (!operator) {\n          throw new Error(`Unknown expression function: ${expressionName}`);\n        }\n        if (\"resolveParams\" in operator && operator.resolveParams === false) {\n          return operator(expressionContext, ...node.args);\n        }\n        const args = node.args.map((n) => resolveNode(n));\n        return operator(expressionContext, ...args);\n      }\n      if (node.type === \"ModelRef\") {\n        return model.get(node.ref, { context: { model: options.model } });\n      }\n      if (node.type === \"MemberExpression\") {\n        const obj = resolveNode(node.object);\n        const prop = resolveNode(node.property);\n        return obj[prop];\n      }\n      if (node.type === \"Assignment\") {\n        if (node.left.type === \"ModelRef\") {\n          const value = resolveNode(node.right);\n          model.set([[node.left.ref, value]]);\n          return value;\n        }\n        if (node.left.type === \"Identifier\") {\n          const value = resolveNode(node.right);\n          this.vars[node.left.name] = value;\n          return value;\n        }\n        return;\n      }\n      if (node.type === \"ConditionalExpression\") {\n        const result = resolveNode(node.test) ? node.consequent : node.alternate;\n        return resolveNode(result);\n      }\n      if (node.type === \"ArrayExpression\") {\n        return node.elements.map((ele) => resolveNode(ele));\n      }\n      if (node.type === \"Modification\") {\n        const operation = this.operators.binary.get(node.operator);\n        if (operation) {\n          let newValue;\n          if (\"resolveParams\" in operation) {\n            if (operation.resolveParams === false) {\n              newValue = operation(expressionContext, node.left, node.right);\n            } else {\n              newValue = operation(\n                expressionContext,\n                resolveNode(node.left),\n                resolveNode(node.right)\n              );\n            }\n          } else {\n            newValue = operation(resolveNode(node.left), resolveNode(node.right));\n          }\n          if (node.left.type === \"ModelRef\") {\n            model.set([[node.left.ref, newValue]]);\n          } else if (node.left.type === \"Identifier\") {\n            this.vars[node.left.name] = newValue;\n          }\n          return newValue;\n        }\n        return resolveNode(node.left);\n      }\n    }\n  };\n  var TapableLogger = class {\n    constructor() {\n      this.hooks = {\n        trace: new SyncHook(),\n        debug: new SyncHook(),\n        info: new SyncHook(),\n        warn: new SyncHook(),\n        error: new SyncHook(),\n        log: new SyncHook()\n      };\n      this.logHandlers = /* @__PURE__ */ new Set();\n      this.trace = this.createHandler(\"trace\");\n      this.debug = this.createHandler(\"debug\");\n      this.info = this.createHandler(\"info\");\n      this.warn = this.createHandler(\"warn\");\n      this.error = this.createHandler(\"error\");\n    }\n    createHandler(severity) {\n      return (...args) => {\n        this.hooks[severity].call(args);\n        this.hooks.log.call(severity, args);\n        this.logHandlers.forEach((logger) => logger[severity](...args));\n      };\n    }\n    addHandler(logHandler) {\n      this.logHandlers.add(logHandler);\n    }\n    removeHandler(logHandler) {\n      this.logHandlers.delete(logHandler);\n    }\n  };\n  var ProxyLogger = class {\n    constructor(loggerProvider) {\n      this.trace = this.createHandler(\"trace\");\n      this.debug = this.createHandler(\"debug\");\n      this.info = this.createHandler(\"info\");\n      this.warn = this.createHandler(\"warn\");\n      this.error = this.createHandler(\"error\");\n      this.proxiedLoggerProvider = loggerProvider;\n    }\n    createHandler(severity) {\n      return (...args) => {\n        const logger = this.proxiedLoggerProvider();\n        logger?.[severity](...args);\n      };\n    }\n  };\n  var identify = (val) => val;\n  function parse2(schema) {\n    const expandedPaths = /* @__PURE__ */ new Map();\n    if (!schema.ROOT) {\n      return expandedPaths;\n    }\n    const parseQueue = [{ node: schema.ROOT, path: [], visited: /* @__PURE__ */ new Set() }];\n    while (parseQueue.length > 0) {\n      const next = parseQueue.shift();\n      if (!next) {\n        break;\n      }\n      const { node, path, visited } = next;\n      Object.entries(node).forEach(([prop, type]) => {\n        const nestedPath = [...path, prop];\n        const nestedPathStr = nestedPath.join(\".\");\n        if (expandedPaths.has(nestedPathStr)) {\n          throw new Error(\n            \"Path has already been processed. There's either a loop somewhere or a bug\"\n          );\n        }\n        if (visited.has(type.type)) {\n          throw new Error(\n            `Path already contained type: ${type.type}. This likely indicates a loop in the schema`\n          );\n        }\n        expandedPaths.set(nestedPathStr, type);\n        if (type.isArray) {\n          nestedPath.push(\"[]\");\n        }\n        if (type.isRecord) {\n          nestedPath.push(\"{}\");\n        }\n        if (type.type && schema[type.type]) {\n          parseQueue.push({\n            path: nestedPath,\n            node: schema[type.type],\n            visited: /* @__PURE__ */ new Set([...visited, type.type])\n          });\n        }\n      });\n    }\n    return expandedPaths;\n  }\n  var SchemaController = class {\n    constructor(schema) {\n      this.formatters = /* @__PURE__ */ new Map();\n      this.types = /* @__PURE__ */ new Map();\n      this.schema = /* @__PURE__ */ new Map();\n      this.bindingSchemaNormalizedCache = /* @__PURE__ */ new Map();\n      this.hooks = {\n        resolveTypeForBinding: new SyncWaterfallHook()\n      };\n      this.schema = schema ? parse2(schema) : /* @__PURE__ */ new Map();\n    }\n    addFormatters(fns) {\n      fns.forEach((def) => {\n        this.formatters.set(def.name, def);\n      });\n    }\n    addDataTypes(types) {\n      types.forEach((t2) => {\n        this.types.set(t2.type, t2);\n      });\n    }\n    getValidationsForBinding(binding) {\n      const typeDef = this.getApparentType(binding);\n      if (!typeDef?.validation?.length) {\n        return void 0;\n      }\n      return typeDef.validation.map((vRef) => ({\n        severity: \"error\",\n        trigger: \"change\",\n        ...vRef\n      }));\n    }\n    normalizeBinding(binding) {\n      const cached = this.bindingSchemaNormalizedCache.get(binding);\n      if (cached) {\n        return cached;\n      }\n      let bindingArray = binding.asArray();\n      let normalized = bindingArray.map((p) => typeof p === \"number\" ? \"[]\" : p).join(\".\");\n      if (normalized) {\n        this.bindingSchemaNormalizedCache.set(binding, normalized);\n        bindingArray = normalized.split(\".\");\n      }\n      bindingArray.forEach((item) => {\n        const recordBinding = bindingArray.map((p) => p === item ? \"{}\" : p).join(\".\");\n        if (this.schema.get(recordBinding)) {\n          this.bindingSchemaNormalizedCache.set(binding, recordBinding);\n          bindingArray = recordBinding.split(\".\");\n          normalized = recordBinding;\n        }\n      });\n      return normalized;\n    }\n    getType(binding) {\n      return this.hooks.resolveTypeForBinding.call(\n        this.schema.get(this.normalizeBinding(binding)),\n        binding\n      );\n    }\n    getApparentType(binding) {\n      const schemaType = this.getType(binding);\n      if (schemaType === void 0) {\n        return void 0;\n      }\n      const baseType = this.getTypeDefinition(schemaType?.type);\n      if (baseType === void 0) {\n        return schemaType;\n      }\n      return {\n        ...baseType,\n        ...schemaType,\n        validation: [\n          ...schemaType.validation ?? [],\n          ...baseType.validation ?? []\n        ]\n      };\n    }\n    getTypeDefinition(dataType) {\n      return this.types.get(dataType);\n    }\n    getFormatterForType(formatReference) {\n      const { type: formatType, ...options } = formatReference;\n      const formatter = this.formatters.get(formatType);\n      if (!formatter) {\n        return;\n      }\n      return {\n        format: formatter.format ? (val) => formatter.format?.(val, options) : identify,\n        deformat: formatter.deformat ? (val) => formatter.deformat?.(val, options) : identify\n      };\n    }\n    /**\n     * Given a binding, fetch a function that's responsible for formatting, and/or de-formatting the data\n     * If no formatter is registered, it will return undefined\n     */\n    getFormatter(binding) {\n      const type = this.getApparentType(binding);\n      if (!type?.format) {\n        return void 0;\n      }\n      return this.getFormatterForType(type.format);\n    }\n  };\n  var DOUBLE_OPEN_CURLY = \"{{\";\n  var DOUBLE_CLOSE_CURLY = \"}}\";\n  function findNextExp(str) {\n    const expStart = str.indexOf(DOUBLE_OPEN_CURLY);\n    if (expStart === -1) {\n      return void 0;\n    }\n    let count = 1;\n    let offset = expStart + DOUBLE_OPEN_CURLY.length;\n    let workingString = str.substring(expStart + DOUBLE_OPEN_CURLY.length);\n    while (count > 0 && workingString.length > 0) {\n      const nextCloseCurly = workingString.indexOf(DOUBLE_CLOSE_CURLY);\n      if (nextCloseCurly === -1) {\n        break;\n      }\n      const nextOpenCurly = workingString.indexOf(DOUBLE_OPEN_CURLY);\n      if (nextOpenCurly !== -1 && nextOpenCurly < nextCloseCurly) {\n        count++;\n        workingString = workingString.substring(\n          nextOpenCurly + DOUBLE_OPEN_CURLY.length\n        );\n        offset += nextOpenCurly + DOUBLE_OPEN_CURLY.length;\n      } else {\n        count--;\n        workingString = workingString.substring(\n          nextCloseCurly + DOUBLE_CLOSE_CURLY.length\n        );\n        offset += nextCloseCurly + DOUBLE_CLOSE_CURLY.length;\n      }\n    }\n    if (count !== 0) {\n      throw new Error(`Unbalanced {{ and }} in exp: ${str}`);\n    }\n    return {\n      start: expStart,\n      end: offset\n    };\n  }\n  function resolveExpressionsInString(val, { evaluate }) {\n    if (!evaluate) {\n      return val;\n    }\n    const expMatch = /@\\[.*?\\]@/;\n    let newVal = val;\n    let match = newVal.match(expMatch);\n    while (match !== null) {\n      const expStrWithBrackets = match[0];\n      const matchStart = newVal.indexOf(expStrWithBrackets);\n      const expString = expStrWithBrackets.substr(\n        \"@[\".length,\n        expStrWithBrackets.length - \"@[\".length - \"]@\".length\n      );\n      const expValue = evaluate(expString);\n      if (matchStart === 0 && expStrWithBrackets === val && typeof expValue !== \"string\") {\n        return expValue;\n      }\n      newVal = newVal.substr(0, matchStart) + expValue + newVal.substr(matchStart + expStrWithBrackets.length);\n      match = newVal.match(expMatch);\n    }\n    return newVal;\n  }\n  function resolveDataRefsInString(val, options) {\n    const { model, formatted = true } = options;\n    let workingString = resolveExpressionsInString(val, options);\n    if (!model || typeof workingString !== \"string\" || workingString.indexOf(DOUBLE_OPEN_CURLY) === -1) {\n      return workingString;\n    }\n    while (workingString.indexOf(DOUBLE_OPEN_CURLY) !== -1) {\n      const expLocation = findNextExp(workingString);\n      if (!expLocation) {\n        return workingString;\n      }\n      const { start, end } = expLocation;\n      const binding = workingString.substring(\n        start + DOUBLE_OPEN_CURLY.length,\n        end - DOUBLE_OPEN_CURLY.length\n      ).trim();\n      const evaledVal = model.get(binding, { formatted });\n      if (start === 0 && end === workingString.length && typeof evaledVal !== \"string\") {\n        return evaledVal;\n      }\n      workingString = workingString.substr(0, start) + evaledVal + workingString.substr(end);\n    }\n    return workingString;\n  }\n  function traverseObject(val, options) {\n    switch (typeof val) {\n      case \"string\": {\n        return resolveDataRefsInString(val, options);\n      }\n      case \"object\": {\n        if (!val)\n          return val;\n        const keys = Object.keys(val);\n        let newVal = val;\n        if (keys.length > 0) {\n          keys.forEach((key) => {\n            newVal = (0, import_timm2.setIn)(\n              newVal,\n              [key],\n              traverseObject(val[key], options)\n            );\n          });\n        }\n        return newVal;\n      }\n      default:\n        return val;\n    }\n  }\n  function resolveDataRefs(val, options) {\n    return traverseObject(val, options);\n  }\n  function removeBindingAndChildrenFromMap(sourceMap, binding) {\n    const targetMap = new Map(sourceMap);\n    const parentBinding = binding.parent();\n    const property = binding.key();\n    targetMap.forEach((_value, trackedBinding) => {\n      if (binding === trackedBinding || binding.contains(trackedBinding)) {\n        targetMap.delete(trackedBinding);\n      }\n    });\n    if (typeof property === \"number\") {\n      const bindingsToRewrite = Array.from(sourceMap.keys()).filter((b) => {\n        if (parentBinding.contains(b)) {\n          const [childIndex] = b.relative(parentBinding);\n          return typeof childIndex === \"number\" && childIndex > property;\n        }\n        return false;\n      }).sort();\n      bindingsToRewrite.forEach((trackedBinding) => {\n        const [childIndex, ...childPath] = trackedBinding.relative(parentBinding);\n        if (typeof childIndex === \"number\") {\n          const newSegments = [childIndex - 1, ...childPath];\n          const newChildBinding = parentBinding.descendent(newSegments);\n          targetMap.set(newChildBinding, targetMap.get(trackedBinding));\n          targetMap.delete(trackedBinding);\n        }\n      });\n    }\n    return targetMap;\n  }\n  var ValidationMiddleware = class {\n    constructor(validator, options) {\n      this.validator = validator;\n      this.shadowModelPaths = /* @__PURE__ */ new Map();\n      this.logger = options?.logger;\n      this.shouldIncludeInvalid = options?.shouldIncludeInvalid;\n    }\n    set(transaction, options, next) {\n      const asModel = toModel(this, { ...options, includeInvalid: true }, next);\n      const nextTransaction = [];\n      const includedBindings = /* @__PURE__ */ new Set();\n      transaction.forEach(([binding, value]) => {\n        this.shadowModelPaths.set(binding, value);\n        includedBindings.add(binding);\n      });\n      const invalidBindings = [];\n      this.shadowModelPaths.forEach((value, binding) => {\n        const validations = this.validator(binding, asModel);\n        if (validations === void 0) {\n          nextTransaction.push([binding, value]);\n        } else if (validations instanceof Set) {\n          validations.forEach((validation) => {\n            invalidBindings.push(validation.binding);\n            if (!validation.isStrong && validation.binding.asString() === binding.asString()) {\n              nextTransaction.push([validation.binding, value]);\n            }\n          });\n        } else if (includedBindings.has(binding)) {\n          invalidBindings.push(binding);\n          this.logger?.debug(\n            `Invalid value for path: ${binding.asString()} - ${validations.severity} - ${validations.message}`\n          );\n        }\n      });\n      let validResults = [];\n      if (next && nextTransaction.length > 0) {\n        nextTransaction.forEach(\n          ([binding]) => this.shadowModelPaths.delete(binding)\n        );\n        const result = next.set(nextTransaction, options);\n        if (invalidBindings.length === 0) {\n          return result;\n        }\n        validResults = result;\n      }\n      const invalidResults = invalidBindings.map((binding) => {\n        return {\n          binding,\n          oldValue: asModel.get(binding),\n          newValue: asModel.get(binding),\n          force: true\n        };\n      });\n      return [...validResults, ...invalidResults];\n    }\n    get(binding, options, next) {\n      let val = next?.get(binding, options);\n      if (this.shouldIncludeInvalid?.(options) ?? options?.includeInvalid === true) {\n        this.shadowModelPaths.forEach((shadowValue, shadowBinding) => {\n          if (shadowBinding === binding) {\n            val = shadowValue;\n            return;\n          }\n          if (binding.contains(shadowBinding)) {\n            val = (0, import_timm3.setIn)(val, shadowBinding.relative(binding), shadowValue);\n          }\n        });\n      }\n      return val;\n    }\n    delete(binding, options, next) {\n      this.shadowModelPaths = removeBindingAndChildrenFromMap(\n        this.shadowModelPaths,\n        binding\n      );\n      return next?.delete(binding, options);\n    }\n  };\n  var ValidatorRegistry = class {\n    constructor() {\n      this.registry = /* @__PURE__ */ new Map();\n    }\n    /** Use the given validator name to fetch the handler */\n    get(name) {\n      return this.registry.get(name);\n    }\n    /** Register a new validator */\n    register(name, handler) {\n      this.registry.set(name, handler);\n    }\n  };\n  var NodeType = /* @__PURE__ */ ((NodeType2) => {\n    NodeType2[\"Asset\"] = \"asset\";\n    NodeType2[\"View\"] = \"view\";\n    NodeType2[\"Applicability\"] = \"applicability\";\n    NodeType2[\"Template\"] = \"template\";\n    NodeType2[\"Value\"] = \"value\";\n    NodeType2[\"MultiNode\"] = \"multi-node\";\n    NodeType2[\"Switch\"] = \"switch\";\n    NodeType2[\"Async\"] = \"async\";\n    NodeType2[\"Unknown\"] = \"unknown\";\n    NodeType2[\"Empty\"] = \"empty\";\n    return NodeType2;\n  })(NodeType || {});\n  function hasTemplateValues(obj, localKey) {\n    return Object.hasOwnProperty.call(obj, \"template\") && Array.isArray(obj?.template) && obj.template.length && obj.template.find((tmpl) => tmpl.output === localKey);\n  }\n  function hasSwitchKey(localKey) {\n    return localKey === \"staticSwitch\" || localKey === \"dynamicSwitch\";\n  }\n  function hasTemplateKey(localKey) {\n    return localKey === \"template\";\n  }\n  function getNodeID(node) {\n    if (!node) {\n      return;\n    }\n    if (\"value\" in node && typeof node.value === \"object\" && typeof node.value?.id === \"string\") {\n      return node.value.id;\n    }\n  }\n  var EMPTY_NODE = {\n    type: \"empty\"\n    /* Empty */\n  };\n  var Parser = class {\n    constructor() {\n      this.hooks = {\n        /**\n         * A hook to interact with an object _before_ parsing it into an AST\n         *\n         * @param value - The object we're are about to parse\n         * @returns - A new value to parse.\n         *  If undefined, the original value is used.\n         *  If null, we stop parsing this node.\n         */\n        onParseObject: new SyncWaterfallHook(),\n        /**\n         * A callback to interact with an AST _after_ we parse it into the AST\n         *\n         * @param value - The object we parsed\n         * @param node - The AST node we generated\n         * @returns - A new AST node to use\n         *   If undefined, the original value is used.\n         *   If null, we ignore this node all together\n         */\n        onCreateASTNode: new SyncWaterfallHook(),\n        parseNode: new SyncBailHook()\n      };\n    }\n    parseView(value) {\n      const viewNode = this.parseObject(\n        value,\n        \"view\"\n        /* View */\n      );\n      if (!viewNode) {\n        throw new Error(\"Unable to parse object into a view\");\n      }\n      return viewNode;\n    }\n    createASTNode(node, value) {\n      const tapped = this.hooks.onCreateASTNode.call(node, value);\n      if (tapped === void 0) {\n        return node;\n      }\n      return tapped;\n    }\n    parseObject(obj, type = \"value\", options = { templateDepth: 0 }) {\n      const parsedNode = this.hooks.parseNode.call(\n        obj,\n        type,\n        options\n      );\n      if (parsedNode || parsedNode === null) {\n        return parsedNode;\n      }\n      const parseLocalObject = (currentValue, objToParse, path = []) => {\n        if (typeof objToParse !== \"object\" || objToParse === null) {\n          return { value: objToParse, children: [] };\n        }\n        const localObj = this.hooks.onParseObject.call(objToParse, type);\n        if (!localObj) {\n          return currentValue;\n        }\n        const objEntries = Array.isArray(localObj) ? localObj.map((v, i) => [i, v]) : [\n          ...Object.entries(localObj),\n          ...Object.getOwnPropertySymbols(localObj).map((s) => [\n            s,\n            localObj[s]\n          ])\n        ];\n        const defaultValue = {\n          children: [],\n          value: currentValue\n        };\n        const newValue = objEntries.reduce((accumulation, current) => {\n          let { value: value2 } = accumulation;\n          const { children: children2 } = accumulation;\n          const [localKey, localValue] = current;\n          const newChildren = this.hooks.parseNode.call(\n            localValue,\n            \"value\",\n            options,\n            {\n              path,\n              key: localKey,\n              parentObj: localObj\n            }\n          );\n          if (newChildren) {\n            children2.push(...newChildren);\n          } else if (localValue && typeof localValue === \"object\") {\n            const result = parseLocalObject(accumulation.value, localValue, [\n              ...path,\n              localKey\n            ]);\n            value2 = result.value;\n            children2.push(...result.children);\n          } else {\n            value2 = (0, import_timm5.setIn)(accumulation.value, [...path, localKey], localValue);\n          }\n          return {\n            value: value2,\n            children: children2\n          };\n        }, defaultValue);\n        return newValue;\n      };\n      const { value, children } = parseLocalObject(void 0, obj);\n      const baseAst = value === void 0 && !children.length ? void 0 : {\n        type,\n        value\n      };\n      if (baseAst && children.length) {\n        const parent = baseAst;\n        parent.children = children;\n        children.forEach((child) => {\n          child.value.parent = parent;\n        });\n      }\n      return this.hooks.onCreateASTNode.call(baseAst, obj) ?? null;\n    }\n  };\n  function caresAboutDataChanges(dataChanges, dependencies) {\n    if (!dataChanges || !dependencies) {\n      return true;\n    }\n    const depArray = Array.from(dependencies.values());\n    const dataChangeArray = Array.from(dataChanges.values());\n    return depArray.find(\n      (dep) => !!dataChangeArray.find(\n        (change) => change === dep || change.contains(dep) || dep.contains(change)\n      )\n    ) !== void 0;\n  }\n  function toNodeResolveOptions(resolverOptions) {\n    return {\n      ...resolverOptions,\n      data: {\n        model: resolverOptions.model,\n        formatValue: (ref, value) => {\n          if (resolverOptions.formatValue) {\n            return resolverOptions.formatValue(ref, value);\n          }\n          return value;\n        },\n        format: (bindingLike, value) => resolverOptions.format ? resolverOptions.format(\n          isBinding(bindingLike) ? bindingLike : resolverOptions.parseBinding(bindingLike),\n          value\n        ) : value\n      },\n      evaluate: (exp) => resolverOptions.evaluator.evaluate(exp, resolverOptions)\n    };\n  }\n  function unpackAndPush(item, initial) {\n    if (item.asset.values && Array.isArray(item.asset.values)) {\n      item.asset.values.forEach((i) => {\n        unpackAndPush(i, initial);\n      });\n    } else {\n      initial.push(item);\n    }\n  }\n  var withContext = (model) => {\n    return {\n      get: (binding, options) => {\n        return model.get(binding, {\n          context: { model },\n          ...options\n        });\n      },\n      set: (transaction, options) => {\n        return model.set(transaction, {\n          context: { model },\n          ...options\n        });\n      },\n      delete: (binding, options) => {\n        return model.delete(binding, {\n          context: { model },\n          ...options\n        });\n      }\n    };\n  };\n  var Resolver = class {\n    constructor(root, options) {\n      this.hooks = {\n        /** A hook to allow skipping of the resolution tree for a specific node */\n        skipResolve: new SyncWaterfallHook(),\n        /** An event emitted before calculating the next update */\n        beforeUpdate: new SyncHook(),\n        /** An event emitted after calculating the next update */\n        afterUpdate: new SyncHook(),\n        /** The options passed to a node to resolve it to an object */\n        resolveOptions: new SyncWaterfallHook(),\n        /** A hook to transform the AST node into a new AST node before resolving it */\n        beforeResolve: new SyncWaterfallHook(),\n        /**\n         * A hook to transform an AST node into it's resolved value.\n         * This runs _before_ any children are resolved\n         */\n        resolve: new SyncWaterfallHook(),\n        /**\n         * A hook to transform the resolved value of an AST node.\n         * This runs _after_ all children nodes are resolved\n         */\n        afterResolve: new SyncWaterfallHook(),\n        /** Called at the very end of a node's tree being updated */\n        afterNodeUpdate: new SyncHook()\n      };\n      this.root = root;\n      this.options = options;\n      this.resolveCache = /* @__PURE__ */ new Map();\n      this.ASTMap = /* @__PURE__ */ new Map();\n      this.logger = options.logger;\n      this.idCache = /* @__PURE__ */ new Set();\n    }\n    getSourceNode(convertedAST) {\n      return this.ASTMap.get(convertedAST);\n    }\n    update(changes) {\n      this.hooks.beforeUpdate.call(changes);\n      const resolveCache = /* @__PURE__ */ new Map();\n      this.idCache.clear();\n      const prevASTMap = new Map(this.ASTMap);\n      this.ASTMap.clear();\n      const updated = this.computeTree(\n        this.root,\n        void 0,\n        changes,\n        resolveCache,\n        toNodeResolveOptions(this.options),\n        void 0,\n        prevASTMap\n      );\n      this.resolveCache = resolveCache;\n      this.hooks.afterUpdate.call(updated.value);\n      return updated.value;\n    }\n    getResolveCache() {\n      return new Map(this.resolveCache);\n    }\n    getPreviousResult(node) {\n      if (!node) {\n        return;\n      }\n      const isFirstUpdate = this.resolveCache.size === 0;\n      const id = getNodeID(node);\n      if (id) {\n        if (this.idCache.has(id)) {\n          if (isFirstUpdate) {\n            if (node.type === \"asset\" || node.type === \"view\") {\n              this.logger?.error(\n                `Cache conflict: Found Asset/View nodes that have conflicting ids: ${id}, may cause cache issues.`\n              );\n            } else if (node.type === \"value\") {\n              this.logger?.info(\n                `Cache conflict: Found Value nodes that have conflicting ids: ${id}, may cause cache issues. To improve performance make value node IDs globally unique.`\n              );\n            }\n          }\n          return;\n        }\n        this.idCache.add(id);\n      }\n      return this.resolveCache.get(node);\n    }\n    cloneNode(node) {\n      const clonedNode = (0, import_timm4.clone)(node);\n      Object.keys(clonedNode).forEach((key) => {\n        if (key === \"parent\")\n          return;\n        const value = clonedNode[key];\n        if (typeof value === \"object\" && value !== null) {\n          clonedNode[key] = Array.isArray(value) ? [...value] : { ...value };\n        }\n      });\n      return clonedNode;\n    }\n    computeTree(node, rawParent, dataChanges, cacheUpdate, options, partiallyResolvedParent, prevASTMap) {\n      const dependencyModel = new DependencyModel(options.data.model);\n      dependencyModel.trackSubset(\"core\");\n      const depModelWithParser = withContext(\n        withParser(dependencyModel, this.options.parseBinding)\n      );\n      const resolveOptions = this.hooks.resolveOptions.call(\n        {\n          ...options,\n          data: {\n            ...options.data,\n            model: depModelWithParser\n          },\n          evaluate: (exp) => this.options.evaluator.evaluate(exp, { model: depModelWithParser }),\n          node\n        },\n        node\n      );\n      const previousResult = this.getPreviousResult(node);\n      const previousDeps = previousResult?.dependencies;\n      const dataChanged = caresAboutDataChanges(dataChanges, previousDeps);\n      const shouldUseLastValue = this.hooks.skipResolve.call(\n        !dataChanged,\n        node,\n        resolveOptions\n      );\n      const clonedNode = {\n        ...this.cloneNode(node),\n        parent: partiallyResolvedParent\n      };\n      const resolvedAST = this.hooks.beforeResolve.call(\n        clonedNode,\n        resolveOptions\n      ) ?? {\n        type: \"empty\"\n        /* Empty */\n      };\n      const isNestedMultiNode = resolvedAST.type === \"multi-node\" && partiallyResolvedParent?.parent?.type === \"multi-node\" && partiallyResolvedParent.type === \"value\";\n      if (previousResult && shouldUseLastValue) {\n        const update2 = {\n          ...previousResult,\n          updated: false\n        };\n        const repopulateASTMapFromCache = (resolvedNode, AST, ASTParent) => {\n          const { node: resolvedASTLocal } = resolvedNode;\n          this.ASTMap.set(resolvedASTLocal, AST);\n          const resolvedUpdate = {\n            ...resolvedNode,\n            updated: false\n          };\n          cacheUpdate.set(AST, resolvedUpdate);\n          const handleChildNode = (childNode) => {\n            const originalChildNode = prevASTMap.get(childNode) ?? childNode;\n            const previousChildResult = this.getPreviousResult(originalChildNode);\n            if (!previousChildResult)\n              return;\n            repopulateASTMapFromCache(\n              previousChildResult,\n              originalChildNode,\n              AST\n            );\n          };\n          if (\"children\" in resolvedASTLocal) {\n            resolvedASTLocal.children?.forEach(\n              ({ value: childAST }) => handleChildNode(childAST)\n            );\n          } else if (resolvedASTLocal.type === \"multi-node\") {\n            resolvedASTLocal.values.forEach(handleChildNode);\n          }\n          this.hooks.afterNodeUpdate.call(AST, ASTParent, resolvedUpdate);\n        };\n        previousResult.node.parent = partiallyResolvedParent;\n        repopulateASTMapFromCache(previousResult, node, rawParent);\n        return update2;\n      }\n      resolvedAST.parent = partiallyResolvedParent;\n      resolveOptions.node = resolvedAST;\n      this.ASTMap.set(resolvedAST, node);\n      let resolved = this.hooks.resolve.call(\n        void 0,\n        resolvedAST,\n        resolveOptions\n      );\n      let updated = !dequal(previousResult?.value, resolved);\n      if (previousResult && !updated) {\n        resolved = previousResult?.value;\n      }\n      const childDependencies = /* @__PURE__ */ new Set();\n      dependencyModel.trackSubset(\"children\");\n      if (\"children\" in resolvedAST) {\n        const newChildren = resolvedAST.children?.map((child) => {\n          const computedChildTree = this.computeTree(\n            child.value,\n            node,\n            dataChanges,\n            cacheUpdate,\n            resolveOptions,\n            resolvedAST,\n            prevASTMap\n          );\n          const {\n            dependencies: childTreeDeps,\n            node: childNode,\n            updated: childUpdated,\n            value: childValue\n          } = computedChildTree;\n          childTreeDeps.forEach((binding) => childDependencies.add(binding));\n          if (childValue) {\n            if (childNode.type === \"multi-node\" && !childNode.override) {\n              const arr = (0, import_timm4.addLast)(\n                dlv_es_default(resolved, child.path, []),\n                childValue\n              );\n              resolved = (0, import_timm4.setIn)(resolved, child.path, arr);\n            } else {\n              resolved = (0, import_timm4.setIn)(resolved, child.path, childValue);\n            }\n          }\n          updated = updated || childUpdated;\n          return { ...child, value: childNode };\n        });\n        resolvedAST.children = newChildren;\n      } else if (resolvedAST.type === \"multi-node\") {\n        const childValue = [];\n        const rawParentToPassIn = isNestedMultiNode ? partiallyResolvedParent?.parent : node;\n        const newValues = resolvedAST.values.map((mValue) => {\n          const mTree = this.computeTree(\n            mValue,\n            rawParentToPassIn,\n            dataChanges,\n            cacheUpdate,\n            resolveOptions,\n            resolvedAST,\n            prevASTMap\n          );\n          if (mTree.value !== void 0 && mTree.value !== null) {\n            if (mValue.type === \"async\" && mValue.flatten && mTree.value.asset && Array.isArray(mTree.value.asset.values)) {\n              unpackAndPush(mTree.value, childValue);\n            } else {\n              childValue.push(mTree.value);\n            }\n          }\n          mTree.dependencies.forEach(\n            (bindingDep) => childDependencies.add(bindingDep)\n          );\n          updated = updated || mTree.updated;\n          return mTree.node;\n        });\n        resolvedAST.values = newValues;\n        resolved = childValue;\n      }\n      childDependencies.forEach(\n        (bindingDep) => dependencyModel.addChildReadDep(bindingDep)\n      );\n      dependencyModel.trackSubset(\"core\");\n      if (previousResult && !updated) {\n        resolved = previousResult?.value;\n      }\n      resolved = this.hooks.afterResolve.call(resolved, resolvedAST, {\n        ...resolveOptions,\n        getDependencies: (scope) => dependencyModel.getDependencies(scope)\n      });\n      const update = {\n        node: resolvedAST,\n        updated,\n        value: resolved,\n        dependencies: /* @__PURE__ */ new Set([\n          ...dependencyModel.getDependencies(),\n          ...childDependencies\n        ])\n      };\n      this.hooks.afterNodeUpdate.call(\n        node,\n        isNestedMultiNode ? partiallyResolvedParent?.parent : rawParent,\n        update\n      );\n      cacheUpdate.set(node, update);\n      return update;\n    }\n  };\n  var CrossfieldProvider = class {\n    constructor(initialView, parser, logger) {\n      this.allValidations = /* @__PURE__ */ new Set();\n      this.byBinding = /* @__PURE__ */ new Map();\n      this.logger = logger;\n      this.parse(initialView, parser);\n    }\n    parse(contentView, parser) {\n      const xfieldRefs = contentView.validation;\n      if (xfieldRefs === void 0) {\n        return;\n      }\n      if (!Array.isArray(xfieldRefs)) {\n        this.logger?.warn(\n          `Unable to register view validations for id: ${contentView.id}. 'validation' property must be an Array.`\n        );\n        return;\n      }\n      xfieldRefs.forEach((vRef) => {\n        const withDefaults = {\n          trigger: \"navigation\",\n          severity: \"error\",\n          ...vRef\n        };\n        this.allValidations.add(withDefaults);\n        const { ref } = vRef;\n        if (ref) {\n          const parsed = parser(ref);\n          if (this.byBinding.has(parsed)) {\n            this.byBinding.get(parsed)?.push(withDefaults);\n          } else {\n            this.byBinding.set(parsed, [withDefaults]);\n          }\n        }\n      });\n    }\n    getValidationsForBinding(binding) {\n      return this.byBinding.get(binding);\n    }\n  };\n  var ViewInstance = class {\n    constructor(initialView, resolverOptions) {\n      this.hooks = {\n        onUpdate: new SyncHook(),\n        parser: new SyncHook(),\n        resolver: new SyncHook(),\n        onTemplatePluginCreated: new SyncHook(),\n        templatePlugin: new SyncHook()\n      };\n      this.initialView = initialView;\n      this.resolverOptions = resolverOptions;\n      this.hooks.onTemplatePluginCreated.tap(\"view\", (templatePlugin) => {\n        this.templatePlugin = templatePlugin;\n      });\n    }\n    updateAsync() {\n      const update = this.resolver?.update();\n      this.lastUpdate = update;\n      this.hooks.onUpdate.call(update);\n    }\n    update(changes) {\n      if (this.rootNode === void 0) {\n        this.validationProvider = new CrossfieldProvider(\n          this.initialView,\n          this.resolverOptions.parseBinding,\n          this.resolverOptions.logger\n        );\n        if (this.templatePlugin) {\n          this.hooks.templatePlugin.call(this.templatePlugin);\n        } else {\n          this.resolverOptions.logger?.warn(\n            \"templatePlugin not set for View, legacy templates may not work\"\n          );\n        }\n        const parser = new Parser();\n        this.hooks.parser.call(parser);\n        this.rootNode = parser.parseView(this.initialView);\n        this.resolver = new Resolver(this.rootNode, {\n          ...this.resolverOptions,\n          parseNode: parser.parseObject.bind(parser)\n        });\n        this.hooks.resolver.call(this.resolver);\n      }\n      const update = this.resolver?.update(changes);\n      if (this.lastUpdate === update) {\n        return this.lastUpdate;\n      }\n      this.lastUpdate = update;\n      this.hooks.onUpdate.call(update);\n      return update;\n    }\n    getValidationsForBinding(binding) {\n      return this.validationProvider?.getValidationsForBinding(binding);\n    }\n  };\n  var templateSymbol = Symbol(\"template\");\n  var TemplatePlugin = class {\n    constructor(options) {\n      this.hooks = {\n        resolveTemplateSubstitutions: new SyncWaterfallHook()\n      };\n      this.options = options;\n    }\n    parseTemplate(parseObject, node, options) {\n      const { template, depth } = node;\n      const data = options.data.model.get(node.data);\n      if (!data) {\n        return null;\n      }\n      if (!Array.isArray(data)) {\n        throw new Error(`Template using '${node.data}' but is not an array`);\n      }\n      const values = [];\n      data.forEach((dataItem, index) => {\n        const templateSubstitutions = this.hooks.resolveTemplateSubstitutions.call(\n          [\n            {\n              expression: new RegExp(`_index${depth || \"\"}_`),\n              value: String(index)\n            }\n          ],\n          {\n            depth,\n            data: dataItem,\n            index\n          }\n        );\n        let templateStr = JSON.stringify(template);\n        for (const { expression, value } of templateSubstitutions) {\n          let flags = \"g\";\n          if (typeof expression === \"object\") {\n            flags = `${expression.flags}${expression.global ? \"\" : \"g\"}`;\n          }\n          templateStr = templateStr.replace(new RegExp(expression, flags), value);\n        }\n        const parsed = parseObject(JSON.parse(templateStr), \"value\", {\n          templateDepth: node.depth + 1\n        });\n        if (parsed) {\n          values.push(parsed);\n        }\n      });\n      const result = {\n        type: \"multi-node\",\n        override: false,\n        values\n      };\n      if (node.placement !== void 0) {\n        result[templateSymbol] = node.placement;\n      }\n      return result;\n    }\n    applyParser(parser) {\n      parser.hooks.onCreateASTNode.tap(\"template\", (node) => {\n        if (node && node.type === \"template\" && !node.dynamic) {\n          return this.parseTemplate(\n            parser.parseObject.bind(parser),\n            node,\n            this.options\n          );\n        }\n        return node;\n      });\n      parser.hooks.onCreateASTNode.tap(\"template\", (node) => {\n        function getTemplateSymbolValue(node2) {\n          if (node2.type === \"multi-node\") {\n            return node2[templateSymbol];\n          } else if (node2.type === \"template\") {\n            return node2.placement;\n          }\n          return void 0;\n        }\n        if (node && (node.type === \"view\" || node.type === \"asset\") && Array.isArray(node.children)) {\n          node.children = node.children.sort((a, b) => {\n            const aPath = a.path.join();\n            const bPath = b.path.join();\n            const pathsEqual = aPath === bPath;\n            if (pathsEqual) {\n              const aPlacement = getTemplateSymbolValue(a.value);\n              const bPlacement = getTemplateSymbolValue(b.value);\n              if (aPlacement !== void 0 && bPlacement === void 0) {\n                return aPlacement === \"prepend\" ? -1 : 1;\n              } else if (bPlacement !== void 0 && aPlacement === void 0) {\n                return bPlacement === \"prepend\" ? 1 : -1;\n              } else if (aPlacement !== void 0 && bPlacement !== void 0) {\n                if (aPlacement === bPlacement) {\n                  return 0;\n                }\n                return aPlacement === \"prepend\" ? -1 : 1;\n              }\n              return 0;\n            }\n            return aPath > bPath ? 1 : -1;\n          });\n        }\n        return node;\n      });\n      parser.hooks.parseNode.tap(\n        \"template\",\n        (obj, _nodeType, options, childOptions) => {\n          if (childOptions && hasTemplateKey(childOptions.key)) {\n            return obj.map((template) => {\n              const templateAST = parser.createASTNode(\n                {\n                  type: \"template\",\n                  depth: options.templateDepth ?? 0,\n                  data: template.data,\n                  template: template.value,\n                  dynamic: template.dynamic ?? false,\n                  placement: template.placement\n                },\n                template\n              );\n              if (!templateAST)\n                return;\n              if (templateAST.type === \"multi-node\") {\n                templateAST.values.forEach((v) => {\n                  v.parent = templateAST;\n                });\n              }\n              return {\n                path: [...childOptions.path, template.output],\n                value: templateAST\n              };\n            }).filter(Boolean);\n          }\n        }\n      );\n    }\n    applyResolverHooks(resolver) {\n      resolver.hooks.beforeResolve.tap(\"template\", (node, options) => {\n        if (node && node.type === \"template\" && node.dynamic) {\n          return this.parseTemplate(options.parseNode, node, options);\n        }\n        return node;\n      });\n    }\n    apply(view) {\n      view.hooks.parser.tap(\"template\", this.applyParser.bind(this));\n      view.hooks.resolver.tap(\"template\", this.applyResolverHooks.bind(this));\n    }\n  };\n  var createPatternMatcher = (start, end) => {\n    return (testStr) => {\n      const startLocation = testStr.indexOf(start);\n      if (startLocation === -1) {\n        return false;\n      }\n      const endLocation = testStr.indexOf(end);\n      if (endLocation === -1) {\n        return false;\n      }\n      return startLocation < endLocation;\n    };\n  };\n  var bindingResolveLookup = createPatternMatcher(\"{{\", \"}}\");\n  var expressionResolveLookup = createPatternMatcher(\"@[\", \"]@\");\n  function hasSomethingToResolve(str) {\n    return bindingResolveLookup(str) || expressionResolveLookup(str);\n  }\n  function resolveString(str, resolveOptions) {\n    return hasSomethingToResolve(str) ? resolveDataRefs(str, {\n      model: resolveOptions.data.model,\n      evaluate: resolveOptions.evaluate\n    }) : str;\n  }\n  function resolveAllRefs(node, resolveOptions, propertiesToSkip) {\n    if (node === null || node === void 0 || typeof node !== \"object\" && typeof node !== \"string\") {\n      return node;\n    }\n    if (typeof node === \"string\") {\n      return resolveString(node, resolveOptions);\n    }\n    let newNode = node;\n    Object.keys(node).forEach((key) => {\n      if (propertiesToSkip.has(key)) {\n        return;\n      }\n      const val = node[key];\n      let newVal = val;\n      if (typeof val === \"object\") {\n        newVal = resolveAllRefs(val, resolveOptions, propertiesToSkip);\n      } else if (typeof val === \"string\") {\n        newVal = resolveString(val, resolveOptions);\n      }\n      if (newVal !== val) {\n        newNode = (0, import_timm6.set)(newNode, key, newVal);\n      }\n    });\n    return newNode;\n  }\n  var findBasePath = (node, resolver) => {\n    const parentNode = node.parent;\n    if (!parentNode) {\n      return [];\n    }\n    if (\"children\" in parentNode) {\n      const original = resolver.getSourceNode(node);\n      return parentNode.children?.find((child) => child.value === original)?.path ?? [];\n    }\n    if (parentNode.type !== \"multi-node\") {\n      return [];\n    }\n    return findBasePath(parentNode, resolver);\n  };\n  var StringResolverPlugin = class {\n    constructor() {\n      this.propertiesToSkipCache = /* @__PURE__ */ new Map();\n    }\n    applyResolver(resolver) {\n      resolver.hooks.resolve.tap(\"string-resolver\", (value, node, options) => {\n        if (node.type === \"empty\" || node.type === \"unknown\") {\n          return null;\n        }\n        if (node.type === \"value\" || node.type === \"asset\" || node.type === \"view\") {\n          let propsToSkip;\n          if (node.type === \"asset\" || node.type === \"view\") {\n            propsToSkip = new Set(\n              node.plugins?.stringResolver?.propertiesToSkip ?? [\"exp\"]\n            );\n            if (node.value?.id) {\n              this.propertiesToSkipCache.set(node.value.id, propsToSkip);\n            }\n          } else if (node.parent?.type === \"multi-node\" && (node.parent?.parent?.type === \"asset\" || node.parent?.parent?.type === \"view\") && node.parent.parent.value?.id && this.propertiesToSkipCache.has(node.parent.parent.value.id)) {\n            propsToSkip = this.propertiesToSkipCache.get(\n              node.parent.parent.value.id\n            );\n          } else {\n            propsToSkip = /* @__PURE__ */ new Set([\"exp\"]);\n          }\n          const nodePath = findBasePath(node, resolver);\n          if (nodePath.length > 0 && nodePath.some((segment) => propsToSkip.has(segment.toString()))) {\n            return node.value;\n          }\n          return resolveAllRefs(node.value, options, propsToSkip);\n        }\n        return value;\n      });\n    }\n    apply(view) {\n      view.hooks.resolver.tap(\"string-resolver\", this.applyResolver.bind(this));\n    }\n  };\n  var ApplicabilityPlugin = class {\n    isApplicability(obj) {\n      return obj && Object.prototype.hasOwnProperty.call(obj, \"applicability\");\n    }\n    applyResolver(resolver) {\n      resolver.hooks.beforeResolve.tap(\n        \"applicability\",\n        (node, options) => {\n          let newNode = node;\n          if (node?.type === \"applicability\") {\n            const isApplicable = options.evaluate(node.expression);\n            if (isApplicable === false) {\n              return null;\n            }\n            newNode = node.value;\n          }\n          return newNode;\n        }\n      );\n    }\n    applyParser(parser) {\n      parser.hooks.parseNode.tap(\n        \"applicability\",\n        (obj, nodeType, options, childOptions) => {\n          if (this.isApplicability(obj)) {\n            const parsedApplicability = parser.parseObject(\n              (0, import_timm7.omit)(obj, \"applicability\"),\n              nodeType,\n              options\n            );\n            if (!parsedApplicability) {\n              return childOptions ? [] : null;\n            }\n            const applicabilityNode = parser.createASTNode(\n              {\n                type: \"applicability\",\n                expression: obj.applicability,\n                value: parsedApplicability\n              },\n              obj\n            );\n            if (!applicabilityNode) {\n              return childOptions ? [] : null;\n            }\n            if (applicabilityNode.type === \"applicability\") {\n              applicabilityNode.value.parent = applicabilityNode;\n            }\n            return childOptions ? [\n              {\n                path: [...childOptions.path, childOptions.key],\n                value: applicabilityNode\n              }\n            ] : applicabilityNode;\n          }\n        }\n      );\n    }\n    apply(view) {\n      view.hooks.resolver.tap(\"applicability\", this.applyResolver.bind(this));\n      view.hooks.parser.tap(\"applicability\", this.applyParser.bind(this));\n    }\n  };\n  var SwitchPlugin = class {\n    constructor(options) {\n      this.options = options;\n    }\n    resolveSwitch(node, options) {\n      for (const switchCase of node.cases) {\n        const isApplicable = options.evaluate(switchCase.case);\n        if (isApplicable) {\n          return switchCase.value;\n        }\n      }\n      return EMPTY_NODE;\n    }\n    isSwitch(obj) {\n      return obj && (Object.prototype.hasOwnProperty.call(obj, \"dynamicSwitch\") || Object.prototype.hasOwnProperty.call(obj, \"staticSwitch\"));\n    }\n    applyParser(parser) {\n      parser.hooks.onCreateASTNode.tap(\"switch\", (node) => {\n        if (node && node.type === \"switch\" && !node.dynamic) {\n          return this.resolveSwitch(node, this.options);\n        }\n        return node;\n      });\n      parser.hooks.parseNode.tap(\n        \"switch\",\n        (obj, _nodeType, options, childOptions) => {\n          if (this.isSwitch(obj) || childOptions && hasSwitchKey(childOptions.key)) {\n            const objToParse = childOptions && hasSwitchKey(childOptions.key) ? { [childOptions.key]: obj } : obj;\n            const dynamic = \"dynamicSwitch\" in objToParse;\n            const switchContent = dynamic ? objToParse.dynamicSwitch : objToParse.staticSwitch;\n            const cases = switchContent.map(\n              (switchCase) => {\n                const { case: switchCaseExpr, ...switchBody } = switchCase;\n                const value = parser.parseObject(\n                  switchBody,\n                  \"value\",\n                  options\n                );\n                if (value) {\n                  return {\n                    case: switchCaseExpr,\n                    value\n                  };\n                }\n                return;\n              }\n            ).filter(Boolean);\n            const switchAST = parser.createASTNode(\n              {\n                type: \"switch\",\n                dynamic,\n                cases\n              },\n              objToParse\n            );\n            if (!switchAST || switchAST.type === \"empty\") {\n              return childOptions ? [] : null;\n            }\n            if (switchAST.type === \"switch\") {\n              switchAST.cases.forEach((sCase) => {\n                sCase.value.parent = switchAST;\n              });\n            }\n            if (childOptions) {\n              let path = [...childOptions.path, childOptions.key];\n              let value = switchAST;\n              if (switchAST.type === \"value\" && switchAST.children?.length === 1 && switchAST.value === void 0) {\n                const firstChild = switchAST.children[0];\n                path = [...path, ...firstChild.path];\n                value = firstChild.value;\n              }\n              return [{ path, value }];\n            }\n            return switchAST;\n          }\n        }\n      );\n    }\n    applyResolver(resolver) {\n      resolver.hooks.beforeResolve.tap(\"switch\", (node, options) => {\n        if (node && node.type === \"switch\" && node.dynamic) {\n          return this.resolveSwitch(node, options);\n        }\n        return node;\n      });\n    }\n    apply(view) {\n      view.hooks.parser.tap(\"switch\", this.applyParser.bind(this));\n      view.hooks.resolver.tap(\"switch\", this.applyResolver.bind(this));\n    }\n  };\n  var MultiNodePlugin = class {\n    applyParser(parser) {\n      parser.hooks.parseNode.tap(\n        \"multi-node\",\n        (obj, nodeType, options, childOptions) => {\n          if (childOptions && !hasTemplateKey(childOptions.key) && Array.isArray(obj)) {\n            const values = obj.map(\n              (childVal) => parser.parseObject(childVal, \"value\", options)\n            ).filter((child) => !!child);\n            if (!values.length) {\n              return [];\n            }\n            const multiNode = parser.createASTNode(\n              {\n                type: \"multi-node\",\n                override: !hasTemplateValues(\n                  childOptions.parentObj,\n                  childOptions.key\n                ),\n                values\n              },\n              obj\n            );\n            if (!multiNode) {\n              return [];\n            }\n            if (multiNode.type === \"multi-node\") {\n              multiNode.values.forEach((v) => {\n                v.parent = multiNode;\n              });\n            }\n            return [\n              {\n                path: [...childOptions.path, childOptions.key],\n                value: multiNode\n              }\n            ];\n          }\n        }\n      );\n    }\n    apply(view) {\n      view.hooks.parser.tap(\"multi-node\", this.applyParser.bind(this));\n    }\n  };\n  var AssetPlugin = class {\n    applyParser(parser) {\n      parser.hooks.parseNode.tap(\n        \"asset\",\n        (obj, nodeType, options, childOptions) => {\n          if (childOptions?.key === \"asset\" && typeof obj === \"object\") {\n            const assetAST = parser.parseObject(obj, \"asset\", options);\n            if (!assetAST) {\n              return [];\n            }\n            return [\n              {\n                path: [...childOptions.path, childOptions.key],\n                value: assetAST\n              }\n            ];\n          }\n        }\n      );\n    }\n    apply(view) {\n      view.hooks.parser.tap(\"asset\", this.applyParser.bind(this));\n    }\n  };\n  var FlowInstance = class {\n    constructor(id, flow, options) {\n      this.isTransitioning = false;\n      this.hooks = {\n        beforeStart: new SyncBailHook(),\n        /** A callback when the onStart node was present */\n        onStart: new SyncHook(),\n        /** A callback when the onEnd node was present */\n        onEnd: new SyncHook(),\n        /** A hook to intercept and block a transition */\n        skipTransition: new SyncBailHook(),\n        /** A chance to manipulate the flow-node used to calculate the given transition used  */\n        beforeTransition: new SyncWaterfallHook(),\n        /** A chance to manipulate the flow-node calculated after a transition */\n        resolveTransitionNode: new SyncWaterfallHook(),\n        /** A callback when a transition from 1 state to another was made */\n        transition: new SyncHook(),\n        /** A callback to run actions after a transition occurs */\n        afterTransition: new SyncHook()\n      };\n      this.id = id;\n      this.flow = flow;\n      this.log = options?.logger;\n      this.history = [];\n      this.hooks.transition.tap(\n        \"startPromise\",\n        async (_oldState, nextState) => {\n          const newState = nextState.value;\n          if (this.flowPromise && newState.state_type === \"END\") {\n            this.flowPromise.resolve(newState);\n          }\n        }\n      );\n    }\n    /** Start the state machine */\n    async start() {\n      if (this.flowPromise) {\n        this.log?.warn(\"Already called start for flow\");\n        return this.flowPromise.promise;\n      }\n      this.flow = this.hooks.beforeStart.call(this.flow) || this.flow;\n      if (this.flow.onStart) {\n        this.hooks.onStart.call(this.flow.onStart);\n      }\n      const initialState = this.flow.startState;\n      if (!initialState) {\n        return Promise.reject(new Error(\"No 'startState' defined for flow\"));\n      }\n      this.flowPromise = (0, import_p_defer2.default)();\n      this.pushHistory(initialState);\n      return this.flowPromise.promise;\n    }\n    transition(transitionValue, options) {\n      if (this.isTransitioning) {\n        throw new Error(\n          `Transitioning while ongoing transition from ${this.currentState?.name} is in progress is not supported`\n        );\n      }\n      if (this.currentState?.value.state_type === \"END\") {\n        this.log?.warn(\n          `Skipping transition using ${transitionValue}. Already at and END state`\n        );\n        return;\n      }\n      if (this.currentState === void 0) {\n        throw new Error(\"Cannot transition when there's no current state\");\n      }\n      if (options?.force) {\n        this.log?.debug(`Forced transition. Skipping validation checks`);\n      } else {\n        const skipTransition = this.hooks.skipTransition.call(this.currentState);\n        if (skipTransition) {\n          this.log?.debug(\n            `Skipping transition from ${this.currentState.name} b/c hook told us to`\n          );\n          return;\n        }\n      }\n      const state = this.hooks.beforeTransition.call(\n        this.currentState.value,\n        transitionValue\n      );\n      if (!(\"transitions\" in state)) {\n        throw new Error(`No transitions defined for ${this.currentState.value}`);\n      }\n      const { transitions } = state;\n      const nextState = transitions[transitionValue] || transitions[\"*\"];\n      if (nextState === void 0) {\n        this.log?.warn(\n          `No transition from ${this.currentState.name} using ${transitionValue} or *`\n        );\n        return;\n      }\n      this.log?.debug(\n        `Transitioning from ${this.currentState.name} to ${nextState} using ${transitionValue} `\n      );\n      return this.pushHistory(nextState, options);\n    }\n    pushHistory(stateName, options) {\n      if (!Object.prototype.hasOwnProperty.call(this.flow, stateName)) {\n        throw new Error(`No flow definition for: ${stateName} was found.`);\n      }\n      let nextState = this.flow[stateName];\n      if (!this.flow[stateName] || typeof nextState !== \"object\" || !(\"state_type\" in nextState)) {\n        this.log?.error(`Flow doesn't contain any states named: ${stateName}`);\n        return;\n      }\n      const prevState = this.currentState;\n      this.isTransitioning = true;\n      nextState = this.hooks.resolveTransitionNode.call(nextState);\n      const newCurrentState = {\n        name: stateName,\n        value: nextState\n      };\n      this.currentState = newCurrentState;\n      this.history.push(stateName);\n      if (newCurrentState.value.state_type === \"END\" && this.flow.onEnd) {\n        this.hooks.onEnd.call(this.flow.onEnd);\n      }\n      this.hooks.transition.call(prevState, {\n        ...newCurrentState\n      });\n      this.isTransitioning = false;\n      this.hooks.afterTransition.call(this);\n    }\n  };\n  var FlowController = class {\n    constructor(navigation, options) {\n      this.hooks = {\n        flow: new SyncHook()\n      };\n      this.navigation = navigation;\n      this.navStack = [];\n      this.log = options?.logger;\n      this.start = this.start.bind(this);\n      this.run = this.run.bind(this);\n      this.transition = this.transition.bind(this);\n      this.addNewFlow = this.addNewFlow.bind(this);\n    }\n    /** Navigate to another state in the state-machine */\n    transition(stateTransition, options) {\n      if (this.current === void 0) {\n        throw new Error(\"Not currently in a flow. Cannot transition.\");\n      }\n      this.current.transition(stateTransition, options);\n    }\n    addNewFlow(flow) {\n      this.navStack.push(flow);\n      this.current = flow;\n      this.hooks.flow.call(flow);\n    }\n    async run(startState) {\n      if (!Object.prototype.hasOwnProperty.call(this.navigation, startState)) {\n        return Promise.reject(new Error(`No flow defined for: ${startState}`));\n      }\n      const startFlow = this.navigation[startState];\n      if (startFlow === null || typeof startFlow !== \"object\") {\n        return Promise.reject(\n          new Error(`Flow: ${startState} needs to be an object`)\n        );\n      }\n      this.log?.debug(`Starting flow: ${startState}`);\n      const flow = new FlowInstance(startState, startFlow, { logger: this.log });\n      this.addNewFlow(flow);\n      flow.hooks.afterTransition.tap(\"flow-controller\", (flowInstance) => {\n        if (flowInstance.currentState?.value.state_type === \"FLOW\") {\n          const subflowId = flowInstance.currentState?.value.ref;\n          this.log?.debug(`Loading subflow ${subflowId}`);\n          this.run(subflowId).then((subFlowEndState) => {\n            this.log?.debug(\n              `Subflow ended. Using outcome: ${subFlowEndState.outcome}`\n            );\n            flowInstance.transition(subFlowEndState?.outcome);\n          });\n        }\n      });\n      const end = await flow.start();\n      this.navStack.pop();\n      if (this.navStack.length > 0) {\n        const firstItem = 0;\n        this.current = this.navStack[firstItem];\n      }\n      return end;\n    }\n    async start() {\n      if (!this.navigation.BEGIN) {\n        return Promise.reject(new Error(\"Must supply a BEGIN state\"));\n      }\n      return this.run(this.navigation.BEGIN);\n    }\n  };\n  var ANY_CHAR_REGEX = /%([a-zA-Z]+)/g;\n  function replaceParams(message, params) {\n    return message.slice().replace(ANY_CHAR_REGEX, (keyExpr) => params[keyExpr.slice(1)] || keyExpr);\n  }\n  var CONTEXT = \"validation-binding-tracker\";\n  var ValidationBindingTrackerViewPlugin = class {\n    constructor(options) {\n      this.trackedBindings = /* @__PURE__ */ new Set();\n      this.options = options;\n    }\n    /** Fetch the tracked bindings in the current view */\n    getBindings() {\n      return this.trackedBindings;\n    }\n    /** Add a binding to the tracked set */\n    trackBinding(binding) {\n      if (this.trackedBindings.has(binding)) {\n        return;\n      }\n      this.trackedBindings.add(binding);\n      this.options.callbacks?.onAdd?.(binding);\n    }\n    /** Attach hooks to the given resolver */\n    applyResolver(resolver) {\n      this.trackedBindings.clear();\n      const tracked = /* @__PURE__ */ new Map();\n      const sections = /* @__PURE__ */ new Map();\n      let lastViewUpdateChangeSet;\n      const lastComputedBindingTree = /* @__PURE__ */ new Map();\n      let currentBindingTree = /* @__PURE__ */ new Map();\n      const lastSectionBindingTree = /* @__PURE__ */ new Map();\n      const resolvedNodeMap = /* @__PURE__ */ new Map();\n      resolver.hooks.beforeUpdate.tap(CONTEXT, (changes) => {\n        lastViewUpdateChangeSet = changes;\n      });\n      resolver.hooks.skipResolve.tap(CONTEXT, (shouldSkip, node) => {\n        const trackedBindingsForNode = lastComputedBindingTree.get(node);\n        if (!shouldSkip || !lastViewUpdateChangeSet || !trackedBindingsForNode) {\n          return shouldSkip;\n        }\n        const intersection = new Set(\n          [...lastViewUpdateChangeSet].filter(\n            (b) => trackedBindingsForNode.has(b)\n          )\n        );\n        return intersection.size === 0;\n      });\n      resolver.hooks.resolveOptions.tap(CONTEXT, (options, node) => {\n        if (options.validation === void 0) {\n          return options;\n        }\n        tracked.delete(node);\n        const track = (binding) => {\n          const parsed = isBinding(binding) ? binding : this.options.parseBinding(binding);\n          if (tracked.has(node)) {\n            tracked.get(node)?.add(parsed);\n          } else {\n            tracked.set(node, /* @__PURE__ */ new Set([parsed]));\n          }\n          let { parent } = node;\n          while (parent) {\n            if (sections.has(parent)) {\n              sections.get(parent)?.add(node);\n              break;\n            } else {\n              parent = parent.parent;\n            }\n          }\n          this.trackedBindings.add(parsed);\n          this.options.callbacks?.onAdd?.(parsed);\n        };\n        return {\n          ...options,\n          validation: {\n            ...options.validation,\n            get: (binding, getOptions) => {\n              if (getOptions?.track) {\n                track(binding);\n              }\n              const eows = options.validation?._getValidationForBinding(binding)?.getAll(getOptions);\n              const firstFieldEOW = eows?.find(\n                (eow) => eow.displayTarget === \"field\" || eow.displayTarget === void 0\n              );\n              return firstFieldEOW;\n            },\n            getValidationsForBinding(binding, getOptions) {\n              if (getOptions?.track) {\n                track(binding);\n              }\n              return options.validation?._getValidationForBinding(binding)?.getAll(getOptions) ?? [];\n            },\n            getChildren: (type) => {\n              const validations = new Array();\n              lastComputedBindingTree.get(node)?.forEach((binding) => {\n                const eow = options.validation?._getValidationForBinding(binding)?.get();\n                if (eow && (type === void 0 || type === eow.displayTarget)) {\n                  validations.push(eow);\n                }\n              });\n              return validations;\n            },\n            getValidationsForSection: () => {\n              const validations = new Array();\n              lastSectionBindingTree.get(node)?.forEach((binding) => {\n                const eow = options.validation?._getValidationForBinding(binding)?.get();\n                if (eow && eow.displayTarget === \"section\") {\n                  validations.push(eow);\n                }\n              });\n              return validations;\n            },\n            register: (registerOptions) => {\n              if (registerOptions?.type === \"section\") {\n                if (!sections.has(node)) {\n                  sections.set(node, /* @__PURE__ */ new Set());\n                }\n              }\n            },\n            track\n          }\n        };\n      });\n      resolver.hooks.afterNodeUpdate.tap(\n        CONTEXT,\n        (originalNode, parent, update) => {\n          const { updated, node: resolvedNode } = update;\n          resolvedNodeMap.set(resolvedNode, originalNode);\n          if (updated) {\n            const newlyComputed = new Set(tracked.get(originalNode));\n            if (resolvedNode.type === \"multi-node\") {\n              resolvedNode.values.forEach(\n                (value) => currentBindingTree.get(value)?.forEach((b) => newlyComputed.add(b))\n              );\n            }\n            if (\"children\" in resolvedNode && resolvedNode.children) {\n              resolvedNode.children.forEach((child) => {\n                currentBindingTree.get(child.value)?.forEach((b) => newlyComputed.add(b));\n              });\n            }\n            currentBindingTree.set(resolvedNode, newlyComputed);\n          } else {\n            currentBindingTree.set(\n              resolvedNode,\n              lastComputedBindingTree.get(originalNode) ?? /* @__PURE__ */ new Set()\n            );\n          }\n          if (originalNode === resolver.root) {\n            this.trackedBindings = new Set(currentBindingTree.get(resolvedNode));\n            lastComputedBindingTree.clear();\n            currentBindingTree.forEach((value, key) => {\n              const node = resolvedNodeMap.get(key);\n              if (node) {\n                lastComputedBindingTree.set(node, value);\n              }\n            });\n            lastSectionBindingTree.clear();\n            sections.forEach((nodeSet, sectionNode) => {\n              const temp = /* @__PURE__ */ new Set();\n              nodeSet.forEach((n) => {\n                tracked.get(n)?.forEach(temp.add, temp);\n              });\n              lastSectionBindingTree.set(sectionNode, temp);\n            });\n            tracked.clear();\n            sections.clear();\n            currentBindingTree = /* @__PURE__ */ new Map();\n          }\n        }\n      );\n    }\n    apply(view) {\n      view.hooks.resolver.tap(CONTEXT, this.applyResolver.bind(this));\n    }\n  };\n  var SCHEMA_VALIDATION_PROVIDER_NAME = \"schema\";\n  var VIEW_VALIDATION_PROVIDER_NAME = \"view\";\n  var VALIDATION_PROVIDER_NAME_SYMBOL = Symbol.for(\n    \"validation-provider-name\"\n  );\n  function isSubset(subset, containingSet) {\n    if (subset.size > containingSet.size)\n      return false;\n    for (const entry of subset)\n      if (!containingSet.has(entry))\n        return false;\n    return true;\n  }\n  function createStatefulValidationObject(obj) {\n    return {\n      value: obj,\n      type: obj.severity,\n      state: \"none\",\n      isBlockingNavigation: false\n    };\n  }\n  var ValidatedBinding = class {\n    constructor(possibleValidations, onDismiss, log, weakBindings) {\n      this.applicableValidations = [];\n      this.validationsByState = {\n        load: [],\n        change: [],\n        navigation: []\n      };\n      this.onDismiss = onDismiss;\n      possibleValidations.forEach((vObj) => {\n        const { trigger } = vObj;\n        if (this.validationsByState[trigger]) {\n          const statefulValidationObject = createStatefulValidationObject(vObj);\n          this.validationsByState[trigger].push(statefulValidationObject);\n        } else {\n          log?.warn(`Unknown validation trigger: ${trigger}`);\n        }\n      });\n      this.weakBindings = weakBindings ?? /* @__PURE__ */ new Set();\n    }\n    get allValidations() {\n      return Object.values(this.validationsByState).flat();\n    }\n    checkIfBlocking(statefulObj) {\n      if (statefulObj.state === \"active\") {\n        const { isBlockingNavigation } = statefulObj;\n        return isBlockingNavigation;\n      }\n      return false;\n    }\n    getAll() {\n      return this.applicableValidations.reduce((all, statefulObj) => {\n        if (statefulObj.state === \"active\" && statefulObj.response) {\n          all.push({\n            ...statefulObj.response,\n            blocking: this.checkIfBlocking(statefulObj)\n          });\n        }\n        return all;\n      }, []);\n    }\n    get() {\n      const firstInvalid = this.applicableValidations.find((statefulObj) => {\n        return statefulObj.state === \"active\" && statefulObj.response;\n      });\n      if (firstInvalid?.state === \"active\") {\n        return {\n          ...firstInvalid.response,\n          blocking: this.checkIfBlocking(firstInvalid)\n        };\n      }\n    }\n    runApplicableValidations(runner, canDismiss, phase) {\n      this.applicableValidations = this.applicableValidations.map(\n        (originalValue) => {\n          if (originalValue.state === \"dismissed\") {\n            return originalValue;\n          }\n          const blocking = originalValue.value.blocking ?? (originalValue.value.severity === \"warning\" && \"once\" || true);\n          const obj = (0, import_timm9.setIn)(\n            originalValue,\n            [\"value\", \"blocking\"],\n            blocking\n          );\n          const isBlockingNavigation = blocking === true || blocking === \"once\" && !canDismiss;\n          if (phase === \"navigation\" && obj.state === \"active\" && obj.value.blocking !== true) {\n            if (obj.value.severity === \"warning\") {\n              const warn = obj;\n              if (warn.dismissable && warn.response.dismiss && (warn.response.blocking !== \"once\" || !warn.response.blocking)) {\n                warn.response.dismiss();\n              } else {\n                if (warn?.response.blocking === \"once\") {\n                  warn.response.blocking = false;\n                }\n                warn.dismissable = true;\n              }\n              return warn;\n            }\n          }\n          const response = runner(obj.value);\n          const newState = {\n            type: obj.type,\n            value: obj.value,\n            state: response ? \"active\" : \"none\",\n            isBlockingNavigation,\n            dismissable: obj.value.severity === \"warning\" && phase === \"navigation\",\n            response: response ? {\n              ...obj.value,\n              message: response.message ?? \"Something is broken\",\n              severity: obj.value.severity,\n              displayTarget: obj.value.displayTarget ?? \"field\"\n            } : void 0\n          };\n          if (newState.state === \"active\" && obj.value.severity === \"warning\") {\n            newState.response.dismiss = () => {\n              newState.state = \"dismissed\";\n              this.onDismiss?.();\n            };\n          }\n          return newState;\n        }\n      );\n    }\n    update(phase, canDismiss, runner) {\n      const newApplicableValidations = [];\n      if (phase === \"load\" && this.currentPhase !== void 0) {\n        return;\n      }\n      if (this.currentPhase === \"navigation\" || phase === this.currentPhase) {\n        this.runApplicableValidations(runner, canDismiss, phase);\n        return;\n      }\n      if (phase === \"load\") {\n        this.currentPhase = \"load\";\n        this.applicableValidations = [...this.validationsByState.load];\n      } else if (phase === \"change\" && this.currentPhase === \"load\") {\n        this.currentPhase = \"change\";\n        this.applicableValidations = [\n          ...this.applicableValidations,\n          ...this.validationsByState.change\n        ];\n      } else if (phase === \"navigation\" && (this.currentPhase === \"load\" || this.currentPhase === \"change\")) {\n        this.applicableValidations.forEach((element) => {\n          if (!(element.type === \"error\" && element.state === \"active\" && element.isBlockingNavigation === false)) {\n            newApplicableValidations.push(element);\n          }\n        });\n        this.applicableValidations = [\n          ...newApplicableValidations,\n          ...this.validationsByState.navigation,\n          ...this.currentPhase === \"load\" ? this.validationsByState.change : []\n        ];\n        this.currentPhase = \"navigation\";\n      }\n      this.runApplicableValidations(runner, canDismiss, phase);\n    }\n  };\n  var ValidationController = class {\n    constructor(schema, options) {\n      this.hooks = {\n        /** A hook called to tap into the validator registry for adding more validators */\n        createValidatorRegistry: new SyncHook(),\n        /** A callback/event when a new validation is added to the view */\n        onAddValidation: new SyncWaterfallHook(),\n        /** The inverse of onAddValidation, this is called when a validation is removed from the list */\n        onRemoveValidation: new SyncWaterfallHook(),\n        resolveValidationProviders: new SyncWaterfallHook(),\n        /** A hook called when a binding is added to the tracker */\n        onTrackBinding: new SyncHook()\n      };\n      this.validations = /* @__PURE__ */ new Map();\n      this.weakBindingTracker = /* @__PURE__ */ new Set();\n      this.schema = schema;\n      this.options = options;\n      this.reset();\n    }\n    setOptions(options) {\n      this.options = options;\n    }\n    /** Return the middleware for the data-model to stop propagation of invalid data */\n    getDataMiddleware() {\n      return [\n        {\n          set: (transaction, options, next) => {\n            return next?.set(transaction, options) ?? [];\n          },\n          get: (binding, options, next) => {\n            return next?.get(binding, options);\n          },\n          delete: (binding, options, next) => {\n            this.validations = removeBindingAndChildrenFromMap(\n              this.validations,\n              binding\n            );\n            return next?.delete(binding, options);\n          }\n        },\n        new ValidationMiddleware(\n          (binding) => {\n            if (!this.options) {\n              return;\n            }\n            this.updateValidationsForBinding(binding, \"change\", this.options);\n            const strongValidation = this.getValidationForBinding(binding);\n            if (strongValidation?.get()?.severity === \"error\") {\n              return strongValidation.get();\n            }\n            const newInvalidBindings = /* @__PURE__ */ new Set();\n            this.validations.forEach((weakValidation, strongBinding) => {\n              if (caresAboutDataChanges(\n                /* @__PURE__ */ new Set([binding]),\n                weakValidation.weakBindings\n              ) && weakValidation?.get()?.severity === \"error\") {\n                weakValidation?.weakBindings.forEach((weakBinding) => {\n                  if (weakBinding === strongBinding) {\n                    newInvalidBindings.add({\n                      binding: weakBinding,\n                      isStrong: true\n                    });\n                  } else {\n                    newInvalidBindings.add({\n                      binding: weakBinding,\n                      isStrong: false\n                    });\n                  }\n                });\n              }\n            });\n            if (newInvalidBindings.size > 0) {\n              return newInvalidBindings;\n            }\n          },\n          { logger: new ProxyLogger(() => this.options?.logger) }\n        )\n      ];\n    }\n    getValidationProviders() {\n      if (this.providers) {\n        return this.providers;\n      }\n      this.providers = this.hooks.resolveValidationProviders.call([\n        {\n          source: SCHEMA_VALIDATION_PROVIDER_NAME,\n          provider: this.schema\n        },\n        {\n          source: VIEW_VALIDATION_PROVIDER_NAME,\n          provider: {\n            getValidationsForBinding: (binding) => {\n              return this.viewValidationProvider?.getValidationsForBinding?.(\n                binding\n              );\n            },\n            getValidationsForView: () => {\n              return this.viewValidationProvider?.getValidationsForView?.();\n            }\n          }\n        }\n      ]);\n      return this.providers;\n    }\n    reset() {\n      this.validations.clear();\n      this.tracker = void 0;\n    }\n    onView(view) {\n      this.validations.clear();\n      if (!this.options) {\n        return;\n      }\n      const bindingTrackerPlugin = new ValidationBindingTrackerViewPlugin({\n        ...this.options,\n        callbacks: {\n          onAdd: (binding) => {\n            if (!this.options || this.getValidationForBinding(binding) !== void 0) {\n              return;\n            }\n            const originalValue = this.options.model.get(binding);\n            const withoutDefault = this.options.model.get(binding, {\n              ignoreDefaultValue: true\n            });\n            if (originalValue !== withoutDefault) {\n              this.options.model.set([[binding, originalValue]], {\n                silent: true\n              });\n            }\n            this.updateValidationsForBinding(\n              binding,\n              \"load\",\n              this.options,\n              () => {\n                view.update(/* @__PURE__ */ new Set([binding]));\n              }\n            );\n            this.hooks.onTrackBinding.call(binding);\n          }\n        }\n      });\n      this.tracker = bindingTrackerPlugin;\n      this.viewValidationProvider = view;\n      bindingTrackerPlugin.apply(view);\n    }\n    updateValidationsForBinding(binding, trigger, validationContext, onDismiss) {\n      const context = validationContext ?? this.options;\n      if (!context) {\n        throw new Error(`Context is required for executing validations`);\n      }\n      if (trigger === \"load\") {\n        const possibleValidations = this.getValidationProviders().reduce((vals, provider) => {\n          vals.push(\n            ...provider.provider.getValidationsForBinding?.(binding)?.map((valObj) => ({\n              ...valObj,\n              [VALIDATION_PROVIDER_NAME_SYMBOL]: provider.source\n            })) ?? []\n          );\n          return vals;\n        }, []);\n        if (possibleValidations.length === 0) {\n          return;\n        }\n        this.validations.set(\n          binding,\n          new ValidatedBinding(\n            possibleValidations,\n            onDismiss,\n            this.options?.logger\n          )\n        );\n      }\n      const trackedValidations = this.validations.get(binding);\n      trackedValidations?.update(trigger, true, (validationObj) => {\n        const response = this.validationRunner(validationObj, binding, context);\n        if (this.weakBindingTracker.size > 0) {\n          const t2 = this.validations.get(binding);\n          this.weakBindingTracker.forEach((b) => t2.weakBindings.add(b));\n        }\n        return response ? { message: response.message } : void 0;\n      });\n      if (trigger !== \"load\") {\n        this.validations.forEach((validation, vBinding) => {\n          if (vBinding !== binding && caresAboutDataChanges(/* @__PURE__ */ new Set([binding]), validation.weakBindings)) {\n            validation.update(trigger, true, (validationObj) => {\n              const response = this.validationRunner(\n                validationObj,\n                vBinding,\n                context\n              );\n              return response ? { message: response.message } : void 0;\n            });\n          }\n        });\n      }\n    }\n    validationRunner(validationObj, binding, context = this.options) {\n      if (!context) {\n        throw new Error(\"No context provided to validation runner\");\n      }\n      const handler = validationObj.handler ?? this.getValidator(validationObj.type);\n      const weakBindings = /* @__PURE__ */ new Set();\n      const model = {\n        get(b, options) {\n          weakBindings.add(isBinding(b) ? binding : context.parseBinding(b));\n          return context.model.get(b, { ...options, includeInvalid: true });\n        },\n        set: context.model.set,\n        delete: context.model.delete\n      };\n      const result = handler?.(\n        {\n          ...context,\n          evaluate: (exp, options = { model }) => context.evaluate(exp, options),\n          model,\n          validation: validationObj,\n          schemaType: this.schema.getType(binding)\n        },\n        context.model.get(binding, {\n          includeInvalid: true,\n          formatted: validationObj.dataTarget === \"formatted\"\n        }),\n        validationObj\n      );\n      this.weakBindingTracker = weakBindings;\n      if (result) {\n        let { message } = result;\n        const { parameters } = result;\n        if (validationObj.message) {\n          message = resolveDataRefs(validationObj.message, {\n            model,\n            evaluate: context.evaluate\n          });\n          if (parameters) {\n            message = replaceParams(message, parameters);\n          }\n        }\n        return {\n          message\n        };\n      }\n    }\n    updateValidationsForView(trigger) {\n      const isNavigationTrigger = trigger === \"navigation\";\n      const lastActiveBindings = this.activeBindings;\n      const updateValidations = (dismissValidations) => {\n        this.getBindings().forEach((binding) => {\n          this.validations.get(binding)?.update(trigger, dismissValidations, (obj) => {\n            if (!this.options) {\n              return;\n            }\n            return this.validationRunner(obj, binding, this.options);\n          });\n        });\n      };\n      updateValidations(!isNavigationTrigger);\n      if (isNavigationTrigger) {\n        const { activeBindings } = this;\n        if (isSubset(activeBindings, lastActiveBindings)) {\n          updateValidations(true);\n        }\n      }\n    }\n    get activeBindings() {\n      return new Set(\n        Array.from(this.getBindings()).filter(\n          (b) => this.validations.get(b)?.get() !== void 0\n        )\n      );\n    }\n    getValidator(type) {\n      if (this.validatorRegistry) {\n        return this.validatorRegistry.get(type);\n      }\n      const registry = new ValidatorRegistry();\n      this.hooks.createValidatorRegistry.call(registry);\n      this.validatorRegistry = registry;\n      return registry.get(type);\n    }\n    getBindings() {\n      return this.tracker?.getBindings() ?? /* @__PURE__ */ new Set();\n    }\n    trackBinding(binding) {\n      this.tracker?.trackBinding(binding);\n    }\n    /** Executes all known validations for the tracked bindings using the given model */\n    validateView(trigger = \"navigation\") {\n      this.updateValidationsForView(trigger);\n      const validations = /* @__PURE__ */ new Map();\n      let canTransition = true;\n      this.getBindings().forEach((b) => {\n        const allValidations = this.getValidationForBinding(b)?.getAll();\n        allValidations?.forEach((v) => {\n          if (trigger === \"navigation\" && v.blocking) {\n            this.options?.logger.debug(\n              `Validation on binding: ${b.asString()} is preventing navigation. ${JSON.stringify(\n                v\n              )}`\n            );\n            canTransition = false;\n          }\n          if (!validations.has(b)) {\n            validations.set(b, v);\n          }\n        });\n      });\n      return {\n        canTransition,\n        validations: validations.size ? validations : void 0\n      };\n    }\n    /** Get the current tracked validation for the given binding */\n    getValidationForBinding(binding) {\n      return this.validations.get(binding);\n    }\n    forView(parser) {\n      return {\n        _getValidationForBinding: (binding) => {\n          return this.getValidationForBinding(\n            isBinding(binding) ? binding : parser(binding)\n          );\n        },\n        getAll: () => {\n          const bindings = this.getBindings();\n          if (bindings.size === 0) {\n            return void 0;\n          }\n          const validationMapping = /* @__PURE__ */ new Map();\n          bindings.forEach((b) => {\n            const validation = this.getValidationForBinding(b)?.get();\n            if (validation) {\n              validationMapping.set(b, validation);\n            }\n          });\n          return validationMapping.size === 0 ? void 0 : validationMapping;\n        },\n        get() {\n          throw new Error(\"Error Access be provided by the view plugin\");\n        },\n        getValidationsForBinding() {\n          throw new Error(\"Error rollup should be provided by the view plugin\");\n        },\n        getChildren() {\n          throw new Error(\"Error rollup should be provided by the view plugin\");\n        },\n        getValidationsForSection() {\n          throw new Error(\"Error rollup should be provided by the view plugin\");\n        },\n        track: () => {\n          throw new Error(\"Tracking should be provided by the view plugin\");\n        },\n        register: () => {\n          throw new Error(\n            \"Section functionality should be provided by the view plugin\"\n          );\n        },\n        type: (binding) => this.schema.getType(isBinding(binding) ? binding : parser(binding))\n      };\n    }\n  };\n  var LocalStateStore = class {\n    constructor(onUpdate) {\n      this.updateCallback = onUpdate;\n      this.state = /* @__PURE__ */ new Map();\n    }\n    removeKey(key) {\n      this.state.delete(key);\n    }\n    reset() {\n      this.state.clear();\n    }\n    useSharedState(key) {\n      return (initialState) => {\n        if (!this.state.has(key)) {\n          this.state.set(key, initialState);\n        }\n        return [\n          this.state.get(key),\n          (newState) => {\n            const current = this.state.get(key);\n            this.state.set(key, newState);\n            if (current !== newState) {\n              this.updateCallback?.();\n            }\n          }\n        ];\n      };\n    }\n    getLocalStateFunction(key, countKey) {\n      return (initialState) => {\n        if (!this.state.has(key)) {\n          this.state.set(key, []);\n        }\n        if (!this.state.has(countKey)) {\n          this.state.set(countKey, 0);\n        }\n        const localState = this.state.get(key);\n        const oldCount = this.state.get(countKey);\n        this.state.set(countKey, oldCount + 1);\n        if (localState.length <= oldCount) {\n          localState.push(initialState);\n        }\n        const value = localState[oldCount];\n        return [\n          value,\n          (newState) => {\n            const oldValue = localState[oldCount];\n            localState[oldCount] = newState;\n            if (oldValue !== newState) {\n              this.updateCallback?.();\n            }\n          }\n        ];\n      };\n    }\n  };\n  function findUp(node, target) {\n    if (node === target) {\n      return true;\n    }\n    if (node.parent) {\n      return findUp(node.parent, target);\n    }\n    return false;\n  }\n  var AssetTransformCorePlugin = class {\n    constructor(registry) {\n      this.registry = registry;\n      this.stateStore = /* @__PURE__ */ new Map();\n      this.beforeResolveSymbol = Symbol(\"before resolve\");\n      this.resolveSymbol = Symbol(\"resolve\");\n      this.beforeResolveCountSymbol = Symbol(\"before resolve count\");\n      this.resolveCountSymbol = Symbol(\"resolve count\");\n    }\n    apply(viewController) {\n      viewController.hooks.view.tap(\"asset-transform\", (view) => {\n        this.stateStore.clear();\n        view.hooks.resolver.tap(\"asset-transform\", (resolver) => {\n          let lastUpdatedNode;\n          const updateState = (node) => {\n            lastUpdatedNode = node;\n            view.update(/* @__PURE__ */ new Set());\n          };\n          const getStore = (node, stepKey) => {\n            let store;\n            const countKey = stepKey === this.resolveSymbol ? this.resolveCountSymbol : this.beforeResolveCountSymbol;\n            const storedState = this.stateStore.get(node);\n            if (storedState) {\n              store = storedState;\n              store.removeKey(countKey);\n            } else {\n              store = new LocalStateStore(() => {\n                updateState(node);\n              });\n              this.stateStore.set(node, store);\n            }\n            return {\n              useSharedState: (key) => {\n                return store.useSharedState(key);\n              },\n              useLocalState: (initialState) => {\n                return store.getLocalStateFunction(\n                  stepKey,\n                  countKey\n                )(initialState);\n              }\n            };\n          };\n          resolver.hooks.beforeResolve.tap(\"asset-transform\", (node, options) => {\n            if (node && (node.type === \"asset\" || node.type === \"view\")) {\n              const transform = this.registry.get(node.value);\n              if (transform?.beforeResolve) {\n                const store = getStore(\n                  options.node ?? node,\n                  this.beforeResolveSymbol\n                );\n                return transform.beforeResolve(node, options, store);\n              }\n            }\n            return node;\n          });\n          resolver.hooks.afterUpdate.tap(\"asset-transform\", () => {\n            lastUpdatedNode = void 0;\n          });\n          resolver.hooks.skipResolve.tap(\"asset-transform\", (skip, node) => {\n            if (!skip || !lastUpdatedNode) {\n              return skip;\n            }\n            const isParentOfUpdated = findUp(lastUpdatedNode, node);\n            const isChildOfUpdated = findUp(node, lastUpdatedNode);\n            return !isParentOfUpdated && !isChildOfUpdated;\n          });\n          resolver.hooks.afterResolve.tap(\n            \"asset-transform\",\n            (value, node, options) => {\n              if (node.type !== \"asset\" && node.type !== \"view\") {\n                return value;\n              }\n              const originalNode = resolver.getSourceNode(node);\n              if (!originalNode) {\n                return value;\n              }\n              const transform = this.registry.get(value);\n              if (transform?.resolve) {\n                const store = getStore(originalNode, this.resolveSymbol);\n                return transform?.resolve(value, options, store);\n              }\n              return value;\n            }\n          );\n        });\n      });\n    }\n  };\n  var ViewController = class {\n    constructor(initialViews, options) {\n      this.hooks = {\n        /** Do any processing before the `View` instance is created */\n        resolveView: new SyncWaterfallHook(),\n        // The hook right before the View starts resolving. Attach anything custom here\n        view: new SyncHook()\n      };\n      this.transformRegistry = new Registry();\n      this.optimizeUpdates = true;\n      this.viewOptions = options;\n      this.viewMap = initialViews.reduce(\n        (viewMap, view) => {\n          viewMap[view.id] = view;\n          return viewMap;\n        },\n        {}\n      );\n      new AssetTransformCorePlugin(this.transformRegistry).apply(this);\n      options.flowController.hooks.flow.tap(\n        \"viewController\",\n        (flow) => {\n          flow.hooks.transition.tap(\"viewController\", (_oldState, newState) => {\n            if (newState.value.state_type === \"VIEW\") {\n              this.onView(newState.value);\n            } else {\n              this.currentView = void 0;\n            }\n          });\n        }\n      );\n      const update = (updates, silent = false) => {\n        if (this.currentView) {\n          if (this.optimizeUpdates) {\n            this.queueUpdate(updates, silent);\n          } else {\n            this.currentView.update();\n          }\n        }\n      };\n      options.model.hooks.onUpdate.tap(\n        \"viewController\",\n        (updates, updateOptions) => {\n          update(\n            new Set(updates.map((t2) => t2.binding)),\n            updateOptions?.silent ?? false\n          );\n        }\n      );\n      options.model.hooks.onDelete.tap(\"viewController\", (binding) => {\n        const parentBinding = binding.parent();\n        const property = binding.key();\n        if (typeof property === \"number\" && parentBinding) {\n          update(/* @__PURE__ */ new Set([parentBinding]));\n        } else {\n          update(/* @__PURE__ */ new Set([binding]));\n        }\n      });\n    }\n    queueUpdate(bindings, silent = false) {\n      if (this.pendingUpdate?.changedBindings) {\n        this.pendingUpdate.changedBindings = /* @__PURE__ */ new Set([\n          ...this.pendingUpdate.changedBindings,\n          ...bindings\n        ]);\n      } else {\n        this.pendingUpdate = { changedBindings: bindings, scheduled: false };\n      }\n      if (!this.pendingUpdate.scheduled && !silent) {\n        this.pendingUpdate.scheduled = true;\n        (0, import_queue_microtask.default)(() => {\n          const updates = this.pendingUpdate?.changedBindings;\n          this.pendingUpdate = void 0;\n          this.currentView?.update(updates);\n        });\n      }\n    }\n    getViewForRef(viewRef) {\n      if (this.viewMap[viewRef]) {\n        return this.viewMap[viewRef];\n      }\n      const matchingViewId = Object.keys(this.viewMap).find(\n        (possibleViewIdMatch) => viewRef === resolveDataRefsInString(possibleViewIdMatch, {\n          model: this.viewOptions.model,\n          evaluate: this.viewOptions.evaluator.evaluate\n        })\n      );\n      if (matchingViewId && this.viewMap[matchingViewId]) {\n        return this.viewMap[matchingViewId];\n      }\n    }\n    onView(state) {\n      const viewId = state.ref;\n      const source = this.hooks.resolveView.call(\n        this.getViewForRef(viewId),\n        viewId,\n        state\n      );\n      if (!source) {\n        throw new Error(`No view with id ${viewId}`);\n      }\n      const view = new ViewInstance(source, this.viewOptions);\n      this.currentView = view;\n      this.hooks.view.call(view);\n      view.update();\n    }\n  };\n  var ReadOnlyDataController = class {\n    constructor(controller, logger) {\n      this.controller = controller;\n      this.logger = logger;\n    }\n    get(binding, options) {\n      return this.controller.get(binding, options);\n    }\n    set(transaction, options) {\n      this.logger?.error(\n        \"Error: Tried to set in a read only instance of the DataController\"\n      );\n      return [];\n    }\n    delete(binding, options) {\n      this.logger?.error(\n        \"Error: Tried to delete in a read only instance of the DataController\"\n      );\n    }\n  };\n  var DataController = class {\n    constructor(model, options) {\n      this.hooks = {\n        resolve: new SyncWaterfallHook(),\n        resolveDataStages: new SyncWaterfallHook(),\n        // On any set or get of an undefined value, redirect the value to be the default\n        resolveDefaultValue: new SyncBailHook(),\n        onDelete: new SyncHook(),\n        onSet: new SyncHook(),\n        onGet: new SyncHook(),\n        onUpdate: new SyncHook(),\n        format: new SyncWaterfallHook(),\n        deformat: new SyncWaterfallHook(),\n        serialize: new SyncWaterfallHook()\n      };\n      this.logger = options.logger;\n      const middleware = options.middleware || [];\n      this.baseMiddleware = [new LocalModel(model), ...middleware];\n      this.trash = /* @__PURE__ */ new Set();\n      this.pathResolver = options.pathResolver;\n    }\n    getModel() {\n      if (!this.model) {\n        const stages = this.hooks.resolveDataStages.call(this.baseMiddleware);\n        const model = new PipelinedDataModel();\n        model.setMiddleware(stages);\n        this.model = model;\n      }\n      return this.model;\n    }\n    resolveDataValue(binding, value, deformat) {\n      if (deformat) {\n        return this.hooks.deformat.call(value, binding);\n      }\n      return value;\n    }\n    set(transaction, options) {\n      let normalizedTransaction = [];\n      if (Array.isArray(transaction)) {\n        normalizedTransaction = transaction.map(([binding, value]) => {\n          const parsed = this.pathResolver.parse(binding);\n          return [\n            parsed,\n            this.resolveDataValue(parsed, value, Boolean(options?.formatted))\n          ];\n        });\n      } else {\n        normalizedTransaction = Object.keys(transaction).map(\n          (binding) => {\n            const parsed = this.pathResolver.parse(binding);\n            const val = transaction[binding];\n            return [\n              parsed,\n              this.resolveDataValue(parsed, val, Boolean(options?.formatted))\n            ];\n          }\n        );\n      }\n      const setUpdates = normalizedTransaction.reduce(\n        (updates, [binding, newVal]) => {\n          const oldVal = this.get(binding, { includeInvalid: true });\n          const update = {\n            binding,\n            newValue: newVal,\n            oldValue: oldVal\n          };\n          if (dequal(oldVal, newVal)) {\n            this.logger?.debug(\n              `Skipping update for path: ${binding.asString()}. Value was unchanged: ${oldVal}`\n            );\n          } else {\n            updates.push(update);\n            this.logger?.debug(\n              `Setting path: ${binding.asString()} from: ${oldVal} to: ${newVal}`\n            );\n          }\n          return updates;\n        },\n        []\n      );\n      const result = this.getModel().set(normalizedTransaction, options);\n      const setUpdateBindings = new Set(setUpdates.map((su) => su.binding));\n      result.forEach((tr) => {\n        if (!setUpdateBindings.has(tr.binding) && (tr.force === true || !dequal(tr.oldValue, tr.newValue))) {\n          this.logger?.debug(\n            `Path: ${tr.binding.asString()} was changed from: ${tr.oldValue} to: ${tr.newValue}`\n          );\n          setUpdates.push(tr);\n        }\n      });\n      this.hooks.onSet.call(normalizedTransaction);\n      if (setUpdates.length > 0) {\n        this.hooks.onUpdate.call(setUpdates, options);\n      }\n      return result;\n    }\n    resolve(binding, readOnly) {\n      return Array.isArray(binding) || typeof binding === \"string\" ? this.pathResolver.parse(binding, { readOnly }) : binding;\n    }\n    get(binding, options) {\n      const resolved = binding instanceof BindingInstance ? binding : this.resolve(binding, true);\n      let result = this.getModel().get(resolved, options);\n      if (result === void 0 && !options?.ignoreDefaultValue) {\n        const defaultVal = this.hooks.resolveDefaultValue.call(resolved);\n        if (defaultVal !== result) {\n          result = defaultVal;\n        }\n      }\n      if (options?.formatted) {\n        result = this.hooks.format.call(result, resolved);\n      } else if (options?.formatted === false) {\n        result = this.hooks.deformat.call(result, resolved);\n      }\n      this.hooks.onGet.call(binding, result);\n      return result;\n    }\n    delete(binding, options) {\n      if (typeof binding !== \"string\" && !Array.isArray(binding) && !(binding instanceof BindingInstance)) {\n        throw new Error(\"Invalid arguments: delete expects a data path (string)\");\n      }\n      const resolved = binding instanceof BindingInstance ? binding : this.resolve(binding, false);\n      const parentBinding = resolved.parent();\n      const property = resolved.key();\n      const parentValue = this.get(parentBinding);\n      const existedBeforeDelete = typeof parentValue === \"object\" && parentValue !== null && Object.prototype.hasOwnProperty.call(parentValue, property);\n      this.getModel().delete(resolved, options);\n      if (existedBeforeDelete && !this.get(resolved)) {\n        this.trash.add(resolved);\n      }\n      this.hooks.onDelete.call(resolved);\n    }\n    serialize() {\n      return this.hooks.serialize.call(this.get(\"\"));\n    }\n    makeReadOnly() {\n      return new ReadOnlyDataController(this, this.logger);\n    }\n  };\n  function flatten(obj, roots = [], sep = \".\") {\n    return Object.keys(obj).reduce(\n      (memo, prop) => ({\n        // create a new object\n        // include previously returned object\n        ...memo,\n        ...Object.prototype.toString.call(obj[prop]) === \"[object Object]\" ? (\n          // keep working if value is an object\n          flatten(obj[prop], roots.concat([prop]))\n        ) : (\n          // include current prop and value and prefix prop with the roots\n          { [roots.concat([prop]).join(sep)]: obj[prop] }\n        )\n      }),\n      {}\n    );\n  }\n  function objectToBatchSet(obj) {\n    const flattenedObj = flatten(obj);\n    const batchTxn = [];\n    Object.keys(flattenedObj).forEach((key) => {\n      batchTxn.push([new BindingInstance(key), flattenedObj[key]]);\n    });\n    return batchTxn;\n  }\n  var ConstantsController = class {\n    constructor() {\n      this.store = /* @__PURE__ */ new Map();\n      this.tempStore = /* @__PURE__ */ new Map();\n    }\n    addConstants(data, namespace) {\n      if (this.store.has(namespace)) {\n        this.store.get(namespace)?.set(objectToBatchSet(data));\n      } else {\n        this.store.set(namespace, new LocalModel(data));\n      }\n    }\n    getConstants(key, namespace, fallback) {\n      const path = new BindingInstance(key);\n      return this.tempStore.get(namespace)?.get(path) ?? this.store.get(namespace)?.get(path) ?? fallback;\n    }\n    setTemporaryValues(data, namespace) {\n      if (this.tempStore.has(namespace)) {\n        this.tempStore.get(namespace)?.set(objectToBatchSet(data));\n      } else {\n        this.tempStore.set(namespace, new LocalModel(data));\n      }\n    }\n    clearTemporaryValues(namespace) {\n      if (namespace) {\n        this.tempStore.get(namespace)?.reset();\n      } else {\n        this.tempStore.forEach((value) => {\n          value.reset();\n        });\n      }\n    }\n  };\n  var FlowExpPlugin = class {\n    constructor() {\n      this.name = \"flow-exp-plugin\";\n    }\n    apply(player) {\n      let expressionEvaluator;\n      const handleEval = (exp) => {\n        if (exp) {\n          if (typeof exp === \"object\" && \"exp\" in exp) {\n            expressionEvaluator?.evaluate(exp.exp);\n          } else {\n            expressionEvaluator?.evaluate(exp);\n          }\n        }\n      };\n      player.hooks.expressionEvaluator.tap(this.name, (evaluator) => {\n        expressionEvaluator = evaluator;\n      });\n      player.hooks.flowController.tap(this.name, (fc) => {\n        fc.hooks.flow.tap(this.name, (flow) => {\n          flow.hooks.onStart.tap(this.name, (exp) => handleEval(exp));\n          flow.hooks.onEnd.tap(this.name, (exp) => handleEval(exp));\n          flow.hooks.resolveTransitionNode.intercept({\n            call: (nextState) => {\n              if (nextState?.onStart) {\n                handleEval(nextState.onStart);\n              }\n            }\n          });\n        });\n      });\n    }\n  };\n  var createFormatFunction = (schema) => {\n    const handler = (ctx, value, formatName) => {\n      return schema.getFormatterForType({ type: formatName })?.format(value) ?? value;\n    };\n    return handler;\n  };\n  var DefaultExpPlugin = class {\n    constructor() {\n      this.name = \"flow-exp-plugin\";\n    }\n    apply(player) {\n      let formatFunction;\n      player.hooks.schema.tap(this.name, (schemaController) => {\n        formatFunction = createFormatFunction(schemaController);\n      });\n      player.hooks.expressionEvaluator.tap(this.name, (expEvaluator) => {\n        if (formatFunction) {\n          expEvaluator.addExpressionFunction(\"format\", formatFunction);\n        }\n        expEvaluator.addExpressionFunction(\"log\", (ctx, ...args) => {\n          player.logger.info(...args);\n        });\n        expEvaluator.addExpressionFunction(\"debug\", (ctx, ...args) => {\n          player.logger.debug(...args);\n        });\n        expEvaluator.addExpressionFunction(\n          \"eval\",\n          (ctx, ...args) => {\n            return ctx.evaluate(...args);\n          }\n        );\n      });\n    }\n  };\n  var NOT_STARTED_STATE = {\n    ref: Symbol(\"not-started\"),\n    status: \"not-started\"\n  };\n  var DefaultViewPlugin = class {\n    constructor() {\n      this.name = \"default-view-plugin\";\n    }\n    apply(player) {\n      player.hooks.viewController.tap(this.name, (viewController) => {\n        viewController.hooks.view.tap(this.name, (view) => {\n          const pluginOptions = toNodeResolveOptions(view.resolverOptions);\n          new AssetPlugin().apply(view);\n          new SwitchPlugin(pluginOptions).apply(view);\n          new ApplicabilityPlugin().apply(view);\n          new StringResolverPlugin().apply(view);\n          const templatePlugin = new TemplatePlugin(pluginOptions);\n          templatePlugin.apply(view);\n          view.hooks.onTemplatePluginCreated.call(templatePlugin);\n          new MultiNodePlugin().apply(view);\n        });\n      });\n    }\n  };\n  var PLAYER_VERSION = true ? \"0.12.0--canary.642.22872\" : \"__VERSION__\";\n  var COMMIT = true ? \"bcaf7bef6960bca2b21ead352496dacc9aff8c9b\" : \"__GIT_COMMIT__\";\n  var _Player = class _Player2 {\n    constructor(config) {\n      this.logger = new TapableLogger();\n      this.constantsController = new ConstantsController();\n      this.state = NOT_STARTED_STATE;\n      this.hooks = {\n        /** The hook that fires every time we create a new flowController (a new Content blob is passed in) */\n        flowController: new SyncHook(),\n        /** The hook that updates/handles views */\n        viewController: new SyncHook(),\n        /** A hook called every-time there's a new view. This is equivalent to the view hook on the view-controller */\n        view: new SyncHook(),\n        /** Called when an expression evaluator was created */\n        expressionEvaluator: new SyncHook(),\n        /** The hook that creates and manages data */\n        dataController: new SyncHook(),\n        /** Called after the schema is created for a flow */\n        schema: new SyncHook(),\n        /** Manages validations (schema and x-field ) */\n        validationController: new SyncHook(),\n        /** Manages parsing binding */\n        bindingParser: new SyncHook(),\n        /** A that's called for state changes in the flow execution */\n        state: new SyncHook(),\n        /** A hook to access the current flow */\n        onStart: new SyncHook(),\n        /** A hook for when the flow ends either in success or failure */\n        onEnd: new SyncHook(),\n        /** Mutate the Content flow before starting */\n        resolveFlowContent: new SyncWaterfallHook()\n      };\n      if (config?.logger) {\n        this.logger.addHandler(config.logger);\n      }\n      this.config = config || {};\n      this.config.plugins = [\n        new DefaultExpPlugin(),\n        new DefaultViewPlugin(),\n        ...this.config.plugins || [],\n        new FlowExpPlugin()\n      ];\n      this.config.plugins?.forEach((plugin) => {\n        plugin.apply(this);\n      });\n    }\n    /**  Returns currently registered plugins */\n    getPlugins() {\n      return this.config.plugins ?? [];\n    }\n    /** Find instance of [Plugin] that has been registered to Player */\n    findPlugin(symbol) {\n      return this.config.plugins?.find((el) => el.symbol === symbol);\n    }\n    /** Retrieve an instance of [Plugin] and conditionally invoke [apply] if it exists */\n    applyTo(symbol, apply) {\n      const plugin = this.findPlugin(symbol);\n      if (plugin) {\n        apply(plugin);\n      }\n    }\n    /** Register and apply [Plugin] if one with the same symbol is not already registered. */\n    registerPlugin(plugin) {\n      plugin.apply(this);\n      this.config.plugins?.push(plugin);\n    }\n    /** Returns the current version of the running player */\n    getVersion() {\n      return _Player2.info.version;\n    }\n    /** Returns the git commit used to build Player version */\n    getCommit() {\n      return _Player2.info.commit;\n    }\n    /**\n     * Fetch the current state of Player.\n     * It will return either `not-started`, `in-progress`, `completed`\n     * with some extra data in each\n     */\n    getState() {\n      return this.state;\n    }\n    /**\n     * A private means of setting the state of Player\n     * Calls the hooks for subscribers to listen for this event\n     */\n    setState(state) {\n      this.state = state;\n      this.hooks.state.call(state);\n    }\n    /** Start Player with the given flow */\n    setupFlow(userContent) {\n      const userFlow = this.hooks.resolveFlowContent.call(userContent);\n      const flowController = new FlowController(userFlow.navigation, {\n        logger: this.logger\n      });\n      this.hooks.onStart.call(userFlow);\n      this.hooks.flowController.call(flowController);\n      let expressionEvaluator;\n      let dataController;\n      const pathResolver = new BindingParser({\n        get: (binding) => {\n          return dataController.get(binding);\n        },\n        set: (transaction) => {\n          return dataController.set(transaction);\n        },\n        evaluate: (expression) => {\n          return expressionEvaluator.evaluate(expression);\n        }\n      });\n      this.hooks.bindingParser.call(pathResolver);\n      const parseBinding = pathResolver.parse;\n      const flowResultDeferred = (0, import_p_defer.default)();\n      const schema = new SchemaController(userFlow.schema);\n      this.hooks.schema.call(schema);\n      const validationController = new ValidationController(schema);\n      this.hooks.validationController.call(validationController);\n      dataController = new DataController(userFlow.data, {\n        pathResolver,\n        middleware: validationController.getDataMiddleware(),\n        logger: this.logger\n      });\n      dataController.hooks.format.tap(\"player\", (value, binding) => {\n        const formatter = schema.getFormatter(binding);\n        return formatter ? formatter.format(value) : value;\n      });\n      dataController.hooks.deformat.tap(\"player\", (value, binding) => {\n        const formatter = schema.getFormatter(binding);\n        return formatter ? formatter.deformat(value) : value;\n      });\n      dataController.hooks.resolveDefaultValue.tap(\n        \"player\",\n        (binding) => schema.getApparentType(binding)?.default\n      );\n      let viewController;\n      expressionEvaluator = new ExpressionEvaluator({\n        model: dataController,\n        logger: this.logger\n      });\n      this.hooks.expressionEvaluator.call(expressionEvaluator);\n      expressionEvaluator.hooks.onError.tap(\"player\", (e) => {\n        flowResultDeferred.reject(e);\n        return true;\n      });\n      function resolveStrings(val, formatted) {\n        return resolveDataRefs(val, {\n          model: dataController,\n          evaluate: expressionEvaluator.evaluate,\n          formatted\n        });\n      }\n      flowController.hooks.flow.tap(\"player\", (flow) => {\n        flow.hooks.beforeTransition.tap(\"player\", (state, transitionVal) => {\n          const computedTransitionVal = state.transitions[transitionVal] ? transitionVal : \"*\";\n          if (state.onEnd && state.transitions[computedTransitionVal]) {\n            if (typeof state.onEnd === \"object\" && \"exp\" in state.onEnd) {\n              expressionEvaluator?.evaluate(state.onEnd.exp);\n            } else {\n              expressionEvaluator?.evaluate(state.onEnd);\n            }\n          }\n          if (!(\"transitions\" in state) || !state.transitions[computedTransitionVal]) {\n            return state;\n          }\n          return (0, import_timm8.setIn)(\n            state,\n            [\"transitions\", computedTransitionVal],\n            resolveStrings(state.transitions[computedTransitionVal])\n          );\n        });\n        flow.hooks.skipTransition.tap(\"validation\", (currentState) => {\n          if (currentState?.value.state_type === \"VIEW\") {\n            const { canTransition, validations } = validationController.validateView(\"navigation\");\n            if (!canTransition && validations) {\n              const bindings = new Set(validations.keys());\n              viewController?.currentView?.update(bindings);\n              return true;\n            }\n          }\n          return void 0;\n        });\n        flow.hooks.resolveTransitionNode.tap(\"player\", (state) => {\n          let newState = state;\n          if (\"ref\" in state) {\n            newState = (0, import_timm8.setIn)(state, [\"ref\"], resolveStrings(state.ref));\n          }\n          if (\"param\" in state) {\n            newState = (0, import_timm8.setIn)(\n              state,\n              [\"param\"],\n              resolveStrings(state.param, false)\n            );\n          }\n          return newState;\n        });\n        flow.hooks.transition.tap(\"player\", (_oldState, newState) => {\n          if (newState.value.state_type !== \"VIEW\") {\n            validationController.reset();\n          }\n        });\n        flow.hooks.afterTransition.tap(\"player\", (flowInstance) => {\n          const value = flowInstance.currentState?.value;\n          if (value && value.state_type === \"ACTION\") {\n            const { exp } = value;\n            flowController?.transition(\n              String(expressionEvaluator?.evaluate(exp))\n            );\n          }\n          expressionEvaluator.reset();\n        });\n      });\n      this.hooks.dataController.call(dataController);\n      validationController.setOptions({\n        parseBinding,\n        model: dataController,\n        logger: this.logger,\n        evaluate: expressionEvaluator.evaluate,\n        constants: this.constantsController\n      });\n      viewController = new ViewController(userFlow.views || [], {\n        evaluator: expressionEvaluator,\n        parseBinding,\n        transition: flowController.transition,\n        model: dataController,\n        utils: {\n          findPlugin: (pluginSymbol) => {\n            return this.findPlugin(pluginSymbol);\n          }\n        },\n        logger: this.logger,\n        flowController,\n        schema,\n        format: (binding, value) => {\n          const formatter = schema.getFormatter(binding);\n          return formatter?.format ? formatter.format(value) : value;\n        },\n        formatValue: (ref, value) => {\n          const formatter = schema.getFormatterForType(ref);\n          return formatter?.format ? formatter.format(value) : value;\n        },\n        validation: {\n          ...validationController.forView(parseBinding),\n          type: (b) => schema.getType(parseBinding(b))\n        },\n        constants: this.constantsController\n      });\n      viewController.hooks.view.tap(\"player\", (view) => {\n        validationController.onView(view);\n        this.hooks.view.call(view);\n      });\n      this.hooks.viewController.call(viewController);\n      return {\n        start: () => {\n          flowController.start().then((endState) => {\n            const flowResult = {\n              endState: resolveStrings(endState, false),\n              data: dataController.serialize()\n            };\n            return flowResult;\n          }).then(flowResultDeferred.resolve).catch((e) => {\n            this.logger.error(`Something went wrong: ${e.message}`);\n            throw e;\n          }).catch(flowResultDeferred.reject).finally(() => this.hooks.onEnd.call());\n        },\n        state: {\n          status: \"in-progress\",\n          flowResult: flowResultDeferred.promise,\n          controllers: {\n            data: dataController,\n            view: viewController,\n            flow: flowController,\n            schema,\n            expression: expressionEvaluator,\n            binding: pathResolver,\n            validation: validationController\n          },\n          fail: flowResultDeferred.reject,\n          flow: userFlow,\n          logger: this.logger\n        }\n      };\n    }\n    async start(payload) {\n      const ref = Symbol(payload?.id ?? \"payload\");\n      const maybeUpdateState = (newState) => {\n        if (this.state.ref !== ref) {\n          this.logger.warn(\n            `Received update for a flow that's not the current one`\n          );\n          return newState;\n        }\n        this.setState(newState);\n        return newState;\n      };\n      this.setState({\n        status: \"not-started\",\n        ref\n      });\n      try {\n        const { state, start } = this.setupFlow(payload);\n        this.setState({\n          ref,\n          ...state\n        });\n        start();\n        const endProps = {\n          ref,\n          status: \"completed\",\n          flow: state.flow,\n          controllers: {\n            data: state.controllers.data.makeReadOnly()\n          }\n        };\n        return maybeUpdateState({\n          ...await state.flowResult,\n          ...endProps\n        });\n      } catch (error) {\n        const errorState = {\n          status: \"error\",\n          ref,\n          flow: payload,\n          error\n        };\n        maybeUpdateState(errorState);\n        throw error;\n      }\n    }\n  };\n  _Player.info = {\n    version: PLAYER_VERSION,\n    commit: COMMIT\n  };\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/check-path/core/src/symbols.ts\n  var CheckPathPluginSymbol = Symbol.for(\"CheckPathPlugin\");\n\n  // ../../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/plugins/check-path/core/src/index.ts\n  function createMatcher2(match) {\n    if (typeof match === \"string\" || typeof match === \"number\") {\n      return createMatcher({ type: match });\n    }\n    if (typeof match === \"function\") {\n      return match;\n    }\n    return createMatcher(match);\n  }\n  function getParent(node, viewInfo) {\n    let working = node;\n    while (working.parent && working.parent.type !== NodeType.Asset && working.parent.type !== NodeType.View) {\n      working = working.parent;\n    }\n    const { parent } = working;\n    if (parent && (parent.type === NodeType.Asset || parent.type === NodeType.View)) {\n      return parent;\n    }\n  }\n  var CheckPathPlugin = class {\n    constructor() {\n      this.name = \"check-path\";\n      this.symbol = CheckPathPluginSymbol;\n    }\n    apply(player) {\n      player.hooks.viewController.tap(this.name, (viewController) => {\n        viewController.hooks.view.tap(this.name, (view) => {\n          view.hooks.resolver.tap(this.name, (resolver) => {\n            const viewInfo = {\n              resolvedMap: /* @__PURE__ */ new Map(),\n              assetIdMap: /* @__PURE__ */ new Map(),\n              resolver\n            };\n            this.viewInfo = viewInfo;\n            resolver.hooks.afterResolve.tap(this.name, (value, node) => {\n              const sourceNode = this.getSourceAssetNode(node);\n              if (sourceNode) {\n                viewInfo.resolvedMap.set(sourceNode, {\n                  resolved: node,\n                  value\n                });\n                if (node.type === NodeType.Asset || node.type === NodeType.View) {\n                  const id = dlv_es_default(value, \"id\");\n                  if (id) {\n                    viewInfo.assetIdMap.set(id, node);\n                  }\n                }\n              }\n              return value;\n            });\n          });\n        });\n      });\n    }\n    /**\n     * Starts at the asset with the given id, and walks backwards _up_ the tree until it finds a match for the parent\n     *\n     * @param id - The id of the asset to _start_ at\n     * @param query - A means of matching a parent asset\n     * @returns - The parent object if a match is found, else undefined\n     */\n    getParent(id, query) {\n      const assetNode = this.viewInfo?.assetIdMap.get(id);\n      if (!assetNode || !this.viewInfo) {\n        return void 0;\n      }\n      let potentialMatch = getParent(assetNode);\n      if (query === void 0) {\n        if (potentialMatch) {\n          return this.getAssetFromAssetNode(potentialMatch);\n        }\n        return;\n      }\n      const queryArray = Array.isArray(query) ? [...query] : [query];\n      let parentQuery = queryArray.shift();\n      let depth = 0;\n      while (potentialMatch && parentQuery) {\n        if (depth++ >= 50) {\n          throw new Error(\n            \"Recursion depth exceeded. Check for cycles in the AST graph\"\n          );\n        }\n        const matcher = createMatcher2(parentQuery);\n        const resolved = this.getAssetFromAssetNode(potentialMatch);\n        if (resolved && matcher(resolved)) {\n          if (queryArray.length === 0) {\n            return resolved;\n          }\n          parentQuery = queryArray.shift();\n        }\n        potentialMatch = getParent(potentialMatch);\n      }\n      return void 0;\n    }\n    /**\n     * Returns the property that the asset resides on relative to it's parent\n     *\n     * @param id - The id of the asset to _start_ at\n     * @returns - The property name or undefined if no parent was found\n     */\n    getParentProp(id) {\n      const assetNode = this.viewInfo?.assetIdMap.get(id);\n      if (!assetNode || !this.viewInfo) {\n        return;\n      }\n      let working = assetNode;\n      let parent;\n      while (working) {\n        parent = working?.parent;\n        if (parent && (parent.type === NodeType.Asset || parent.type === NodeType.View)) {\n          break;\n        }\n        working = working?.parent;\n      }\n      if (parent && \"children\" in parent) {\n        const childProp = parent.children?.find(\n          (child) => child.value === working\n        );\n        return childProp?.path?.[0];\n      }\n      return void 0;\n    }\n    /** Given a node, return itself, or the nested asset if the node is an applicability node */\n    getSourceAssetNode(node) {\n      let sourceNode = this.viewInfo?.resolver.getSourceNode(node);\n      if (sourceNode?.type === \"applicability\") {\n        sourceNode = sourceNode.value;\n      }\n      return sourceNode;\n    }\n    /**\n     * Given the starting node, check to verify that the supplied queries are relevant to the current asset's parents.\n     *\n     * @param id - The id of the asset to _start_ at\n     * @returns - true if the context applies, false if it doesn't\n     */\n    hasParentContext(id, query) {\n      return Boolean(this.getParent(id, query));\n    }\n    /** Search the node for any matching paths in the graph that match the query  */\n    findChildPath(node, query, includeSelfMatch = true) {\n      if (query.length === 0) {\n        return true;\n      }\n      const [first, ...rest] = query;\n      const matcher = createMatcher2(first);\n      if (node.type === NodeType.Asset || node.type === NodeType.View || node.type === NodeType.Applicability) {\n        const resolvedValue = this.getResolvedValue(node);\n        const includesSelf = (includeSelfMatch && matcher(resolvedValue)) ?? false;\n        const childQuery = includesSelf ? rest : query;\n        if (childQuery.length === 0 && includesSelf) {\n          return true;\n        }\n        const children = node.type === NodeType.Applicability ? node.value.children : node.children;\n        if (childQuery.length && (!children || children.length === 0)) {\n          return false;\n        }\n        if (children?.some(\n          (childNode) => this.findChildPath(childNode.value, childQuery)\n        )) {\n          return true;\n        }\n      } else if (node.type === NodeType.MultiNode && node.values.some((childNode) => this.findChildPath(childNode, query))) {\n        return true;\n      } else if (\"children\" in node && node.children?.some(\n        (childNode) => this.findChildPath(childNode.value, query)\n      )) {\n        return true;\n      }\n      return false;\n    }\n    /**\n     * Given the starting node, check to verify that the supplied queries are relevant to the current asset's children.\n     *\n     * @param id - The id of the asset to _start_ at\n     * @returns - true if the context applies, false if it doesn't\n     */\n    hasChildContext(id, query) {\n      const assetNode = this.viewInfo?.assetIdMap.get(id);\n      const queryArray = Array.isArray(query) ? [...query] : [query];\n      if (!assetNode) {\n        return false;\n      }\n      return this.findChildPath(assetNode, queryArray, false);\n    }\n    /** Get the asset represented by id */\n    getAsset(id) {\n      const assetNode = this.viewInfo?.assetIdMap.get(id);\n      if (!assetNode)\n        return;\n      return this.getAssetFromAssetNode(assetNode);\n    }\n    /**\n     * Gets the value for an asset from an asset node\n     */\n    getAssetFromAssetNode(assetNode) {\n      const sourceNode = this.getSourceAssetNode(assetNode);\n      if (!sourceNode)\n        return;\n      return this.viewInfo?.resolvedMap.get(sourceNode)?.value;\n    }\n    /**\n     * Get the path of the asset in the view upto\n     * the asset that matches the query or to the view if no query is provided\n     */\n    getPath(id, query) {\n      const assetNode = this.viewInfo?.assetIdMap.get(id);\n      if (!assetNode || !this.viewInfo) {\n        return;\n      }\n      let path = [];\n      let queryArray = [];\n      if (query) {\n        queryArray = Array.isArray(query) ? [...query] : [query];\n      }\n      let parentQuery = queryArray.shift();\n      let working = assetNode;\n      const findWorkingChild = (parent) => {\n        return parent.children?.find((n) => n.value === working);\n      };\n      while (working !== void 0) {\n        const { parent } = working;\n        if (parent) {\n          if (parent.type === NodeType.MultiNode) {\n            const index = parent.values.indexOf(working);\n            if (index !== -1) {\n              const actualIndex = index - parent.values.slice(0, index).reduce(\n                (undefCount, next) => this.getResolvedValue(next) === void 0 ? undefCount + 1 : undefCount,\n                0\n              );\n              path = [actualIndex, ...path];\n            }\n          } else if (\"children\" in parent) {\n            const childProp = findWorkingChild(parent);\n            path = [...childProp?.path ?? [], ...path];\n          }\n          if (parentQuery) {\n            const matcher = createMatcher2(parentQuery);\n            if (matcher(this.getResolvedValue(parent))) {\n              parentQuery = queryArray.shift();\n              if (!parentQuery)\n                return path;\n            }\n          }\n        }\n        working = working.parent;\n      }\n      return parentQuery ? void 0 : path;\n    }\n    getResolvedValue(node) {\n      const sourceNode = this.getSourceAssetNode(node);\n      return this.viewInfo?.resolvedMap.get(sourceNode ?? node)?.value;\n    }\n  };\n  return __toCommonJS(src_exports);\n})();\n/*! Bundled license information:\n\ntimm/lib/timm.js:\n  (*!\n   * Timm\n   *\n   * Immutability helpers with fast reads and acceptable writes.\n   *\n   * @copyright Guillermo Grau Panea 2016\n   * @license MIT\n   *)\n\nqueue-microtask/index.js:\n  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n*/\n","/**\n * Checks if `value` is equal to `check` if `check` is a string or in `check` if check is an Array\n *\n * @param value - the value being searched for\n * @param check - the values to check against\n * @returns `boolean`\n */\nexport function equalToOrIn(value: string, check: string | Array<string>) {\n  if (Array.isArray(check)) {\n    return check.includes(value);\n  }\n\n  return check === value;\n}\n","import { equalToOrIn } from \"./utils\";\n\nexport type Interceptor<Args extends any[], ReturnType, ContextType> = {\n  /** An optional name for the interceptor */\n  name?: string;\n  /** Callback for each loop when used by the hook */\n  loop?: (...args: Args) => void;\n  /** Callback when an error occurs during the hook's call */\n  error?: (err: Error) => void;\n  /** Callback when a result is found for a hook's invocation */\n  result?: (\n    r: ReturnType extends Promise<infer AwaitedValue>\n      ? AwaitedValue\n      : ReturnType\n  ) => void;\n  /** Callback when a hook's call is complete */\n  done?: () => void;\n  /** Callback when a hook is tapped */\n  tap?: (tap: Tap<Args, ReturnType, ContextType>) => void;\n} & (\n  | {\n      /** If context should be omitted from the 'call'. This is the default */\n      context?: false;\n      /** Callback when the hook is tapped without context */\n      call?: (...args: Args) => void;\n    }\n  | {\n      /** If context should be included in the 'call' */\n      context: true;\n      /** Callback when the hook is tapped with context */\n      call?: (context: ContextType, ...args: Args) => void;\n    }\n);\n\nexport type Tap<Args extends any[], ReturnType, ContextType = unknown> = {\n  key: symbol;\n  name: string;\n  before?: string | Array<string>;\n} & (\n  | {\n      context: false;\n      callback: (...args: Args) => ReturnType;\n    }\n  | {\n      context: true;\n      callback: (context: ContextType, ...args: Args) => ReturnType;\n    }\n);\n\ntype BasicTap<Args extends any[], ReturnType, ContextType> = (\n  name: string,\n  callback: (...args: Args) => ReturnType,\n  before?: string | Array<string>\n) => Tap<Args, ReturnType, ContextType>;\n\ntype TapWithContext<Args extends any[], ReturnType, ContextType> =\n  | ((\n      options: {\n        name: string;\n        context?: false;\n        before?: string | Array<string>;\n      },\n      callback: (...args: Args) => ReturnType\n    ) => Tap<Args, ReturnType>)\n  | ((\n      options: {\n        name: string;\n        context: true;\n        before?: string | Array<string>;\n      },\n      callback: (context: ContextType, ...args: Args) => ReturnType\n    ) => Tap<Args, ReturnType>);\n\ninterface SyncBaseHookType<Args extends any[], ReturnType, ContextType> {\n  tap:\n    | BasicTap<Args, ReturnType, ContextType>\n    | TapWithContext<Args, ReturnType, ContextType>;\n  call(...args: Args): void;\n  untap(key: Tap<Args, ReturnType>): void;\n  isUsed(): boolean;\n  intercept(int: Interceptor<Args, ReturnType, ContextType>): void;\n}\n\nfunction callTap<Args extends any[], ReturnType, ContextType>(\n  tap: Tap<Args, ReturnType, ContextType>,\n  args: Args,\n  ctx: ContextType\n) {\n  if (tap.context) {\n    return tap.callback(ctx, ...args);\n  }\n\n  return tap.callback(...args);\n}\n\n/** A manager for all intercepts inside of a tap */\nclass InterceptionManager<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> {\n  protected interceptions: Array<Interceptor<Args, ReturnType, ContextType>>;\n  private interceptionKeySet: Set<\n    keyof Interceptor<Args, ReturnType, ContextType>\n  >;\n\n  constructor() {\n    this.interceptions = [];\n    this.interceptionKeySet = new Set();\n  }\n\n  isUsed() {\n    return this.interceptions.length > 0;\n  }\n\n  intercept(int: Interceptor<Args, ReturnType, ContextType>): void {\n    this.interceptions.push(int);\n    Object.keys(int).forEach((s) => {\n      this.interceptionKeySet.add(s as any);\n    });\n  }\n\n  tap(tap: Tap<Args, ReturnType, ContextType>): void {\n    if (this.interceptionKeySet.has(\"tap\")) {\n      this.interceptions.forEach((i) => {\n        i.tap?.(tap);\n      });\n    }\n  }\n\n  call(ctx: ContextType, ...args: Args): void {\n    if (this.interceptionKeySet.has(\"call\")) {\n      this.interceptions.forEach((i) => {\n        if (i.context) {\n          i.call?.(ctx, ...args);\n        } else {\n          i.call?.(...args);\n        }\n      });\n    }\n  }\n\n  loop(...args: Args): void {\n    if (this.interceptionKeySet.has(\"loop\")) {\n      this.interceptions.forEach((i) => {\n        i.loop?.(...args);\n      });\n    }\n  }\n\n  error(err: unknown): void {\n    if (this.interceptionKeySet.has(\"error\")) {\n      if (err instanceof Error) {\n        const asError: Error = err;\n        this.interceptions.forEach((i) => {\n          i.error?.(asError);\n        });\n      }\n    }\n  }\n\n  result(\n    r: ReturnType extends Promise<infer AwaitedValue>\n      ? AwaitedValue\n      : ReturnType\n  ): void {\n    if (this.interceptionKeySet.has(\"result\")) {\n      this.interceptions.forEach((i) => {\n        i.result?.(r);\n      });\n    }\n  }\n\n  done(): void {\n    if (this.interceptionKeySet.has(\"done\")) {\n      this.interceptions.forEach((i) => {\n        i.done?.();\n      });\n    }\n  }\n}\n\nabstract class Hook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> implements SyncBaseHookType<Args, ReturnType, ContextType>\n{\n  protected taps: Array<Tap<Args, ReturnType, ContextType>>;\n  protected interceptions: InterceptionManager<Args, ReturnType, ContextType>;\n\n  constructor() {\n    this.taps = [];\n    this.interceptions = new InterceptionManager<\n      Args,\n      ReturnType,\n      ContextType\n    >();\n  }\n\n  public tap(\n    options: { name: string; context?: false; before?: string | Array<string> },\n    callback: (...args: Args) => ReturnType\n  ): Tap<Args, ReturnType, ContextType>;\n\n  public tap(\n    options: { name: string; context: true; before?: string | Array<string> },\n    callback: (ctx: ContextType, ...args: Args) => ReturnType\n  ): Tap<Args, ReturnType, ContextType>;\n\n  public tap(\n    name: string,\n    callback: (...args: Args) => ReturnType\n  ): Tap<Args, ReturnType, ContextType>;\n\n  public tap(options: any, callback: any): Tap<Args, ReturnType, ContextType> {\n    const resolvedOptions =\n      typeof options === \"string\"\n        ? {\n            name: options,\n            context: false,\n          }\n        : {\n            context: false,\n            ...options,\n          };\n\n    const key = Symbol(resolvedOptions.name);\n    const tap: Tap<Args, ReturnType, ContextType> = {\n      key,\n      ...resolvedOptions,\n      callback,\n    };\n\n    if (tap.before) {\n      let insertionIndex = this.taps.length;\n      const beforeSet = new Set(\n        Array.isArray(tap.before) ? tap.before : [tap.before]\n      );\n      for (\n        insertionIndex;\n        insertionIndex > 0 && beforeSet.size > 0;\n        insertionIndex--\n      ) {\n        const t = this.taps[insertionIndex - 1];\n        if (beforeSet.has(t.name)) {\n          beforeSet.delete(t.name);\n        }\n\n        if (t.before && equalToOrIn(tap.name, t.before)) {\n          break;\n        }\n      }\n\n      this.taps.splice(insertionIndex, 0, tap);\n    } else {\n      this.taps.push(tap);\n    }\n\n    this.interceptions.tap(tap);\n\n    return tap;\n  }\n\n  abstract call(...args: Args): ReturnType;\n\n  public untap(tap: Tap<Args, ReturnType, ContextType>) {\n    this.taps = this.taps.filter((t) => t.key !== tap.key);\n  }\n\n  public isUsed() {\n    return this.taps.length > 0 || this.interceptions.isUsed();\n  }\n\n  public intercept(int: Interceptor<Args, ReturnType, ContextType>): void {\n    this.interceptions.intercept(int);\n  }\n}\n\nexport class SyncHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, void, ContextType> {\n  public call(...args: Args) {\n    if (!this.isUsed()) {\n      return;\n    }\n\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      this.taps.forEach((t) => {\n        callTap(t, args, ctx);\n      });\n    } catch (err: unknown) {\n      this.interceptions.error(err);\n\n      throw err;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class SyncBailHook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> extends Hook<Args, ReturnType | undefined | null, ContextType> {\n  public call(...args: Args): ReturnType | undefined | null {\n    if (!this.isUsed()) {\n      return;\n    }\n\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n      const rtn = callTap(this.taps[tapIndex], args, ctx);\n      if (rtn !== undefined) {\n        this.interceptions.result(rtn as any);\n        return rtn;\n      }\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class SyncWaterfallHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Args[0], ContextType> {\n  public call(...args: Args): Args[0] {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    // eslint-disable-next-line prefer-const\n    let [rtn, ...rest] = args;\n\n    for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n      const tapValue = callTap(this.taps[tapIndex], [rtn, ...rest] as any, ctx);\n      if (tapValue !== undefined) {\n        rtn = tapValue;\n      }\n    }\n\n    this.interceptions.result(rtn);\n\n    return rtn;\n  }\n}\n\nexport class SyncLoopHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, void, ContextType> {\n  public call(...args: Args) {\n    let finished = false;\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      while (finished !== true) {\n        finished = true;\n        this.interceptions.loop(...args);\n        for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n          const rtn = callTap(this.taps[tapIndex], args, ctx);\n\n          if (rtn !== undefined) {\n            finished = false;\n            break;\n          }\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncParallelHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<void>, ContextType> {\n  public async call(...args: Args): Promise<void> {\n    const ctx: ContextType = {} as any;\n    this.interceptions.call(ctx, ...args);\n\n    await Promise.allSettled(this.taps.map((tap) => callTap(tap, args, ctx)));\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncParallelBailHook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<ReturnType>, ContextType> {\n  public async call(...args: Args): Promise<ReturnType> {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      const rtn = await Promise.race(\n        this.taps.map((tap) => callTap(tap, args, ctx))\n      );\n\n      this.interceptions.result(rtn as any);\n      return rtn;\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n  }\n}\n\nexport class AsyncSeriesHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<void>, ContextType> {\n  public async call(...args: Args): Promise<void> {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        await callTap(this.taps[tapIndex], args, ctx);\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncSeriesBailHook<\n  Args extends any[],\n  ReturnType,\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<ReturnType | undefined | null>, ContextType> {\n  public async call(...args: Args): Promise<ReturnType | undefined | null> {\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        const rtn = await callTap(this.taps[tapIndex], args, ctx);\n        if (rtn !== undefined) {\n          this.interceptions.result(rtn);\n          return rtn;\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n\nexport class AsyncSeriesWaterfallHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<Args[0]>, ContextType> {\n  public async call(...args: Args): Promise<Args[0]> {\n    // eslint-disable-next-line prefer-const\n    let [rtn, ...rest] = args;\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n        const tapValue = await callTap(\n          this.taps[tapIndex],\n          [rtn, ...rest] as any,\n          ctx\n        );\n        if (tapValue !== undefined) {\n          rtn = tapValue;\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.result(rtn);\n\n    return rtn;\n  }\n}\n\nexport class AsyncSeriesLoopHook<\n  Args extends any[],\n  ContextType = Record<string, any>\n> extends Hook<Args, Promise<void>, ContextType> {\n  public async call(...args: Args): Promise<void> {\n    let finished = false;\n    const ctx: ContextType = {} as any;\n\n    this.interceptions.call(ctx, ...args);\n\n    try {\n      while (finished !== true) {\n        finished = true;\n        this.interceptions.loop(...args);\n        for (let tapIndex = 0; tapIndex < this.taps.length; tapIndex += 1) {\n          const rtn = await callTap(this.taps[tapIndex], args, ctx);\n\n          if (rtn !== undefined) {\n            finished = false;\n            break;\n          }\n        }\n      }\n    } catch (e: unknown) {\n      this.interceptions.error(e);\n      throw e;\n    }\n\n    this.interceptions.done();\n  }\n}\n","export default function dlv(obj, key, def, p, undef) {\n\tkey = key.split ? key.split('.') : key;\n\tfor (p = 0; p < key.length; p++) {\n\t\tobj = obj ? obj[key[p]] : undef;\n\t}\n\treturn obj === undef ? def : obj;\n}\n","var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import dlv from \"dlv\";\n\n/** A function that checks overlapping properties against a reference value */\nexport type Matcher = ((searchObj: object) => boolean) & {\n  /** The count represents the specificity of this matcher */\n  count: number;\n};\n\n/** Traverse an object and collect any key/value pairs including nested keys */\nfunction traverseObj(\n  object: Record<any, any>,\n  path: string[] = [],\n  pairs: Map<string[], any> = new Map(),\n): Map<string[], any> {\n  for (const key of Object.keys(object)) {\n    const val: any = object[key];\n    const nestedPath = [...path, key];\n\n    if (typeof val === \"object\") {\n      traverseObj(val, nestedPath, pairs);\n    } else {\n      pairs.set(nestedPath, val);\n    }\n  }\n\n  return pairs;\n}\n\n/** Given an object, create a function that compares any set key/value pairs in the given object against a new value */\nexport default function createMatcher(partialObj: object): Matcher {\n  // Convert the partial object into a list of [key, value] pairs;\n  const pairs = traverseObj(partialObj);\n\n  /** Generate a function to match against all of the properties we care about */\n  const matchFunction = (searchObj: object) => {\n    for (const entry of Array.from(pairs)) {\n      const [path, value] = entry;\n\n      if (dlv(searchObj, path) !== value) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  // Keep track of the specificity of the comparator\n  matchFunction.count = pairs.size;\n\n  return matchFunction;\n}\n","import SortedArray from \"sorted-array\";\nimport type { Matcher } from \"./deep-partial-matcher\";\nimport createObjectMatcher from \"./deep-partial-matcher\";\n\nexport { default as createObjectMatcher } from \"./deep-partial-matcher\";\n\n/** create a matcher function that matches exactly */\nfunction createBasicMatcher(seed: any): Matcher {\n  /** a simple matcher function that only matches itself */\n  const matcher = (match: any) => seed === match;\n  matcher.count = 1;\n\n  return matcher;\n}\n\ninterface RegistryIndex<V> {\n  /** The original object we wanted to match on  */\n  key: object;\n\n  /** The value to return */\n  value: V;\n\n  /** The matcher function for this entry */\n  matcher: Matcher;\n}\n\n/** create an empty sorted array using the matcher count */\nconst createSortedArray = <V>() =>\n  new SortedArray<RegistryIndex<V>>([], (c) => c.matcher.count);\n\n/**\n * A partial match registry is a map that uses an object to \"match\" against keys.\n * More specific matches take precedence over less specific ones.\n */\nexport class Registry<V> {\n  private store = createSortedArray<V>();\n\n  constructor(initialSet?: Array<[any, V]>) {\n    initialSet?.forEach(([match, value]) => {\n      this.set(match, value);\n    });\n  }\n\n  /** Add match -> value mapping to the registry */\n  set(match: any, value: V) {\n    const matcher =\n      typeof match === \"object\"\n        ? createObjectMatcher(match)\n        : createBasicMatcher(match);\n\n    this.store.insert({\n      key: match,\n      value,\n      matcher,\n    });\n  }\n\n  /** Fetch the best match in the registry */\n  get(query: any): V | undefined {\n    for (const entry of this.store.array) {\n      if (entry.matcher(query)) {\n        return entry.value;\n      }\n    }\n  }\n\n  /** Loop over all entries and run callback */\n  forEach(callbackfn: (value: RegistryIndex<V>) => void): void {\n    for (const entry of this.store.array) {\n      callbackfn(entry);\n    }\n  }\n\n  /** Reset the items in the registry */\n  clear() {\n    this.store = createSortedArray<V>();\n  }\n\n  /** Check if the registry is empty*/\n  isRegistryEmpty() {\n    return this.store.array.length === 0;\n  }\n}\n","var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/index.ts\nexport * from \"@player-ui/types\";\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/index.ts\nimport { SyncBailHook, SyncWaterfallHook } from \"tapable-ts\";\nimport { NestedError as NestedError2 } from \"ts-nested-error\";\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding-grammar/ast.ts\nvar toValue = (value) => ({\n  name: \"Value\",\n  value\n});\nvar toExpression = (value) => ({\n  name: \"Expression\",\n  value\n});\nvar toPath = (path) => ({\n  name: \"PathNode\",\n  path\n});\nvar toQuery = (key, value) => ({\n  name: \"Query\",\n  key,\n  value\n});\nvar toConcatenatedNode = (values) => {\n  if (values.length === 1) {\n    return values[0];\n  }\n  return {\n    name: \"Concatenated\",\n    value: values\n  };\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding-grammar/custom/index.ts\nvar SEGMENT_SEPARATOR = \".\";\nvar OPEN_CURL = \"{\";\nvar CLOSE_CURL = \"}\";\nvar OPEN_BRACKET = \"[\";\nvar CLOSE_BRACKET = \"]\";\nvar EQUALS = \"=\";\nvar SINGLE_QUOTE = \"'\";\nvar DOUBLE_QUOTE = '\"';\nvar BACK_TICK = \"`\";\nvar isIdentifierChar = (char) => {\n  if (!char) {\n    return false;\n  }\n  const charCode = char.charCodeAt(0);\n  const matches = charCode === 32 || // ' '\n  charCode === 34 || // \"\n  charCode === 39 || // '\n  charCode === 40 || // (\n  charCode === 41 || // )\n  charCode === 42 || // *\n  charCode === 46 || // .\n  charCode === 61 || // =\n  charCode === 91 || // [\n  charCode === 93 || // ]\n  charCode === 96 || // `\n  charCode === 123 || // {\n  charCode === 125;\n  return !matches;\n};\nvar parse = (path) => {\n  let index = 1;\n  let ch = path.charAt(0);\n  const next = (expected) => {\n    if (expected && ch !== expected) {\n      throw new Error(`Expected char: ${expected} but got: ${ch}`);\n    }\n    ch = path.charAt(index);\n    index += 1;\n    return ch;\n  };\n  const whitespace = () => {\n    while (ch === \" \") {\n      next();\n    }\n  };\n  const identifier = () => {\n    if (!isIdentifierChar(ch)) {\n      return;\n    }\n    let value = ch;\n    while (next()) {\n      if (!isIdentifierChar(ch)) {\n        break;\n      }\n      value += ch;\n    }\n    if (value) {\n      const maybeNumber = Number(value);\n      value = isNaN(maybeNumber) ? value : maybeNumber;\n      return toValue(value);\n    }\n  };\n  const expression = () => {\n    if (ch === BACK_TICK) {\n      next(BACK_TICK);\n      let exp = ch;\n      while (next()) {\n        if (ch === BACK_TICK) {\n          break;\n        }\n        exp += ch;\n      }\n      next(BACK_TICK);\n      if (exp) {\n        return toExpression(exp);\n      }\n    }\n  };\n  const regex = (match) => {\n    if (!ch?.match(match)) {\n      return;\n    }\n    let value = ch;\n    while (next()) {\n      if (!ch?.match(match)) {\n        break;\n      }\n      value += ch;\n    }\n    if (value) {\n      return toValue(value);\n    }\n  };\n  const nestedPath = () => {\n    if (ch === OPEN_CURL) {\n      next(OPEN_CURL);\n      next(OPEN_CURL);\n      const modelRef = parsePath();\n      next(CLOSE_CURL);\n      next(CLOSE_CURL);\n      return modelRef;\n    }\n  };\n  const simpleSegment = () => nestedPath() ?? expression() ?? identifier();\n  const segment = () => {\n    const segments = [];\n    let nextSegment = simpleSegment();\n    while (nextSegment !== void 0) {\n      segments.push(nextSegment);\n      nextSegment = simpleSegment();\n    }\n    if (segments.length === 0) {\n      return void 0;\n    }\n    return toConcatenatedNode(segments);\n  };\n  const optionallyQuotedSegment = () => {\n    whitespace();\n    if (ch === SINGLE_QUOTE || ch === DOUBLE_QUOTE) {\n      const singleQuote = ch === SINGLE_QUOTE;\n      next(singleQuote ? SINGLE_QUOTE : DOUBLE_QUOTE);\n      const id = regex(/[^'\"]+/);\n      next(singleQuote ? SINGLE_QUOTE : DOUBLE_QUOTE);\n      return id;\n    }\n    return simpleSegment();\n  };\n  const equals = () => {\n    if (ch !== EQUALS) {\n      return false;\n    }\n    while (ch === EQUALS) {\n      next();\n    }\n    return true;\n  };\n  const parseBracket = () => {\n    if (ch === OPEN_BRACKET) {\n      next(OPEN_BRACKET);\n      whitespace();\n      let value = optionallyQuotedSegment();\n      if (value) {\n        whitespace();\n        if (equals()) {\n          whitespace();\n          const second = optionallyQuotedSegment();\n          value = toQuery(value, second);\n          whitespace();\n        }\n      } else {\n        throw new Error(`Expected identifier`);\n      }\n      if (value) {\n        next(CLOSE_BRACKET);\n      }\n      return value;\n    }\n  };\n  const parseSegmentAndBrackets = () => {\n    const parsed = [];\n    const firstSegment = segment();\n    if (firstSegment) {\n      parsed.push(firstSegment);\n      let bracketSegment = parseBracket();\n      if (bracketSegment?.name === \"Value\") {\n        const maybeNumber = Number(bracketSegment.value);\n        bracketSegment.value = isNaN(maybeNumber) || String(maybeNumber) !== bracketSegment.value ? bracketSegment.value : maybeNumber;\n      }\n      while (bracketSegment !== void 0) {\n        parsed.push(bracketSegment);\n        bracketSegment = parseBracket();\n      }\n    }\n    return parsed;\n  };\n  const parsePath = () => {\n    const parts = [];\n    let nextSegment = parseSegmentAndBrackets();\n    while (nextSegment !== void 0) {\n      parts.push(...nextSegment);\n      if (!ch || ch === CLOSE_CURL) {\n        break;\n      }\n      if (nextSegment.length === 0 && ch) {\n        throw new Error(`Unexpected character: ${ch}`);\n      }\n      next(SEGMENT_SEPARATOR);\n      nextSegment = parseSegmentAndBrackets();\n    }\n    return toPath(parts);\n  };\n  try {\n    const result = parsePath();\n    return {\n      status: true,\n      path: result\n    };\n  } catch (e) {\n    return {\n      status: false,\n      error: e.message\n    };\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/utils.ts\nfunction isBinding(binding) {\n  return !(typeof binding === \"string\" || Array.isArray(binding));\n}\nfunction maybeConvertToNum(i) {\n  const asInt = parseInt(i, 10);\n  if (isNaN(asInt)) {\n    return i;\n  }\n  return asInt;\n}\nfunction getBindingSegments(binding) {\n  if (Array.isArray(binding)) {\n    return binding;\n  }\n  if (typeof binding === \"string\") {\n    return binding.split(\".\");\n  }\n  return binding.asArray();\n}\nfunction findInArray(array, key, value) {\n  return array.findIndex((obj) => {\n    if (obj && typeof obj === \"object\") {\n      return obj[key] == value;\n    }\n    return false;\n  });\n}\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/binding.ts\nvar BindingInstance = class _BindingInstance {\n  constructor(raw, factory = (rawBinding) => new _BindingInstance(rawBinding)) {\n    const split = Array.isArray(raw) ? raw : raw.split(\".\");\n    this.split = split.map((segment) => {\n      if (typeof segment === \"number\") {\n        return segment;\n      }\n      const tryNum = Number(segment);\n      return isNaN(tryNum) || String(tryNum) !== segment ? segment : tryNum;\n    });\n    Object.freeze(this.split);\n    this.joined = this.split.join(\".\");\n    this.factory = factory;\n  }\n  asArray() {\n    return this.split;\n  }\n  asString() {\n    return this.joined;\n  }\n  /**\n   * Check to see if the given binding is a sub-path of the current one\n   */\n  contains(binding) {\n    const bindingAsArray = binding.asArray();\n    if (bindingAsArray.length < this.split.length) {\n      return false;\n    }\n    for (let i = 0; i < this.split.length; i++) {\n      if (this.split[i] !== bindingAsArray[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  relative(binding) {\n    return this.asArray().slice(binding.asArray().length);\n  }\n  parent() {\n    return this.factory(this.split.slice(0, -1));\n  }\n  key() {\n    return this.split[this.split.length - 1];\n  }\n  /**\n   * This is a utility method to get a binding that is a descendent of this binding\n   *\n   * @param relative - The relative path to descend to\n   */\n  descendent(relative) {\n    const descendentSegments = getBindingSegments(relative);\n    return this.factory(this.split.concat(descendentSegments));\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/resolver.ts\nimport { NestedError } from \"ts-nested-error\";\nfunction resolveBindingAST(bindingPathNode, options, hooks) {\n  const context = {\n    updates: {},\n    path: []\n  };\n  function getValueForNode(node) {\n    if (node.name === \"Value\") {\n      return node.value;\n    }\n    if (node.name === \"PathNode\") {\n      const nestedResolvedValue = resolveBindingAST(node, options);\n      if (nestedResolvedValue.updates) {\n        context.updates = {\n          ...context.updates,\n          ...nestedResolvedValue.updates\n        };\n      }\n      try {\n        return options.convertToPath(\n          options.getValue(nestedResolvedValue.path)\n        );\n      } catch (e) {\n        throw new NestedError(\n          `Unable to resolve path segment: ${nestedResolvedValue.path}`,\n          e\n        );\n      }\n    }\n    if (node.name === \"Expression\") {\n      try {\n        const actualValue = options.evaluate(node.value);\n        return options.convertToPath(actualValue);\n      } catch (e) {\n        throw new NestedError(`Unable to resolve path: ${node.value}`, e);\n      }\n    }\n    throw new Error(`Unable to resolve value for node: ${node.name}`);\n  }\n  function appendPathSegments(segment) {\n    if (typeof segment === \"string\" && segment.indexOf(\".\") > -1) {\n      segment.split(\".\").forEach((i) => {\n        context.path.push(maybeConvertToNum(i));\n      });\n    } else {\n      context.path.push(segment);\n    }\n  }\n  function resolveNode(_node) {\n    const resolvedNode = hooks?.beforeResolveNode.call(_node, { ...context, ...options }) ?? _node;\n    switch (resolvedNode.name) {\n      case \"Expression\":\n      case \"PathNode\":\n        appendPathSegments(getValueForNode(resolvedNode));\n        break;\n      case \"Value\":\n        appendPathSegments(resolvedNode.value);\n        break;\n      case \"Query\": {\n        const objToQuery = options.getValue(context.path) ?? [];\n        const { key, value } = resolvedNode;\n        const resolvedKey = getValueForNode(key);\n        const resolvedValue = value && getValueForNode(value);\n        const index = findInArray(objToQuery, resolvedKey, resolvedValue);\n        if (index === void 0 || index === -1) {\n          context.updates[[...context.path, objToQuery.length, resolvedKey].join(\".\")] = resolvedValue;\n          context.path.push(objToQuery.length);\n        } else {\n          context.path.push(index);\n        }\n        break;\n      }\n      case \"Concatenated\":\n        context.path.push(resolvedNode.value.map(getValueForNode).join(\"\"));\n        break;\n      default:\n        throw new Error(`Unsupported node type: ${resolvedNode.name}`);\n    }\n  }\n  bindingPathNode.path.forEach(resolveNode);\n  return {\n    path: context.path,\n    updates: Object.keys(context.updates ?? {}).length > 0 ? context.updates : void 0\n  };\n}\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/binding/index.ts\nvar SIMPLE_BINDING_REGEX = /^[\\w\\-@]+(\\.[\\w\\-@]+)*$/;\nvar BINDING_BRACKETS_REGEX = /[\\s()*=`{}'\"[\\]]/;\nvar LAZY_BINDING_REGEX = /^[^.]+(\\..+)*$/;\nvar DEFAULT_OPTIONS = {\n  get: () => {\n    throw new Error(\"Not Implemented\");\n  },\n  set: () => {\n    throw new Error(\"Not Implemented\");\n  },\n  evaluate: () => {\n    throw new Error(\"Not Implemented\");\n  }\n};\nvar BindingParser = class {\n  constructor(options) {\n    this.hooks = {\n      skipOptimization: new SyncBailHook(),\n      beforeResolveNode: new SyncWaterfallHook()\n    };\n    this.parserOptions = { ...DEFAULT_OPTIONS, ...options };\n    this.cache = {};\n    this.parseCache = {};\n    this.parse = this.parse.bind(this);\n  }\n  /**\n   * Takes a binding path, parses it, and returns an equivalent, normalized\n   * representation of that path.\n   */\n  normalizePath(path, resolveOptions) {\n    if (!BINDING_BRACKETS_REGEX.test(path) && LAZY_BINDING_REGEX.test(path) && this.hooks.skipOptimization.call(path) !== true) {\n      return { path: path.split(\".\"), updates: void 0 };\n    }\n    const ast = this.parseCache[path] ?? parse(path);\n    this.parseCache[path] = ast;\n    if (typeof ast !== \"object\" || !ast?.status) {\n      throw new TypeError(\n        `Cannot normalize path \"${path}\": ${ast?.error ?? \"Unknown Error.\"}`\n      );\n    }\n    try {\n      return resolveBindingAST(ast.path, resolveOptions, this.hooks);\n    } catch (e) {\n      throw new NestedError2(`Cannot resolve binding: ${path}`, e);\n    }\n  }\n  getBindingForNormalizedResult(normalized) {\n    const normalizedStr = normalized.path.join(\".\");\n    if (this.cache[normalizedStr]) {\n      return this.cache[normalizedStr];\n    }\n    const created = new BindingInstance(\n      normalizedStr === \"\" ? [] : normalized.path,\n      this.parse\n    );\n    this.cache[normalizedStr] = created;\n    return created;\n  }\n  parse(rawBinding, overrides = {}) {\n    if (isBinding(rawBinding)) {\n      return rawBinding;\n    }\n    const options = {\n      ...this.parserOptions,\n      ...overrides\n    };\n    let updates = {};\n    const joined = Array.isArray(rawBinding) ? rawBinding.join(\".\") : String(rawBinding);\n    const normalizeConfig = {\n      getValue: (path) => {\n        const normalized2 = this.normalizePath(path.join(\".\"), normalizeConfig);\n        return options.get(this.getBindingForNormalizedResult(normalized2));\n      },\n      evaluate: (exp) => {\n        return options.evaluate(exp);\n      },\n      convertToPath: (path) => {\n        if (path === void 0) {\n          throw new Error(\n            \"Attempted to convert undefined value to binding path\"\n          );\n        }\n        if (typeof path !== \"string\" && typeof path !== \"number\" && typeof path !== \"boolean\") {\n          throw new Error(\n            `Attempting to convert ${typeof path} to a binding path.`\n          );\n        }\n        const normalized2 = this.normalizePath(String(path), normalizeConfig);\n        if (normalized2.updates) {\n          updates = {\n            ...updates,\n            ...normalized2.updates\n          };\n        }\n        const joinedNormalizedPath = normalized2.path.join(\".\");\n        if (joinedNormalizedPath === \"\") {\n          throw new Error(\"Nested path resolved to an empty path\");\n        }\n        return joinedNormalizedPath;\n      }\n    };\n    const normalized = this.normalizePath(joined, normalizeConfig);\n    if (normalized.updates) {\n      updates = {\n        ...updates,\n        ...normalized.updates\n      };\n    }\n    const updateKeys = Object.keys(updates);\n    if (!options.readOnly && updateKeys.length > 0) {\n      const updateTransaction = updateKeys.map(\n        (updatedBinding) => [\n          this.parse(updatedBinding),\n          updates[updatedBinding]\n        ]\n      );\n      options.set(updateTransaction);\n    }\n    return this.getBindingForNormalizedResult(normalized);\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/dependency-tracker.ts\nvar DependencyTracker = class {\n  constructor() {\n    this.readDeps = /* @__PURE__ */ new Set();\n    this.writeDeps = /* @__PURE__ */ new Set();\n    this.namedDependencySets = {};\n    this.namedSet = \"core\";\n    this.createSubset(\"core\");\n    this.createSubset(\"children\");\n  }\n  createSubset(name, force = false) {\n    if (force || !this.namedDependencySets[name]) {\n      this.namedDependencySets[name] = {\n        readDeps: /* @__PURE__ */ new Set(),\n        writeDeps: /* @__PURE__ */ new Set()\n      };\n    }\n  }\n  /** Grab all of the bindings that this depended on */\n  getDependencies(name) {\n    if (name !== void 0) {\n      return this.namedDependencySets?.[name]?.readDeps ?? /* @__PURE__ */ new Set();\n    }\n    return this.readDeps;\n  }\n  trackSubset(name) {\n    this.createSubset(name);\n    this.namedSet = name;\n  }\n  trackDefault() {\n    this.namedSet = \"core\";\n  }\n  /** Grab all of the bindings this wrote to */\n  getModified(name) {\n    if (name !== void 0) {\n      return this.namedDependencySets?.[name]?.writeDeps ?? /* @__PURE__ */ new Set();\n    }\n    return this.writeDeps;\n  }\n  /**\n   * Check to see if the dataModel has read the value at the given binding\n   *\n   * @param binding - The binding you want to check for\n   */\n  readsBinding(binding) {\n    return this.readDeps.has(binding);\n  }\n  /**\n   * Check to see if the dataModel has written to the binding\n   */\n  writesBinding(binding) {\n    return this.writeDeps.has(binding);\n  }\n  /** Reset all tracking of dependencies */\n  reset() {\n    this.readDeps = /* @__PURE__ */ new Set();\n    this.writeDeps = /* @__PURE__ */ new Set();\n    this.namedDependencySets = {};\n    this.namedSet = \"core\";\n    this.createSubset(\"core\", true);\n    this.createSubset(\"children\", true);\n  }\n  addReadDep(binding, namedSet = this.namedSet) {\n    if (namedSet) {\n      this.namedDependencySets?.[namedSet]?.readDeps.add(binding);\n    }\n    this.readDeps.add(binding);\n  }\n  addWriteDep(binding, namedSet = this.namedSet) {\n    if (namedSet) {\n      this.namedDependencySets?.[namedSet]?.writeDeps.add(binding);\n    }\n    this.writeDeps.add(binding);\n  }\n  addChildReadDep(binding) {\n    this.addReadDep(binding, \"children\");\n  }\n};\nvar DependencyMiddleware = class extends DependencyTracker {\n  constructor() {\n    super();\n    this.get = this.get.bind(this);\n    this.set = this.set.bind(this);\n  }\n  set(transaction, options, next) {\n    transaction.forEach(([binding]) => this.addWriteDep(binding));\n    return next?.set(transaction, options) ?? [];\n  }\n  get(binding, options, next) {\n    this.addReadDep(binding);\n    return next?.get(binding, options);\n  }\n  delete(binding, options, next) {\n    this.addWriteDep(binding);\n    return next?.delete(binding, options);\n  }\n};\nvar DependencyModel = class extends DependencyTracker {\n  constructor(rootModel) {\n    super();\n    this.rootModel = rootModel;\n    this.set = this.set.bind(this);\n    this.get = this.get.bind(this);\n  }\n  set(transaction, options) {\n    transaction.forEach(([binding]) => this.addWriteDep(binding));\n    return this.rootModel.set(transaction, options);\n  }\n  get(binding, options) {\n    this.addReadDep(binding);\n    return this.rootModel.get(binding, options);\n  }\n  delete(binding, options) {\n    this.addWriteDep(binding);\n    return this.rootModel.delete(binding, options);\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/model.ts\nimport { SyncHook } from \"tapable-ts\";\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/noop-model.ts\nvar NOOPDataModel = class {\n  get() {\n    return void 0;\n  }\n  set() {\n    return [];\n  }\n  delete() {\n  }\n};\nvar NOOP_MODEL = new NOOPDataModel();\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/model.ts\nvar ROOT_BINDING = new BindingInstance([]);\nfunction withParser(model, parseBinding) {\n  function maybeParse(binding, readOnly) {\n    const parsed = isBinding(binding) ? binding : parseBinding(binding, {\n      get: model.get,\n      set: model.set,\n      readOnly\n    });\n    if (!parsed) {\n      throw new Error(\"Unable to parse binding\");\n    }\n    return parsed;\n  }\n  return {\n    get(binding, options) {\n      return model.get(maybeParse(binding, true), options);\n    },\n    set(transaction, options) {\n      return model.set(\n        transaction.map(([key, val]) => [maybeParse(key, false), val]),\n        options\n      );\n    },\n    delete(binding, options) {\n      return model.delete(maybeParse(binding, false), options);\n    }\n  };\n}\nfunction toModel(middleware, defaultOptions, next) {\n  if (!next) {\n    return middleware;\n  }\n  return {\n    get: (binding, options) => {\n      const resolvedOptions = options ?? defaultOptions;\n      if (middleware.get) {\n        return middleware.get(binding, resolvedOptions, next);\n      }\n      return next?.get(binding, resolvedOptions);\n    },\n    set: (transaction, options) => {\n      const resolvedOptions = options ?? defaultOptions;\n      if (middleware.set) {\n        return middleware.set(transaction, resolvedOptions, next);\n      }\n      return next?.set(transaction, resolvedOptions);\n    },\n    delete: (binding, options) => {\n      const resolvedOptions = options ?? defaultOptions;\n      if (middleware.delete) {\n        return middleware.delete(binding, resolvedOptions, next);\n      }\n      return next?.delete(binding, resolvedOptions);\n    }\n  };\n}\nfunction constructModelForPipeline(pipeline) {\n  if (pipeline.length === 0) {\n    return NOOP_MODEL;\n  }\n  if (pipeline.length === 1) {\n    return toModel(pipeline[0]);\n  }\n  function createModelWithOptions(options) {\n    const model = pipeline.reduce(\n      (nextModel, middleware) => toModel(middleware, options, nextModel),\n      void 0\n    ) ?? NOOP_MODEL;\n    return model;\n  }\n  return {\n    get: (binding, options) => {\n      return createModelWithOptions(options)?.get(binding, options);\n    },\n    set: (transaction, options) => {\n      return createModelWithOptions(options)?.set(transaction, options);\n    },\n    delete: (binding, options) => {\n      return createModelWithOptions(options)?.delete(binding, options);\n    }\n  };\n}\nvar PipelinedDataModel = class {\n  constructor(pipeline = []) {\n    this.hooks = {\n      onSet: new SyncHook()\n    };\n    this.pipeline = pipeline;\n    this.effectiveDataModel = constructModelForPipeline(this.pipeline);\n  }\n  setMiddleware(handlers) {\n    this.pipeline = handlers;\n    this.effectiveDataModel = constructModelForPipeline(handlers);\n  }\n  addMiddleware(handler) {\n    this.pipeline = [...this.pipeline, handler];\n    this.effectiveDataModel = constructModelForPipeline(this.pipeline);\n  }\n  reset(model = {}) {\n    this.pipeline.forEach((middleware) => {\n      if (\"reset\" in middleware) {\n        middleware.reset?.();\n      }\n    });\n    this.set([[ROOT_BINDING, model]]);\n  }\n  set(transaction, options) {\n    const appliedTransaction = this.effectiveDataModel.set(\n      transaction,\n      options\n    );\n    this.hooks.onSet.call(transaction);\n    return appliedTransaction;\n  }\n  get(binding, options) {\n    return this.effectiveDataModel.get(binding, options);\n  }\n  delete(binding, options) {\n    return this.effectiveDataModel.delete(binding, options);\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/data/local-model.ts\nimport get from \"dlv\";\nimport { setIn, omit, removeAt } from \"timm\";\nvar LocalModel = class {\n  constructor(model = {}) {\n    this.model = model;\n    this.get = this.get.bind(this);\n    this.set = this.set.bind(this);\n  }\n  reset(model = {}) {\n    this.model = model;\n  }\n  get(binding) {\n    if (!binding || !binding.asString()) {\n      return this.model;\n    }\n    return get(this.model, binding.asArray());\n  }\n  set(transaction) {\n    const effectiveOperations = [];\n    transaction.forEach(([binding, value]) => {\n      const oldValue = this.get(binding);\n      this.model = setIn(this.model, binding.asArray(), value);\n      effectiveOperations.push({ binding, oldValue, newValue: value });\n    });\n    return effectiveOperations;\n  }\n  delete(binding) {\n    const parentBinding = binding.parent();\n    if (parentBinding) {\n      const parentValue = this.get(parentBinding);\n      if (parentValue !== void 0) {\n        if (Array.isArray(parentValue)) {\n          this.model = setIn(\n            this.model,\n            parentBinding.asArray(),\n            removeAt(parentValue, binding.key())\n          );\n        } else {\n          this.model = setIn(\n            this.model,\n            parentBinding.asArray(),\n            omit(parentValue, binding.key())\n          );\n        }\n      }\n    }\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/evaluator.ts\nimport { SyncWaterfallHook as SyncWaterfallHook2, SyncBailHook as SyncBailHook2 } from \"tapable-ts\";\nimport { NestedError as NestedError3 } from \"ts-nested-error\";\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/types.ts\nvar ExpNodeOpaqueIdentifier = Symbol(\"Expression Node ID\");\nfunction isExpressionNode(x) {\n  return typeof x === \"object\" && x !== null && !Array.isArray(x) && x.__id === ExpNodeOpaqueIdentifier;\n}\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/parser.ts\nvar PERIOD_CODE = 46;\nvar COMMA_CODE = 44;\nvar SQUOTE_CODE = 39;\nvar DQUOTE_CODE = 34;\nvar OPAREN_CODE = 40;\nvar CPAREN_CODE = 41;\nvar OBRACK_CODE = 91;\nvar CBRACK_CODE = 93;\nvar QUMARK_CODE = 63;\nvar SEMCOL_CODE = 59;\nvar COLON_CODE = 58;\nvar OCURL_CODE = 123;\nvar CCURL_CODE = 125;\nvar t = true;\nvar unaryOps = { \"-\": t, \"!\": t, \"~\": t, \"+\": t };\nvar binaryOps = {\n  \"=\": 3,\n  \"+=\": 3,\n  \"-=\": 3,\n  \"&=\": 3,\n  \"|=\": 3,\n  // Conditional: 4,\n  \"||\": 5,\n  \"&&\": 6,\n  \"|\": 7,\n  \"^\": 8,\n  \"&\": 9,\n  \"==\": 10,\n  \"!=\": 10,\n  \"===\": 10,\n  \"!==\": 10,\n  \"<\": 11,\n  \">\": 11,\n  \"<=\": 11,\n  \">=\": 11,\n  \"<<\": 12,\n  \">>\": 12,\n  \">>>\": 12,\n  \"+\": 13,\n  \"-\": 13,\n  \"*\": 14,\n  \"/\": 14,\n  \"%\": 14\n};\nfunction throwError(message, index) {\n  const err = new Error(`${message} at character ${index}`);\n  err.index = index;\n  err.description = message;\n  throw err;\n}\nfunction createSpanningLocation(start, end) {\n  if (!start || !end) {\n    return;\n  }\n  return {\n    start: start.start,\n    end: end.end\n  };\n}\nfunction getMaxKeyLen(obj) {\n  let maxLen = 0;\n  Object.keys(obj).forEach((key) => {\n    if (key.length > maxLen && Object.prototype.hasOwnProperty.call(obj, key)) {\n      maxLen = key.length;\n    }\n  });\n  return maxLen;\n}\nvar maxUnopLen = getMaxKeyLen(unaryOps);\nvar maxBinopLen = getMaxKeyLen(binaryOps);\nvar literals = {\n  true: true,\n  false: false,\n  null: null,\n  undefined: void 0\n};\nvar thisStr = \"this\";\nfunction binaryPrecedence(opVal) {\n  return binaryOps[opVal] || 0;\n}\nfunction createBinaryExpression(operator, left, right, location) {\n  let type;\n  if (operator === \"||\" || operator === \"&&\") {\n    type = \"LogicalExpression\";\n  } else if (operator === \"=\") {\n    type = \"Assignment\";\n  } else if (operator === \"+=\" || operator === \"-=\" || operator === \"&=\" || operator === \"|=\") {\n    type = \"Modification\";\n  } else {\n    type = \"BinaryExpression\";\n  }\n  return {\n    __id: ExpNodeOpaqueIdentifier,\n    type,\n    operator,\n    left,\n    right,\n    location\n  };\n}\nfunction isDecimalDigit(ch) {\n  return ch >= 48 && ch <= 57;\n}\nfunction isIdentifierStart(ch) {\n  return ch === 36 || ch === 95 || // `$` and `_`\n  ch >= 65 && ch <= 90 || // A...Z\n  ch >= 97 && ch <= 122;\n}\nfunction isIdentifierPart(ch) {\n  return ch === 36 || ch === 95 || // `$` and `_`\n  ch >= 65 && ch <= 90 || // A...Z\n  ch >= 97 && ch <= 122 || // A...z\n  ch >= 48 && ch <= 57;\n}\nfunction isModelRefStart(ch0, ch1) {\n  return ch0 === OCURL_CODE && ch1 === OCURL_CODE;\n}\nfunction parseExpression(expr, options) {\n  const strictMode = options?.strict ?? true;\n  const charAtFunc = expr.charAt;\n  const charCodeAtFunc = expr.charCodeAt;\n  const { length } = expr;\n  let index = 0;\n  const getLocation = (startChar) => {\n    return {\n      start: {\n        character: startChar\n      },\n      end: {\n        character: index\n      }\n    };\n  };\n  function exprI(i) {\n    return charAtFunc.call(expr, i);\n  }\n  function exprICode(i) {\n    return charCodeAtFunc.call(expr, i);\n  }\n  function gobbleObjects() {\n    const attributes = [];\n    let closed = false;\n    let shouldDefineKey = true;\n    let key;\n    let value;\n    let chCode;\n    const startCharIndex = index;\n    ++index;\n    while (index < length) {\n      gobbleSpaces();\n      chCode = exprICode(index);\n      if (chCode === CCURL_CODE) {\n        if (key) {\n          throwError(\"A key was defined but a value was not\", index);\n        }\n        index++;\n        closed = true;\n        break;\n      } else if (shouldDefineKey) {\n        if (chCode !== SQUOTE_CODE && chCode !== DQUOTE_CODE) {\n          throwError(\"An object must start wtih a key\", index);\n        }\n        key = gobbleStringLiteral();\n        gobbleSpaces();\n        if (exprICode(index) === COLON_CODE) {\n          index++;\n          shouldDefineKey = false;\n        } else {\n          throwError(\"A colon must follow an object key\", index);\n        }\n      } else {\n        value = gobbleExpression();\n        attributes.push({ key, value });\n        gobbleSpaces();\n        chCode = exprICode(index);\n        if (chCode === COMMA_CODE) {\n          index++;\n        } else if (chCode !== CCURL_CODE) {\n          throwError(\"Please add a comma to add another key\", index);\n        }\n        shouldDefineKey = true;\n        key = void 0;\n        value = void 0;\n      }\n      chCode = exprICode(index);\n    }\n    if (!closed) {\n      throwError(`Unclosed brace in object`, index);\n    }\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Object\",\n      attributes,\n      location: getLocation(startCharIndex)\n    };\n  }\n  function gobbleSpaces() {\n    let ch = exprICode(index);\n    while (ch === 32 || ch === 9) {\n      ch = exprICode(++index);\n    }\n  }\n  function gobbleExpression() {\n    const test = gobbleBinaryExpression();\n    gobbleSpaces();\n    const startCharIndex = index;\n    if (index < length && exprICode(index) === QUMARK_CODE) {\n      index++;\n      const consequent = gobbleExpression();\n      if (!consequent) {\n        throwError(\"Expected expression\", index);\n      }\n      gobbleSpaces();\n      if (exprICode(index) === COLON_CODE) {\n        index++;\n        const alternate = gobbleExpression();\n        if (!alternate) {\n          throwError(\"Expected expression\", index);\n        }\n        return {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"ConditionalExpression\",\n          test,\n          consequent,\n          alternate,\n          location: getLocation(startCharIndex)\n        };\n      }\n      throwError(\"Expected :\", index);\n    }\n    return test;\n  }\n  function gobbleBinaryOp() {\n    gobbleSpaces();\n    let toCheck = expr.substr(index, maxBinopLen);\n    let tcLen = toCheck.length;\n    while (tcLen > 0) {\n      if (Object.prototype.hasOwnProperty.call(binaryOps, toCheck)) {\n        index += tcLen;\n        return toCheck;\n      }\n      toCheck = toCheck.substr(0, --tcLen);\n    }\n    return false;\n  }\n  function gobbleBinaryExpression() {\n    let node;\n    let prec;\n    let i;\n    let left = gobbleToken();\n    let biop = gobbleBinaryOp();\n    if (!biop) {\n      return left;\n    }\n    let biopInfo = { value: biop, prec: binaryPrecedence(biop) };\n    let right = gobbleToken();\n    if (!right) {\n      throwError(`Expected expression after ${biop}`, index);\n    }\n    const stack = [left, biopInfo, right];\n    biop = gobbleBinaryOp();\n    while (biop) {\n      prec = binaryPrecedence(biop);\n      if (prec === 0) {\n        break;\n      }\n      biopInfo = { value: biop, prec };\n      while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n        right = stack.pop();\n        biop = stack.pop().value;\n        left = stack.pop();\n        node = createBinaryExpression(\n          biop,\n          left,\n          right,\n          createSpanningLocation(left.location, right.location)\n        );\n        stack.push(node);\n      }\n      node = gobbleToken();\n      if (!node) {\n        throwError(`Expected expression after ${biop}`, index);\n      }\n      stack.push(biopInfo, node);\n      biop = gobbleBinaryOp();\n    }\n    i = stack.length - 1;\n    node = stack[i];\n    while (i > 1) {\n      node = createBinaryExpression(\n        stack[i - 1].value,\n        stack[i - 2],\n        node,\n        createSpanningLocation(stack[i - 2].location, node.location)\n      );\n      i -= 2;\n    }\n    return node;\n  }\n  function gobbleToken() {\n    gobbleSpaces();\n    const ch = exprICode(index);\n    const startCharIndex = index;\n    if (isDecimalDigit(ch) || ch === PERIOD_CODE) {\n      return gobbleNumericLiteral();\n    }\n    if (ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\n      return gobbleStringLiteral();\n    }\n    if (isIdentifierStart(ch) || ch === OPAREN_CODE) {\n      return gobbleVariable();\n    }\n    if (ch === OBRACK_CODE) {\n      return gobbleArray();\n    }\n    if (isModelRefStart(ch, exprICode(index + 1))) {\n      return gobbleModelRef();\n    }\n    if (ch === OCURL_CODE) {\n      return gobbleObjects();\n    }\n    let toCheck = expr.substr(index, maxUnopLen);\n    let tcLen = toCheck.length;\n    while (tcLen > 0) {\n      if (Object.prototype.hasOwnProperty.call(unaryOps, toCheck)) {\n        index += tcLen;\n        return {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"UnaryExpression\",\n          operator: toCheck,\n          argument: gobbleToken(),\n          prefix: true,\n          location: getLocation(startCharIndex)\n        };\n      }\n      toCheck = toCheck.substr(0, --tcLen);\n    }\n    return false;\n  }\n  function gobbleNumericLiteral() {\n    let num = \"\";\n    const startCharIndex = index;\n    while (isDecimalDigit(exprICode(index))) {\n      num += exprI(index++);\n    }\n    if (exprICode(index) === PERIOD_CODE) {\n      num += exprI(index++);\n      while (isDecimalDigit(exprICode(index))) {\n        num += exprI(index++);\n      }\n    }\n    let ch = exprI(index);\n    if (ch === \"e\" || ch === \"E\") {\n      num += exprI(index++);\n      ch = exprI(index);\n      if (ch === \"+\" || ch === \"-\") {\n        num += exprI(index++);\n      }\n      while (isDecimalDigit(exprICode(index))) {\n        num += exprI(index++);\n      }\n      if (!isDecimalDigit(exprICode(index - 1))) {\n        throwError(`Expected exponent (${num}${exprI(index)})`, index);\n      }\n    }\n    const chCode = exprICode(index);\n    if (isIdentifierStart(chCode)) {\n      throwError(\n        `Variable names cannot start with a number (${num}${exprI(index)})`,\n        index\n      );\n    } else if (chCode === PERIOD_CODE) {\n      throwError(\"Unexpected period\", index);\n    }\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Literal\",\n      value: parseFloat(num),\n      raw: num,\n      location: getLocation(startCharIndex)\n    };\n  }\n  function gobbleStringLiteral() {\n    const quote = exprI(index++);\n    let str = \"\";\n    let closed = false;\n    const startCharIndex = index;\n    while (index < length) {\n      let ch = exprI(index++);\n      if (ch === quote) {\n        closed = true;\n        break;\n      }\n      if (ch !== \"\\\\\") {\n        str += ch;\n        continue;\n      }\n      ch = exprI(index++);\n      switch (ch) {\n        case \"n\":\n          str += \"\\n\";\n          break;\n        case \"r\":\n          str += \"\\r\";\n          break;\n        case \"t\":\n          str += \"\t\";\n          break;\n        case \"b\":\n          str += \"\\b\";\n          break;\n        case \"f\":\n          str += \"\\f\";\n          break;\n        case \"v\":\n          str += \"\\v\";\n          break;\n        default:\n      }\n    }\n    if (!closed) {\n      throwError(`Unclosed quote after \"${str}\"`, index);\n    }\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Literal\",\n      value: str,\n      raw: `${quote}${str}${quote}`,\n      location: getLocation(startCharIndex)\n    };\n  }\n  function gobbleModelRef() {\n    let str = \"\";\n    let closed = false;\n    let openBraceCount = 1;\n    const startCharIndex = index;\n    index += 2;\n    while (index < length) {\n      const ch = exprI(index++);\n      if (ch === \"}\" && exprICode(index) === CCURL_CODE) {\n        index++;\n        openBraceCount--;\n        if (openBraceCount === 0) {\n          closed = true;\n          break;\n        }\n        str += \"}}\";\n      } else if (ch === \"{\" && exprICode(index) === OCURL_CODE) {\n        openBraceCount++;\n        str += \"{{\";\n        index++;\n      } else {\n        str += ch;\n      }\n    }\n    if (!closed) {\n      throwError(`Unclosed brace after \"${str}\"`, index);\n    }\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"ModelRef\",\n      ref: str,\n      location: getLocation(startCharIndex)\n    };\n  }\n  function gobbleIdentifier() {\n    const start = index;\n    let ch = exprICode(start);\n    if (isIdentifierStart(ch)) {\n      index++;\n    } else {\n      throwError(`Unexpected ${exprI(index)}`, index);\n    }\n    while (index < length) {\n      ch = exprICode(index);\n      if (isIdentifierPart(ch)) {\n        index++;\n      } else {\n        break;\n      }\n    }\n    const identifier = expr.slice(start, index);\n    if (Object.prototype.hasOwnProperty.call(literals, identifier)) {\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"Literal\",\n        value: literals[identifier],\n        raw: identifier,\n        location: getLocation(start)\n      };\n    }\n    if (identifier === thisStr) {\n      return {\n        __id: ExpNodeOpaqueIdentifier,\n        type: \"ThisExpression\",\n        location: getLocation(start)\n      };\n    }\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Identifier\",\n      name: identifier,\n      location: getLocation(start)\n    };\n  }\n  function gobbleArguments(termination) {\n    const args = [];\n    let charIndex;\n    let node;\n    while (index < length) {\n      gobbleSpaces();\n      charIndex = exprICode(index);\n      if (charIndex === termination) {\n        index++;\n        break;\n      }\n      if (charIndex === COMMA_CODE) {\n        index++;\n        continue;\n      }\n      node = gobbleExpression();\n      if (!node || node.type === \"Compound\") {\n        throwError(\"Expected comma\", index);\n      }\n      args.push(node);\n    }\n    if (strictMode && charIndex !== termination) {\n      throwError(`Expected ${String.fromCharCode(termination)}`, index);\n    }\n    return args;\n  }\n  function gobbleVariable() {\n    let charIndex = exprICode(index);\n    let node = charIndex === OPAREN_CODE ? gobbleGroup() : gobbleIdentifier();\n    const startCharIndex = index;\n    gobbleSpaces();\n    charIndex = exprICode(index);\n    while (charIndex === PERIOD_CODE || charIndex === OBRACK_CODE || charIndex === OPAREN_CODE) {\n      index++;\n      if (charIndex === PERIOD_CODE) {\n        gobbleSpaces();\n        node = {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"MemberExpression\",\n          computed: false,\n          object: node,\n          property: gobbleIdentifier(),\n          location: getLocation(startCharIndex)\n        };\n      } else if (charIndex === OBRACK_CODE) {\n        node = {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"MemberExpression\",\n          computed: true,\n          object: node,\n          property: gobbleExpression(),\n          location: getLocation(startCharIndex)\n        };\n        gobbleSpaces();\n        charIndex = exprICode(index);\n        if (charIndex !== CBRACK_CODE) {\n          throwError(\"Unclosed [\", index);\n        }\n        index++;\n      } else if (charIndex === OPAREN_CODE) {\n        node = {\n          __id: ExpNodeOpaqueIdentifier,\n          type: \"CallExpression\",\n          args: gobbleArguments(CPAREN_CODE),\n          callTarget: node,\n          location: getLocation(startCharIndex)\n        };\n      }\n      gobbleSpaces();\n      charIndex = exprICode(index);\n    }\n    return node;\n  }\n  function gobbleGroup() {\n    index++;\n    const node = gobbleExpression();\n    gobbleSpaces();\n    if (exprICode(index) === CPAREN_CODE) {\n      index++;\n      return node;\n    }\n    throwError(\"Unclosed (\", index);\n  }\n  function gobbleArray() {\n    const startCharIndex = index;\n    index++;\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"ArrayExpression\",\n      elements: gobbleArguments(CBRACK_CODE),\n      location: getLocation(startCharIndex)\n    };\n  }\n  const nodes = [];\n  try {\n    while (index < length) {\n      const chIndex = exprICode(index);\n      if (chIndex === SEMCOL_CODE || chIndex === COMMA_CODE) {\n        index++;\n        continue;\n      }\n      const node = gobbleExpression();\n      if (node) {\n        nodes.push(node);\n      } else if (strictMode && index < length) {\n        throwError(`Unexpected \"${exprI(index)}\"`, index);\n      }\n    }\n    if (nodes.length === 1) {\n      return nodes[0];\n    }\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Compound\",\n      body: nodes,\n      location: getLocation(0)\n    };\n  } catch (e) {\n    if (strictMode || !(e instanceof Error)) {\n      throw e;\n    }\n    return {\n      __id: ExpNodeOpaqueIdentifier,\n      type: \"Compound\",\n      body: nodes,\n      location: getLocation(0),\n      error: e\n    };\n  }\n}\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/evaluator-functions.ts\nvar evaluator_functions_exports = {};\n__export(evaluator_functions_exports, {\n  conditional: () => conditional,\n  deleteDataVal: () => deleteDataVal,\n  getDataVal: () => getDataVal,\n  setDataVal: () => setDataVal\n});\nvar setDataVal = (_context, binding, value) => {\n  _context.model.set([[binding, value]]);\n};\nvar getDataVal = (_context, binding) => {\n  return _context.model.get(binding);\n};\nvar deleteDataVal = (_context, binding) => {\n  return _context.model.delete(binding);\n};\nvar conditional = (ctx, condition, ifTrue, ifFalse) => {\n  const resolution = ctx.evaluate(condition);\n  if (resolution) {\n    return ctx.evaluate(ifTrue);\n  }\n  if (ifFalse) {\n    return ctx.evaluate(ifFalse);\n  }\n  return null;\n};\nconditional.resolveParams = false;\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/utils.ts\nfunction withoutContext(fn) {\n  return (_context, ...args) => fn(...args);\n}\nfunction isInRange(position, location) {\n  return position.character >= location.start.character && position.character <= location.end.character;\n}\nfunction findClosestNodeAtPosition(node, position) {\n  switch (node.type) {\n    case \"Modification\":\n    case \"Assignment\":\n    case \"LogicalExpression\":\n    case \"BinaryExpression\": {\n      const check = findClosestNodeAtPosition(node.left, position) ?? findClosestNodeAtPosition(node.right, position);\n      if (check) {\n        return check;\n      }\n      break;\n    }\n    case \"UnaryExpression\": {\n      const checkArg = findClosestNodeAtPosition(node.argument, position);\n      if (checkArg) {\n        return checkArg;\n      }\n      break;\n    }\n    case \"MemberExpression\": {\n      const checkObject = findClosestNodeAtPosition(node.object, position) ?? findClosestNodeAtPosition(node.property, position);\n      if (checkObject) {\n        return checkObject;\n      }\n      break;\n    }\n    case \"ConditionalExpression\": {\n      const checkObject = findClosestNodeAtPosition(node.test, position) ?? findClosestNodeAtPosition(node.consequent, position) ?? findClosestNodeAtPosition(node.alternate, position);\n      if (checkObject) {\n        return checkObject;\n      }\n      break;\n    }\n    case \"ArrayExpression\":\n    case \"Compound\": {\n      const elements = node.type === \"ArrayExpression\" ? node.elements : node.body;\n      const anyElements = elements.find(\n        (e) => findClosestNodeAtPosition(e, position)\n      );\n      if (anyElements) {\n        return anyElements;\n      }\n      break;\n    }\n    case \"Object\": {\n      const checkObject = node.attributes.reduce(\n        (found, next) => {\n          return found ?? findClosestNodeAtPosition(next.key, position) ?? findClosestNodeAtPosition(next.value, position);\n        },\n        void 0\n      );\n      if (checkObject) {\n        return checkObject;\n      }\n      break;\n    }\n    case \"CallExpression\": {\n      const anyArgs = node.args.find((arg) => {\n        return findClosestNodeAtPosition(arg, position);\n      }) ?? findClosestNodeAtPosition(node.callTarget, position);\n      if (anyArgs) {\n        return anyArgs;\n      }\n      break;\n    }\n  }\n  if (node.location && isInRange(position, node.location)) {\n    return node;\n  }\n}\nfunction isObjectExpression(expr) {\n  if (isExpressionNode(expr)) {\n    return false;\n  }\n  return typeof expr === \"object\" && expr !== null && !Array.isArray(expr) && \"value\" in expr;\n}\nfunction isErrorWithLocation(error) {\n  return error.index !== void 0 && error.description !== void 0;\n}\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/expressions/evaluator.ts\nvar andandOperator = (ctx, a, b) => {\n  return ctx.evaluate(a) && ctx.evaluate(b);\n};\nandandOperator.resolveParams = false;\nvar ororOperator = (ctx, a, b) => {\n  return ctx.evaluate(a) || ctx.evaluate(b);\n};\nororOperator.resolveParams = false;\nvar DEFAULT_BINARY_OPERATORS = {\n  // TODO: A lot of these functions used to do type coercion. Not sure if we want to keep that behavior or not.\n  \"+\": (a, b) => a + b,\n  \"-\": (a, b) => a - b,\n  \"*\": (a, b) => a * b,\n  \"/\": (a, b) => a / b,\n  \"%\": (a, b) => a % b,\n  // eslint-disable-next-line\n  \"==\": (a, b) => a == b,\n  // eslint-disable-next-line\n  \"!=\": (a, b) => a != b,\n  \">\": (a, b) => a > b,\n  \">=\": (a, b) => a >= b,\n  \"<\": (a, b) => a < b,\n  \"<=\": (a, b) => a <= b,\n  \"&&\": andandOperator,\n  \"||\": ororOperator,\n  \"!==\": (a, b) => a !== b,\n  \"===\": (a, b) => a === b,\n  // eslint-disable-next-line\n  \"|\": (a, b) => a | b,\n  // eslint-disable-next-line\n  \"&\": (a, b) => a & b,\n  \"+=\": (a, b) => a + b,\n  \"-=\": (a, b) => a - b,\n  // eslint-disable-next-line\n  \"&=\": (a, b) => a & b,\n  // eslint-disable-next-line\n  \"|=\": (a, b) => a | b\n};\nvar DEFAULT_UNARY_OPERATORS = {\n  \"-\": (a) => -a,\n  \"+\": (a) => Number(a),\n  \"!\": (a) => !a\n};\nvar ExpressionEvaluator = class {\n  constructor(defaultOptions) {\n    this.vars = {};\n    this.hooks = {\n      /** Resolve an AST node for an expression to a value */\n      resolve: new SyncWaterfallHook2(),\n      /** Gets the options that will be passed in calls to the resolve hook */\n      resolveOptions: new SyncWaterfallHook2(),\n      /** Allows users to change the expression to be evaluated before processing */\n      beforeEvaluate: new SyncWaterfallHook2(),\n      /**\n       * An optional means of handling an error in the expression execution\n       * Return true if handled, to stop propagation of the error\n       */\n      onError: new SyncBailHook2()\n    };\n    this.expressionsCache = /* @__PURE__ */ new Map();\n    this.operators = {\n      binary: new Map(Object.entries(DEFAULT_BINARY_OPERATORS)),\n      unary: new Map(Object.entries(DEFAULT_UNARY_OPERATORS)),\n      expressions: new Map(\n        Object.entries(evaluator_functions_exports)\n      )\n    };\n    this.defaultHookOptions = {\n      ...defaultOptions,\n      evaluate: (expr) => this.evaluate(expr, this.defaultHookOptions),\n      resolveNode: (node) => this._execAST(node, this.defaultHookOptions)\n    };\n    this.hooks.resolve.tap(\"ExpressionEvaluator\", this._resolveNode.bind(this));\n    this.evaluate = this.evaluate.bind(this);\n  }\n  reset() {\n    this.expressionsCache.clear();\n  }\n  evaluate(expr, options) {\n    const resolvedOpts = this.hooks.resolveOptions.call({\n      ...this.defaultHookOptions,\n      ...options,\n      resolveNode: (node) => this._execAST(node, resolvedOpts)\n    });\n    let expression = this.hooks.beforeEvaluate.call(expr, resolvedOpts) ?? expr;\n    while (isObjectExpression(expression)) {\n      expression = expression.value;\n    }\n    if (typeof expression === \"number\" || typeof expression === \"boolean\" || expression === void 0 || expression === null) {\n      return expression;\n    }\n    if (isExpressionNode(expression)) {\n      return this._execAST(expression, resolvedOpts);\n    }\n    if (Array.isArray(expression)) {\n      return expression.reduce(\n        (_nothing, exp) => this.evaluate(exp, options),\n        null\n      );\n    }\n    return this._execString(String(expression), resolvedOpts);\n  }\n  addExpressionFunction(name, handler) {\n    this.operators.expressions.set(name, handler);\n  }\n  addBinaryOperator(operator, handler) {\n    this.operators.binary.set(operator, handler);\n  }\n  addUnaryOperator(operator, handler) {\n    this.operators.unary.set(operator, handler);\n  }\n  setExpressionVariable(name, value) {\n    this.vars[name] = value;\n  }\n  getExpressionVariable(name) {\n    return this.vars[name];\n  }\n  _execAST(node, options) {\n    return this.hooks.resolve.call(void 0, node, options);\n  }\n  _execString(exp, options) {\n    if (exp === \"\") {\n      return exp;\n    }\n    const matches = exp.match(/^@\\[(.*)\\]@$/);\n    let matchedExp = exp;\n    if (matches) {\n      [, matchedExp] = Array.from(matches);\n    }\n    let storedAST;\n    try {\n      storedAST = this.expressionsCache.get(matchedExp) ?? parseExpression(matchedExp, { strict: options.strict });\n      this.expressionsCache.set(matchedExp, storedAST);\n    } catch (e) {\n      if (options.throwErrors || !this.hooks.onError.call(e)) {\n        throw new NestedError3(`Error parsing expression: ${exp}`, e);\n      }\n      return;\n    }\n    try {\n      return this._execAST(storedAST, options);\n    } catch (e) {\n      if (options.throwErrors || !this.hooks.onError.call(e)) {\n        throw new NestedError3(`Error evaluating expression: ${exp}`, e);\n      }\n    }\n  }\n  _resolveNode(_currentValue, node, options) {\n    const { resolveNode, model } = options;\n    const expressionContext = {\n      ...options,\n      evaluate: (expr) => this.evaluate(expr, options)\n    };\n    if (node.type === \"Literal\") {\n      return node.value;\n    }\n    if (node.type === \"Identifier\") {\n      return this.vars[node.name];\n    }\n    if (node.type === \"Compound\" || node.type === \"ThisExpression\") {\n      throw new Error(`Expression type: ${node.type} is not supported`);\n    }\n    if (node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\") {\n      const operator = this.operators.binary.get(node.operator);\n      if (operator) {\n        if (\"resolveParams\" in operator) {\n          if (operator.resolveParams === false) {\n            return operator(expressionContext, node.left, node.right);\n          }\n          return operator(\n            expressionContext,\n            resolveNode(node.left),\n            resolveNode(node.right)\n          );\n        }\n        return operator(resolveNode(node.left), resolveNode(node.right));\n      }\n      return;\n    }\n    if (node.type === \"UnaryExpression\") {\n      const operator = this.operators.unary.get(node.operator);\n      if (operator) {\n        if (\"resolveParams\" in operator) {\n          return operator(\n            expressionContext,\n            operator.resolveParams === false ? node.argument : resolveNode(node.argument)\n          );\n        }\n        return operator(resolveNode(node.argument));\n      }\n      return;\n    }\n    if (node.type === \"Object\") {\n      const { attributes } = node;\n      const resolvedAttributes = {};\n      attributes.forEach((attr) => {\n        const key = resolveNode(attr.key);\n        const value = resolveNode(attr.value);\n        resolvedAttributes[key] = value;\n      });\n      return resolvedAttributes;\n    }\n    if (node.type === \"CallExpression\") {\n      const expressionName = node.callTarget.name;\n      const operator = this.operators.expressions.get(expressionName);\n      if (!operator) {\n        throw new Error(`Unknown expression function: ${expressionName}`);\n      }\n      if (\"resolveParams\" in operator && operator.resolveParams === false) {\n        return operator(expressionContext, ...node.args);\n      }\n      const args = node.args.map((n) => resolveNode(n));\n      return operator(expressionContext, ...args);\n    }\n    if (node.type === \"ModelRef\") {\n      return model.get(node.ref, { context: { model: options.model } });\n    }\n    if (node.type === \"MemberExpression\") {\n      const obj = resolveNode(node.object);\n      const prop = resolveNode(node.property);\n      return obj[prop];\n    }\n    if (node.type === \"Assignment\") {\n      if (node.left.type === \"ModelRef\") {\n        const value = resolveNode(node.right);\n        model.set([[node.left.ref, value]]);\n        return value;\n      }\n      if (node.left.type === \"Identifier\") {\n        const value = resolveNode(node.right);\n        this.vars[node.left.name] = value;\n        return value;\n      }\n      return;\n    }\n    if (node.type === \"ConditionalExpression\") {\n      const result = resolveNode(node.test) ? node.consequent : node.alternate;\n      return resolveNode(result);\n    }\n    if (node.type === \"ArrayExpression\") {\n      return node.elements.map((ele) => resolveNode(ele));\n    }\n    if (node.type === \"Modification\") {\n      const operation = this.operators.binary.get(node.operator);\n      if (operation) {\n        let newValue;\n        if (\"resolveParams\" in operation) {\n          if (operation.resolveParams === false) {\n            newValue = operation(expressionContext, node.left, node.right);\n          } else {\n            newValue = operation(\n              expressionContext,\n              resolveNode(node.left),\n              resolveNode(node.right)\n            );\n          }\n        } else {\n          newValue = operation(resolveNode(node.left), resolveNode(node.right));\n        }\n        if (node.left.type === \"ModelRef\") {\n          model.set([[node.left.ref, newValue]]);\n        } else if (node.left.type === \"Identifier\") {\n          this.vars[node.left.name] = newValue;\n        }\n        return newValue;\n      }\n      return resolveNode(node.left);\n    }\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/logger/types.ts\nvar severities = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/logger/consoleLogger.ts\nvar ConsoleLogger = class {\n  constructor(severity = \"warn\", _console = console) {\n    this.trace = this.createHandler(\"trace\");\n    this.debug = this.createHandler(\"debug\");\n    this.info = this.createHandler(\"info\");\n    this.warn = this.createHandler(\"warn\");\n    this.error = this.createHandler(\"error\");\n    this.severity = severity;\n    this._console = _console;\n  }\n  setSeverity(severity) {\n    this.severity = severity;\n  }\n  getConsoleFn(severity) {\n    switch (severities.indexOf(severity)) {\n      case 0:\n      case 1:\n      case 2:\n        return this._console.log;\n      case 3:\n        return this._console.warn;\n      default:\n        return this._console.error;\n    }\n  }\n  createHandler(severity) {\n    return (...args) => {\n      const sevIndex = severities.indexOf(severity);\n      const sevConf = severities.indexOf(this.severity);\n      if (sevIndex >= sevConf) {\n        this.getConsoleFn(severity)(`player - ${severity} -`, ...args);\n      }\n    };\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/logger/noopLogger.ts\nvar noop = () => {\n};\nvar NoopLogger = class {\n  constructor() {\n    this.trace = noop;\n    this.debug = noop;\n    this.info = noop;\n    this.warn = noop;\n    this.error = noop;\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/logger/tapableLogger.ts\nimport { SyncHook as SyncHook2 } from \"tapable-ts\";\nvar TapableLogger = class {\n  constructor() {\n    this.hooks = {\n      trace: new SyncHook2(),\n      debug: new SyncHook2(),\n      info: new SyncHook2(),\n      warn: new SyncHook2(),\n      error: new SyncHook2(),\n      log: new SyncHook2()\n    };\n    this.logHandlers = /* @__PURE__ */ new Set();\n    this.trace = this.createHandler(\"trace\");\n    this.debug = this.createHandler(\"debug\");\n    this.info = this.createHandler(\"info\");\n    this.warn = this.createHandler(\"warn\");\n    this.error = this.createHandler(\"error\");\n  }\n  createHandler(severity) {\n    return (...args) => {\n      this.hooks[severity].call(args);\n      this.hooks.log.call(severity, args);\n      this.logHandlers.forEach((logger) => logger[severity](...args));\n    };\n  }\n  addHandler(logHandler) {\n    this.logHandlers.add(logHandler);\n  }\n  removeHandler(logHandler) {\n    this.logHandlers.delete(logHandler);\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/logger/proxyLogger.ts\nvar ProxyLogger = class {\n  constructor(loggerProvider) {\n    this.trace = this.createHandler(\"trace\");\n    this.debug = this.createHandler(\"debug\");\n    this.info = this.createHandler(\"info\");\n    this.warn = this.createHandler(\"warn\");\n    this.error = this.createHandler(\"error\");\n    this.proxiedLoggerProvider = loggerProvider;\n  }\n  createHandler(severity) {\n    return (...args) => {\n      const logger = this.proxiedLoggerProvider();\n      logger?.[severity](...args);\n    };\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/schema/schema.ts\nimport { SyncWaterfallHook as SyncWaterfallHook3 } from \"tapable-ts\";\nvar identify = (val) => val;\nfunction parse2(schema) {\n  const expandedPaths = /* @__PURE__ */ new Map();\n  if (!schema.ROOT) {\n    return expandedPaths;\n  }\n  const parseQueue = [{ node: schema.ROOT, path: [], visited: /* @__PURE__ */ new Set() }];\n  while (parseQueue.length > 0) {\n    const next = parseQueue.shift();\n    if (!next) {\n      break;\n    }\n    const { node, path, visited } = next;\n    Object.entries(node).forEach(([prop, type]) => {\n      const nestedPath = [...path, prop];\n      const nestedPathStr = nestedPath.join(\".\");\n      if (expandedPaths.has(nestedPathStr)) {\n        throw new Error(\n          \"Path has already been processed. There's either a loop somewhere or a bug\"\n        );\n      }\n      if (visited.has(type.type)) {\n        throw new Error(\n          `Path already contained type: ${type.type}. This likely indicates a loop in the schema`\n        );\n      }\n      expandedPaths.set(nestedPathStr, type);\n      if (type.isArray) {\n        nestedPath.push(\"[]\");\n      }\n      if (type.isRecord) {\n        nestedPath.push(\"{}\");\n      }\n      if (type.type && schema[type.type]) {\n        parseQueue.push({\n          path: nestedPath,\n          node: schema[type.type],\n          visited: /* @__PURE__ */ new Set([...visited, type.type])\n        });\n      }\n    });\n  }\n  return expandedPaths;\n}\nvar SchemaController = class {\n  constructor(schema) {\n    this.formatters = /* @__PURE__ */ new Map();\n    this.types = /* @__PURE__ */ new Map();\n    this.schema = /* @__PURE__ */ new Map();\n    this.bindingSchemaNormalizedCache = /* @__PURE__ */ new Map();\n    this.hooks = {\n      resolveTypeForBinding: new SyncWaterfallHook3()\n    };\n    this.schema = schema ? parse2(schema) : /* @__PURE__ */ new Map();\n  }\n  addFormatters(fns) {\n    fns.forEach((def) => {\n      this.formatters.set(def.name, def);\n    });\n  }\n  addDataTypes(types) {\n    types.forEach((t2) => {\n      this.types.set(t2.type, t2);\n    });\n  }\n  getValidationsForBinding(binding) {\n    const typeDef = this.getApparentType(binding);\n    if (!typeDef?.validation?.length) {\n      return void 0;\n    }\n    return typeDef.validation.map((vRef) => ({\n      severity: \"error\",\n      trigger: \"change\",\n      ...vRef\n    }));\n  }\n  normalizeBinding(binding) {\n    const cached = this.bindingSchemaNormalizedCache.get(binding);\n    if (cached) {\n      return cached;\n    }\n    let bindingArray = binding.asArray();\n    let normalized = bindingArray.map((p) => typeof p === \"number\" ? \"[]\" : p).join(\".\");\n    if (normalized) {\n      this.bindingSchemaNormalizedCache.set(binding, normalized);\n      bindingArray = normalized.split(\".\");\n    }\n    bindingArray.forEach((item) => {\n      const recordBinding = bindingArray.map((p) => p === item ? \"{}\" : p).join(\".\");\n      if (this.schema.get(recordBinding)) {\n        this.bindingSchemaNormalizedCache.set(binding, recordBinding);\n        bindingArray = recordBinding.split(\".\");\n        normalized = recordBinding;\n      }\n    });\n    return normalized;\n  }\n  getType(binding) {\n    return this.hooks.resolveTypeForBinding.call(\n      this.schema.get(this.normalizeBinding(binding)),\n      binding\n    );\n  }\n  getApparentType(binding) {\n    const schemaType = this.getType(binding);\n    if (schemaType === void 0) {\n      return void 0;\n    }\n    const baseType = this.getTypeDefinition(schemaType?.type);\n    if (baseType === void 0) {\n      return schemaType;\n    }\n    return {\n      ...baseType,\n      ...schemaType,\n      validation: [\n        ...schemaType.validation ?? [],\n        ...baseType.validation ?? []\n      ]\n    };\n  }\n  getTypeDefinition(dataType) {\n    return this.types.get(dataType);\n  }\n  getFormatterForType(formatReference) {\n    const { type: formatType, ...options } = formatReference;\n    const formatter = this.formatters.get(formatType);\n    if (!formatter) {\n      return;\n    }\n    return {\n      format: formatter.format ? (val) => formatter.format?.(val, options) : identify,\n      deformat: formatter.deformat ? (val) => formatter.deformat?.(val, options) : identify\n    };\n  }\n  /**\n   * Given a binding, fetch a function that's responsible for formatting, and/or de-formatting the data\n   * If no formatter is registered, it will return undefined\n   */\n  getFormatter(binding) {\n    const type = this.getApparentType(binding);\n    if (!type?.format) {\n      return void 0;\n    }\n    return this.getFormatterForType(type.format);\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/string-resolver/index.ts\nimport { setIn as setIn2 } from \"timm\";\nvar DOUBLE_OPEN_CURLY = \"{{\";\nvar DOUBLE_CLOSE_CURLY = \"}}\";\nfunction findNextExp(str) {\n  const expStart = str.indexOf(DOUBLE_OPEN_CURLY);\n  if (expStart === -1) {\n    return void 0;\n  }\n  let count = 1;\n  let offset = expStart + DOUBLE_OPEN_CURLY.length;\n  let workingString = str.substring(expStart + DOUBLE_OPEN_CURLY.length);\n  while (count > 0 && workingString.length > 0) {\n    const nextCloseCurly = workingString.indexOf(DOUBLE_CLOSE_CURLY);\n    if (nextCloseCurly === -1) {\n      break;\n    }\n    const nextOpenCurly = workingString.indexOf(DOUBLE_OPEN_CURLY);\n    if (nextOpenCurly !== -1 && nextOpenCurly < nextCloseCurly) {\n      count++;\n      workingString = workingString.substring(\n        nextOpenCurly + DOUBLE_OPEN_CURLY.length\n      );\n      offset += nextOpenCurly + DOUBLE_OPEN_CURLY.length;\n    } else {\n      count--;\n      workingString = workingString.substring(\n        nextCloseCurly + DOUBLE_CLOSE_CURLY.length\n      );\n      offset += nextCloseCurly + DOUBLE_CLOSE_CURLY.length;\n    }\n  }\n  if (count !== 0) {\n    throw new Error(`Unbalanced {{ and }} in exp: ${str}`);\n  }\n  return {\n    start: expStart,\n    end: offset\n  };\n}\nfunction resolveExpressionsInString(val, { evaluate }) {\n  if (!evaluate) {\n    return val;\n  }\n  const expMatch = /@\\[.*?\\]@/;\n  let newVal = val;\n  let match = newVal.match(expMatch);\n  while (match !== null) {\n    const expStrWithBrackets = match[0];\n    const matchStart = newVal.indexOf(expStrWithBrackets);\n    const expString = expStrWithBrackets.substr(\n      \"@[\".length,\n      expStrWithBrackets.length - \"@[\".length - \"]@\".length\n    );\n    const expValue = evaluate(expString);\n    if (matchStart === 0 && expStrWithBrackets === val && typeof expValue !== \"string\") {\n      return expValue;\n    }\n    newVal = newVal.substr(0, matchStart) + expValue + newVal.substr(matchStart + expStrWithBrackets.length);\n    match = newVal.match(expMatch);\n  }\n  return newVal;\n}\nfunction resolveDataRefsInString(val, options) {\n  const { model, formatted = true } = options;\n  let workingString = resolveExpressionsInString(val, options);\n  if (!model || typeof workingString !== \"string\" || workingString.indexOf(DOUBLE_OPEN_CURLY) === -1) {\n    return workingString;\n  }\n  while (workingString.indexOf(DOUBLE_OPEN_CURLY) !== -1) {\n    const expLocation = findNextExp(workingString);\n    if (!expLocation) {\n      return workingString;\n    }\n    const { start, end } = expLocation;\n    const binding = workingString.substring(\n      start + DOUBLE_OPEN_CURLY.length,\n      end - DOUBLE_OPEN_CURLY.length\n    ).trim();\n    const evaledVal = model.get(binding, { formatted });\n    if (start === 0 && end === workingString.length && typeof evaledVal !== \"string\") {\n      return evaledVal;\n    }\n    workingString = workingString.substr(0, start) + evaledVal + workingString.substr(end);\n  }\n  return workingString;\n}\nfunction traverseObject(val, options) {\n  switch (typeof val) {\n    case \"string\": {\n      return resolveDataRefsInString(val, options);\n    }\n    case \"object\": {\n      if (!val)\n        return val;\n      const keys = Object.keys(val);\n      let newVal = val;\n      if (keys.length > 0) {\n        keys.forEach((key) => {\n          newVal = setIn2(\n            newVal,\n            [key],\n            traverseObject(val[key], options)\n          );\n        });\n      }\n      return newVal;\n    }\n    default:\n      return val;\n  }\n}\nfunction resolveDataRefs(val, options) {\n  return traverseObject(val, options);\n}\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/validator/validation-middleware.ts\nimport { setIn as setIn3 } from \"timm\";\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/validator/binding-map-splice.ts\nfunction removeBindingAndChildrenFromMap(sourceMap, binding) {\n  const targetMap = new Map(sourceMap);\n  const parentBinding = binding.parent();\n  const property = binding.key();\n  targetMap.forEach((_value, trackedBinding) => {\n    if (binding === trackedBinding || binding.contains(trackedBinding)) {\n      targetMap.delete(trackedBinding);\n    }\n  });\n  if (typeof property === \"number\") {\n    const bindingsToRewrite = Array.from(sourceMap.keys()).filter((b) => {\n      if (parentBinding.contains(b)) {\n        const [childIndex] = b.relative(parentBinding);\n        return typeof childIndex === \"number\" && childIndex > property;\n      }\n      return false;\n    }).sort();\n    bindingsToRewrite.forEach((trackedBinding) => {\n      const [childIndex, ...childPath] = trackedBinding.relative(parentBinding);\n      if (typeof childIndex === \"number\") {\n        const newSegments = [childIndex - 1, ...childPath];\n        const newChildBinding = parentBinding.descendent(newSegments);\n        targetMap.set(newChildBinding, targetMap.get(trackedBinding));\n        targetMap.delete(trackedBinding);\n      }\n    });\n  }\n  return targetMap;\n}\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/validator/validation-middleware.ts\nvar ValidationMiddleware = class {\n  constructor(validator, options) {\n    this.validator = validator;\n    this.shadowModelPaths = /* @__PURE__ */ new Map();\n    this.logger = options?.logger;\n    this.shouldIncludeInvalid = options?.shouldIncludeInvalid;\n  }\n  set(transaction, options, next) {\n    const asModel = toModel(this, { ...options, includeInvalid: true }, next);\n    const nextTransaction = [];\n    const includedBindings = /* @__PURE__ */ new Set();\n    transaction.forEach(([binding, value]) => {\n      this.shadowModelPaths.set(binding, value);\n      includedBindings.add(binding);\n    });\n    const invalidBindings = [];\n    this.shadowModelPaths.forEach((value, binding) => {\n      const validations = this.validator(binding, asModel);\n      if (validations === void 0) {\n        nextTransaction.push([binding, value]);\n      } else if (validations instanceof Set) {\n        validations.forEach((validation) => {\n          invalidBindings.push(validation.binding);\n          if (!validation.isStrong && validation.binding.asString() === binding.asString()) {\n            nextTransaction.push([validation.binding, value]);\n          }\n        });\n      } else if (includedBindings.has(binding)) {\n        invalidBindings.push(binding);\n        this.logger?.debug(\n          `Invalid value for path: ${binding.asString()} - ${validations.severity} - ${validations.message}`\n        );\n      }\n    });\n    let validResults = [];\n    if (next && nextTransaction.length > 0) {\n      nextTransaction.forEach(\n        ([binding]) => this.shadowModelPaths.delete(binding)\n      );\n      const result = next.set(nextTransaction, options);\n      if (invalidBindings.length === 0) {\n        return result;\n      }\n      validResults = result;\n    }\n    const invalidResults = invalidBindings.map((binding) => {\n      return {\n        binding,\n        oldValue: asModel.get(binding),\n        newValue: asModel.get(binding),\n        force: true\n      };\n    });\n    return [...validResults, ...invalidResults];\n  }\n  get(binding, options, next) {\n    let val = next?.get(binding, options);\n    if (this.shouldIncludeInvalid?.(options) ?? options?.includeInvalid === true) {\n      this.shadowModelPaths.forEach((shadowValue, shadowBinding) => {\n        if (shadowBinding === binding) {\n          val = shadowValue;\n          return;\n        }\n        if (binding.contains(shadowBinding)) {\n          val = setIn3(val, shadowBinding.relative(binding), shadowValue);\n        }\n      });\n    }\n    return val;\n  }\n  delete(binding, options, next) {\n    this.shadowModelPaths = removeBindingAndChildrenFromMap(\n      this.shadowModelPaths,\n      binding\n    );\n    return next?.delete(binding, options);\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/validator/registry.ts\nvar ValidatorRegistry = class {\n  constructor() {\n    this.registry = /* @__PURE__ */ new Map();\n  }\n  /** Use the given validator name to fetch the handler */\n  get(name) {\n    return this.registry.get(name);\n  }\n  /** Register a new validator */\n  register(name, handler) {\n    this.registry.set(name, handler);\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/view.ts\nimport { SyncHook as SyncHook4 } from \"tapable-ts\";\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/resolver/index.ts\nimport { SyncWaterfallHook as SyncWaterfallHook5, SyncHook as SyncHook3 } from \"tapable-ts\";\nimport { setIn as setIn5, addLast, clone } from \"timm\";\nimport dlv from \"dlv\";\nimport { dequal } from \"dequal\";\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/parser/index.ts\nimport { setIn as setIn4 } from \"timm\";\nimport { SyncBailHook as SyncBailHook3, SyncWaterfallHook as SyncWaterfallHook4 } from \"tapable-ts\";\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/parser/types.ts\nvar NodeType = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[\"Asset\"] = \"asset\";\n  NodeType2[\"View\"] = \"view\";\n  NodeType2[\"Applicability\"] = \"applicability\";\n  NodeType2[\"Template\"] = \"template\";\n  NodeType2[\"Value\"] = \"value\";\n  NodeType2[\"MultiNode\"] = \"multi-node\";\n  NodeType2[\"Switch\"] = \"switch\";\n  NodeType2[\"Async\"] = \"async\";\n  NodeType2[\"Unknown\"] = \"unknown\";\n  NodeType2[\"Empty\"] = \"empty\";\n  return NodeType2;\n})(NodeType || {});\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/parser/utils.ts\nfunction hasTemplateValues(obj, localKey) {\n  return Object.hasOwnProperty.call(obj, \"template\") && Array.isArray(obj?.template) && obj.template.length && obj.template.find((tmpl) => tmpl.output === localKey);\n}\nfunction hasSwitchKey(localKey) {\n  return localKey === \"staticSwitch\" || localKey === \"dynamicSwitch\";\n}\nfunction hasTemplateKey(localKey) {\n  return localKey === \"template\";\n}\nfunction getNodeID(node) {\n  if (!node) {\n    return;\n  }\n  if (\"value\" in node && typeof node.value === \"object\" && typeof node.value?.id === \"string\") {\n    return node.value.id;\n  }\n}\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/parser/index.ts\nvar EMPTY_NODE = {\n  type: \"empty\" /* Empty */\n};\nvar Parser = class {\n  constructor() {\n    this.hooks = {\n      /**\n       * A hook to interact with an object _before_ parsing it into an AST\n       *\n       * @param value - The object we're are about to parse\n       * @returns - A new value to parse.\n       *  If undefined, the original value is used.\n       *  If null, we stop parsing this node.\n       */\n      onParseObject: new SyncWaterfallHook4(),\n      /**\n       * A callback to interact with an AST _after_ we parse it into the AST\n       *\n       * @param value - The object we parsed\n       * @param node - The AST node we generated\n       * @returns - A new AST node to use\n       *   If undefined, the original value is used.\n       *   If null, we ignore this node all together\n       */\n      onCreateASTNode: new SyncWaterfallHook4(),\n      parseNode: new SyncBailHook3()\n    };\n  }\n  parseView(value) {\n    const viewNode = this.parseObject(value, \"view\" /* View */);\n    if (!viewNode) {\n      throw new Error(\"Unable to parse object into a view\");\n    }\n    return viewNode;\n  }\n  createASTNode(node, value) {\n    const tapped = this.hooks.onCreateASTNode.call(node, value);\n    if (tapped === void 0) {\n      return node;\n    }\n    return tapped;\n  }\n  parseObject(obj, type = \"value\" /* Value */, options = { templateDepth: 0 }) {\n    const parsedNode = this.hooks.parseNode.call(\n      obj,\n      type,\n      options\n    );\n    if (parsedNode || parsedNode === null) {\n      return parsedNode;\n    }\n    const parseLocalObject = (currentValue, objToParse, path = []) => {\n      if (typeof objToParse !== \"object\" || objToParse === null) {\n        return { value: objToParse, children: [] };\n      }\n      const localObj = this.hooks.onParseObject.call(objToParse, type);\n      if (!localObj) {\n        return currentValue;\n      }\n      const objEntries = Array.isArray(localObj) ? localObj.map((v, i) => [i, v]) : [\n        ...Object.entries(localObj),\n        ...Object.getOwnPropertySymbols(localObj).map((s) => [\n          s,\n          localObj[s]\n        ])\n      ];\n      const defaultValue = {\n        children: [],\n        value: currentValue\n      };\n      const newValue = objEntries.reduce((accumulation, current) => {\n        let { value: value2 } = accumulation;\n        const { children: children2 } = accumulation;\n        const [localKey, localValue] = current;\n        const newChildren = this.hooks.parseNode.call(\n          localValue,\n          \"value\" /* Value */,\n          options,\n          {\n            path,\n            key: localKey,\n            parentObj: localObj\n          }\n        );\n        if (newChildren) {\n          children2.push(...newChildren);\n        } else if (localValue && typeof localValue === \"object\") {\n          const result = parseLocalObject(accumulation.value, localValue, [\n            ...path,\n            localKey\n          ]);\n          value2 = result.value;\n          children2.push(...result.children);\n        } else {\n          value2 = setIn4(accumulation.value, [...path, localKey], localValue);\n        }\n        return {\n          value: value2,\n          children: children2\n        };\n      }, defaultValue);\n      return newValue;\n    };\n    const { value, children } = parseLocalObject(void 0, obj);\n    const baseAst = value === void 0 && !children.length ? void 0 : {\n      type,\n      value\n    };\n    if (baseAst && children.length) {\n      const parent = baseAst;\n      parent.children = children;\n      children.forEach((child) => {\n        child.value.parent = parent;\n      });\n    }\n    return this.hooks.onCreateASTNode.call(baseAst, obj) ?? null;\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/resolver/utils.ts\nfunction caresAboutDataChanges(dataChanges, dependencies) {\n  if (!dataChanges || !dependencies) {\n    return true;\n  }\n  const depArray = Array.from(dependencies.values());\n  const dataChangeArray = Array.from(dataChanges.values());\n  return depArray.find(\n    (dep) => !!dataChangeArray.find(\n      (change) => change === dep || change.contains(dep) || dep.contains(change)\n    )\n  ) !== void 0;\n}\nfunction toNodeResolveOptions(resolverOptions) {\n  return {\n    ...resolverOptions,\n    data: {\n      model: resolverOptions.model,\n      formatValue: (ref, value) => {\n        if (resolverOptions.formatValue) {\n          return resolverOptions.formatValue(ref, value);\n        }\n        return value;\n      },\n      format: (bindingLike, value) => resolverOptions.format ? resolverOptions.format(\n        isBinding(bindingLike) ? bindingLike : resolverOptions.parseBinding(bindingLike),\n        value\n      ) : value\n    },\n    evaluate: (exp) => resolverOptions.evaluator.evaluate(exp, resolverOptions)\n  };\n}\nfunction unpackAndPush(item, initial) {\n  if (item.asset.values && Array.isArray(item.asset.values)) {\n    item.asset.values.forEach((i) => {\n      unpackAndPush(i, initial);\n    });\n  } else {\n    initial.push(item);\n  }\n}\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/resolver/index.ts\nvar withContext = (model) => {\n  return {\n    get: (binding, options) => {\n      return model.get(binding, {\n        context: { model },\n        ...options\n      });\n    },\n    set: (transaction, options) => {\n      return model.set(transaction, {\n        context: { model },\n        ...options\n      });\n    },\n    delete: (binding, options) => {\n      return model.delete(binding, {\n        context: { model },\n        ...options\n      });\n    }\n  };\n};\nvar Resolver = class {\n  constructor(root, options) {\n    this.hooks = {\n      /** A hook to allow skipping of the resolution tree for a specific node */\n      skipResolve: new SyncWaterfallHook5(),\n      /** An event emitted before calculating the next update */\n      beforeUpdate: new SyncHook3(),\n      /** An event emitted after calculating the next update */\n      afterUpdate: new SyncHook3(),\n      /** The options passed to a node to resolve it to an object */\n      resolveOptions: new SyncWaterfallHook5(),\n      /** A hook to transform the AST node into a new AST node before resolving it */\n      beforeResolve: new SyncWaterfallHook5(),\n      /**\n       * A hook to transform an AST node into it's resolved value.\n       * This runs _before_ any children are resolved\n       */\n      resolve: new SyncWaterfallHook5(),\n      /**\n       * A hook to transform the resolved value of an AST node.\n       * This runs _after_ all children nodes are resolved\n       */\n      afterResolve: new SyncWaterfallHook5(),\n      /** Called at the very end of a node's tree being updated */\n      afterNodeUpdate: new SyncHook3()\n    };\n    this.root = root;\n    this.options = options;\n    this.resolveCache = /* @__PURE__ */ new Map();\n    this.ASTMap = /* @__PURE__ */ new Map();\n    this.logger = options.logger;\n    this.idCache = /* @__PURE__ */ new Set();\n  }\n  getSourceNode(convertedAST) {\n    return this.ASTMap.get(convertedAST);\n  }\n  update(changes) {\n    this.hooks.beforeUpdate.call(changes);\n    const resolveCache = /* @__PURE__ */ new Map();\n    this.idCache.clear();\n    const prevASTMap = new Map(this.ASTMap);\n    this.ASTMap.clear();\n    const updated = this.computeTree(\n      this.root,\n      void 0,\n      changes,\n      resolveCache,\n      toNodeResolveOptions(this.options),\n      void 0,\n      prevASTMap\n    );\n    this.resolveCache = resolveCache;\n    this.hooks.afterUpdate.call(updated.value);\n    return updated.value;\n  }\n  getResolveCache() {\n    return new Map(this.resolveCache);\n  }\n  getPreviousResult(node) {\n    if (!node) {\n      return;\n    }\n    const isFirstUpdate = this.resolveCache.size === 0;\n    const id = getNodeID(node);\n    if (id) {\n      if (this.idCache.has(id)) {\n        if (isFirstUpdate) {\n          if (node.type === \"asset\" /* Asset */ || node.type === \"view\" /* View */) {\n            this.logger?.error(\n              `Cache conflict: Found Asset/View nodes that have conflicting ids: ${id}, may cause cache issues.`\n            );\n          } else if (node.type === \"value\" /* Value */) {\n            this.logger?.info(\n              `Cache conflict: Found Value nodes that have conflicting ids: ${id}, may cause cache issues. To improve performance make value node IDs globally unique.`\n            );\n          }\n        }\n        return;\n      }\n      this.idCache.add(id);\n    }\n    return this.resolveCache.get(node);\n  }\n  cloneNode(node) {\n    const clonedNode = clone(node);\n    Object.keys(clonedNode).forEach((key) => {\n      if (key === \"parent\")\n        return;\n      const value = clonedNode[key];\n      if (typeof value === \"object\" && value !== null) {\n        clonedNode[key] = Array.isArray(value) ? [...value] : { ...value };\n      }\n    });\n    return clonedNode;\n  }\n  computeTree(node, rawParent, dataChanges, cacheUpdate, options, partiallyResolvedParent, prevASTMap) {\n    const dependencyModel = new DependencyModel(options.data.model);\n    dependencyModel.trackSubset(\"core\");\n    const depModelWithParser = withContext(\n      withParser(dependencyModel, this.options.parseBinding)\n    );\n    const resolveOptions = this.hooks.resolveOptions.call(\n      {\n        ...options,\n        data: {\n          ...options.data,\n          model: depModelWithParser\n        },\n        evaluate: (exp) => this.options.evaluator.evaluate(exp, { model: depModelWithParser }),\n        node\n      },\n      node\n    );\n    const previousResult = this.getPreviousResult(node);\n    const previousDeps = previousResult?.dependencies;\n    const dataChanged = caresAboutDataChanges(dataChanges, previousDeps);\n    const shouldUseLastValue = this.hooks.skipResolve.call(\n      !dataChanged,\n      node,\n      resolveOptions\n    );\n    const clonedNode = {\n      ...this.cloneNode(node),\n      parent: partiallyResolvedParent\n    };\n    const resolvedAST = this.hooks.beforeResolve.call(\n      clonedNode,\n      resolveOptions\n    ) ?? {\n      type: \"empty\" /* Empty */\n    };\n    const isNestedMultiNode = resolvedAST.type === \"multi-node\" /* MultiNode */ && partiallyResolvedParent?.parent?.type === \"multi-node\" /* MultiNode */ && partiallyResolvedParent.type === \"value\" /* Value */;\n    if (previousResult && shouldUseLastValue) {\n      const update2 = {\n        ...previousResult,\n        updated: false\n      };\n      const repopulateASTMapFromCache = (resolvedNode, AST, ASTParent) => {\n        const { node: resolvedASTLocal } = resolvedNode;\n        this.ASTMap.set(resolvedASTLocal, AST);\n        const resolvedUpdate = {\n          ...resolvedNode,\n          updated: false\n        };\n        cacheUpdate.set(AST, resolvedUpdate);\n        const handleChildNode = (childNode) => {\n          const originalChildNode = prevASTMap.get(childNode) ?? childNode;\n          const previousChildResult = this.getPreviousResult(originalChildNode);\n          if (!previousChildResult)\n            return;\n          repopulateASTMapFromCache(\n            previousChildResult,\n            originalChildNode,\n            AST\n          );\n        };\n        if (\"children\" in resolvedASTLocal) {\n          resolvedASTLocal.children?.forEach(\n            ({ value: childAST }) => handleChildNode(childAST)\n          );\n        } else if (resolvedASTLocal.type === \"multi-node\" /* MultiNode */) {\n          resolvedASTLocal.values.forEach(handleChildNode);\n        }\n        this.hooks.afterNodeUpdate.call(AST, ASTParent, resolvedUpdate);\n      };\n      previousResult.node.parent = partiallyResolvedParent;\n      repopulateASTMapFromCache(previousResult, node, rawParent);\n      return update2;\n    }\n    resolvedAST.parent = partiallyResolvedParent;\n    resolveOptions.node = resolvedAST;\n    this.ASTMap.set(resolvedAST, node);\n    let resolved = this.hooks.resolve.call(\n      void 0,\n      resolvedAST,\n      resolveOptions\n    );\n    let updated = !dequal(previousResult?.value, resolved);\n    if (previousResult && !updated) {\n      resolved = previousResult?.value;\n    }\n    const childDependencies = /* @__PURE__ */ new Set();\n    dependencyModel.trackSubset(\"children\");\n    if (\"children\" in resolvedAST) {\n      const newChildren = resolvedAST.children?.map((child) => {\n        const computedChildTree = this.computeTree(\n          child.value,\n          node,\n          dataChanges,\n          cacheUpdate,\n          resolveOptions,\n          resolvedAST,\n          prevASTMap\n        );\n        const {\n          dependencies: childTreeDeps,\n          node: childNode,\n          updated: childUpdated,\n          value: childValue\n        } = computedChildTree;\n        childTreeDeps.forEach((binding) => childDependencies.add(binding));\n        if (childValue) {\n          if (childNode.type === \"multi-node\" /* MultiNode */ && !childNode.override) {\n            const arr = addLast(\n              dlv(resolved, child.path, []),\n              childValue\n            );\n            resolved = setIn5(resolved, child.path, arr);\n          } else {\n            resolved = setIn5(resolved, child.path, childValue);\n          }\n        }\n        updated = updated || childUpdated;\n        return { ...child, value: childNode };\n      });\n      resolvedAST.children = newChildren;\n    } else if (resolvedAST.type === \"multi-node\" /* MultiNode */) {\n      const childValue = [];\n      const rawParentToPassIn = isNestedMultiNode ? partiallyResolvedParent?.parent : node;\n      const newValues = resolvedAST.values.map((mValue) => {\n        const mTree = this.computeTree(\n          mValue,\n          rawParentToPassIn,\n          dataChanges,\n          cacheUpdate,\n          resolveOptions,\n          resolvedAST,\n          prevASTMap\n        );\n        if (mTree.value !== void 0 && mTree.value !== null) {\n          if (mValue.type === \"async\" /* Async */ && mValue.flatten && mTree.value.asset && Array.isArray(mTree.value.asset.values)) {\n            unpackAndPush(mTree.value, childValue);\n          } else {\n            childValue.push(mTree.value);\n          }\n        }\n        mTree.dependencies.forEach(\n          (bindingDep) => childDependencies.add(bindingDep)\n        );\n        updated = updated || mTree.updated;\n        return mTree.node;\n      });\n      resolvedAST.values = newValues;\n      resolved = childValue;\n    }\n    childDependencies.forEach(\n      (bindingDep) => dependencyModel.addChildReadDep(bindingDep)\n    );\n    dependencyModel.trackSubset(\"core\");\n    if (previousResult && !updated) {\n      resolved = previousResult?.value;\n    }\n    resolved = this.hooks.afterResolve.call(resolved, resolvedAST, {\n      ...resolveOptions,\n      getDependencies: (scope) => dependencyModel.getDependencies(scope)\n    });\n    const update = {\n      node: resolvedAST,\n      updated,\n      value: resolved,\n      dependencies: /* @__PURE__ */ new Set([\n        ...dependencyModel.getDependencies(),\n        ...childDependencies\n      ])\n    };\n    this.hooks.afterNodeUpdate.call(\n      node,\n      isNestedMultiNode ? partiallyResolvedParent?.parent : rawParent,\n      update\n    );\n    cacheUpdate.set(node, update);\n    return update;\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/view.ts\nvar CrossfieldProvider = class {\n  constructor(initialView, parser, logger) {\n    this.allValidations = /* @__PURE__ */ new Set();\n    this.byBinding = /* @__PURE__ */ new Map();\n    this.logger = logger;\n    this.parse(initialView, parser);\n  }\n  parse(contentView, parser) {\n    const xfieldRefs = contentView.validation;\n    if (xfieldRefs === void 0) {\n      return;\n    }\n    if (!Array.isArray(xfieldRefs)) {\n      this.logger?.warn(\n        `Unable to register view validations for id: ${contentView.id}. 'validation' property must be an Array.`\n      );\n      return;\n    }\n    xfieldRefs.forEach((vRef) => {\n      const withDefaults = {\n        trigger: \"navigation\",\n        severity: \"error\",\n        ...vRef\n      };\n      this.allValidations.add(withDefaults);\n      const { ref } = vRef;\n      if (ref) {\n        const parsed = parser(ref);\n        if (this.byBinding.has(parsed)) {\n          this.byBinding.get(parsed)?.push(withDefaults);\n        } else {\n          this.byBinding.set(parsed, [withDefaults]);\n        }\n      }\n    });\n  }\n  getValidationsForBinding(binding) {\n    return this.byBinding.get(binding);\n  }\n};\nvar ViewInstance = class {\n  constructor(initialView, resolverOptions) {\n    this.hooks = {\n      onUpdate: new SyncHook4(),\n      parser: new SyncHook4(),\n      resolver: new SyncHook4(),\n      onTemplatePluginCreated: new SyncHook4(),\n      templatePlugin: new SyncHook4()\n    };\n    this.initialView = initialView;\n    this.resolverOptions = resolverOptions;\n    this.hooks.onTemplatePluginCreated.tap(\"view\", (templatePlugin) => {\n      this.templatePlugin = templatePlugin;\n    });\n  }\n  updateAsync() {\n    const update = this.resolver?.update();\n    this.lastUpdate = update;\n    this.hooks.onUpdate.call(update);\n  }\n  update(changes) {\n    if (this.rootNode === void 0) {\n      this.validationProvider = new CrossfieldProvider(\n        this.initialView,\n        this.resolverOptions.parseBinding,\n        this.resolverOptions.logger\n      );\n      if (this.templatePlugin) {\n        this.hooks.templatePlugin.call(this.templatePlugin);\n      } else {\n        this.resolverOptions.logger?.warn(\n          \"templatePlugin not set for View, legacy templates may not work\"\n        );\n      }\n      const parser = new Parser();\n      this.hooks.parser.call(parser);\n      this.rootNode = parser.parseView(this.initialView);\n      this.resolver = new Resolver(this.rootNode, {\n        ...this.resolverOptions,\n        parseNode: parser.parseObject.bind(parser)\n      });\n      this.hooks.resolver.call(this.resolver);\n    }\n    const update = this.resolver?.update(changes);\n    if (this.lastUpdate === update) {\n      return this.lastUpdate;\n    }\n    this.lastUpdate = update;\n    this.hooks.onUpdate.call(update);\n    return update;\n  }\n  getValidationsForBinding(binding) {\n    return this.validationProvider?.getValidationsForBinding(binding);\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/builder/index.ts\nvar Builder = class _Builder {\n  /**\n   * Creates an asset node\n   *\n   * @param value - the value to put in the asset node\n   */\n  static asset(value) {\n    return {\n      type: \"asset\" /* Asset */,\n      value\n    };\n  }\n  static assetWrapper(value) {\n    const valueNode = _Builder.value();\n    _Builder.addChild(valueNode, \"asset\", value);\n    return valueNode;\n  }\n  /**\n   * Creates a value node\n   *\n   * @param v - The object to put in the value node\n   */\n  static value(v) {\n    return {\n      type: \"value\" /* Value */,\n      value: v\n    };\n  }\n  /**\n   * Creates a multiNode and associates the multiNode as the parent\n   * of all the value nodes\n   *\n   * @param values - the value, applicability or async nodes to put in the multinode\n   */\n  static multiNode(...values) {\n    const m = {\n      type: \"multi-node\" /* MultiNode */,\n      override: true,\n      values\n    };\n    values.forEach((v) => {\n      v.parent = m;\n    });\n    return m;\n  }\n  /**\n   * Creates an async node\n   *\n   * @param id - the id of async node. It should be identical for each async node\n   */\n  static asyncNode(id, flatten2 = true) {\n    return {\n      id,\n      type: \"async\" /* Async */,\n      flatten: flatten2,\n      value: {\n        type: \"value\" /* Value */,\n        value: {\n          id\n        }\n      }\n    };\n  }\n  /**\n   * Adds a child node to a node\n   *\n   * @param node - The node to add a child to\n   * @param path - The path at which to add the child\n   * @param child - The child node\n   */\n  static addChild(node, path, child) {\n    child.parent = node;\n    const newChild = {\n      path: Array.isArray(path) ? path : [path],\n      value: child\n    };\n    node.children = node.children || [];\n    node.children.push(newChild);\n    return node;\n  }\n  /**\n   * Updates children of a node of the same path and preserves order\n   *\n   * @param node - The node to update children for\n   * @param pathToMatch - The path to match against child paths\n   * @param mapFn - Function to transform matching children\n   */\n  static updateChildrenByPath(node, pathToMatch, updateFn) {\n    if (!node.children)\n      return node;\n    const updatedChildren = node.children.map(\n      (child) => (\n        // Check if paths match exactly\n        child.path.join() === pathToMatch.join() ? { ...child, value: updateFn(child) } : child\n      )\n    );\n    return {\n      ...node,\n      children: updatedChildren\n    };\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/template.ts\nimport { SyncWaterfallHook as SyncWaterfallHook6 } from \"tapable-ts\";\nvar templateSymbol = Symbol(\"template\");\nvar TemplatePlugin = class {\n  constructor(options) {\n    this.hooks = {\n      resolveTemplateSubstitutions: new SyncWaterfallHook6()\n    };\n    this.options = options;\n  }\n  parseTemplate(parseObject, node, options) {\n    const { template, depth } = node;\n    const data = options.data.model.get(node.data);\n    if (!data) {\n      return null;\n    }\n    if (!Array.isArray(data)) {\n      throw new Error(`Template using '${node.data}' but is not an array`);\n    }\n    const values = [];\n    data.forEach((dataItem, index) => {\n      const templateSubstitutions = this.hooks.resolveTemplateSubstitutions.call(\n        [\n          {\n            expression: new RegExp(`_index${depth || \"\"}_`),\n            value: String(index)\n          }\n        ],\n        {\n          depth,\n          data: dataItem,\n          index\n        }\n      );\n      let templateStr = JSON.stringify(template);\n      for (const { expression, value } of templateSubstitutions) {\n        let flags = \"g\";\n        if (typeof expression === \"object\") {\n          flags = `${expression.flags}${expression.global ? \"\" : \"g\"}`;\n        }\n        templateStr = templateStr.replace(new RegExp(expression, flags), value);\n      }\n      const parsed = parseObject(JSON.parse(templateStr), \"value\" /* Value */, {\n        templateDepth: node.depth + 1\n      });\n      if (parsed) {\n        values.push(parsed);\n      }\n    });\n    const result = {\n      type: \"multi-node\" /* MultiNode */,\n      override: false,\n      values\n    };\n    if (node.placement !== void 0) {\n      result[templateSymbol] = node.placement;\n    }\n    return result;\n  }\n  applyParser(parser) {\n    parser.hooks.onCreateASTNode.tap(\"template\", (node) => {\n      if (node && node.type === \"template\" /* Template */ && !node.dynamic) {\n        return this.parseTemplate(\n          parser.parseObject.bind(parser),\n          node,\n          this.options\n        );\n      }\n      return node;\n    });\n    parser.hooks.onCreateASTNode.tap(\"template\", (node) => {\n      function getTemplateSymbolValue(node2) {\n        if (node2.type === \"multi-node\" /* MultiNode */) {\n          return node2[templateSymbol];\n        } else if (node2.type === \"template\" /* Template */) {\n          return node2.placement;\n        }\n        return void 0;\n      }\n      if (node && (node.type === \"view\" /* View */ || node.type === \"asset\" /* Asset */) && Array.isArray(node.children)) {\n        node.children = node.children.sort((a, b) => {\n          const aPath = a.path.join();\n          const bPath = b.path.join();\n          const pathsEqual = aPath === bPath;\n          if (pathsEqual) {\n            const aPlacement = getTemplateSymbolValue(a.value);\n            const bPlacement = getTemplateSymbolValue(b.value);\n            if (aPlacement !== void 0 && bPlacement === void 0) {\n              return aPlacement === \"prepend\" ? -1 : 1;\n            } else if (bPlacement !== void 0 && aPlacement === void 0) {\n              return bPlacement === \"prepend\" ? 1 : -1;\n            } else if (aPlacement !== void 0 && bPlacement !== void 0) {\n              if (aPlacement === bPlacement) {\n                return 0;\n              }\n              return aPlacement === \"prepend\" ? -1 : 1;\n            }\n            return 0;\n          }\n          return aPath > bPath ? 1 : -1;\n        });\n      }\n      return node;\n    });\n    parser.hooks.parseNode.tap(\n      \"template\",\n      (obj, _nodeType, options, childOptions) => {\n        if (childOptions && hasTemplateKey(childOptions.key)) {\n          return obj.map((template) => {\n            const templateAST = parser.createASTNode(\n              {\n                type: \"template\" /* Template */,\n                depth: options.templateDepth ?? 0,\n                data: template.data,\n                template: template.value,\n                dynamic: template.dynamic ?? false,\n                placement: template.placement\n              },\n              template\n            );\n            if (!templateAST)\n              return;\n            if (templateAST.type === \"multi-node\" /* MultiNode */) {\n              templateAST.values.forEach((v) => {\n                v.parent = templateAST;\n              });\n            }\n            return {\n              path: [...childOptions.path, template.output],\n              value: templateAST\n            };\n          }).filter(Boolean);\n        }\n      }\n    );\n  }\n  applyResolverHooks(resolver) {\n    resolver.hooks.beforeResolve.tap(\"template\", (node, options) => {\n      if (node && node.type === \"template\" /* Template */ && node.dynamic) {\n        return this.parseTemplate(options.parseNode, node, options);\n      }\n      return node;\n    });\n  }\n  apply(view) {\n    view.hooks.parser.tap(\"template\", this.applyParser.bind(this));\n    view.hooks.resolver.tap(\"template\", this.applyResolverHooks.bind(this));\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/string-resolver.ts\nimport { set } from \"timm\";\nvar createPatternMatcher = (start, end) => {\n  return (testStr) => {\n    const startLocation = testStr.indexOf(start);\n    if (startLocation === -1) {\n      return false;\n    }\n    const endLocation = testStr.indexOf(end);\n    if (endLocation === -1) {\n      return false;\n    }\n    return startLocation < endLocation;\n  };\n};\nvar bindingResolveLookup = createPatternMatcher(\"{{\", \"}}\");\nvar expressionResolveLookup = createPatternMatcher(\"@[\", \"]@\");\nfunction hasSomethingToResolve(str) {\n  return bindingResolveLookup(str) || expressionResolveLookup(str);\n}\nfunction resolveString(str, resolveOptions) {\n  return hasSomethingToResolve(str) ? resolveDataRefs(str, {\n    model: resolveOptions.data.model,\n    evaluate: resolveOptions.evaluate\n  }) : str;\n}\nfunction resolveAllRefs(node, resolveOptions, propertiesToSkip) {\n  if (node === null || node === void 0 || typeof node !== \"object\" && typeof node !== \"string\") {\n    return node;\n  }\n  if (typeof node === \"string\") {\n    return resolveString(node, resolveOptions);\n  }\n  let newNode = node;\n  Object.keys(node).forEach((key) => {\n    if (propertiesToSkip.has(key)) {\n      return;\n    }\n    const val = node[key];\n    let newVal = val;\n    if (typeof val === \"object\") {\n      newVal = resolveAllRefs(val, resolveOptions, propertiesToSkip);\n    } else if (typeof val === \"string\") {\n      newVal = resolveString(val, resolveOptions);\n    }\n    if (newVal !== val) {\n      newNode = set(newNode, key, newVal);\n    }\n  });\n  return newNode;\n}\nvar findBasePath = (node, resolver) => {\n  const parentNode = node.parent;\n  if (!parentNode) {\n    return [];\n  }\n  if (\"children\" in parentNode) {\n    const original = resolver.getSourceNode(node);\n    return parentNode.children?.find((child) => child.value === original)?.path ?? [];\n  }\n  if (parentNode.type !== \"multi-node\" /* MultiNode */) {\n    return [];\n  }\n  return findBasePath(parentNode, resolver);\n};\nvar StringResolverPlugin = class {\n  constructor() {\n    this.propertiesToSkipCache = /* @__PURE__ */ new Map();\n  }\n  applyResolver(resolver) {\n    resolver.hooks.resolve.tap(\"string-resolver\", (value, node, options) => {\n      if (node.type === \"empty\" /* Empty */ || node.type === \"unknown\" /* Unknown */) {\n        return null;\n      }\n      if (node.type === \"value\" /* Value */ || node.type === \"asset\" /* Asset */ || node.type === \"view\" /* View */) {\n        let propsToSkip;\n        if (node.type === \"asset\" /* Asset */ || node.type === \"view\" /* View */) {\n          propsToSkip = new Set(\n            node.plugins?.stringResolver?.propertiesToSkip ?? [\"exp\"]\n          );\n          if (node.value?.id) {\n            this.propertiesToSkipCache.set(node.value.id, propsToSkip);\n          }\n        } else if (node.parent?.type === \"multi-node\" /* MultiNode */ && (node.parent?.parent?.type === \"asset\" /* Asset */ || node.parent?.parent?.type === \"view\" /* View */) && node.parent.parent.value?.id && this.propertiesToSkipCache.has(node.parent.parent.value.id)) {\n          propsToSkip = this.propertiesToSkipCache.get(\n            node.parent.parent.value.id\n          );\n        } else {\n          propsToSkip = /* @__PURE__ */ new Set([\"exp\"]);\n        }\n        const nodePath = findBasePath(node, resolver);\n        if (nodePath.length > 0 && nodePath.some((segment) => propsToSkip.has(segment.toString()))) {\n          return node.value;\n        }\n        return resolveAllRefs(node.value, options, propsToSkip);\n      }\n      return value;\n    });\n  }\n  apply(view) {\n    view.hooks.resolver.tap(\"string-resolver\", this.applyResolver.bind(this));\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/applicability.ts\nimport { omit as omit2 } from \"timm\";\nvar ApplicabilityPlugin = class {\n  isApplicability(obj) {\n    return obj && Object.prototype.hasOwnProperty.call(obj, \"applicability\");\n  }\n  applyResolver(resolver) {\n    resolver.hooks.beforeResolve.tap(\n      \"applicability\",\n      (node, options) => {\n        let newNode = node;\n        if (node?.type === \"applicability\" /* Applicability */) {\n          const isApplicable = options.evaluate(node.expression);\n          if (isApplicable === false) {\n            return null;\n          }\n          newNode = node.value;\n        }\n        return newNode;\n      }\n    );\n  }\n  applyParser(parser) {\n    parser.hooks.parseNode.tap(\n      \"applicability\",\n      (obj, nodeType, options, childOptions) => {\n        if (this.isApplicability(obj)) {\n          const parsedApplicability = parser.parseObject(\n            omit2(obj, \"applicability\"),\n            nodeType,\n            options\n          );\n          if (!parsedApplicability) {\n            return childOptions ? [] : null;\n          }\n          const applicabilityNode = parser.createASTNode(\n            {\n              type: \"applicability\" /* Applicability */,\n              expression: obj.applicability,\n              value: parsedApplicability\n            },\n            obj\n          );\n          if (!applicabilityNode) {\n            return childOptions ? [] : null;\n          }\n          if (applicabilityNode.type === \"applicability\" /* Applicability */) {\n            applicabilityNode.value.parent = applicabilityNode;\n          }\n          return childOptions ? [\n            {\n              path: [...childOptions.path, childOptions.key],\n              value: applicabilityNode\n            }\n          ] : applicabilityNode;\n        }\n      }\n    );\n  }\n  apply(view) {\n    view.hooks.resolver.tap(\"applicability\", this.applyResolver.bind(this));\n    view.hooks.parser.tap(\"applicability\", this.applyParser.bind(this));\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/switch.ts\nvar SwitchPlugin = class {\n  constructor(options) {\n    this.options = options;\n  }\n  resolveSwitch(node, options) {\n    for (const switchCase of node.cases) {\n      const isApplicable = options.evaluate(switchCase.case);\n      if (isApplicable) {\n        return switchCase.value;\n      }\n    }\n    return EMPTY_NODE;\n  }\n  isSwitch(obj) {\n    return obj && (Object.prototype.hasOwnProperty.call(obj, \"dynamicSwitch\") || Object.prototype.hasOwnProperty.call(obj, \"staticSwitch\"));\n  }\n  applyParser(parser) {\n    parser.hooks.onCreateASTNode.tap(\"switch\", (node) => {\n      if (node && node.type === \"switch\" /* Switch */ && !node.dynamic) {\n        return this.resolveSwitch(node, this.options);\n      }\n      return node;\n    });\n    parser.hooks.parseNode.tap(\n      \"switch\",\n      (obj, _nodeType, options, childOptions) => {\n        if (this.isSwitch(obj) || childOptions && hasSwitchKey(childOptions.key)) {\n          const objToParse = childOptions && hasSwitchKey(childOptions.key) ? { [childOptions.key]: obj } : obj;\n          const dynamic = \"dynamicSwitch\" in objToParse;\n          const switchContent = dynamic ? objToParse.dynamicSwitch : objToParse.staticSwitch;\n          const cases = switchContent.map(\n            (switchCase) => {\n              const { case: switchCaseExpr, ...switchBody } = switchCase;\n              const value = parser.parseObject(\n                switchBody,\n                \"value\" /* Value */,\n                options\n              );\n              if (value) {\n                return {\n                  case: switchCaseExpr,\n                  value\n                };\n              }\n              return;\n            }\n          ).filter(Boolean);\n          const switchAST = parser.createASTNode(\n            {\n              type: \"switch\" /* Switch */,\n              dynamic,\n              cases\n            },\n            objToParse\n          );\n          if (!switchAST || switchAST.type === \"empty\" /* Empty */) {\n            return childOptions ? [] : null;\n          }\n          if (switchAST.type === \"switch\" /* Switch */) {\n            switchAST.cases.forEach((sCase) => {\n              sCase.value.parent = switchAST;\n            });\n          }\n          if (childOptions) {\n            let path = [...childOptions.path, childOptions.key];\n            let value = switchAST;\n            if (switchAST.type === \"value\" /* Value */ && switchAST.children?.length === 1 && switchAST.value === void 0) {\n              const firstChild = switchAST.children[0];\n              path = [...path, ...firstChild.path];\n              value = firstChild.value;\n            }\n            return [{ path, value }];\n          }\n          return switchAST;\n        }\n      }\n    );\n  }\n  applyResolver(resolver) {\n    resolver.hooks.beforeResolve.tap(\"switch\", (node, options) => {\n      if (node && node.type === \"switch\" /* Switch */ && node.dynamic) {\n        return this.resolveSwitch(node, options);\n      }\n      return node;\n    });\n  }\n  apply(view) {\n    view.hooks.parser.tap(\"switch\", this.applyParser.bind(this));\n    view.hooks.resolver.tap(\"switch\", this.applyResolver.bind(this));\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/multi-node.ts\nvar MultiNodePlugin = class {\n  applyParser(parser) {\n    parser.hooks.parseNode.tap(\n      \"multi-node\",\n      (obj, nodeType, options, childOptions) => {\n        if (childOptions && !hasTemplateKey(childOptions.key) && Array.isArray(obj)) {\n          const values = obj.map(\n            (childVal) => parser.parseObject(childVal, \"value\" /* Value */, options)\n          ).filter((child) => !!child);\n          if (!values.length) {\n            return [];\n          }\n          const multiNode = parser.createASTNode(\n            {\n              type: \"multi-node\" /* MultiNode */,\n              override: !hasTemplateValues(\n                childOptions.parentObj,\n                childOptions.key\n              ),\n              values\n            },\n            obj\n          );\n          if (!multiNode) {\n            return [];\n          }\n          if (multiNode.type === \"multi-node\" /* MultiNode */) {\n            multiNode.values.forEach((v) => {\n              v.parent = multiNode;\n            });\n          }\n          return [\n            {\n              path: [...childOptions.path, childOptions.key],\n              value: multiNode\n            }\n          ];\n        }\n      }\n    );\n  }\n  apply(view) {\n    view.hooks.parser.tap(\"multi-node\", this.applyParser.bind(this));\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/view/plugins/asset.ts\nvar AssetPlugin = class {\n  applyParser(parser) {\n    parser.hooks.parseNode.tap(\n      \"asset\",\n      (obj, nodeType, options, childOptions) => {\n        if (childOptions?.key === \"asset\" && typeof obj === \"object\") {\n          const assetAST = parser.parseObject(obj, \"asset\" /* Asset */, options);\n          if (!assetAST) {\n            return [];\n          }\n          return [\n            {\n              path: [...childOptions.path, childOptions.key],\n              value: assetAST\n            }\n          ];\n        }\n      }\n    );\n  }\n  apply(view) {\n    view.hooks.parser.tap(\"asset\", this.applyParser.bind(this));\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/player.ts\nimport { setIn as setIn7 } from \"timm\";\nimport deferred from \"p-defer\";\nimport { SyncHook as SyncHook10, SyncWaterfallHook as SyncWaterfallHook11 } from \"tapable-ts\";\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/flow/flow.ts\nimport { SyncBailHook as SyncBailHook4, SyncHook as SyncHook5, SyncWaterfallHook as SyncWaterfallHook7 } from \"tapable-ts\";\nimport defer from \"p-defer\";\nvar FlowInstance = class {\n  constructor(id, flow, options) {\n    this.isTransitioning = false;\n    this.hooks = {\n      beforeStart: new SyncBailHook4(),\n      /** A callback when the onStart node was present */\n      onStart: new SyncHook5(),\n      /** A callback when the onEnd node was present */\n      onEnd: new SyncHook5(),\n      /** A hook to intercept and block a transition */\n      skipTransition: new SyncBailHook4(),\n      /** A chance to manipulate the flow-node used to calculate the given transition used  */\n      beforeTransition: new SyncWaterfallHook7(),\n      /** A chance to manipulate the flow-node calculated after a transition */\n      resolveTransitionNode: new SyncWaterfallHook7(),\n      /** A callback when a transition from 1 state to another was made */\n      transition: new SyncHook5(),\n      /** A callback to run actions after a transition occurs */\n      afterTransition: new SyncHook5()\n    };\n    this.id = id;\n    this.flow = flow;\n    this.log = options?.logger;\n    this.history = [];\n    this.hooks.transition.tap(\n      \"startPromise\",\n      async (_oldState, nextState) => {\n        const newState = nextState.value;\n        if (this.flowPromise && newState.state_type === \"END\") {\n          this.flowPromise.resolve(newState);\n        }\n      }\n    );\n  }\n  /** Start the state machine */\n  async start() {\n    if (this.flowPromise) {\n      this.log?.warn(\"Already called start for flow\");\n      return this.flowPromise.promise;\n    }\n    this.flow = this.hooks.beforeStart.call(this.flow) || this.flow;\n    if (this.flow.onStart) {\n      this.hooks.onStart.call(this.flow.onStart);\n    }\n    const initialState = this.flow.startState;\n    if (!initialState) {\n      return Promise.reject(new Error(\"No 'startState' defined for flow\"));\n    }\n    this.flowPromise = defer();\n    this.pushHistory(initialState);\n    return this.flowPromise.promise;\n  }\n  transition(transitionValue, options) {\n    if (this.isTransitioning) {\n      throw new Error(\n        `Transitioning while ongoing transition from ${this.currentState?.name} is in progress is not supported`\n      );\n    }\n    if (this.currentState?.value.state_type === \"END\") {\n      this.log?.warn(\n        `Skipping transition using ${transitionValue}. Already at and END state`\n      );\n      return;\n    }\n    if (this.currentState === void 0) {\n      throw new Error(\"Cannot transition when there's no current state\");\n    }\n    if (options?.force) {\n      this.log?.debug(`Forced transition. Skipping validation checks`);\n    } else {\n      const skipTransition = this.hooks.skipTransition.call(this.currentState);\n      if (skipTransition) {\n        this.log?.debug(\n          `Skipping transition from ${this.currentState.name} b/c hook told us to`\n        );\n        return;\n      }\n    }\n    const state = this.hooks.beforeTransition.call(\n      this.currentState.value,\n      transitionValue\n    );\n    if (!(\"transitions\" in state)) {\n      throw new Error(`No transitions defined for ${this.currentState.value}`);\n    }\n    const { transitions } = state;\n    const nextState = transitions[transitionValue] || transitions[\"*\"];\n    if (nextState === void 0) {\n      this.log?.warn(\n        `No transition from ${this.currentState.name} using ${transitionValue} or *`\n      );\n      return;\n    }\n    this.log?.debug(\n      `Transitioning from ${this.currentState.name} to ${nextState} using ${transitionValue} `\n    );\n    return this.pushHistory(nextState, options);\n  }\n  pushHistory(stateName, options) {\n    if (!Object.prototype.hasOwnProperty.call(this.flow, stateName)) {\n      throw new Error(`No flow definition for: ${stateName} was found.`);\n    }\n    let nextState = this.flow[stateName];\n    if (!this.flow[stateName] || typeof nextState !== \"object\" || !(\"state_type\" in nextState)) {\n      this.log?.error(`Flow doesn't contain any states named: ${stateName}`);\n      return;\n    }\n    const prevState = this.currentState;\n    this.isTransitioning = true;\n    nextState = this.hooks.resolveTransitionNode.call(nextState);\n    const newCurrentState = {\n      name: stateName,\n      value: nextState\n    };\n    this.currentState = newCurrentState;\n    this.history.push(stateName);\n    if (newCurrentState.value.state_type === \"END\" && this.flow.onEnd) {\n      this.hooks.onEnd.call(this.flow.onEnd);\n    }\n    this.hooks.transition.call(prevState, {\n      ...newCurrentState\n    });\n    this.isTransitioning = false;\n    this.hooks.afterTransition.call(this);\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/flow/controller.ts\nimport { SyncHook as SyncHook6 } from \"tapable-ts\";\nvar FlowController = class {\n  constructor(navigation, options) {\n    this.hooks = {\n      flow: new SyncHook6()\n    };\n    this.navigation = navigation;\n    this.navStack = [];\n    this.log = options?.logger;\n    this.start = this.start.bind(this);\n    this.run = this.run.bind(this);\n    this.transition = this.transition.bind(this);\n    this.addNewFlow = this.addNewFlow.bind(this);\n  }\n  /** Navigate to another state in the state-machine */\n  transition(stateTransition, options) {\n    if (this.current === void 0) {\n      throw new Error(\"Not currently in a flow. Cannot transition.\");\n    }\n    this.current.transition(stateTransition, options);\n  }\n  addNewFlow(flow) {\n    this.navStack.push(flow);\n    this.current = flow;\n    this.hooks.flow.call(flow);\n  }\n  async run(startState) {\n    if (!Object.prototype.hasOwnProperty.call(this.navigation, startState)) {\n      return Promise.reject(new Error(`No flow defined for: ${startState}`));\n    }\n    const startFlow = this.navigation[startState];\n    if (startFlow === null || typeof startFlow !== \"object\") {\n      return Promise.reject(\n        new Error(`Flow: ${startState} needs to be an object`)\n      );\n    }\n    this.log?.debug(`Starting flow: ${startState}`);\n    const flow = new FlowInstance(startState, startFlow, { logger: this.log });\n    this.addNewFlow(flow);\n    flow.hooks.afterTransition.tap(\"flow-controller\", (flowInstance) => {\n      if (flowInstance.currentState?.value.state_type === \"FLOW\") {\n        const subflowId = flowInstance.currentState?.value.ref;\n        this.log?.debug(`Loading subflow ${subflowId}`);\n        this.run(subflowId).then((subFlowEndState) => {\n          this.log?.debug(\n            `Subflow ended. Using outcome: ${subFlowEndState.outcome}`\n          );\n          flowInstance.transition(subFlowEndState?.outcome);\n        });\n      }\n    });\n    const end = await flow.start();\n    this.navStack.pop();\n    if (this.navStack.length > 0) {\n      const firstItem = 0;\n      this.current = this.navStack[firstItem];\n    }\n    return end;\n  }\n  async start() {\n    if (!this.navigation.BEGIN) {\n      return Promise.reject(new Error(\"Must supply a BEGIN state\"));\n    }\n    return this.run(this.navigation.BEGIN);\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/validation/controller.ts\nimport { SyncHook as SyncHook7, SyncWaterfallHook as SyncWaterfallHook8 } from \"tapable-ts\";\nimport { setIn as setIn6 } from \"timm\";\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/utils/replaceParams.ts\nvar ANY_CHAR_REGEX = /%([a-zA-Z]+)/g;\nfunction replaceParams(message, params) {\n  return message.slice().replace(ANY_CHAR_REGEX, (keyExpr) => params[keyExpr.slice(1)] || keyExpr);\n}\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/validation/binding-tracker.ts\nvar CONTEXT = \"validation-binding-tracker\";\nvar ValidationBindingTrackerViewPlugin = class {\n  constructor(options) {\n    this.trackedBindings = /* @__PURE__ */ new Set();\n    this.options = options;\n  }\n  /** Fetch the tracked bindings in the current view */\n  getBindings() {\n    return this.trackedBindings;\n  }\n  /** Add a binding to the tracked set */\n  trackBinding(binding) {\n    if (this.trackedBindings.has(binding)) {\n      return;\n    }\n    this.trackedBindings.add(binding);\n    this.options.callbacks?.onAdd?.(binding);\n  }\n  /** Attach hooks to the given resolver */\n  applyResolver(resolver) {\n    this.trackedBindings.clear();\n    const tracked = /* @__PURE__ */ new Map();\n    const sections = /* @__PURE__ */ new Map();\n    let lastViewUpdateChangeSet;\n    const lastComputedBindingTree = /* @__PURE__ */ new Map();\n    let currentBindingTree = /* @__PURE__ */ new Map();\n    const lastSectionBindingTree = /* @__PURE__ */ new Map();\n    const resolvedNodeMap = /* @__PURE__ */ new Map();\n    resolver.hooks.beforeUpdate.tap(CONTEXT, (changes) => {\n      lastViewUpdateChangeSet = changes;\n    });\n    resolver.hooks.skipResolve.tap(CONTEXT, (shouldSkip, node) => {\n      const trackedBindingsForNode = lastComputedBindingTree.get(node);\n      if (!shouldSkip || !lastViewUpdateChangeSet || !trackedBindingsForNode) {\n        return shouldSkip;\n      }\n      const intersection = new Set(\n        [...lastViewUpdateChangeSet].filter(\n          (b) => trackedBindingsForNode.has(b)\n        )\n      );\n      return intersection.size === 0;\n    });\n    resolver.hooks.resolveOptions.tap(CONTEXT, (options, node) => {\n      if (options.validation === void 0) {\n        return options;\n      }\n      tracked.delete(node);\n      const track = (binding) => {\n        const parsed = isBinding(binding) ? binding : this.options.parseBinding(binding);\n        if (tracked.has(node)) {\n          tracked.get(node)?.add(parsed);\n        } else {\n          tracked.set(node, /* @__PURE__ */ new Set([parsed]));\n        }\n        let { parent } = node;\n        while (parent) {\n          if (sections.has(parent)) {\n            sections.get(parent)?.add(node);\n            break;\n          } else {\n            parent = parent.parent;\n          }\n        }\n        this.trackedBindings.add(parsed);\n        this.options.callbacks?.onAdd?.(parsed);\n      };\n      return {\n        ...options,\n        validation: {\n          ...options.validation,\n          get: (binding, getOptions) => {\n            if (getOptions?.track) {\n              track(binding);\n            }\n            const eows = options.validation?._getValidationForBinding(binding)?.getAll(getOptions);\n            const firstFieldEOW = eows?.find(\n              (eow) => eow.displayTarget === \"field\" || eow.displayTarget === void 0\n            );\n            return firstFieldEOW;\n          },\n          getValidationsForBinding(binding, getOptions) {\n            if (getOptions?.track) {\n              track(binding);\n            }\n            return options.validation?._getValidationForBinding(binding)?.getAll(getOptions) ?? [];\n          },\n          getChildren: (type) => {\n            const validations = new Array();\n            lastComputedBindingTree.get(node)?.forEach((binding) => {\n              const eow = options.validation?._getValidationForBinding(binding)?.get();\n              if (eow && (type === void 0 || type === eow.displayTarget)) {\n                validations.push(eow);\n              }\n            });\n            return validations;\n          },\n          getValidationsForSection: () => {\n            const validations = new Array();\n            lastSectionBindingTree.get(node)?.forEach((binding) => {\n              const eow = options.validation?._getValidationForBinding(binding)?.get();\n              if (eow && eow.displayTarget === \"section\") {\n                validations.push(eow);\n              }\n            });\n            return validations;\n          },\n          register: (registerOptions) => {\n            if (registerOptions?.type === \"section\") {\n              if (!sections.has(node)) {\n                sections.set(node, /* @__PURE__ */ new Set());\n              }\n            }\n          },\n          track\n        }\n      };\n    });\n    resolver.hooks.afterNodeUpdate.tap(\n      CONTEXT,\n      (originalNode, parent, update) => {\n        const { updated, node: resolvedNode } = update;\n        resolvedNodeMap.set(resolvedNode, originalNode);\n        if (updated) {\n          const newlyComputed = new Set(tracked.get(originalNode));\n          if (resolvedNode.type === \"multi-node\" /* MultiNode */) {\n            resolvedNode.values.forEach(\n              (value) => currentBindingTree.get(value)?.forEach((b) => newlyComputed.add(b))\n            );\n          }\n          if (\"children\" in resolvedNode && resolvedNode.children) {\n            resolvedNode.children.forEach((child) => {\n              currentBindingTree.get(child.value)?.forEach((b) => newlyComputed.add(b));\n            });\n          }\n          currentBindingTree.set(resolvedNode, newlyComputed);\n        } else {\n          currentBindingTree.set(\n            resolvedNode,\n            lastComputedBindingTree.get(originalNode) ?? /* @__PURE__ */ new Set()\n          );\n        }\n        if (originalNode === resolver.root) {\n          this.trackedBindings = new Set(currentBindingTree.get(resolvedNode));\n          lastComputedBindingTree.clear();\n          currentBindingTree.forEach((value, key) => {\n            const node = resolvedNodeMap.get(key);\n            if (node) {\n              lastComputedBindingTree.set(node, value);\n            }\n          });\n          lastSectionBindingTree.clear();\n          sections.forEach((nodeSet, sectionNode) => {\n            const temp = /* @__PURE__ */ new Set();\n            nodeSet.forEach((n) => {\n              tracked.get(n)?.forEach(temp.add, temp);\n            });\n            lastSectionBindingTree.set(sectionNode, temp);\n          });\n          tracked.clear();\n          sections.clear();\n          currentBindingTree = /* @__PURE__ */ new Map();\n        }\n      }\n    );\n  }\n  apply(view) {\n    view.hooks.resolver.tap(CONTEXT, this.applyResolver.bind(this));\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/validation/controller.ts\nvar SCHEMA_VALIDATION_PROVIDER_NAME = \"schema\";\nvar VIEW_VALIDATION_PROVIDER_NAME = \"view\";\nvar VALIDATION_PROVIDER_NAME_SYMBOL = Symbol.for(\n  \"validation-provider-name\"\n);\nfunction isSubset(subset, containingSet) {\n  if (subset.size > containingSet.size)\n    return false;\n  for (const entry of subset)\n    if (!containingSet.has(entry))\n      return false;\n  return true;\n}\nfunction createStatefulValidationObject(obj) {\n  return {\n    value: obj,\n    type: obj.severity,\n    state: \"none\",\n    isBlockingNavigation: false\n  };\n}\nvar ValidatedBinding = class {\n  constructor(possibleValidations, onDismiss, log, weakBindings) {\n    this.applicableValidations = [];\n    this.validationsByState = {\n      load: [],\n      change: [],\n      navigation: []\n    };\n    this.onDismiss = onDismiss;\n    possibleValidations.forEach((vObj) => {\n      const { trigger } = vObj;\n      if (this.validationsByState[trigger]) {\n        const statefulValidationObject = createStatefulValidationObject(vObj);\n        this.validationsByState[trigger].push(statefulValidationObject);\n      } else {\n        log?.warn(`Unknown validation trigger: ${trigger}`);\n      }\n    });\n    this.weakBindings = weakBindings ?? /* @__PURE__ */ new Set();\n  }\n  get allValidations() {\n    return Object.values(this.validationsByState).flat();\n  }\n  checkIfBlocking(statefulObj) {\n    if (statefulObj.state === \"active\") {\n      const { isBlockingNavigation } = statefulObj;\n      return isBlockingNavigation;\n    }\n    return false;\n  }\n  getAll() {\n    return this.applicableValidations.reduce((all, statefulObj) => {\n      if (statefulObj.state === \"active\" && statefulObj.response) {\n        all.push({\n          ...statefulObj.response,\n          blocking: this.checkIfBlocking(statefulObj)\n        });\n      }\n      return all;\n    }, []);\n  }\n  get() {\n    const firstInvalid = this.applicableValidations.find((statefulObj) => {\n      return statefulObj.state === \"active\" && statefulObj.response;\n    });\n    if (firstInvalid?.state === \"active\") {\n      return {\n        ...firstInvalid.response,\n        blocking: this.checkIfBlocking(firstInvalid)\n      };\n    }\n  }\n  runApplicableValidations(runner, canDismiss, phase) {\n    this.applicableValidations = this.applicableValidations.map(\n      (originalValue) => {\n        if (originalValue.state === \"dismissed\") {\n          return originalValue;\n        }\n        const blocking = originalValue.value.blocking ?? (originalValue.value.severity === \"warning\" && \"once\" || true);\n        const obj = setIn6(\n          originalValue,\n          [\"value\", \"blocking\"],\n          blocking\n        );\n        const isBlockingNavigation = blocking === true || blocking === \"once\" && !canDismiss;\n        if (phase === \"navigation\" && obj.state === \"active\" && obj.value.blocking !== true) {\n          if (obj.value.severity === \"warning\") {\n            const warn = obj;\n            if (warn.dismissable && warn.response.dismiss && (warn.response.blocking !== \"once\" || !warn.response.blocking)) {\n              warn.response.dismiss();\n            } else {\n              if (warn?.response.blocking === \"once\") {\n                warn.response.blocking = false;\n              }\n              warn.dismissable = true;\n            }\n            return warn;\n          }\n        }\n        const response = runner(obj.value);\n        const newState = {\n          type: obj.type,\n          value: obj.value,\n          state: response ? \"active\" : \"none\",\n          isBlockingNavigation,\n          dismissable: obj.value.severity === \"warning\" && phase === \"navigation\",\n          response: response ? {\n            ...obj.value,\n            message: response.message ?? \"Something is broken\",\n            severity: obj.value.severity,\n            displayTarget: obj.value.displayTarget ?? \"field\"\n          } : void 0\n        };\n        if (newState.state === \"active\" && obj.value.severity === \"warning\") {\n          newState.response.dismiss = () => {\n            newState.state = \"dismissed\";\n            this.onDismiss?.();\n          };\n        }\n        return newState;\n      }\n    );\n  }\n  update(phase, canDismiss, runner) {\n    const newApplicableValidations = [];\n    if (phase === \"load\" && this.currentPhase !== void 0) {\n      return;\n    }\n    if (this.currentPhase === \"navigation\" || phase === this.currentPhase) {\n      this.runApplicableValidations(runner, canDismiss, phase);\n      return;\n    }\n    if (phase === \"load\") {\n      this.currentPhase = \"load\";\n      this.applicableValidations = [...this.validationsByState.load];\n    } else if (phase === \"change\" && this.currentPhase === \"load\") {\n      this.currentPhase = \"change\";\n      this.applicableValidations = [\n        ...this.applicableValidations,\n        ...this.validationsByState.change\n      ];\n    } else if (phase === \"navigation\" && (this.currentPhase === \"load\" || this.currentPhase === \"change\")) {\n      this.applicableValidations.forEach((element) => {\n        if (!(element.type === \"error\" && element.state === \"active\" && element.isBlockingNavigation === false)) {\n          newApplicableValidations.push(element);\n        }\n      });\n      this.applicableValidations = [\n        ...newApplicableValidations,\n        ...this.validationsByState.navigation,\n        ...this.currentPhase === \"load\" ? this.validationsByState.change : []\n      ];\n      this.currentPhase = \"navigation\";\n    }\n    this.runApplicableValidations(runner, canDismiss, phase);\n  }\n};\nvar ValidationController = class {\n  constructor(schema, options) {\n    this.hooks = {\n      /** A hook called to tap into the validator registry for adding more validators */\n      createValidatorRegistry: new SyncHook7(),\n      /** A callback/event when a new validation is added to the view */\n      onAddValidation: new SyncWaterfallHook8(),\n      /** The inverse of onAddValidation, this is called when a validation is removed from the list */\n      onRemoveValidation: new SyncWaterfallHook8(),\n      resolveValidationProviders: new SyncWaterfallHook8(),\n      /** A hook called when a binding is added to the tracker */\n      onTrackBinding: new SyncHook7()\n    };\n    this.validations = /* @__PURE__ */ new Map();\n    this.weakBindingTracker = /* @__PURE__ */ new Set();\n    this.schema = schema;\n    this.options = options;\n    this.reset();\n  }\n  setOptions(options) {\n    this.options = options;\n  }\n  /** Return the middleware for the data-model to stop propagation of invalid data */\n  getDataMiddleware() {\n    return [\n      {\n        set: (transaction, options, next) => {\n          return next?.set(transaction, options) ?? [];\n        },\n        get: (binding, options, next) => {\n          return next?.get(binding, options);\n        },\n        delete: (binding, options, next) => {\n          this.validations = removeBindingAndChildrenFromMap(\n            this.validations,\n            binding\n          );\n          return next?.delete(binding, options);\n        }\n      },\n      new ValidationMiddleware(\n        (binding) => {\n          if (!this.options) {\n            return;\n          }\n          this.updateValidationsForBinding(binding, \"change\", this.options);\n          const strongValidation = this.getValidationForBinding(binding);\n          if (strongValidation?.get()?.severity === \"error\") {\n            return strongValidation.get();\n          }\n          const newInvalidBindings = /* @__PURE__ */ new Set();\n          this.validations.forEach((weakValidation, strongBinding) => {\n            if (caresAboutDataChanges(\n              /* @__PURE__ */ new Set([binding]),\n              weakValidation.weakBindings\n            ) && weakValidation?.get()?.severity === \"error\") {\n              weakValidation?.weakBindings.forEach((weakBinding) => {\n                if (weakBinding === strongBinding) {\n                  newInvalidBindings.add({\n                    binding: weakBinding,\n                    isStrong: true\n                  });\n                } else {\n                  newInvalidBindings.add({\n                    binding: weakBinding,\n                    isStrong: false\n                  });\n                }\n              });\n            }\n          });\n          if (newInvalidBindings.size > 0) {\n            return newInvalidBindings;\n          }\n        },\n        { logger: new ProxyLogger(() => this.options?.logger) }\n      )\n    ];\n  }\n  getValidationProviders() {\n    if (this.providers) {\n      return this.providers;\n    }\n    this.providers = this.hooks.resolveValidationProviders.call([\n      {\n        source: SCHEMA_VALIDATION_PROVIDER_NAME,\n        provider: this.schema\n      },\n      {\n        source: VIEW_VALIDATION_PROVIDER_NAME,\n        provider: {\n          getValidationsForBinding: (binding) => {\n            return this.viewValidationProvider?.getValidationsForBinding?.(\n              binding\n            );\n          },\n          getValidationsForView: () => {\n            return this.viewValidationProvider?.getValidationsForView?.();\n          }\n        }\n      }\n    ]);\n    return this.providers;\n  }\n  reset() {\n    this.validations.clear();\n    this.tracker = void 0;\n  }\n  onView(view) {\n    this.validations.clear();\n    if (!this.options) {\n      return;\n    }\n    const bindingTrackerPlugin = new ValidationBindingTrackerViewPlugin({\n      ...this.options,\n      callbacks: {\n        onAdd: (binding) => {\n          if (!this.options || this.getValidationForBinding(binding) !== void 0) {\n            return;\n          }\n          const originalValue = this.options.model.get(binding);\n          const withoutDefault = this.options.model.get(binding, {\n            ignoreDefaultValue: true\n          });\n          if (originalValue !== withoutDefault) {\n            this.options.model.set([[binding, originalValue]], {\n              silent: true\n            });\n          }\n          this.updateValidationsForBinding(\n            binding,\n            \"load\",\n            this.options,\n            () => {\n              view.update(/* @__PURE__ */ new Set([binding]));\n            }\n          );\n          this.hooks.onTrackBinding.call(binding);\n        }\n      }\n    });\n    this.tracker = bindingTrackerPlugin;\n    this.viewValidationProvider = view;\n    bindingTrackerPlugin.apply(view);\n  }\n  updateValidationsForBinding(binding, trigger, validationContext, onDismiss) {\n    const context = validationContext ?? this.options;\n    if (!context) {\n      throw new Error(`Context is required for executing validations`);\n    }\n    if (trigger === \"load\") {\n      const possibleValidations = this.getValidationProviders().reduce((vals, provider) => {\n        vals.push(\n          ...provider.provider.getValidationsForBinding?.(binding)?.map((valObj) => ({\n            ...valObj,\n            [VALIDATION_PROVIDER_NAME_SYMBOL]: provider.source\n          })) ?? []\n        );\n        return vals;\n      }, []);\n      if (possibleValidations.length === 0) {\n        return;\n      }\n      this.validations.set(\n        binding,\n        new ValidatedBinding(\n          possibleValidations,\n          onDismiss,\n          this.options?.logger\n        )\n      );\n    }\n    const trackedValidations = this.validations.get(binding);\n    trackedValidations?.update(trigger, true, (validationObj) => {\n      const response = this.validationRunner(validationObj, binding, context);\n      if (this.weakBindingTracker.size > 0) {\n        const t2 = this.validations.get(binding);\n        this.weakBindingTracker.forEach((b) => t2.weakBindings.add(b));\n      }\n      return response ? { message: response.message } : void 0;\n    });\n    if (trigger !== \"load\") {\n      this.validations.forEach((validation, vBinding) => {\n        if (vBinding !== binding && caresAboutDataChanges(/* @__PURE__ */ new Set([binding]), validation.weakBindings)) {\n          validation.update(trigger, true, (validationObj) => {\n            const response = this.validationRunner(\n              validationObj,\n              vBinding,\n              context\n            );\n            return response ? { message: response.message } : void 0;\n          });\n        }\n      });\n    }\n  }\n  validationRunner(validationObj, binding, context = this.options) {\n    if (!context) {\n      throw new Error(\"No context provided to validation runner\");\n    }\n    const handler = validationObj.handler ?? this.getValidator(validationObj.type);\n    const weakBindings = /* @__PURE__ */ new Set();\n    const model = {\n      get(b, options) {\n        weakBindings.add(isBinding(b) ? binding : context.parseBinding(b));\n        return context.model.get(b, { ...options, includeInvalid: true });\n      },\n      set: context.model.set,\n      delete: context.model.delete\n    };\n    const result = handler?.(\n      {\n        ...context,\n        evaluate: (exp, options = { model }) => context.evaluate(exp, options),\n        model,\n        validation: validationObj,\n        schemaType: this.schema.getType(binding)\n      },\n      context.model.get(binding, {\n        includeInvalid: true,\n        formatted: validationObj.dataTarget === \"formatted\"\n      }),\n      validationObj\n    );\n    this.weakBindingTracker = weakBindings;\n    if (result) {\n      let { message } = result;\n      const { parameters } = result;\n      if (validationObj.message) {\n        message = resolveDataRefs(validationObj.message, {\n          model,\n          evaluate: context.evaluate\n        });\n        if (parameters) {\n          message = replaceParams(message, parameters);\n        }\n      }\n      return {\n        message\n      };\n    }\n  }\n  updateValidationsForView(trigger) {\n    const isNavigationTrigger = trigger === \"navigation\";\n    const lastActiveBindings = this.activeBindings;\n    const updateValidations = (dismissValidations) => {\n      this.getBindings().forEach((binding) => {\n        this.validations.get(binding)?.update(trigger, dismissValidations, (obj) => {\n          if (!this.options) {\n            return;\n          }\n          return this.validationRunner(obj, binding, this.options);\n        });\n      });\n    };\n    updateValidations(!isNavigationTrigger);\n    if (isNavigationTrigger) {\n      const { activeBindings } = this;\n      if (isSubset(activeBindings, lastActiveBindings)) {\n        updateValidations(true);\n      }\n    }\n  }\n  get activeBindings() {\n    return new Set(\n      Array.from(this.getBindings()).filter(\n        (b) => this.validations.get(b)?.get() !== void 0\n      )\n    );\n  }\n  getValidator(type) {\n    if (this.validatorRegistry) {\n      return this.validatorRegistry.get(type);\n    }\n    const registry = new ValidatorRegistry();\n    this.hooks.createValidatorRegistry.call(registry);\n    this.validatorRegistry = registry;\n    return registry.get(type);\n  }\n  getBindings() {\n    return this.tracker?.getBindings() ?? /* @__PURE__ */ new Set();\n  }\n  trackBinding(binding) {\n    this.tracker?.trackBinding(binding);\n  }\n  /** Executes all known validations for the tracked bindings using the given model */\n  validateView(trigger = \"navigation\") {\n    this.updateValidationsForView(trigger);\n    const validations = /* @__PURE__ */ new Map();\n    let canTransition = true;\n    this.getBindings().forEach((b) => {\n      const allValidations = this.getValidationForBinding(b)?.getAll();\n      allValidations?.forEach((v) => {\n        if (trigger === \"navigation\" && v.blocking) {\n          this.options?.logger.debug(\n            `Validation on binding: ${b.asString()} is preventing navigation. ${JSON.stringify(\n              v\n            )}`\n          );\n          canTransition = false;\n        }\n        if (!validations.has(b)) {\n          validations.set(b, v);\n        }\n      });\n    });\n    return {\n      canTransition,\n      validations: validations.size ? validations : void 0\n    };\n  }\n  /** Get the current tracked validation for the given binding */\n  getValidationForBinding(binding) {\n    return this.validations.get(binding);\n  }\n  forView(parser) {\n    return {\n      _getValidationForBinding: (binding) => {\n        return this.getValidationForBinding(\n          isBinding(binding) ? binding : parser(binding)\n        );\n      },\n      getAll: () => {\n        const bindings = this.getBindings();\n        if (bindings.size === 0) {\n          return void 0;\n        }\n        const validationMapping = /* @__PURE__ */ new Map();\n        bindings.forEach((b) => {\n          const validation = this.getValidationForBinding(b)?.get();\n          if (validation) {\n            validationMapping.set(b, validation);\n          }\n        });\n        return validationMapping.size === 0 ? void 0 : validationMapping;\n      },\n      get() {\n        throw new Error(\"Error Access be provided by the view plugin\");\n      },\n      getValidationsForBinding() {\n        throw new Error(\"Error rollup should be provided by the view plugin\");\n      },\n      getChildren() {\n        throw new Error(\"Error rollup should be provided by the view plugin\");\n      },\n      getValidationsForSection() {\n        throw new Error(\"Error rollup should be provided by the view plugin\");\n      },\n      track: () => {\n        throw new Error(\"Tracking should be provided by the view plugin\");\n      },\n      register: () => {\n        throw new Error(\n          \"Section functionality should be provided by the view plugin\"\n        );\n      },\n      type: (binding) => this.schema.getType(isBinding(binding) ? binding : parser(binding))\n    };\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/view/store.ts\nvar LocalStateStore = class {\n  constructor(onUpdate) {\n    this.updateCallback = onUpdate;\n    this.state = /* @__PURE__ */ new Map();\n  }\n  removeKey(key) {\n    this.state.delete(key);\n  }\n  reset() {\n    this.state.clear();\n  }\n  useSharedState(key) {\n    return (initialState) => {\n      if (!this.state.has(key)) {\n        this.state.set(key, initialState);\n      }\n      return [\n        this.state.get(key),\n        (newState) => {\n          const current = this.state.get(key);\n          this.state.set(key, newState);\n          if (current !== newState) {\n            this.updateCallback?.();\n          }\n        }\n      ];\n    };\n  }\n  getLocalStateFunction(key, countKey) {\n    return (initialState) => {\n      if (!this.state.has(key)) {\n        this.state.set(key, []);\n      }\n      if (!this.state.has(countKey)) {\n        this.state.set(countKey, 0);\n      }\n      const localState = this.state.get(key);\n      const oldCount = this.state.get(countKey);\n      this.state.set(countKey, oldCount + 1);\n      if (localState.length <= oldCount) {\n        localState.push(initialState);\n      }\n      const value = localState[oldCount];\n      return [\n        value,\n        (newState) => {\n          const oldValue = localState[oldCount];\n          localState[oldCount] = newState;\n          if (oldValue !== newState) {\n            this.updateCallback?.();\n          }\n        }\n      ];\n    };\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/view/asset-transform.ts\nfunction findUp(node, target) {\n  if (node === target) {\n    return true;\n  }\n  if (node.parent) {\n    return findUp(node.parent, target);\n  }\n  return false;\n}\nvar AssetTransformCorePlugin = class {\n  constructor(registry) {\n    this.registry = registry;\n    this.stateStore = /* @__PURE__ */ new Map();\n    this.beforeResolveSymbol = Symbol(\"before resolve\");\n    this.resolveSymbol = Symbol(\"resolve\");\n    this.beforeResolveCountSymbol = Symbol(\"before resolve count\");\n    this.resolveCountSymbol = Symbol(\"resolve count\");\n  }\n  apply(viewController) {\n    viewController.hooks.view.tap(\"asset-transform\", (view) => {\n      this.stateStore.clear();\n      view.hooks.resolver.tap(\"asset-transform\", (resolver) => {\n        let lastUpdatedNode;\n        const updateState = (node) => {\n          lastUpdatedNode = node;\n          view.update(/* @__PURE__ */ new Set());\n        };\n        const getStore = (node, stepKey) => {\n          let store;\n          const countKey = stepKey === this.resolveSymbol ? this.resolveCountSymbol : this.beforeResolveCountSymbol;\n          const storedState = this.stateStore.get(node);\n          if (storedState) {\n            store = storedState;\n            store.removeKey(countKey);\n          } else {\n            store = new LocalStateStore(() => {\n              updateState(node);\n            });\n            this.stateStore.set(node, store);\n          }\n          return {\n            useSharedState: (key) => {\n              return store.useSharedState(key);\n            },\n            useLocalState: (initialState) => {\n              return store.getLocalStateFunction(\n                stepKey,\n                countKey\n              )(initialState);\n            }\n          };\n        };\n        resolver.hooks.beforeResolve.tap(\"asset-transform\", (node, options) => {\n          if (node && (node.type === \"asset\" || node.type === \"view\")) {\n            const transform = this.registry.get(node.value);\n            if (transform?.beforeResolve) {\n              const store = getStore(\n                options.node ?? node,\n                this.beforeResolveSymbol\n              );\n              return transform.beforeResolve(node, options, store);\n            }\n          }\n          return node;\n        });\n        resolver.hooks.afterUpdate.tap(\"asset-transform\", () => {\n          lastUpdatedNode = void 0;\n        });\n        resolver.hooks.skipResolve.tap(\"asset-transform\", (skip, node) => {\n          if (!skip || !lastUpdatedNode) {\n            return skip;\n          }\n          const isParentOfUpdated = findUp(lastUpdatedNode, node);\n          const isChildOfUpdated = findUp(node, lastUpdatedNode);\n          return !isParentOfUpdated && !isChildOfUpdated;\n        });\n        resolver.hooks.afterResolve.tap(\n          \"asset-transform\",\n          (value, node, options) => {\n            if (node.type !== \"asset\" /* Asset */ && node.type !== \"view\" /* View */) {\n              return value;\n            }\n            const originalNode = resolver.getSourceNode(node);\n            if (!originalNode) {\n              return value;\n            }\n            const transform = this.registry.get(value);\n            if (transform?.resolve) {\n              const store = getStore(originalNode, this.resolveSymbol);\n              return transform?.resolve(value, options, store);\n            }\n            return value;\n          }\n        );\n      });\n    });\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/view/controller.ts\nimport { SyncHook as SyncHook8, SyncWaterfallHook as SyncWaterfallHook9 } from \"tapable-ts\";\nimport queueMicrotask from \"queue-microtask\";\nimport { Registry } from \"@player-ui/partial-match-registry\";\nvar ViewController = class {\n  constructor(initialViews, options) {\n    this.hooks = {\n      /** Do any processing before the `View` instance is created */\n      resolveView: new SyncWaterfallHook9(),\n      // The hook right before the View starts resolving. Attach anything custom here\n      view: new SyncHook8()\n    };\n    this.transformRegistry = new Registry();\n    this.optimizeUpdates = true;\n    this.viewOptions = options;\n    this.viewMap = initialViews.reduce(\n      (viewMap, view) => {\n        viewMap[view.id] = view;\n        return viewMap;\n      },\n      {}\n    );\n    new AssetTransformCorePlugin(this.transformRegistry).apply(this);\n    options.flowController.hooks.flow.tap(\n      \"viewController\",\n      (flow) => {\n        flow.hooks.transition.tap(\"viewController\", (_oldState, newState) => {\n          if (newState.value.state_type === \"VIEW\") {\n            this.onView(newState.value);\n          } else {\n            this.currentView = void 0;\n          }\n        });\n      }\n    );\n    const update = (updates, silent = false) => {\n      if (this.currentView) {\n        if (this.optimizeUpdates) {\n          this.queueUpdate(updates, silent);\n        } else {\n          this.currentView.update();\n        }\n      }\n    };\n    options.model.hooks.onUpdate.tap(\n      \"viewController\",\n      (updates, updateOptions) => {\n        update(\n          new Set(updates.map((t2) => t2.binding)),\n          updateOptions?.silent ?? false\n        );\n      }\n    );\n    options.model.hooks.onDelete.tap(\"viewController\", (binding) => {\n      const parentBinding = binding.parent();\n      const property = binding.key();\n      if (typeof property === \"number\" && parentBinding) {\n        update(/* @__PURE__ */ new Set([parentBinding]));\n      } else {\n        update(/* @__PURE__ */ new Set([binding]));\n      }\n    });\n  }\n  queueUpdate(bindings, silent = false) {\n    if (this.pendingUpdate?.changedBindings) {\n      this.pendingUpdate.changedBindings = /* @__PURE__ */ new Set([\n        ...this.pendingUpdate.changedBindings,\n        ...bindings\n      ]);\n    } else {\n      this.pendingUpdate = { changedBindings: bindings, scheduled: false };\n    }\n    if (!this.pendingUpdate.scheduled && !silent) {\n      this.pendingUpdate.scheduled = true;\n      queueMicrotask(() => {\n        const updates = this.pendingUpdate?.changedBindings;\n        this.pendingUpdate = void 0;\n        this.currentView?.update(updates);\n      });\n    }\n  }\n  getViewForRef(viewRef) {\n    if (this.viewMap[viewRef]) {\n      return this.viewMap[viewRef];\n    }\n    const matchingViewId = Object.keys(this.viewMap).find(\n      (possibleViewIdMatch) => viewRef === resolveDataRefsInString(possibleViewIdMatch, {\n        model: this.viewOptions.model,\n        evaluate: this.viewOptions.evaluator.evaluate\n      })\n    );\n    if (matchingViewId && this.viewMap[matchingViewId]) {\n      return this.viewMap[matchingViewId];\n    }\n  }\n  onView(state) {\n    const viewId = state.ref;\n    const source = this.hooks.resolveView.call(\n      this.getViewForRef(viewId),\n      viewId,\n      state\n    );\n    if (!source) {\n      throw new Error(`No view with id ${viewId}`);\n    }\n    const view = new ViewInstance(source, this.viewOptions);\n    this.currentView = view;\n    this.hooks.view.call(view);\n    view.update();\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/data/controller.ts\nimport { SyncHook as SyncHook9, SyncWaterfallHook as SyncWaterfallHook10, SyncBailHook as SyncBailHook5 } from \"tapable-ts\";\nimport { dequal as dequal2 } from \"dequal\";\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/data/utils.ts\nvar ReadOnlyDataController = class {\n  constructor(controller, logger) {\n    this.controller = controller;\n    this.logger = logger;\n  }\n  get(binding, options) {\n    return this.controller.get(binding, options);\n  }\n  set(transaction, options) {\n    this.logger?.error(\n      \"Error: Tried to set in a read only instance of the DataController\"\n    );\n    return [];\n  }\n  delete(binding, options) {\n    this.logger?.error(\n      \"Error: Tried to delete in a read only instance of the DataController\"\n    );\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/data/controller.ts\nvar DataController = class {\n  constructor(model, options) {\n    this.hooks = {\n      resolve: new SyncWaterfallHook10(),\n      resolveDataStages: new SyncWaterfallHook10(),\n      // On any set or get of an undefined value, redirect the value to be the default\n      resolveDefaultValue: new SyncBailHook5(),\n      onDelete: new SyncHook9(),\n      onSet: new SyncHook9(),\n      onGet: new SyncHook9(),\n      onUpdate: new SyncHook9(),\n      format: new SyncWaterfallHook10(),\n      deformat: new SyncWaterfallHook10(),\n      serialize: new SyncWaterfallHook10()\n    };\n    this.logger = options.logger;\n    const middleware = options.middleware || [];\n    this.baseMiddleware = [new LocalModel(model), ...middleware];\n    this.trash = /* @__PURE__ */ new Set();\n    this.pathResolver = options.pathResolver;\n  }\n  getModel() {\n    if (!this.model) {\n      const stages = this.hooks.resolveDataStages.call(this.baseMiddleware);\n      const model = new PipelinedDataModel();\n      model.setMiddleware(stages);\n      this.model = model;\n    }\n    return this.model;\n  }\n  resolveDataValue(binding, value, deformat) {\n    if (deformat) {\n      return this.hooks.deformat.call(value, binding);\n    }\n    return value;\n  }\n  set(transaction, options) {\n    let normalizedTransaction = [];\n    if (Array.isArray(transaction)) {\n      normalizedTransaction = transaction.map(([binding, value]) => {\n        const parsed = this.pathResolver.parse(binding);\n        return [\n          parsed,\n          this.resolveDataValue(parsed, value, Boolean(options?.formatted))\n        ];\n      });\n    } else {\n      normalizedTransaction = Object.keys(transaction).map(\n        (binding) => {\n          const parsed = this.pathResolver.parse(binding);\n          const val = transaction[binding];\n          return [\n            parsed,\n            this.resolveDataValue(parsed, val, Boolean(options?.formatted))\n          ];\n        }\n      );\n    }\n    const setUpdates = normalizedTransaction.reduce(\n      (updates, [binding, newVal]) => {\n        const oldVal = this.get(binding, { includeInvalid: true });\n        const update = {\n          binding,\n          newValue: newVal,\n          oldValue: oldVal\n        };\n        if (dequal2(oldVal, newVal)) {\n          this.logger?.debug(\n            `Skipping update for path: ${binding.asString()}. Value was unchanged: ${oldVal}`\n          );\n        } else {\n          updates.push(update);\n          this.logger?.debug(\n            `Setting path: ${binding.asString()} from: ${oldVal} to: ${newVal}`\n          );\n        }\n        return updates;\n      },\n      []\n    );\n    const result = this.getModel().set(normalizedTransaction, options);\n    const setUpdateBindings = new Set(setUpdates.map((su) => su.binding));\n    result.forEach((tr) => {\n      if (!setUpdateBindings.has(tr.binding) && (tr.force === true || !dequal2(tr.oldValue, tr.newValue))) {\n        this.logger?.debug(\n          `Path: ${tr.binding.asString()} was changed from: ${tr.oldValue} to: ${tr.newValue}`\n        );\n        setUpdates.push(tr);\n      }\n    });\n    this.hooks.onSet.call(normalizedTransaction);\n    if (setUpdates.length > 0) {\n      this.hooks.onUpdate.call(setUpdates, options);\n    }\n    return result;\n  }\n  resolve(binding, readOnly) {\n    return Array.isArray(binding) || typeof binding === \"string\" ? this.pathResolver.parse(binding, { readOnly }) : binding;\n  }\n  get(binding, options) {\n    const resolved = binding instanceof BindingInstance ? binding : this.resolve(binding, true);\n    let result = this.getModel().get(resolved, options);\n    if (result === void 0 && !options?.ignoreDefaultValue) {\n      const defaultVal = this.hooks.resolveDefaultValue.call(resolved);\n      if (defaultVal !== result) {\n        result = defaultVal;\n      }\n    }\n    if (options?.formatted) {\n      result = this.hooks.format.call(result, resolved);\n    } else if (options?.formatted === false) {\n      result = this.hooks.deformat.call(result, resolved);\n    }\n    this.hooks.onGet.call(binding, result);\n    return result;\n  }\n  delete(binding, options) {\n    if (typeof binding !== \"string\" && !Array.isArray(binding) && !(binding instanceof BindingInstance)) {\n      throw new Error(\"Invalid arguments: delete expects a data path (string)\");\n    }\n    const resolved = binding instanceof BindingInstance ? binding : this.resolve(binding, false);\n    const parentBinding = resolved.parent();\n    const property = resolved.key();\n    const parentValue = this.get(parentBinding);\n    const existedBeforeDelete = typeof parentValue === \"object\" && parentValue !== null && Object.prototype.hasOwnProperty.call(parentValue, property);\n    this.getModel().delete(resolved, options);\n    if (existedBeforeDelete && !this.get(resolved)) {\n      this.trash.add(resolved);\n    }\n    this.hooks.onDelete.call(resolved);\n  }\n  serialize() {\n    return this.hooks.serialize.call(this.get(\"\"));\n  }\n  makeReadOnly() {\n    return new ReadOnlyDataController(this, this.logger);\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/constants/utils.ts\nfunction flatten(obj, roots = [], sep = \".\") {\n  return Object.keys(obj).reduce(\n    (memo, prop) => ({\n      // create a new object\n      // include previously returned object\n      ...memo,\n      ...Object.prototype.toString.call(obj[prop]) === \"[object Object]\" ? (\n        // keep working if value is an object\n        flatten(obj[prop], roots.concat([prop]))\n      ) : (\n        // include current prop and value and prefix prop with the roots\n        { [roots.concat([prop]).join(sep)]: obj[prop] }\n      )\n    }),\n    {}\n  );\n}\nfunction objectToBatchSet(obj) {\n  const flattenedObj = flatten(obj);\n  const batchTxn = [];\n  Object.keys(flattenedObj).forEach((key) => {\n    batchTxn.push([new BindingInstance(key), flattenedObj[key]]);\n  });\n  return batchTxn;\n}\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/controllers/constants/index.ts\nvar ConstantsController = class {\n  constructor() {\n    this.store = /* @__PURE__ */ new Map();\n    this.tempStore = /* @__PURE__ */ new Map();\n  }\n  addConstants(data, namespace) {\n    if (this.store.has(namespace)) {\n      this.store.get(namespace)?.set(objectToBatchSet(data));\n    } else {\n      this.store.set(namespace, new LocalModel(data));\n    }\n  }\n  getConstants(key, namespace, fallback) {\n    const path = new BindingInstance(key);\n    return this.tempStore.get(namespace)?.get(path) ?? this.store.get(namespace)?.get(path) ?? fallback;\n  }\n  setTemporaryValues(data, namespace) {\n    if (this.tempStore.has(namespace)) {\n      this.tempStore.get(namespace)?.set(objectToBatchSet(data));\n    } else {\n      this.tempStore.set(namespace, new LocalModel(data));\n    }\n  }\n  clearTemporaryValues(namespace) {\n    if (namespace) {\n      this.tempStore.get(namespace)?.reset();\n    } else {\n      this.tempStore.forEach((value) => {\n        value.reset();\n      });\n    }\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/plugins/flow-exp-plugin.ts\nvar FlowExpPlugin = class {\n  constructor() {\n    this.name = \"flow-exp-plugin\";\n  }\n  apply(player) {\n    let expressionEvaluator;\n    const handleEval = (exp) => {\n      if (exp) {\n        if (typeof exp === \"object\" && \"exp\" in exp) {\n          expressionEvaluator?.evaluate(exp.exp);\n        } else {\n          expressionEvaluator?.evaluate(exp);\n        }\n      }\n    };\n    player.hooks.expressionEvaluator.tap(this.name, (evaluator) => {\n      expressionEvaluator = evaluator;\n    });\n    player.hooks.flowController.tap(this.name, (fc) => {\n      fc.hooks.flow.tap(this.name, (flow) => {\n        flow.hooks.onStart.tap(this.name, (exp) => handleEval(exp));\n        flow.hooks.onEnd.tap(this.name, (exp) => handleEval(exp));\n        flow.hooks.resolveTransitionNode.intercept({\n          call: (nextState) => {\n            if (nextState?.onStart) {\n              handleEval(nextState.onStart);\n            }\n          }\n        });\n      });\n    });\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/plugins/default-exp-plugin.ts\nvar createFormatFunction = (schema) => {\n  const handler = (ctx, value, formatName) => {\n    return schema.getFormatterForType({ type: formatName })?.format(value) ?? value;\n  };\n  return handler;\n};\nvar DefaultExpPlugin = class {\n  constructor() {\n    this.name = \"flow-exp-plugin\";\n  }\n  apply(player) {\n    let formatFunction;\n    player.hooks.schema.tap(this.name, (schemaController) => {\n      formatFunction = createFormatFunction(schemaController);\n    });\n    player.hooks.expressionEvaluator.tap(this.name, (expEvaluator) => {\n      if (formatFunction) {\n        expEvaluator.addExpressionFunction(\"format\", formatFunction);\n      }\n      expEvaluator.addExpressionFunction(\"log\", (ctx, ...args) => {\n        player.logger.info(...args);\n      });\n      expEvaluator.addExpressionFunction(\"debug\", (ctx, ...args) => {\n        player.logger.debug(...args);\n      });\n      expEvaluator.addExpressionFunction(\n        \"eval\",\n        (ctx, ...args) => {\n          return ctx.evaluate(...args);\n        }\n      );\n    });\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/types.ts\nvar NOT_STARTED_STATE = {\n  ref: Symbol(\"not-started\"),\n  status: \"not-started\"\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/plugins/default-view-plugin.ts\nvar DefaultViewPlugin = class {\n  constructor() {\n    this.name = \"default-view-plugin\";\n  }\n  apply(player) {\n    player.hooks.viewController.tap(this.name, (viewController) => {\n      viewController.hooks.view.tap(this.name, (view) => {\n        const pluginOptions = toNodeResolveOptions(view.resolverOptions);\n        new AssetPlugin().apply(view);\n        new SwitchPlugin(pluginOptions).apply(view);\n        new ApplicabilityPlugin().apply(view);\n        new StringResolverPlugin().apply(view);\n        const templatePlugin = new TemplatePlugin(pluginOptions);\n        templatePlugin.apply(view);\n        view.hooks.onTemplatePluginCreated.call(templatePlugin);\n        new MultiNodePlugin().apply(view);\n      });\n    });\n  }\n};\n\n// ../../../../../../../../../../execroot/_main/bazel-out/k8-fastbuild/bin/core/player/src/player.ts\nvar PLAYER_VERSION = true ? \"0.12.0--canary.642.22872\" : \"__VERSION__\";\nvar COMMIT = true ? \"bcaf7bef6960bca2b21ead352496dacc9aff8c9b\" : \"__GIT_COMMIT__\";\nvar _Player = class _Player {\n  constructor(config) {\n    this.logger = new TapableLogger();\n    this.constantsController = new ConstantsController();\n    this.state = NOT_STARTED_STATE;\n    this.hooks = {\n      /** The hook that fires every time we create a new flowController (a new Content blob is passed in) */\n      flowController: new SyncHook10(),\n      /** The hook that updates/handles views */\n      viewController: new SyncHook10(),\n      /** A hook called every-time there's a new view. This is equivalent to the view hook on the view-controller */\n      view: new SyncHook10(),\n      /** Called when an expression evaluator was created */\n      expressionEvaluator: new SyncHook10(),\n      /** The hook that creates and manages data */\n      dataController: new SyncHook10(),\n      /** Called after the schema is created for a flow */\n      schema: new SyncHook10(),\n      /** Manages validations (schema and x-field ) */\n      validationController: new SyncHook10(),\n      /** Manages parsing binding */\n      bindingParser: new SyncHook10(),\n      /** A that's called for state changes in the flow execution */\n      state: new SyncHook10(),\n      /** A hook to access the current flow */\n      onStart: new SyncHook10(),\n      /** A hook for when the flow ends either in success or failure */\n      onEnd: new SyncHook10(),\n      /** Mutate the Content flow before starting */\n      resolveFlowContent: new SyncWaterfallHook11()\n    };\n    if (config?.logger) {\n      this.logger.addHandler(config.logger);\n    }\n    this.config = config || {};\n    this.config.plugins = [\n      new DefaultExpPlugin(),\n      new DefaultViewPlugin(),\n      ...this.config.plugins || [],\n      new FlowExpPlugin()\n    ];\n    this.config.plugins?.forEach((plugin) => {\n      plugin.apply(this);\n    });\n  }\n  /**  Returns currently registered plugins */\n  getPlugins() {\n    return this.config.plugins ?? [];\n  }\n  /** Find instance of [Plugin] that has been registered to Player */\n  findPlugin(symbol) {\n    return this.config.plugins?.find((el) => el.symbol === symbol);\n  }\n  /** Retrieve an instance of [Plugin] and conditionally invoke [apply] if it exists */\n  applyTo(symbol, apply) {\n    const plugin = this.findPlugin(symbol);\n    if (plugin) {\n      apply(plugin);\n    }\n  }\n  /** Register and apply [Plugin] if one with the same symbol is not already registered. */\n  registerPlugin(plugin) {\n    plugin.apply(this);\n    this.config.plugins?.push(plugin);\n  }\n  /** Returns the current version of the running player */\n  getVersion() {\n    return _Player.info.version;\n  }\n  /** Returns the git commit used to build Player version */\n  getCommit() {\n    return _Player.info.commit;\n  }\n  /**\n   * Fetch the current state of Player.\n   * It will return either `not-started`, `in-progress`, `completed`\n   * with some extra data in each\n   */\n  getState() {\n    return this.state;\n  }\n  /**\n   * A private means of setting the state of Player\n   * Calls the hooks for subscribers to listen for this event\n   */\n  setState(state) {\n    this.state = state;\n    this.hooks.state.call(state);\n  }\n  /** Start Player with the given flow */\n  setupFlow(userContent) {\n    const userFlow = this.hooks.resolveFlowContent.call(userContent);\n    const flowController = new FlowController(userFlow.navigation, {\n      logger: this.logger\n    });\n    this.hooks.onStart.call(userFlow);\n    this.hooks.flowController.call(flowController);\n    let expressionEvaluator;\n    let dataController;\n    const pathResolver = new BindingParser({\n      get: (binding) => {\n        return dataController.get(binding);\n      },\n      set: (transaction) => {\n        return dataController.set(transaction);\n      },\n      evaluate: (expression) => {\n        return expressionEvaluator.evaluate(expression);\n      }\n    });\n    this.hooks.bindingParser.call(pathResolver);\n    const parseBinding = pathResolver.parse;\n    const flowResultDeferred = deferred();\n    const schema = new SchemaController(userFlow.schema);\n    this.hooks.schema.call(schema);\n    const validationController = new ValidationController(schema);\n    this.hooks.validationController.call(validationController);\n    dataController = new DataController(userFlow.data, {\n      pathResolver,\n      middleware: validationController.getDataMiddleware(),\n      logger: this.logger\n    });\n    dataController.hooks.format.tap(\"player\", (value, binding) => {\n      const formatter = schema.getFormatter(binding);\n      return formatter ? formatter.format(value) : value;\n    });\n    dataController.hooks.deformat.tap(\"player\", (value, binding) => {\n      const formatter = schema.getFormatter(binding);\n      return formatter ? formatter.deformat(value) : value;\n    });\n    dataController.hooks.resolveDefaultValue.tap(\n      \"player\",\n      (binding) => schema.getApparentType(binding)?.default\n    );\n    let viewController;\n    expressionEvaluator = new ExpressionEvaluator({\n      model: dataController,\n      logger: this.logger\n    });\n    this.hooks.expressionEvaluator.call(expressionEvaluator);\n    expressionEvaluator.hooks.onError.tap(\"player\", (e) => {\n      flowResultDeferred.reject(e);\n      return true;\n    });\n    function resolveStrings(val, formatted) {\n      return resolveDataRefs(val, {\n        model: dataController,\n        evaluate: expressionEvaluator.evaluate,\n        formatted\n      });\n    }\n    flowController.hooks.flow.tap(\"player\", (flow) => {\n      flow.hooks.beforeTransition.tap(\"player\", (state, transitionVal) => {\n        const computedTransitionVal = state.transitions[transitionVal] ? transitionVal : \"*\";\n        if (state.onEnd && state.transitions[computedTransitionVal]) {\n          if (typeof state.onEnd === \"object\" && \"exp\" in state.onEnd) {\n            expressionEvaluator?.evaluate(state.onEnd.exp);\n          } else {\n            expressionEvaluator?.evaluate(state.onEnd);\n          }\n        }\n        if (!(\"transitions\" in state) || !state.transitions[computedTransitionVal]) {\n          return state;\n        }\n        return setIn7(\n          state,\n          [\"transitions\", computedTransitionVal],\n          resolveStrings(state.transitions[computedTransitionVal])\n        );\n      });\n      flow.hooks.skipTransition.tap(\"validation\", (currentState) => {\n        if (currentState?.value.state_type === \"VIEW\") {\n          const { canTransition, validations } = validationController.validateView(\"navigation\");\n          if (!canTransition && validations) {\n            const bindings = new Set(validations.keys());\n            viewController?.currentView?.update(bindings);\n            return true;\n          }\n        }\n        return void 0;\n      });\n      flow.hooks.resolveTransitionNode.tap(\"player\", (state) => {\n        let newState = state;\n        if (\"ref\" in state) {\n          newState = setIn7(state, [\"ref\"], resolveStrings(state.ref));\n        }\n        if (\"param\" in state) {\n          newState = setIn7(\n            state,\n            [\"param\"],\n            resolveStrings(state.param, false)\n          );\n        }\n        return newState;\n      });\n      flow.hooks.transition.tap(\"player\", (_oldState, newState) => {\n        if (newState.value.state_type !== \"VIEW\") {\n          validationController.reset();\n        }\n      });\n      flow.hooks.afterTransition.tap(\"player\", (flowInstance) => {\n        const value = flowInstance.currentState?.value;\n        if (value && value.state_type === \"ACTION\") {\n          const { exp } = value;\n          flowController?.transition(\n            String(expressionEvaluator?.evaluate(exp))\n          );\n        }\n        expressionEvaluator.reset();\n      });\n    });\n    this.hooks.dataController.call(dataController);\n    validationController.setOptions({\n      parseBinding,\n      model: dataController,\n      logger: this.logger,\n      evaluate: expressionEvaluator.evaluate,\n      constants: this.constantsController\n    });\n    viewController = new ViewController(userFlow.views || [], {\n      evaluator: expressionEvaluator,\n      parseBinding,\n      transition: flowController.transition,\n      model: dataController,\n      utils: {\n        findPlugin: (pluginSymbol) => {\n          return this.findPlugin(pluginSymbol);\n        }\n      },\n      logger: this.logger,\n      flowController,\n      schema,\n      format: (binding, value) => {\n        const formatter = schema.getFormatter(binding);\n        return formatter?.format ? formatter.format(value) : value;\n      },\n      formatValue: (ref, value) => {\n        const formatter = schema.getFormatterForType(ref);\n        return formatter?.format ? formatter.format(value) : value;\n      },\n      validation: {\n        ...validationController.forView(parseBinding),\n        type: (b) => schema.getType(parseBinding(b))\n      },\n      constants: this.constantsController\n    });\n    viewController.hooks.view.tap(\"player\", (view) => {\n      validationController.onView(view);\n      this.hooks.view.call(view);\n    });\n    this.hooks.viewController.call(viewController);\n    return {\n      start: () => {\n        flowController.start().then((endState) => {\n          const flowResult = {\n            endState: resolveStrings(endState, false),\n            data: dataController.serialize()\n          };\n          return flowResult;\n        }).then(flowResultDeferred.resolve).catch((e) => {\n          this.logger.error(`Something went wrong: ${e.message}`);\n          throw e;\n        }).catch(flowResultDeferred.reject).finally(() => this.hooks.onEnd.call());\n      },\n      state: {\n        status: \"in-progress\",\n        flowResult: flowResultDeferred.promise,\n        controllers: {\n          data: dataController,\n          view: viewController,\n          flow: flowController,\n          schema,\n          expression: expressionEvaluator,\n          binding: pathResolver,\n          validation: validationController\n        },\n        fail: flowResultDeferred.reject,\n        flow: userFlow,\n        logger: this.logger\n      }\n    };\n  }\n  async start(payload) {\n    const ref = Symbol(payload?.id ?? \"payload\");\n    const maybeUpdateState = (newState) => {\n      if (this.state.ref !== ref) {\n        this.logger.warn(\n          `Received update for a flow that's not the current one`\n        );\n        return newState;\n      }\n      this.setState(newState);\n      return newState;\n    };\n    this.setState({\n      status: \"not-started\",\n      ref\n    });\n    try {\n      const { state, start } = this.setupFlow(payload);\n      this.setState({\n        ref,\n        ...state\n      });\n      start();\n      const endProps = {\n        ref,\n        status: \"completed\",\n        flow: state.flow,\n        controllers: {\n          data: state.controllers.data.makeReadOnly()\n        }\n      };\n      return maybeUpdateState({\n        ...await state.flowResult,\n        ...endProps\n      });\n    } catch (error) {\n      const errorState = {\n        status: \"error\",\n        ref,\n        flow: payload,\n        error\n      };\n      maybeUpdateState(errorState);\n      throw error;\n    }\n  }\n};\n_Player.info = {\n  version: PLAYER_VERSION,\n  commit: COMMIT\n};\nvar Player = _Player;\nexport {\n  ApplicabilityPlugin,\n  AssetPlugin,\n  AssetTransformCorePlugin,\n  BINDING_BRACKETS_REGEX,\n  BindingInstance,\n  BindingParser,\n  Builder,\n  ConsoleLogger,\n  ConstantsController,\n  DataController,\n  DependencyMiddleware,\n  DependencyModel,\n  DependencyTracker,\n  EMPTY_NODE,\n  ExpNodeOpaqueIdentifier,\n  ExpressionEvaluator,\n  FlowController,\n  FlowExpPlugin,\n  FlowInstance,\n  LocalModel,\n  LocalStateStore,\n  MultiNodePlugin,\n  NOOPDataModel,\n  NOOP_MODEL,\n  NOT_STARTED_STATE,\n  NodeType,\n  NoopLogger,\n  Parser,\n  PipelinedDataModel,\n  Player,\n  ProxyLogger,\n  ROOT_BINDING,\n  Resolver,\n  SCHEMA_VALIDATION_PROVIDER_NAME,\n  SIMPLE_BINDING_REGEX,\n  SchemaController,\n  StringResolverPlugin,\n  SwitchPlugin,\n  TapableLogger,\n  TemplatePlugin,\n  VALIDATION_PROVIDER_NAME_SYMBOL,\n  VIEW_VALIDATION_PROVIDER_NAME,\n  ValidationBindingTrackerViewPlugin,\n  ValidationController,\n  ValidationMiddleware,\n  ValidatorRegistry,\n  ViewController,\n  ViewInstance,\n  caresAboutDataChanges,\n  constructModelForPipeline,\n  findClosestNodeAtPosition,\n  findInArray,\n  findNextExp,\n  getBindingSegments,\n  getNodeID,\n  hasSwitchKey,\n  hasTemplateKey,\n  hasTemplateValues,\n  isBinding,\n  isErrorWithLocation,\n  isExpressionNode,\n  isObjectExpression,\n  maybeConvertToNum,\n  parse2 as parse,\n  parseExpression,\n  removeBindingAndChildrenFromMap,\n  resolveDataRefs,\n  resolveDataRefsInString,\n  resolveExpressionsInString,\n  severities,\n  toModel,\n  toNodeResolveOptions,\n  unpackAndPush,\n  withParser,\n  withoutContext\n};\n//# sourceMappingURL=index.mjs.mapingURL=index.mjs.map","import { NodeType } from \"@player-ui/player\";\nimport type {\n  Player,\n  Asset,\n  PlayerPlugin,\n  Node,\n  Resolver,\n} from \"@player-ui/player\";\nimport { createObjectMatcher } from \"@player-ui/partial-match-registry\";\nimport dlv from \"dlv\";\nimport { CheckPathPluginSymbol } from \"./symbols\";\n\nexport type QueryFunction = (asset: Asset) => boolean;\nexport type Query = QueryFunction | string | object;\n\n/** Generate a function that matches on the given input */\nfunction createMatcher(\n  match: number | string | object | QueryFunction,\n): QueryFunction {\n  if (typeof match === \"string\" || typeof match === \"number\") {\n    return createObjectMatcher({ type: match });\n  }\n\n  if (typeof match === \"function\") {\n    return match as QueryFunction;\n  }\n\n  return createObjectMatcher(match);\n}\n\ninterface ViewInfo {\n  /** The root of the view graph */\n  root?: Node.Node;\n\n  /** A cache of an asset or view's id to it's node */\n  assetIdMap: Map<string, Node.Asset | Node.View>;\n\n  /** A map of a node to it's resolved node and value */\n  resolvedMap: Map<\n    Node.Node,\n    {\n      /** The final resolved AST node */\n      resolved: Node.Node;\n\n      /** The final, resolved value of the node */\n      value: any;\n    }\n  >;\n\n  /** The resolver instance tied to this view. Used to map back to original nodes */\n  resolver: Resolver;\n}\n\n/**\n * Traverse up the tree until reaching the first asset or view\n * Returns undefined if no matching parent is found\n */\nfunction getParent(\n  node: Node.Node,\n  viewInfo?: ViewInfo,\n): Node.ViewOrAsset | undefined {\n  let working = node;\n\n  while (\n    working.parent &&\n    working.parent.type !== NodeType.Asset &&\n    working.parent.type !== NodeType.View\n  ) {\n    working = working.parent;\n  }\n\n  const { parent } = working;\n\n  if (\n    parent &&\n    (parent.type === NodeType.Asset || parent.type === NodeType.View)\n  ) {\n    return parent;\n  }\n}\n\n/**\n * The `check-path-plugin` enables developers to query segments of the view tree for contextual rendering or behavior.\n * This is best suited to be referenced during the UI rendering phase, where one can make decisions about the rendering of an asset based on where it lies in the tree.\n */\nexport class CheckPathPlugin implements PlayerPlugin {\n  name = \"check-path\";\n  private viewInfo?: ViewInfo;\n  public readonly symbol = CheckPathPluginSymbol;\n\n  apply(player: Player) {\n    player.hooks.viewController.tap(this.name, (viewController) => {\n      viewController.hooks.view.tap(this.name, (view) => {\n        view.hooks.resolver.tap(this.name, (resolver: Resolver) => {\n          const viewInfo: ViewInfo = {\n            resolvedMap: new Map(),\n            assetIdMap: new Map(),\n            resolver,\n          };\n          this.viewInfo = viewInfo;\n\n          resolver.hooks.afterResolve.tap(this.name, (value, node) => {\n            const sourceNode = this.getSourceAssetNode(node);\n\n            if (sourceNode) {\n              viewInfo.resolvedMap.set(sourceNode, {\n                resolved: node,\n                value,\n              });\n\n              if (node.type === NodeType.Asset || node.type === NodeType.View) {\n                const id = dlv(value, \"id\");\n\n                if (id) {\n                  viewInfo.assetIdMap.set(id, node);\n                }\n              }\n            }\n\n            return value;\n          });\n        });\n      });\n    });\n  }\n\n  /**\n   * Starts at the asset with the given id, and walks backwards _up_ the tree until it finds a match for the parent\n   *\n   * @param id - The id of the asset to _start_ at\n   * @param query - A means of matching a parent asset\n   * @returns - The parent object if a match is found, else undefined\n   */\n  public getParent(\n    id: string,\n    query?: Query | Array<Query>,\n  ): Asset | undefined {\n    const assetNode = this.viewInfo?.assetIdMap.get(id);\n\n    if (!assetNode || !this.viewInfo) {\n      return undefined;\n    }\n\n    let potentialMatch = getParent(assetNode);\n\n    // Handle the case of an empty query (just get the immediate parent)\n    if (query === undefined) {\n      if (potentialMatch) {\n        return this.getAssetFromAssetNode(potentialMatch);\n      }\n\n      return;\n    }\n\n    const queryArray = Array.isArray(query) ? [...query] : [query];\n    let parentQuery = queryArray.shift();\n\n    // Keep track of the recursive depth in case we loop forever\n    let depth = 0;\n\n    while (potentialMatch && parentQuery) {\n      if (depth++ >= 50) {\n        throw new Error(\n          \"Recursion depth exceeded. Check for cycles in the AST graph\",\n        );\n      }\n\n      const matcher = createMatcher(parentQuery);\n      const resolved = this.getAssetFromAssetNode(potentialMatch);\n\n      if (resolved && matcher(resolved)) {\n        // This is the last match.\n        if (queryArray.length === 0) {\n          return resolved;\n        }\n\n        parentQuery = queryArray.shift();\n      }\n\n      potentialMatch = getParent(potentialMatch);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Returns the property that the asset resides on relative to it's parent\n   *\n   * @param id - The id of the asset to _start_ at\n   * @returns - The property name or undefined if no parent was found\n   */\n  public getParentProp(id: string): string | number | undefined {\n    const assetNode = this.viewInfo?.assetIdMap.get(id);\n\n    if (!assetNode || !this.viewInfo) {\n      return;\n    }\n\n    let working: Node.Node | undefined = assetNode;\n    let parent;\n\n    while (working) {\n      parent = working?.parent;\n\n      if (\n        parent &&\n        (parent.type === NodeType.Asset || parent.type === NodeType.View)\n      ) {\n        break;\n      }\n\n      working = working?.parent;\n    }\n\n    if (parent && \"children\" in parent) {\n      const childProp = parent.children?.find(\n        (child) => child.value === working,\n      );\n\n      return childProp?.path?.[0];\n    }\n\n    return undefined;\n  }\n\n  /** Given a node, return itself, or the nested asset if the node is an applicability node */\n  private getSourceAssetNode(node: Node.Node) {\n    let sourceNode = this.viewInfo?.resolver.getSourceNode(node);\n    if (sourceNode?.type === \"applicability\") {\n      sourceNode = sourceNode.value;\n    }\n\n    return sourceNode;\n  }\n\n  /**\n   * Given the starting node, check to verify that the supplied queries are relevant to the current asset's parents.\n   *\n   * @param id - The id of the asset to _start_ at\n   * @returns - true if the context applies, false if it doesn't\n   */\n  public hasParentContext(id: string, query: Query | Array<Query>): boolean {\n    return Boolean(this.getParent(id, query));\n  }\n\n  /** Search the node for any matching paths in the graph that match the query  */\n  private findChildPath(\n    node: Node.Node,\n    query: Array<Query>,\n    includeSelfMatch = true,\n  ): boolean {\n    if (query.length === 0) {\n      return true;\n    }\n\n    const [first, ...rest] = query;\n    const matcher = createMatcher(first);\n\n    if (\n      node.type === NodeType.Asset ||\n      node.type === NodeType.View ||\n      node.type === NodeType.Applicability\n    ) {\n      const resolvedValue = this.getResolvedValue(node);\n      const includesSelf =\n        (includeSelfMatch && matcher(resolvedValue)) ?? false;\n      const childQuery = includesSelf ? rest : query;\n\n      if (childQuery.length === 0 && includesSelf) {\n        return true;\n      }\n\n      const children =\n        node.type === NodeType.Applicability\n          ? (node.value as Node.ViewOrAsset).children\n          : node.children;\n      if (childQuery.length && (!children || children.length === 0)) {\n        return false;\n      }\n\n      if (\n        children?.some((childNode) =>\n          this.findChildPath(childNode.value, childQuery),\n        )\n      ) {\n        return true;\n      }\n    } else if (\n      node.type === NodeType.MultiNode &&\n      node.values.some((childNode) => this.findChildPath(childNode, query))\n    ) {\n      return true;\n    } else if (\n      \"children\" in node &&\n      node.children?.some((childNode) =>\n        this.findChildPath(childNode.value, query),\n      )\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Given the starting node, check to verify that the supplied queries are relevant to the current asset's children.\n   *\n   * @param id - The id of the asset to _start_ at\n   * @returns - true if the context applies, false if it doesn't\n   */\n  public hasChildContext(id: string, query: Query | Array<Query>): boolean {\n    const assetNode = this.viewInfo?.assetIdMap.get(id);\n    const queryArray = Array.isArray(query) ? [...query] : [query];\n\n    if (!assetNode) {\n      return false;\n    }\n\n    return this.findChildPath(assetNode, queryArray, false);\n  }\n\n  /** Get the asset represented by id */\n  public getAsset(id: string): Asset | undefined {\n    const assetNode = this.viewInfo?.assetIdMap.get(id);\n    if (!assetNode) return;\n\n    return this.getAssetFromAssetNode(assetNode);\n  }\n\n  /**\n   * Gets the value for an asset from an asset node\n   */\n  public getAssetFromAssetNode(\n    assetNode: Node.Asset | Node.View,\n  ): Asset | undefined {\n    const sourceNode = this.getSourceAssetNode(assetNode);\n    if (!sourceNode) return;\n\n    return this.viewInfo?.resolvedMap.get(sourceNode)?.value;\n  }\n\n  /**\n   * Get the path of the asset in the view upto\n   * the asset that matches the query or to the view if no query is provided\n   */\n  public getPath(\n    id: string,\n    query?: Query | Array<Query>,\n  ): Array<string | number> | undefined {\n    const assetNode = this.viewInfo?.assetIdMap.get(id);\n\n    if (!assetNode || !this.viewInfo) {\n      return;\n    }\n\n    let path: Array<string | number> = [];\n\n    let queryArray: Query[] = [];\n\n    if (query) {\n      queryArray = Array.isArray(query) ? [...query] : [query];\n    }\n\n    let parentQuery = queryArray.shift();\n\n    let working: Node.Node | undefined = assetNode;\n\n    /** Find the child value for the working value from the given parent */\n    const findWorkingChild = (parent: Node.ViewOrAsset | Node.Value) => {\n      return parent.children?.find((n) => n.value === working);\n    };\n\n    while (working !== undefined) {\n      const { parent } = working;\n\n      if (parent) {\n        if (parent.type === NodeType.MultiNode) {\n          const index = parent.values.indexOf(working);\n\n          if (index !== -1) {\n            const actualIndex =\n              index -\n              parent.values\n                .slice(0, index)\n                .reduce(\n                  (undefCount, next) =>\n                    this.getResolvedValue(next) === undefined\n                      ? undefCount + 1\n                      : undefCount,\n                  0,\n                );\n\n            path = [actualIndex, ...path];\n          }\n        } else if (\"children\" in parent) {\n          const childProp = findWorkingChild(parent);\n          path = [...(childProp?.path ?? []), ...path];\n        }\n\n        if (parentQuery) {\n          const matcher = createMatcher(parentQuery);\n          if (matcher(this.getResolvedValue(parent))) {\n            parentQuery = queryArray.shift();\n            if (!parentQuery) return path;\n          }\n        }\n      }\n\n      working = working.parent;\n    }\n\n    /* if at the end all queries haven't been consumed, \n       it means we couldn't find a path till the matching query */\n    return parentQuery ? undefined : path;\n  }\n\n  private getResolvedValue(node: Node.Node) {\n    const sourceNode = this.getSourceAssetNode(node);\n    return this.viewInfo?.resolvedMap.get(sourceNode ?? node)?.value;\n  }\n}\n","/**\n * Subclass of standard `Error` that eagerly collects the callstack of the error\n * that caused it. This way you can investigate the core problem that happened\n * by looking at the callstack from up to bottom (from higher level errors to\n * lower level).\n */\nexport class NestedError extends Error {\n    /**\n     * Combined callstack of this error and the errors that it wraps.\n     * If the JavaScript runtime doesn't support `Error::stack` property\n     * this will contain only the concatenated messages.\n     */\n    readonly stack: string;\n\n    /**\n     * The list of lower-level errors wrapped by this error.\n     */\n    readonly innerErrors: Error[];\n\n    /**\n     * Provides the first `Error` of the `innerErrors` (if it exists);\n     * otherwise, `null`.\n     *\n     * @deprecated Please shift to using the `innerErrors` (with an 's') property.\n     */\n    get innerError(): Error | null {\n        return this.innerErrors.length === 0\n            ? null\n            : this.innerErrors[0];\n    }\n\n    private static readonly getErrorReport = typeof new Error().stack === 'string'\n        ? (err: Error) => err.stack!\n        : (err: Error) => `${err.name}: ${err.message}`;\n\n    /**\n     * Returns the function that accepts any value that was thrown as the first argument and\n     * throws it wrapped into `NestedError` or class derived from `NestedError` (provided\n     * this method was called directly in the context of that dervied class constructor)\n     * with the given `message`.\n     * Returned function will pass accepted `Error` object directly to `NestedError`\n     * as `innerErrors` by invoking `toError(err)` on it.\n     *\n     * You'll most likely want to use this method with promises:\n     *\n     * ```ts\n     * userService.getPage().then(\n     *     data => console.log(`Hooray! data: ${data}`),\n     *     NestedError.rethrow('failed to fetch users page')\n     * );\n     * ```\n     *\n     * @param message Message to attach `NestedError` created by the returned function.\n     */\n    static rethrow(message: string) {\n        return (...errs: unknown[]) => { throw new this(message, ...errs); };\n    }\n\n    /**\n     * Allocates an instance of `NestedError` with the given error `message` and\n     * optional `innerError` (which will be automatically coerced using `toError()`).\n     *\n     * @param message     Laconic error message to attach to the created `NestedError`.\n     * @param innerErrors Optional errors that will be wrapped by this higher level\n     *                    error. This value will be automatically coerced using `toError()`.\n     */\n    constructor(message?: string, ...innerErrors: unknown[]) {\n        super(message);\n        const thisErrorReport = NestedError.getErrorReport(this);\n        if (innerErrors.length === 1) {\n            const innerError = toError(innerErrors[0]);\n            this.innerErrors = [innerError];\n            const errReport = NestedError.getErrorReport(innerError);\n            this.stack = `${thisErrorReport}\\n\\n======= INNER ERROR =======\\n\\n${errReport}`;\n            return;\n        }\n        this.innerErrors = innerErrors.map(err => toError(err));\n        const innerErrorReports = this.innerErrors\n            .map((error, idx) => {\n                const errReport = NestedError.getErrorReport(error);\n                return `======= INNER ERROR (${idx + 1} of ${innerErrors.length}) =======\\n\\n${errReport}`;\n            })\n            .join(\"\\n\\n\");\n        this.stack = `${thisErrorReport}\\n\\n${innerErrorReports}`;\n    }\n}\n\nNestedError.prototype.name = nameof(NestedError);\n\n/**\n * @deprecated You should not call this function on an object of statically assumed `Error` type,\n *             because it is intended to be used in a dynamic context where the type of thrown value\n *             is not known ahead of time (during the compile time).\n */\nexport function toError(err: Error): Error;\n\n/**\n * Returns `err` itself if `err instanceof Error === true`, otherwise attemts to\n * stringify it and wrap into `Error` object to be returned.\n *\n * **This function is guaranteed never to throw.**\n *\n * @param err Possbile `instanceof Error` to return or value of any type that will\n *            be wrapped into a fully-fledged `Error` object.\n */\nexport function toError(err: unknown): Error;\n\nexport function toError(err: unknown) {\n    try {\n        return err instanceof Error\n            ? err\n            : new Error(`Value that is not an instance of Error was thrown: ${err}`);\n    } catch {\n        return new Error(\n            \"Failed to stringify non-instance of Error that was thrown.\" +\n            \"This is possibly due to the fact that toString() method of the value\" +\n            \"doesn't return a primitive value.\"\n        );\n    }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clone = clone;\nexports.addLast = addLast;\nexports.addFirst = addFirst;\nexports.removeLast = removeLast;\nexports.removeFirst = removeFirst;\nexports.insert = insert;\nexports.removeAt = removeAt;\nexports.replaceAt = replaceAt;\nexports.getIn = getIn;\nexports.set = set;\nexports.setIn = setIn;\nexports.update = update;\nexports.updateIn = updateIn;\nexports.merge = merge;\nexports.mergeDeep = mergeDeep;\nexports.mergeIn = mergeIn;\nexports.omit = omit;\nexports.addDefaults = addDefaults;\nexports.default = void 0;\n\n/* eslint-disable @typescript-eslint/ban-types */\n\n/*!\n * Timm\n *\n * Immutability helpers with fast reads and acceptable writes.\n *\n * @copyright Guillermo Grau Panea 2016\n * @license MIT\n */\nconst INVALID_ARGS = 'INVALID_ARGS';\nconst IS_DEV = process.env.NODE_ENV !== 'production';\n\n// ===============================================\n// ### Helpers\n// ===============================================\nfunction throwStr(msg) {\n  throw new Error(msg);\n}\n\nfunction getKeysAndSymbols(obj) {\n  const keys = Object.keys(obj);\n\n  if (Object.getOwnPropertySymbols) {\n    // @ts-ignore\n    return keys.concat(Object.getOwnPropertySymbols(obj));\n  }\n\n  return keys;\n}\n\nconst hasOwnProperty = {}.hasOwnProperty;\n\nfunction clone(obj0) {\n  // As array\n  if (Array.isArray(obj0)) return obj0.slice(); // As object\n\n  const obj = obj0;\n  const keys = getKeysAndSymbols(obj);\n  const out = {};\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    out[key] = obj[key];\n  } // @ts-ignore (see type tests)\n\n\n  return out;\n} // Custom guard\n\n\nfunction isObject(o) {\n  return o != null && typeof o === 'object';\n} // _deepFreeze = (obj) ->\n//   Object.freeze obj\n//   for key in Object.getOwnPropertyNames obj\n//     val = obj[key]\n//     if isObject(val) and not Object.isFrozen val\n//       _deepFreeze val\n//   obj\n// ===============================================\n// -- ### Arrays\n// ===============================================\n// -- #### addLast()\n// -- Returns a new array with an appended item or items.\n// --\n// -- Usage: `addLast(array, val)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = addLast(arr, 'c')\n// -- // ['a', 'b', 'c']\n// -- arr2 === arr\n// -- // false\n// -- arr3 = addLast(arr, ['c', 'd'])\n// -- // ['a', 'b', 'c', 'd']\n// -- ```\n// `array.concat(val)` also handles the scalar case,\n// but is apparently very slow\n\n\nfunction addLast(array, val) {\n  if (Array.isArray(val)) return array.concat(val);\n  return array.concat([val]);\n} // -- #### addFirst()\n// -- Returns a new array with a prepended item or items.\n// --\n// -- Usage: `addFirst(array, val)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = addFirst(arr, 'c')\n// -- // ['c', 'a', 'b']\n// -- arr2 === arr\n// -- // false\n// -- arr3 = addFirst(arr, ['c', 'd'])\n// -- // ['c', 'd', 'a', 'b']\n// -- ```\n\n\nfunction addFirst(array, val) {\n  if (Array.isArray(val)) return val.concat(array);\n  return [val].concat(array);\n} // -- #### removeLast()\n// -- Returns a new array removing the last item.\n// --\n// -- Usage: `removeLast(array)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = removeLast(arr)\n// -- // ['a']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- arr3 = []\n// -- removeLast(arr3) === arr3\n// -- // true\n// -- ```\n\n\nfunction removeLast(array) {\n  if (!array.length) return array;\n  return array.slice(0, array.length - 1);\n} // -- #### removeFirst()\n// -- Returns a new array removing the first item.\n// --\n// -- Usage: `removeFirst(array)`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = removeFirst(arr)\n// -- // ['b']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- arr3 = []\n// -- removeFirst(arr3) === arr3\n// -- // true\n// -- ```\n\n\nfunction removeFirst(array) {\n  if (!array.length) return array;\n  return array.slice(1);\n} // -- #### insert()\n// -- Returns a new array obtained by inserting an item or items\n// -- at a specified index.\n// --\n// -- Usage: `insert(array, idx, val)`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = insert(arr, 1, 'd')\n// -- // ['a', 'd', 'b', 'c']\n// -- arr2 === arr\n// -- // false\n// -- insert(arr, 1, ['d', 'e'])\n// -- // ['a', 'd', 'e', 'b', 'c']\n// -- ```\n\n\nfunction insert(array, idx, val) {\n  return array.slice(0, idx).concat(Array.isArray(val) ? val : [val]).concat(array.slice(idx));\n} // -- #### removeAt()\n// -- Returns a new array obtained by removing an item at\n// -- a specified index.\n// --\n// -- Usage: `removeAt(array, idx)`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = removeAt(arr, 1)\n// -- // ['a', 'c']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- removeAt(arr, 4) === arr\n// -- // true\n// -- ```\n\n\nfunction removeAt(array, idx) {\n  if (idx >= array.length || idx < 0) return array;\n  return array.slice(0, idx).concat(array.slice(idx + 1));\n} // -- #### replaceAt()\n// -- Returns a new array obtained by replacing an item at\n// -- a specified index. If the provided item is the same as\n// -- (*referentially equal to*) the previous item at that position,\n// -- the original array is returned.\n// --\n// -- Usage: `replaceAt(array, idx, newItem)`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = replaceAt(arr, 1, 'd')\n// -- // ['a', 'd', 'c']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- replaceAt(arr, 1, 'b') === arr\n// -- // true\n// -- ```\n\n\nfunction replaceAt(array, idx, newItem) {\n  if (array[idx] === newItem) return array;\n  const len = array.length;\n  const result = Array(len);\n\n  for (let i = 0; i < len; i++) {\n    result[i] = array[i];\n  }\n\n  result[idx] = newItem;\n  return result;\n} // ===============================================\n// -- ### Collections (objects and arrays)\n// ===============================================\n// -- #### getIn()\n// -- Returns a value from an object at a given path. Works with\n// -- nested arrays and objects. If the path does not exist, it returns\n// -- `undefined`.\n// --\n// -- Usage: `getIn(obj, path)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: ['a', 'b', 'c'] }\n// -- getIn(obj, ['d', 'd1'])\n// -- // 3\n// -- getIn(obj, ['e', 1])\n// -- // 'b'\n// -- ```\n\n\nfunction getIn(obj, path) {\n  if (!Array.isArray(path)) {\n    throwStr(IS_DEV ? 'A path array should be provided when calling getIn()' : INVALID_ARGS);\n  }\n\n  if (obj == null) return undefined;\n  let ptr = obj;\n\n  for (let i = 0; i < path.length; i++) {\n    const key = path[i];\n    ptr = ptr != null ? ptr[key] : undefined;\n    if (ptr === undefined) return ptr;\n  }\n\n  return ptr;\n} // -- #### set()\n// -- Returns a new object with a modified attribute.\n// -- If the provided value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `set(obj, key, val)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3 }\n// -- obj2 = set(obj, 'b', 5)\n// -- // { a: 1, b: 5, c: 3 }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- set(obj, 'b', 2) === obj\n// -- // true\n// -- ```\n// When called with an undefined/null `obj`, `set()` returns either\n// a single-element array, or a single-key object\n\n\n// Implementation\nfunction set(obj0, key, val) {\n  let obj = obj0;\n  if (obj == null) obj = typeof key === 'number' ? [] : {};\n  if (obj[key] === val) return obj;\n  const obj2 = clone(obj);\n  obj2[key] = val;\n  return obj2;\n} // -- #### setIn()\n// -- Returns a new object with a modified **nested** attribute.\n// --\n// -- Notes:\n// --\n// -- * If the provided value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// -- * If the path does not exist, it will be created before setting\n// -- the new value.\n// --\n// -- Usage: `setIn(obj, path, val)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj2 = setIn(obj, ['d', 'd1'], 4)\n// -- // { a: 1, b: 2, d: { d1: 4, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj2 === obj\n// -- // false\n// -- obj2.d === obj.d\n// -- // false\n// -- obj2.e === obj.e\n// -- // true\n// --\n// -- // The same object is returned if there are no changes:\n// -- obj3 = setIn(obj, ['d', 'd1'], 3)\n// -- // { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj3 === obj\n// -- // true\n// -- obj3.d === obj.d\n// -- // true\n// -- obj3.e === obj.e\n// -- // true\n// --\n// -- // ... unknown paths create intermediate keys. Numeric segments are treated as array indices:\n// -- setIn({ a: 3 }, ['unknown', 0, 'path'], 4)\n// -- // { a: 3, unknown: [{ path: 4 }] }\n// -- ```\n\n\nfunction setIn(obj, path, val) {\n  if (!path.length) return val;\n  return doSetIn(obj, path, val, 0);\n}\n\nfunction doSetIn(obj, path, val, idx) {\n  let newValue;\n  const key = path[idx];\n\n  if (idx === path.length - 1) {\n    newValue = val;\n  } else {\n    const nestedObj = isObject(obj) && isObject(obj[key]) ? obj[key] : typeof path[idx + 1] === 'number' ? [] : {};\n    newValue = doSetIn(nestedObj, path, val, idx + 1);\n  }\n\n  return set(obj, key, newValue);\n} // -- #### update()\n// -- Returns a new object with a modified attribute,\n// -- calculated via a user-provided callback based on the current value.\n// -- If the calculated value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `update(obj, key, fnUpdate)`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3 }\n// -- obj2 = update(obj, 'b', (val) => val + 1)\n// -- // { a: 1, b: 3, c: 3 }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- update(obj, 'b', (val) => val) === obj\n// -- // true\n// -- ```\n\n\nfunction update(obj, key, fnUpdate) {\n  const prevVal = obj == null ? undefined : obj[key];\n  const nextVal = fnUpdate(prevVal);\n  return set(obj, key, nextVal);\n} // -- #### updateIn()\n// -- Returns a new object with a modified **nested** attribute,\n// -- calculated via a user-provided callback based on the current value.\n// -- If the calculated value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `updateIn<T: ArrayOrObject>(obj: T, path: Array<Key>,\n// -- fnUpdate: (prevValue: any) => any): T`\n// --\n// -- ```js\n// -- obj = { a: 1, d: { d1: 3, d2: 4 } }\n// -- obj2 = updateIn(obj, ['d', 'd1'], (val) => val + 1)\n// -- // { a: 1, d: { d1: 4, d2: 4 } }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- obj3 = updateIn(obj, ['d', 'd1'], (val) => val)\n// -- // { a: 1, d: { d1: 3, d2: 4 } }\n// -- obj3 === obj\n// -- // true\n// -- ```\n\n\nfunction updateIn(obj, path, fnUpdate) {\n  const prevVal = getIn(obj, path);\n  const nextVal = fnUpdate(prevVal);\n  return setIn(obj, path, nextVal);\n} // -- #### merge()\n// -- Returns a new object built as follows: the overlapping keys from the\n// -- second one overwrite the corresponding entries from the first one.\n// -- Similar to `Object.assign()`, but immutable.\n// --\n// -- Usage:\n// --\n// -- * `merge(obj1, obj2)`\n// -- * `merge(obj1, ...objects)`\n// --\n// -- The unmodified `obj1` is returned if `obj2` does not *provide something\n// -- new to* `obj1`, i.e. if either of the following\n// -- conditions are true:\n// --\n// -- * `obj2` is `null` or `undefined`\n// -- * `obj2` is an object, but it is empty\n// -- * All attributes of `obj2` are `undefined`\n// -- * All attributes of `obj2` are referentially equal to the\n// --   corresponding attributes of `obj1`\n// --\n// -- Note that `undefined` attributes in `obj2` do not modify the\n// -- corresponding attributes in `obj1`.\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: 3 }\n// -- obj2 = { c: 4, d: 5 }\n// -- obj3 = merge(obj1, obj2)\n// -- // { a: 1, b: 2, c: 4, d: 5 }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- merge(obj1, { c: 3 }) === obj1\n// -- // true\n// -- ```\n// Signatures:\n// - 1 arg\n\n\n// Implementation\nfunction merge(a, b, c, d, e, f, ...rest) {\n  return rest.length ? doMerge.call(null, false, false, a, b, c, d, e, f, ...rest) : doMerge(false, false, a, b, c, d, e, f);\n} // -- #### mergeDeep()\n// -- Returns a new object built as follows: the overlapping keys from the\n// -- second one overwrite the corresponding entries from the first one.\n// -- If both the first and second entries are objects they are merged recursively.\n// -- Similar to `Object.assign()`, but immutable, and deeply merging.\n// --\n// -- Usage:\n// --\n// -- * `mergeDeep(obj1, obj2)`\n// -- * `mergeDeep(obj1, ...objects)`\n// --\n// -- The unmodified `obj1` is returned if `obj2` does not *provide something\n// -- new to* `obj1`, i.e. if either of the following\n// -- conditions are true:\n// --\n// -- * `obj2` is `null` or `undefined`\n// -- * `obj2` is an object, but it is empty\n// -- * All attributes of `obj2` are `undefined`\n// -- * All attributes of `obj2` are referentially equal to the\n// --   corresponding attributes of `obj1`\n// --\n// -- Note that `undefined` attributes in `obj2` do not modify the\n// -- corresponding attributes in `obj1`.\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: { a: 1 } }\n// -- obj2 = { b: 3, c: { b: 2 } }\n// -- obj3 = mergeDeep(obj1, obj2)\n// -- // { a: 1, b: 3, c: { a: 1, b: 2 }  }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- mergeDeep(obj1, { c: { a: 1 } }) === obj1\n// -- // true\n// -- ```\n\n\nfunction mergeDeep(a, b, c, d, e, f, ...rest) {\n  return rest.length ? doMerge.call(null, false, true, a, b, c, d, e, f, ...rest) : doMerge(false, true, a, b, c, d, e, f);\n} // -- #### mergeIn()\n// -- Similar to `merge()`, but merging the value at a given nested path.\n// --\n// -- Usage examples:\n// --\n// -- * `mergeIn(obj1, path, obj2)`\n// -- * `mergeIn(obj1, path, ...objects)`\n// --\n// -- ```js\n// -- obj1 = { a: 1, d: { b: { d1: 3, d2: 4 } } }\n// -- obj2 = { d3: 5 }\n// -- obj3 = mergeIn(obj1, ['d', 'b'], obj2)\n// -- // { a: 1, d: { b: { d1: 3, d2: 4, d3: 5 } } }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- mergeIn(obj1, ['d', 'b'], { d2: 4 }) === obj1\n// -- // true\n// -- ```\n\n\nfunction mergeIn(a, path, b, c, d, e, f, ...rest) {\n  let prevVal = getIn(a, path);\n  if (prevVal == null) prevVal = {};\n  let nextVal;\n\n  if (rest.length) {\n    nextVal = doMerge.call(null, false, false, prevVal, b, c, d, e, f, ...rest);\n  } else {\n    nextVal = doMerge(false, false, prevVal, b, c, d, e, f);\n  }\n\n  return setIn(a, path, nextVal);\n} // -- #### omit()\n// -- Returns an object excluding one or several attributes.\n// --\n// -- Usage: `omit(obj, attrs)`\n//\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3, d: 4 }\n// -- omit(obj, 'a')\n// -- // { b: 2, c: 3, d: 4 }\n// -- omit(obj, ['b', 'c'])\n// -- // { a: 1, d: 4 }\n// --\n// -- // The same object is returned if there are no changes:\n// -- omit(obj, 'z') === obj1\n// -- // true\n// -- ```\n\n\nfunction omit(obj, attrs) {\n  const omitList = Array.isArray(attrs) ? attrs : [attrs];\n  let fDoSomething = false;\n\n  for (let i = 0; i < omitList.length; i++) {\n    if (hasOwnProperty.call(obj, omitList[i])) {\n      fDoSomething = true;\n      break;\n    }\n  }\n\n  if (!fDoSomething) return obj;\n  const out = {};\n  const keys = getKeysAndSymbols(obj);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (omitList.indexOf(key) >= 0) continue;\n    out[key] = obj[key];\n  }\n\n  return out;\n} // -- #### addDefaults()\n// -- Returns a new object built as follows: `undefined` keys in the first one\n// -- are filled in with the corresponding values from the second one\n// -- (even if they are `null`).\n// --\n// -- Usage:\n// --\n// -- * `addDefaults(obj, defaults)`\n// -- * `addDefaults(obj, ...defaultObjects)`\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: 3 }\n// -- obj2 = { c: 4, d: 5, e: null }\n// -- obj3 = addDefaults(obj1, obj2)\n// -- // { a: 1, b: 2, c: 3, d: 5, e: null }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- addDefaults(obj1, { c: 4 }) === obj1\n// -- // true\n// -- ```\n// Signatures:\n// - 2 args\n\n\n// Implementation and catch-all\nfunction addDefaults(a, b, c, d, e, f, ...rest) {\n  return rest.length ? doMerge.call(null, true, false, a, b, c, d, e, f, ...rest) : doMerge(true, false, a, b, c, d, e, f);\n}\n\nfunction doMerge(fAddDefaults, fDeep, first, ...rest) {\n  let out = first;\n\n  if (!(out != null)) {\n    throwStr(IS_DEV ? 'At least one object should be provided to merge()' : INVALID_ARGS);\n  }\n\n  let fChanged = false;\n\n  for (let idx = 0; idx < rest.length; idx++) {\n    const obj = rest[idx];\n    if (obj == null) continue;\n    const keys = getKeysAndSymbols(obj);\n    if (!keys.length) continue;\n\n    for (let j = 0; j <= keys.length; j++) {\n      const key = keys[j];\n      if (fAddDefaults && out[key] !== undefined) continue;\n      let nextVal = obj[key];\n\n      if (fDeep && isObject(out[key]) && isObject(nextVal)) {\n        nextVal = doMerge(fAddDefaults, fDeep, out[key], nextVal);\n      }\n\n      if (nextVal === undefined || nextVal === out[key]) continue;\n\n      if (!fChanged) {\n        fChanged = true;\n        out = clone(out);\n      }\n\n      out[key] = nextVal;\n    }\n  }\n\n  return out;\n} // ===============================================\n// ### Public API\n// ===============================================\n\n\nconst timm = {\n  clone,\n  addLast,\n  addFirst,\n  removeLast,\n  removeFirst,\n  insert,\n  removeAt,\n  replaceAt,\n  getIn,\n  set,\n  setIn,\n  update,\n  updateIn,\n  merge,\n  mergeDeep,\n  mergeIn,\n  omit,\n  addDefaults\n};\nvar _default = timm;\nexports.default = _default;","'use strict';\n\nconst pDefer = () => {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n};\n\nmodule.exports = pDefer;\n","/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n","var SortedArray = (function () {\n    var SortedArray = defclass({\n\n        constructor: function (array, compare) {\n            this.array   = [];\n            this.compare = compare || compareDefault;\n            var length   = array.length,\n                index    = 0;\n            while (index < length) this.insert(array[index++]);\n        },\n        insert: function (element) {\n            var array   = this.array,\n                compare = this.compare,\n                high    = array.length-1,\n                low     = 0,\n                pos = -1,\n                index,\n                ordering;\n\n            // The array is sorted. You must find the position of new element in O(log(n)), not O(n).\n            while (high >= low) {\n                index    = (high + low) / 2 >>> 0;\n                ordering = compare(array[index], element);                \n                if (ordering < 0) low  = index + 1;\n                else if (ordering > 0) high = index - 1;\n                else {\n                    pos = index;\n                    break;\n                };\n            }\n\n            if (pos === -1) {\n                // if element was not found, high < low.\n                pos = high;\n            }\n            // This assures that equal elements inserted after will be in a higher position in array.\n            // They can be equal for comparison purposes, but different objects with different data.\n            // Respecting the chronological order can be important for many applications.\n            pos++;\n            high = array.length-1;\n            while ((pos < high) && (compare(element, array[pos]) === 0)){\n                pos++;\n            }\n            index = array.length;\n            // Just to increase array size.\n            array.push(element);            \n            // Much faster. No need to elements swap.\n            while (index > pos) {\n                array[index] = array[--index];\n            }\n            // Set the new element on its correct position.\n            array[pos] = element;\n\n            return this;\n        },\n        search: function (element) {\n            var array   = this.array,\n                compare = this.compare,\n                high    = array.length-1,\n                low     = 0,\n                // In most languages, inner variable declaration makes the code slower.\n                index,\n                ordering;\n\n            while (high >= low) {\n                index    = (high + low) / 2 >>> 0;\n                ordering = compare(array[index], element);\n\n                     if (ordering < 0) low  = index + 1;\n                else if (ordering > 0) high = index - 1;\n                else return index;\n            }\n\n            return -1;\n        },\n        remove: function (element) {\n            var index = this.search(element);\n            if (index >= 0) this.array.splice(index, 1);\n            return this;\n        }\n    });\n\n    SortedArray.comparing = function (property, array) {\n        return new SortedArray(array, function (a, b) {\n            // This should be faster than calling functions.\n            // Besides, this way it is not needed to create useless function to return property value.\n            return compareDefault(a[property], b[property]);\n        });\n    };\n\n    return SortedArray;\n\n    function defclass(prototype) {\n        var constructor = prototype.constructor;\n        constructor.prototype = prototype;\n        return constructor;\n    }\n\n    function compareDefault(a, b) {\n        // Equality has a very low chance to happen. It should be the last option.\n        if (a < b)\n            return -1;\n        else if (a > b)\n            return 1;\n        else\n            return 0;\n    }\n}());\n\nif (typeof module === \"object\") module.exports = SortedArray;\nif (typeof define === \"function\" && define.amd)\n    define(function () { return SortedArray; });\n","export const CheckPathPluginSymbol = Symbol.for(\"CheckPathPlugin\");\n"]}