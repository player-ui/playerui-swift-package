{"version":3,"sources":["../../../../../../../../../../../../execroot/_main/bazel-out/darwin_arm64-fastbuild/bin/plugins/pubsub/core/src/index.ts","../../../../../../../../../../../../execroot/_main/bazel-out/darwin_arm64-fastbuild/bin/plugins/pubsub/core/src/pubsub.ts","../../../../../../../../../../../../execroot/_main/bazel-out/darwin_arm64-fastbuild/bin/plugins/pubsub/core/src/symbols.ts","../../../../../../../../../../../../execroot/_main/bazel-out/darwin_arm64-fastbuild/bin/plugins/pubsub/core/src/plugin.ts","../../../../../../../../../../../../execroot/_main/bazel-out/darwin_arm64-fastbuild/bin/plugins/pubsub/core/src/utils.ts","../../../../../../../../../../../../execroot/_main/bazel-out/darwin_arm64-fastbuild/bin/plugins/pubsub/core/src/handler.ts"],"names":["handlers","pubsub"],"mappings":"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","sourcesContent":["export * from \"./plugin\";\nexport * from \"./symbols\";\nexport * from \"./handler\";\n","/**\n * Based off the pubsub-js library and rewritten to match the same used APIs but modified so that\n * multiple arguments could be passed into the publish and subscription handlers.\n */\n\nexport type SubscribeHandler<T extends string, A extends unknown[]> = (\n  type: T,\n  ...args: A\n) => void;\n\nexport type PubSubUUID = `uuid_${number}`;\n\n/**\n * Split a string into an array of event layers\n */\nfunction splitEvent(event: string) {\n  return event.split(\".\").reduce<string[]>((prev, curr, index) => {\n    if (index === 0) {\n      return [curr];\n    }\n\n    return [...prev, `${prev[index - 1]}.${curr}`];\n  }, []);\n}\n\nlet count = 1;\n\n/**\n * Tiny pubsub maker\n */\nexport class TinyPubSub {\n  private events: Map<string, Map<PubSubUUID, SubscribeHandler<any, any>>>;\n  private tokens: Map<PubSubUUID, string>;\n\n  constructor() {\n    this.events = new Map();\n    this.tokens = new Map();\n  }\n\n  /**\n   * Publish an event with any number of additional arguments\n   */\n  publish(event: string, ...args: unknown[]) {\n    if (typeof event !== \"string\") {\n      return;\n    }\n\n    if (event.includes(\".\")) {\n      const eventKeys = splitEvent(event);\n\n      eventKeys.forEach((key) => {\n        this.deliver(key, event, ...args);\n      });\n    } else {\n      this.deliver(event, event, ...args);\n    }\n\n    this.deliver(\"*\", event, ...args);\n  }\n\n  /**\n   * Subscribe to an event\n   *\n   * Events are also heirarchical when separated by a period. Given the following:\n   *\n   * publish('a.b.c', 'one', 'two', 'three)\n   *\n   * The subscribe event will be called when the event is passed as 'a', 'a.b', or 'a.b.c'.\n   *\n   * @example\n   * // subscribes to the top level 'a' publish\n   * subscribe('a', (event, ...args) => console.log(event, ...args))\n   */\n  subscribe(event: string, handler: SubscribeHandler<any, any>) {\n    const uuid = `uuid_${++count}`;\n\n    if (typeof event === \"string\") {\n      if (!this.events.has(event)) {\n        this.events.set(event, new Map());\n      }\n\n      const handlers = this.events.get(event);\n      handlers!.set(uuid as PubSubUUID, handler);\n      this.tokens.set(uuid as PubSubUUID, event);\n    }\n\n    return uuid;\n  }\n\n  /**\n   * Unsubscribes to a specific subscription given it's symbol or an entire\n   * event when passed as a string.\n   *\n   * When existing subscriptions exist for heirarchical events such as 'a.b.c',\n   * when passing an event 'a' to unsubscribe, all subscriptions for 'a', 'a.b',\n   * & 'a.b.c' will be unsubscribed as well.\n   */\n  unsubscribe(value: string | symbol) {\n    if (typeof value === \"string\" && value.startsWith(\"uuid\")) {\n      const path = this.tokens.get(value as PubSubUUID);\n\n      if (typeof path === \"undefined\") {\n        return;\n      }\n\n      const innerPath = this.events.get(path);\n      innerPath?.delete(value as PubSubUUID);\n      this.tokens.delete(value as PubSubUUID);\n      return;\n    }\n\n    if (typeof value === \"string\") {\n      for (const key of this.events.keys()) {\n        if (key.indexOf(value) === 0) {\n          const tokens = this.events.get(key);\n\n          if (tokens && tokens.size) {\n            // eslint-disable-next-line max-depth\n            for (const token of tokens.keys()) {\n              this.tokens.delete(token);\n            }\n          }\n\n          this.events.delete(key);\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the number of subscriptions for a specific event, or when left blank\n   * will return the overall number of subscriptions for the entire pubsub.\n   */\n  count(event?: string) {\n    let counter = 0;\n\n    if (typeof event === \"undefined\") {\n      for (const handlers of this.events.values()) {\n        counter += handlers.size;\n      }\n\n      return counter;\n    }\n\n    const handlers = this.events.get(event);\n\n    if (handlers?.size) {\n      return handlers.size;\n    }\n\n    return counter;\n  }\n\n  /**\n   * Deletes all existing subscriptions\n   */\n  clear() {\n    this.events.clear();\n    this.tokens.clear();\n  }\n\n  private deliver(path: string, event: string, ...args: unknown[]) {\n    const handlers = this.events.get(path);\n\n    if (handlers && handlers.size) {\n      for (const handler of handlers.values()) {\n        handler(event, ...args);\n      }\n    }\n  }\n}\n\nexport const pubsub = new TinyPubSub();\n","export const PubSubPluginSymbol = Symbol.for(\"PubSubPlugin\");\n","import type {\n  Player,\n  PlayerPlugin,\n  ExpressionContext,\n} from \"@player-ui/player\";\nimport type { SubscribeHandler, TinyPubSub } from \"./pubsub\";\nimport { pubsub } from \"./pubsub\";\nimport { PubSubPluginSymbol } from \"./symbols\";\n\nexport interface PubSubConfig {\n  /** A custom expression name to register  */\n  expressionName: string;\n}\n\n/**\n * The PubSubPlugin is a great way to enable your FRF content to publish events back to your app\n * It injects a publish() function into the expression language, and will forward all events back to any subscribers.\n *\n * Published/Subscribed events support a hierarchy:\n * - publish('foo', 'data') -- will trigger any listeners for 'foo'\n * - publish('foo.bar', 'data') -- will trigger any listeners for 'foo' or 'foo.bar'\n *\n */\nexport class PubSubPlugin implements PlayerPlugin {\n  name = \"pub-sub\";\n\n  static Symbol = PubSubPluginSymbol;\n  public readonly symbol = PubSubPlugin.Symbol;\n\n  protected pubsub: TinyPubSub;\n\n  private expressionName: string;\n\n  constructor(config?: PubSubConfig) {\n    this.expressionName = config?.expressionName ?? \"publish\";\n    this.pubsub = pubsub;\n  }\n\n  apply(player: Player) {\n    // if there is already a pubsub plugin, reuse its pubsub instance\n    // to maintain the singleton across bundles for iOS/Android\n    const existing = player.findPlugin<PubSubPlugin>(PubSubPluginSymbol);\n    if (existing !== undefined) {\n      this.pubsub = existing.pubsub;\n    }\n\n    player.hooks.expressionEvaluator.tap(this.name, (expEvaluator) => {\n      const existingExpression = expEvaluator.operators.expressions.get(\n        this.expressionName,\n      );\n\n      if (existingExpression) {\n        player.logger.warn(\n          `[PubSubPlugin] expression ${this.expressionName} is already registered.`,\n        );\n      } else {\n        expEvaluator.addExpressionFunction(\n          this.expressionName,\n          (_ctx: ExpressionContext, event: unknown, ...args: unknown[]) => {\n            if (typeof event === \"string\") {\n              this.publish(event, ...args);\n            }\n          },\n        );\n      }\n    });\n\n    player.hooks.onEnd.tap(this.name, () => {\n      this.clear();\n    });\n  }\n\n  /**\n   * A way of publishing an event, notifying any listeners\n   *\n   * @param event - The name of the event to publish. Can take sub-topics like: foo.bar\n   * @param data - Any additional data to attach to the event\n   */\n  publish(event: string, ...args: unknown[]) {\n    this.pubsub.publish(event, ...args);\n  }\n\n  /**\n   * Subscribe to an event with the given name. The handler will get called for any published event\n   *\n   * @param event - The name of the event to subscribe to\n   * @param handler - A function to be called when the event is triggered\n   * @returns A token to be used to unsubscribe from the event\n   */\n  subscribe<T extends string, A extends unknown[]>(\n    event: T,\n    handler: SubscribeHandler<T, A>,\n  ) {\n    return this.pubsub.subscribe(event, handler);\n  }\n\n  /**\n   * Remove any subscriptions using the given token\n   *\n   * @param token - A token from a `subscribe` call\n   */\n  unsubscribe(token: string) {\n    this.pubsub.unsubscribe(token);\n  }\n\n  /**\n   * Remove all subscriptions\n   */\n  clear() {\n    this.pubsub.clear();\n  }\n}\n","import type { Player } from \"@player-ui/player\";\nimport { PubSubPlugin } from \"./plugin\";\nimport { PubSubPluginSymbol } from \"./symbols\";\n\n/**\n * Returns the existing PubSubPlugin or creates and registers a new plugin\n */\nexport function getPubSubPlugin(player: Player) {\n  const existing = player.findPlugin<PubSubPlugin>(PubSubPluginSymbol);\n  const plugin = existing || new PubSubPlugin();\n\n  if (!existing) {\n    player.registerPlugin(plugin);\n  }\n\n  return plugin;\n}\n","import type { Player, PlayerPlugin, InProgressState } from \"@player-ui/player\";\nimport { getPubSubPlugin } from \"./utils\";\n\nexport type PubSubHandler<T extends unknown[]> = (\n  context: InProgressState,\n  ...args: T\n) => void;\n\nexport type SubscriptionMap = Map<string, PubSubHandler<any>>;\n\n/**\n * Plugin to easily add subscribers to the PubSubPlugin\n */\nexport class PubSubHandlerPlugin implements PlayerPlugin {\n  name = \"pubsub-handler\";\n  private subscriptions: SubscriptionMap;\n\n  constructor(subscriptions: SubscriptionMap) {\n    this.subscriptions = subscriptions;\n  }\n\n  apply(player: Player) {\n    const pubsub = getPubSubPlugin(player);\n\n    player.hooks.onStart.tap(this.name, () => {\n      this.subscriptions.forEach((handler, key) => {\n        pubsub.subscribe(key, (_, ...args) => {\n          const state = player.getState();\n\n          if (state.status === \"in-progress\") {\n            return handler(state, ...args);\n          }\n\n          player.logger.info(\n            `[PubSubHandlerPlugin] subscriber for ${key} was called when player was not in-progress`,\n          );\n        });\n      });\n    });\n  }\n}\n"]}